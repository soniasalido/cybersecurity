hay una cosa que no entiendo, cuando he obtenido los strings de la muestra del malware desempaquetado, se han visto strings como: InternetOpenA, InternetOpenUrlA, InternetCloseHandle.... y sin embargo no aparecen en ningua de las funciones analizadas. Que puede pasar?


ChatGPT said:

Buena observaci√≥n. El hecho de que veas strings como InternetOpenA, InternetOpenUrlA, InternetCloseHandle, etc., en el binario desempaquetado pero no aparezcan en las funciones que has analizado directamente tiene varias explicaciones posibles ‚Äî y todas son habituales en malware:
üîç 1. Llamadas API por punteros indirectos (IAT / Import Table din√°mica)

El malware no llama directamente a InternetOpenA(...), sino que:

    Usa GetProcAddress(LoadLibraryA("wininet.dll"), "InternetOpenA") para obtener la direcci√≥n.

    Guarda esa direcci√≥n en una variable.

    Llama a esa direcci√≥n como si fuese una funci√≥n: call eax.

‚ùó Esto oculta la llamada API a herramientas que hacen an√°lisis superficial o incluso a reversores si no rastrean el valor del puntero.

‚úÖ Prueba: has visto en los strings funciones como:

LoadLibraryA
GetProcAddress
InternetOpenA
InternetOpenUrlA

Y tambi√©n estructuras IAT como DAT_004050... llenas de direcciones. Eso indica que el malware resuelve din√°micamente esas funciones en tiempo de ejecuci√≥n.
üß™ 2. Uso indirecto en payload desencriptado

Otro escenario com√∫n:

    El malware desempaqueta c√≥digo (por ejemplo, usando FUN_00401300, FUN_00401190, FUN_004010b1‚Ä¶).

    Este c√≥digo se guarda en memoria (heap o VirtualAlloc).

    Luego salta a esa zona con c√≥digo, que s√≠ utiliza esas APIs.

üîÅ En otras palabras: esas funciones API est√°n en el segundo stage, no en el stub inicial.
üîß 3. Tabla de funciones (dispatcher o switch)

En algunas funciones que ya has analizado, como FUN_0040234D, se ejecutan funciones indirectas desde tablas, con punteros cargados din√°micamente (como plugins o comandos).

üì¶ El string http://%s/%s/ y las funciones InternetOpenA, etc., probablemente se usan all√≠ para conectarse a un C2 y descargar m√°s datos o exfiltrar informaci√≥n.
üß© ¬øC√≥mo confirmarlo?

Para confirmar qu√© pasa, puedes:

    Buscar en Ghidra / IDA:

        Las referencias a GetProcAddress y LoadLibraryA.

        Las funciones que reciben o usan esas direcciones.

        Rastrear llamadas tipo call eax o call [esi+offset].

    Colocar breakpoints en runtime:

        Con x64dbg, en InternetOpenA o GetProcAddress, y ver desde d√≥nde se llaman.

    Buscar zonas en memoria:

        Que contengan c√≥digo con esas funciones (dump de heap con Volatility o similar).

‚úÖ Conclusi√≥n

Las strings como InternetOpenA, InternetReadFile, etc., s√≠ est√°n presentes porque el binario las necesita, pero no se llaman directamente desde el c√≥digo que has analizado ‚Äî se usan:

    ‚úÖ Por resoluci√≥n din√°mica con GetProcAddress.

    ‚úÖ En c√≥digo desencriptado / desempaquetado din√°micamente.

    ‚úÖ Posiblemente tras un salto indirecto a memoria ejecutable (shellcode, heap, etc.).



-----------------------------------------------------
Poner un breakpoint en InternetOpenA desde x64dbg y ver desde d√≥nde se llama en tu malware desempaquetado, sigue estos pasos:
‚úÖ PASO A PASO: Breakpoint en InternetOpenA
1. Abre el malware en x64dbg (el dump desempaquetado):

    Usa File ‚Üí Open o arr√°stralo.

    Si es un dump manual, aseg√∫rate de haberlo reconfigurado con Scylla o ImportREC.

2. Pulsa Ctrl+G (Go to expression)

Se abrir√° una ventana para ir a una direcci√≥n o s√≠mbolo.

‚úçÔ∏è Escribe:

InternetOpenA

3. Presiona Enter

    x64dbg deber√≠a llevarte directamente a la direcci√≥n de esa API dentro de wininet.dll.

    Ver√°s algo como:

wininet.InternetOpenA:
7E471234  MOV ...

4. Poner el Breakpoint

Con la l√≠nea de c√≥digo de InternetOpenA seleccionada, presiona:

F2

üî¥ Aparecer√° un punto rojo: se ha colocado el breakpoint.
5. Ejecuta (F9) y espera

    Pulsa F9 para dejar que el malware se ejecute.

    En cuanto el programa intente conectarse, se parar√° en ese breakpoint.

6. Ver qui√©n llam√≥

Ahora lo m√°s importante:

‚úÖ Pulsa Alt+K o haz clic en "Call Stack" (pesta√±a a la derecha).

Ah√≠ ver√°s qu√© funci√≥n del malware ha llamado a InternetOpenA. Esto te da una pista clara del flujo de ejecuci√≥n y desde qu√© direcci√≥n se invoca.
üõ†Ô∏è Consejos adicionales

    Si no se para nunca en InternetOpenA, tambi√©n puedes probar con:

        InternetOpenUrlA

        InternetReadFile

        URLDownloadToFileA

    Para m√°s control: en vez de InternetOpenA, pon un breakpoint en GetProcAddress para ver cu√°ndo el malware resuelve esa API.

¬øQuieres que hagamos un breakpoint en GetProcAddress tambi√©n para interceptar cu√°ndo el malware resuelve din√°micamente InternetOpenA? Eso puede darte a√∫n m√°s contexto.
You said:
Ctrl+G (Go to expression) no funciona. Dame un comando para ir a esa direccion o simbolo
ChatGPT said:

Perfecto. Si Ctrl+G no funciona en tu entorno de x64dbg, puedes usar el comando manual en la consola del debugger.
‚úÖ OPCI√ìN 1: Ir manualmente con el comando symresolve

Abre la consola inferior de x64dbg (pesta√±a Log / Command o Alt+C) y escribe:

symresolve InternetOpenA

Esto resolver√° la direcci√≥n de InternetOpenA si wininet.dll ya est√° cargado.

Luego escribe:

goto [direcci√≥n_resuelta]

Por ejemplo, si el resultado fue 7E471234, haz:

goto 7E471234

y luego pulsa Enter.
‚úÖ OPCI√ìN 2: Si wininet.dll a√∫n no est√° cargado

Algunos malware no cargan wininet.dll hasta que lo necesitan. En ese caso:

    Ejecuta el malware con F9 hasta que la API sea llamada.

    Ve a la pesta√±a "Symbols" o usa el comando:

lm wininet

Si ves que a√∫n no est√° cargado, sigue ejecutando con F9 hasta que lo est√©.

Cuando est√© cargado, vuelve a hacer:

    symresolve InternetOpenA
    goto [direcci√≥n]

‚úÖ OPCI√ìN 3: Buscar manualmente en el m√≥dulo wininet

Si todo lo dem√°s falla:

    Ve a la pesta√±a "Symbols" o "Modules".

    Haz doble clic en wininet.dll.

    Busca InternetOpenA en la vista de funciones exportadas (puedes usar Ctrl+F en el disassembler).

    Una vez localizada la direcci√≥n, presiona F2 para poner el breakpoint.

---------------------------------
se ve claramente que el malware est√° llamando a InternetOpenA en tiempo de ejecuci√≥n y que la direcci√≥n de la API es 73805C00, que pertenece al m√≥dulo wininet.dll.

Adem√°s, se ve que la llamada proviene desde Lab_01-3.00401264, que es una direcci√≥n interna del binario del malware, espec√≠ficamente:

00401264 ‚Üí llamada a InternetOpenA

‚úÖ Qu√© puedes hacer ahora:
1. Poner breakpoint en InternetOpenA

En la consola (Alt+C), escribe:

bp 73805C00

o bien, haz clic derecho en esa l√≠nea en la columna Address ‚Üí Set Breakpoint.
2. Ir a la direcci√≥n de llamada en el malware

Para analizar qui√©n llama a InternetOpenA desde el malware:

goto 00401264

Y ah√≠ ver√°s la instrucci√≥n como:

CALL DWORD PTR DS:[<&wininet.InternetOpenA>]

o similar.
3. (Opcional) Seguir el flujo

Desde ah√≠ puedes hacer:

    U para desensamblar hacia arriba.

    F2 para poner un breakpoint en 00401264.

    Shift+F9 para correr hasta que se ejecute esa funci√≥n y ver sus par√°metros (en la pila o registros).




----------------------------------------
xxxx captura dntro de InternetOpenA

Est√°s dentro de InternetOpenA en la librer√≠a wininet.dll, y los argumentos se ven correctamente en la pila (ESP). Ya puedes inspeccionarlos directamente.
üß† Argumentos de InternetOpenA (documentaci√≥n oficial)

La funci√≥n InternetOpenA tiene la siguiente firma:

HINTERNET InternetOpenA(
  LPCSTR lpszAgent,         // [ESP + 0]
  DWORD  dwAccessType,      // [ESP + 4]
  LPCSTR lpszProxy,         // [ESP + 8]
  LPCSTR lpszProxyBypass,   // [ESP + C]
  DWORD  dwFlags            // [ESP + 10]
);

üß™ En tu caso actual

Desde tu captura:

    ESP + 0 = 0019FD34 ‚Üí "Mozilla/4.0" ‚úîÔ∏è
    (User-Agent string que delata uso de funciones HTTP)

    ESP + 4 = 00000000 ‚Üí INTERNET_OPEN_TYPE_PRECONFIG
    (usa la configuraci√≥n de proxy del sistema)

    ESP + 8, +C, +10 = 00000000 ‚Üí sin proxy, sin bypass, sin flags personalizados.

üõ†Ô∏è C√≥mo ver esto t√∫ misma:
Opci√≥n 1: Dump r√°pido

En la consola, escribe:

dd esp L5

Esto mostrar√° los 5 primeros DWORDs de la pila (los argumentos).
Opci√≥n 2: Mostrar strings

da [esp]        ; muestra lpszAgent

Y repite con:

da [esp+8]      ; muestra lpszProxy si existe
da [esp+C]      ; muestra lpszProxyBypass si existe


-------------------------------------------
üîç An√°lisis detallado
1. Cadena sospechosa

    El valor de edx apunta a la cadena:

alwareanalysis.com/REVTSlRPUC1JOTI1/

Como edx - 23 apunta al comienzo de la cadena, lo que est√° oculto es probablemente:

mal***wareanalysis.com/REVTSlRPUC1JOTI1/

‚Üí Muy probablemente sea:

    malwareanalysis.com/REVTSlRPUC1JOTI1/

2. Contexto de ejecuci√≥n

    Est√°s dentro de una funci√≥n de wininet.dll, justo despu√©s de una llamada a InternetOpenA, como viste en capturas anteriores.

    Eso indica que el malware est√° usando APIs leg√≠timas de Windows para abrir una URL a un dominio personalizado con una ruta que parece estar Base64 codificada.

3. Cadena codificada en la URL

    "REVTSlRPUC1JOTI1" es Base64 y decodifica a:

DEVTOP-J925

Es decir, la URL completa podr√≠a ser:

http://malwareanalysis.com/DEVTOP-J925

o:

    http://malwareanalysis.com/REVTSlRPUC1JOTI1/

    El malware podr√≠a usar este sufijo codificado para:

        Identificar el host.

        Incluir par√°metros cifrados.

        Obtener payloads espec√≠ficos.

üìå Conclusi√≥n

    El malware construye din√°micamente la URL apuntando a malwareanalysis.com y accede a una subruta posiblemente identificadora o cifrada.

    Est√°s viendo c√≥mo usa la API InternetOpenA / InternetOpenUrlA para abrir una URL remota y hacer una petici√≥n HTTP.

    Est√°s dentro del c√≥digo de wininet.dll, justo en un punto que manipula esta URL en memoria.


