## Firma
```
file > sha256,212B29A8E36CCC8F65205122E33D84940A156A9A91329F747A713F988A157948
dos-stub > sha256,E9F12CE2F18E518C7373D057CA498BDD33A36F98C8C65554D99EF60C01AC4D4C
dos-header > sha256,3F4CA3CC0A0C57FAB2EAAE2F865502DCE5ABE084DC862052645EE362B87FEEDF
section > LOL1 > sha256,D9C0B93135D1A4A6E6DBCBF5DFE9501D6A5A75687BC89790BDB8B051E39DA3E3
section > .rsrc > sha256,64FCC1096B8875AF6608286AC8A3674B11CC272F3FB6C938E9E739B45D835EDF
```

------------------------------
## Info general

```
file > name,c:\users\usuario\desktop\lab_01-3.malware
file > signature,Microsoft Linker 6.0 | UPX v0.8X
file > sha256,212B29A8E36CCC8F65205122E33D84940A156A9A91329F747A713F988A157948
file > info,size: 14336 bytes, entropy: 7.508
file > type,executable, 32-bit, console
stamp > compiler,Tue Nov 08 23:03:23 2011
resource > file,signature: unknown, offset: 0xFFFFF660, size: 32 bytes
languages > names,English-US
resources > info,count: 1, size: 32 bytes, file-ratio: 0.22%
file > version,n/a
section > virtualized,name: LOL0
entry-point > location,0x0000AF60 (section: LOL1)
section > writable,name: LOL0
sections > self-modifying,name: LOL0 | LOL1
certificate,n/a
libraries > flag,WININET.dll (Internet Extensions for Win32 Library)
libraries > flag,WS2_32.dll (Windows Socket Library)
imports > ordinal > count,1
imports > flag,InternetOpenA | VirtualAlloc | VirtualProtect
imphash > md5,50D7F396EA527DD2ED138CD2F1DFD49D
exports,n/a
overlay,n/a
```

------------------------------
## VirusTotal
https://www.virustotal.com/gui/file/212b29a8e36ccc8f65205122e33d84940a156a9a91329f747a713f988a157948

-------------------------------
## ¬øEst√° el malware empaquetado?
```
PACKERS:
‚îî‚îÄ$ pepack Lab_01-3.malware -d db_packer.txt 
packer:                          UPX -> www.upx.sourceforge.net

Intentamos desempaquetar con UPX
‚îî‚îÄ$ upx -d Lab_01-3.malware -o Lab_01-3_unpacked.exe
                       Ultimate Packer for eXecutables
                          Copyright (C) 1996 - 2024
UPX 4.2.4       Markus Oberhumer, Laszlo Molnar & John Reiser    May 9th 2024

        File size         Ratio      Format      Name
   --------------------   ------   -----------   -----------
upx: Lab_01-3.malware: CantUnpackException: file is modified/hacked/protected; take care!!!

Unpacked 0 files.
```

La muestra fue empaquetada originalmente con UPX, pero fue modificada despu√©s, probablemente para dificultar el an√°lisis. Esto es com√∫n en malware: usan una versi√≥n de UPX modificada o alteran manualmente el encabezado despu√©s del empaquetado.


_______________________________________________

## üîé ¬øQu√© podemos hacer ahora?
‚úÖ 1. Verificar con Detect It Easy (DIE)

DIE puede confirmar si el ejecutable sigue teniendo una firma reconocible de UPX y en qu√© secciones.


‚úÖ 2. Forzar el desempaquetado manualmente

Ya que UPX no puede desempaquetar autom√°ticamente, podemos:

**üõ†Ô∏è Opci√≥n A: Usar un desempaquetado manual en x64dbg**
- C√°rgalo en x64dbg (en una VM).
  - Poner un breakpoint en OEP (Original Entry Point): Buscamos una instrucci√≥n tipo JMP EAX, PUSHAD, CALL, etc., que salte al c√≥digo desempaquetado.
- Cuando llegue al c√≥digo desenpaquetado:
  - Ejecutamos hasta que veamos llamadas a funciones API t√≠picas (GetProcAddress, LoadLibrary, etc.).
  - Hacemos un dump de la memoria en ese punto con: x64dbg ‚Üí men√∫ contextual ‚Üí Dump memory ‚Üí Save .exe.
- Reparamos el dump con Scylla o ImpRec para reconstruir la Import Table.

**üõ†Ô∏è Opci√≥n B: Usar herramientas autom√°ticas de dump**
- Exeinfo PE (en Windows): nos puede decir si es UPX modificado y sugerir herramientas para desempacar.
- unupx.py: script de Python para intentar recuperar binarios alterados.
- Qiling + LIEF: para an√°lisis din√°mico y reconstrucci√≥n de binarios.

**UPX alterado = trampa para analistas.**

El malware probablemente:
- Modific√≥ el encabezado UPX.
- Inyect√≥ basura o cifrado adicional.
- Protegi√≥ contra an√°lisis (anti-debug, anti-VM, etc.).
  
---------------------------------
## An√°lisis con DIE
```
Empaquetador: UPX [modified]
(Heur)Empaquetar: Compressed or packed data
EntryPoint + Imports like UPX (v2.90-3.XX)
Sections collision ("LOL1") + "pushal" at EP + High entropy + Section 1 ("LOL1") compressed
```
![Captura-DIE](packers/die.png)

**UPX [modified]:** El ejecutable fue empaquetado con UPX, pero el header o la estructura fue modificada posteriormente para evitar su desempaquetado con herramientas como upx -d. Este es un truco com√∫n en malware.

**EntryPoint + Imports like UPX:** El punto de entrada y los patrones de importaci√≥n se parecen mucho a los de un binario UPX cl√°sico, lo que confirma el origen.

**Sections collision ("LOL1"):** Esto sugiere que hay secciones que se solapan o est√°n manipuladas, lo que no es normal en un binario leg√≠timo. La secci√≥n llamada "LOL1" probablemente es inventada para confundir o romper herramientas de an√°lisis.

**"pushal" at EP:** Instrucci√≥n PUSHAD en ensamblador x86, t√≠pica en binarios empaquetados para guardar el estado antes de desempaquetar el c√≥digo en tiempo de ejecuci√≥n. Aparece justo al inicio del c√≥digo real que se ejecuta.

**High entropy + compressed section:** Alt√≠sima entrop√≠a = datos comprimidos o cifrados, muy posiblemente c√≥digo empaquetado en la secci√≥n LOL1.



------------------------------------------
## ü™õ Desempaquetar en x64dbg

### 1. Copiamos el binario a una VM Windows aislada.

### 2. Abrimos x64dbg y cargamos Lab_01-3.malware.

### 3.Ejecutamos hasta pasar el stub de UPX.
Pulsamos F9 --> Como est√° activado el break point en el EntryPoint, x64dbg se detendr√° directamente en el codigo empaquetado del ejecutable, el STUB UPX modificado, justo en el punto de entrada del binario empaquetado, como lo muestra esta l√≠nea:

```
0040AF60 | 60 | pushad
```
üß† Esto es t√≠pico del c√≥digo de desempaquetado: guarda los registros antes de modificar la memoria.


### üîç 4.FUNCI√ìN entry() ‚Äî An√°lisis estructurado

[Funci√≥n entry()](../decompilado/Funcion_entry.md)

#### üü¶ 4.1. Desempaquetado en memoria (decrypted copy)
```
0040af60  PUSHAD
0040af61  MOV ESI, DAT_00408000       ; puntero al bloque de datos comprimido
0040af66  LEA EDI, [ESI - 0x7000]     ; destino donde se va a copiar/expandir

0040af70‚Äì0040b02a                     ; bucle complejo de descompresi√≥n
```
- Esta parte descomprime o copia el c√≥digo malicioso real desde ESI a EDI, usando un algoritmo tipo LZ o RLE (con muchos ADC, MOV, JNZ, etc.).
- El c√≥digo se desempaqueta din√°micamente y se coloca en una zona de memoria RWX.

#### üü® 4.2. Decodificaci√≥n de punteros y reubicaciones
```
0040b02a  POP ESI
0040b02b  MOV EDI, ESI
0040b037‚Äì0040b05c ; bucle que manipula punteros en el √°rea desempaquetada
```
- Se corrigen direcciones relativas, posiblemente para funciones API importadas manualmente.
- Usa c√°lculos complejos sobre punteros y direcciones relativas ‚Üí indica unloader manual o loader que prepara llamadas a funciones externas.

#### üü© 4.3. Resoluci√≥n de APIs (carga de DLLs + funciones)
```
0040b064‚Äì0040b0a9
```
- Lee nombres como "KERNEL32.DLL", "LoadLibraryA", "GetProcAddress".
- Usa llamadas a funciones ya resueltas (por direcci√≥n indirecta).
- Este bloque implementa un "resolver manual": carga din√°micamente DLLs (como KERNEL32.DLL, WININET.DLL) y obtiene punteros a funciones clave.
- Evita usar la IAT tradicional ‚Üí t√©cnica anti-an√°lisis muy com√∫n.

#### üü• 4.4. Limpieza de memoria, restauraci√≥n del entorno y salto al payload
```
0040b0af‚Äì0040b0ec
```
- Cambia protecciones con `VirtualProtect`
- Limpia la stack
- POPAD (restaura registros)
- JMP 00401681 ; salto al payload real
- Restaura permisos de memoria (probablemente para quitar RWX).
- Limpia la pila para evitar rastros.
- Usa JMP para transferir ejecuci√≥n al c√≥digo real del malware: FUN_00401681.


#### üéØ 4.5 CONCLUSI√ìN: ¬øQu√© hace la funci√≥n entry()?
| Etapa	 | Funci√≥n |
| -- | -- |
| Desempaquetado	| Copia y/o descomprime el cuerpo real del malware |
| Reubicaci√≥n interna	| Corrige direcciones y punteros en tiempo de ejecuci√≥n |
| Resoluci√≥n API	| Carga din√°micamente DLLs y obtiene funciones con LoadLibrary y GetProcAddress |
| Salto al payload	| Transfiere el control al binario real desempaquetado (00401681) |

Es un stub loader cl√°sico con capacidades anti-an√°lisis.


![Captura-DIE](packers/Stub-UPX-modificado.png)


### 5. El flujo de ejecuci√≥n probablemente terminar√° en una instrucci√≥n POPAD:
```
0040B0DE  POPAD
....
....
0040B0DF  ..... JMP LAB_00401681
```
üëâ Ese JMP es el salto al c√≥digo real desempaquetado.

![Captura-DIE](capturas/direccion-OEP.png)


**En la direccion 00401681 est√°n las instrucciones desempaquetadas.**

![Captura-DIE](capturas/comienzo-OEP-real-del-ejecutable-ya-desempaquetado.png)



### 6. Avanzar hasta el OEP (Original Entry Point):
Vamos a seguir el flujo del stub hasta encontrar el c√≥digo desempaquetado. Esto se hace paso a paso con F8 o avanzando hasta ver que el c√≥digo tiene sentido.
- Seguimos con F8 y F9 hasta llegar al c√≥digo "real" (desempaquetado en memoria).
- Se√±ales de que estamos en el OEP: ves llamadas a GetProcAddress, LoadLibraryA, etc.

![OEP real del ejecutable ya desempaquetado](capturas/comienzo-OEP-real-del-ejecutable-ya-desempaquetado.png)

El OEP real del ejecutable ya desempaquetado (0x00401681). üéØ

```
00401681 55             push ebp
00401682 8BEC           mov ebp, esp
...
004016A8 FF15 [...]     call dword ptr [<&GetVersion>]
```

Estas son instrucciones claras y limpias de un ejecutable normal, no de un stub de desempaquetado. Hemos llegado al c√≥digo real del malware.  Adem√°s vemos llamadas API (GetVersion) y vemos una estructura t√≠pica de pr√≥logo de funci√≥n (push ebp, mov ebp, esp). Esto confirma 100% que estamos en el OEP.



### 7. Hacer un dump de memoria (para capturar el binario desempaquetado). Dump del binario desde memoria:
- Pesta√±a memory map.
- Nos situamos en el punto 00401000.
- Boton derecho: Dump to file.
- Guardamos esas instrucciones desempaquetadas como un nuevo fichero. Guardamos como Lab_01-3_dump.exe.

![Captura-DIE](capturas/memory-map.png)

‚úÖ Nuestro m√≥dulo desempaquetado est√° aqu√≠:

En la l√≠nea:
```
00400000    lab_01-3.malware    "LOLO" "LOL1" ".rsrc"
```
Direcci√≥n base: 00400000 ‚úÖ

Nombre del m√≥dulo: lab_01-3.malware ‚úÖ

Este es el ejecutable cargado, ya desempaquetado en memoria.



Haz clic derecho sobre esa l√≠nea (00400000 lab_01-3.malware):  
    - Selecciona: ‚úÖ Dump memory to file
    - Guardamos el archivo como: Lab_01-3_dump.exe
    - Ya tenemos el volcado de memoria completo del binario desempaquetado.

    
    
En x64dbg:
- Vamos al men√∫: File ‚Üí Dump memory
- En la ventana que aparece:
    - Base address: aseg√∫rate que sea 00400000.
    - Size: puede ser entre 0x10000 y 0x200000 seg√∫n el tama√±o del binario. Si no sabes, puedes dejar el valor por defecto.
    - Marca las casillas:
        - ‚úÖ Rebuild PE header
        - ‚úÖ Fix raw size
    - Guardamos el archivo como Lab_01-3_dump-sin-imports-table.exe.



------------------------------
## Reconstruir Imports con Scylla

    Abre Scylla.

    Selecciona el proceso Lab_01-3.malware (si sigue abierto).

    En Scylla:

        Pulsa "IAT Autosearch"

        Luego: "Get Imports"

        Si todo est√° bien: pulsa "Fix Dump" y selecciona el archivo .dump.exe que acabas de guardar.

        Guardamos como Lab_01-3_dump-con-imports-table.exe.


------------------------------
## Ahora tenemos un binario:

    Desempaquetado ‚úîÔ∏è

    Con imports reconstruidos ‚úîÔ∏è

    Listo para an√°lisis con:

        üß† Ghidra

        üîç PE-bear

        üî¨ strings, die, pestudio

        üêõ Sandbox, procmon, wireshark si quieres an√°lisis din√°mico


------------------------------
## Obtenemos los strings del fichero con las instrucciones desempaquetadas

[Strings del malware desempaquetado](strings/Lab_01-3-copia_dump-desempaquetado-ascii.txt)


1. Indicadores de que el malware fue creado en Visual C++
```
Microsoft Visual C++ Runtime Library
Runtime Error!
R6025 - pure virtual function call
R6016 - not enough space for thread data
...
```

Esto indica que el binario se compil√≥ probablemente con Microsoft Visual C++, y tiene v√≠nculos con las librer√≠as est√°ndar de C++.

üåê 2. Capacidades de red detectadas
```
http://%s/%s/
Mozilla/4.0
InternetOpenA
InternetOpenUrlA
InternetCloseHandle
InternetReadFile
WININET.dll
WS2_32.dll
```
Este bloque indica que el malware:
- Puede realizar conexiones HTTP (probablemente a un C2).
- Simula un agente de usuario Mozilla/4.0.
- Usa WinINet, una API com√∫n de Windows para tr√°fico web.
- Usa funciones de bajo nivel (WS2_32.dll) para manejo de sockets.

üî∫ Conclusi√≥n: tiene capacidades de beaconing y comunicaci√≥n remota.

üì¶ 3. Carga din√°mica de funciones
```
LoadLibraryA
GetProcAddress
VirtualProtect
VirtualAlloc
VirtualFree
```
Estas funciones permiten:
- Cargar DLLs en tiempo de ejecuci√≥n.
- Obtener punteros a funciones en ellas.
- Reservar, modificar y liberar memoria virtual.

üî∫ Indica posible shellcode, desofuscaci√≥n din√°mica o self-injection.


üóÉÔ∏è 4. Manejo de recursos y posibles strings personalizados
```
FindResourceA
LoadResource
LockResource
GlobalAlloc
SizeofResource
```
Esto sugiere que:
- El malware probablemente extrae recursos embebidos (como ejecutables, DLLs, payloads secundarios o configuraciones).
- Podr√≠a estar autocontenida con payloads ocultos en la secci√≥n .rsrc.

üìå 5. Strings sospechosos / C2 / herramientas
```
http://%s/%s/
www.practicalmalwareanalysis.com
C:\Users\usuario\Desktop\Lab_01-3 - copia.exe
```
- Se detecta una plantilla para URLs ‚Üí probablemente reemplazada en tiempo de ejecuci√≥n.
- Referencia al entorno de an√°lisis (usuario\Desktop...) ‚Üí probablemente el entorno donde fue capturado el dump.

‚ö†Ô∏è 6. Otras funciones clave
```
ExitProcess
TerminateProcess
UnhandledExceptionFilter
GetCurrentProcess
SetHandleCount
GetStartupInfoA
HeapAlloc / HeapFree / HeapCreate
```
- Control de flujo, manejo de errores y heap manual ‚Üí t√≠pico de malware m√°s avanzado o ofuscado.

üß© Resumen del comportamiento detectado
| Componente	 | Evidencia |
| -- | -- |
| Comunicaci√≥n remota (C2)	 | InternetOpenUrlA, http://%s/%s/, Mozilla/4.0 |
| Carga din√°mica de c√≥digo	 | LoadLibraryA, GetProcAddress, VirtualProtect, VirtualAlloc |
| Desempaquetado / Shellcode	 | VirtualProtect, uso de .rsrc, SizeofResource, FlushFileBuffers |
| Autocontenidos / recursos	 | FindResourceA, LockResource, LoadResource, .rsrc |
| Persistencia o ejecuci√≥n	 |ExitProcess, TerminateProcess, GetStartupInfoA |

**üö® Conclusi√≥n:**  
La muestra desempaquetada tiene caracter√≠sticas t√≠picas de malware con payload embebido, cifrado en recursos o secciones, y capacidades de conexi√≥n remota para posiblemente contactar con un servidor C2.

Adem√°s, se apoya en t√©cnicas de evasi√≥n como carga din√°mica de funciones y uso de memoria protegida, lo que sugiere que pudo haber sido ofuscado o construido como dropper/injector.

------------------------------
## Comparativa muestra sin desempaquetar VS muestra empaquetada

**Muestra empaquetada:**
![Instrucciones sin desempaquetar](capturas/instrucciones-del-malware-sin-desempaquetar.png)

**Muestra desempaquetada:**
![Instrucciones desempaquetadas](capturas/instrucciones-del-malware-desempaquetadas.png)



------------------------------
## FUN_00401000
[FUN_0040100](../decompilado/FUN_00401000.md)


## FUN_004010b1
La funci√≥n FUN_004010b1 implementa una rutina completa de codificaci√≥n Base64 para una cadena de entrada.
üß† ¬øQu√© hace?

Codifica una cadena en Base64, usando bloques de 3 bytes para producir bloques de 4 caracteres ASCII (seg√∫n la tabla Base64).

üîí ¬øPor qu√© esto es relevante en malware?

Muchos malwares codifican datos en Base64 para:

    Evitar detecci√≥n est√°tica (strings codificadas).

    Encapsular datos binarios (payloads, shellcode).

    Transmisi√≥n por red sin problemas de formato.
    

------------------------------
## FUN_00401190

[FUN_00401190](../decompilado/FUN_00401190.md)

La funci√≥n FUN_00401190 realiza una operaci√≥n simple de ofuscaci√≥n XOR por byte sobre una secuencia de datos.
üß† ¬øQu√© hace exactamente?

Hace un bucle desde 0 hasta param_2 (cantidad de bytes) y:

    Lee un byte del buffer en param_1.

    Lo XORea con 0x3B.

    Escribe el resultado en el mismo lugar (operaci√≥n in-place).
    

Esta t√©cnica:

    Es extremadamente r√°pida y ligera.

    Evita que strings como "http://...", "cmd.exe" o payloads binarios sean visibles en texto plano.

    Puede ser usada antes/despu√©s de almacenar o enviar datos.

------------------------------
## FUN_004011c9

Parece ser la funci√≥n principal de decodificaci√≥n o preparaci√≥n del payload en el malware. 

üß† Funci√≥n FUN_004011c9: ¬øQu√© hace?

Esta funci√≥n parece:

    Inicializar m√∫ltiples buffers locales grandes en la pila.

    Realizar decodificaci√≥n o desofuscaci√≥n de datos almacenados probablemente como texto ofuscado (XOR, Base64, etc.).

    Llamar a funciones auxiliares que ya hemoss analizado:

        FUN_004010b1: codificaci√≥n Base64.

        FUN_00401190: XOR con 0x3B.

        FUN_00401000: codificador Base64 para bloques de 3 bytes ‚Üí 4 caracteres.

    Mover, copiar o transformar datos entre m√∫ltiples buffers.

    Preparar algo que ser√° ejecutado o usado posteriormente (como una carga √∫til o un comando).

    
üß© Pistas desde los nombres de variables

    local_154, local_158, local_35c, local_55c: Son buffers relativamente grandes, por lo que probablemente contienen datos codificados.

    local_34, local_54, local_10, etc.: Variables auxiliares, usadas como flags o iteradores.    

------------------------------
## FUN_00401300
La funci√≥n FUN_00401300 es clave dentro del malware. Se encarga de cargar un recurso incrustado, descodificarlo (con una funci√≥n XOR) y devolver un puntero al buffer listo para su uso.
Vamos a desglosarla por partes:
üß† ¬øQu√© hace a alto nivel?

    Carga un recurso embebido (posiblemente un ejecutable, DLL, shellcode o string codificada).
    
    ‚ùå Si no se encuentra el recurso, muestra un mensaje: "Could not load exe." y termina.

    Obtiene un puntero a dicho recurso y su tama√±o.

    Reserva memoria.

    Copia el recurso en memoria.

    Aplica una operaci√≥n de descifrado XOR con la funci√≥n FUN_00401190.

    Devuelve el puntero al buffer descifrado.
    
üéØ Conclusi√≥n: Prop√≥sito de FUN_00401300

Esta funci√≥n se usa para:

    Cargar un recurso embebido (como un binario adicional o shellcode).

    Descifrarlo (XOR 0x3B).

    Reservar memoria ejecutable para su uso posterior.
    
------------------------------
## FUN_004013ed

La funci√≥n FUN_004013ed parece ser el punto central de ejecuci√≥n del payload. Organiza la ejecuci√≥n del recurso desencriptado cargado previamente y act√∫a como un bucle de ejecuci√≥n persistente. Vamos paso a paso para comprender su comportamiento.
üß† ¬øQu√© hace FUN_004013ed?

    Llama a FUN_00401300 para obtener un puntero a datos (probablemente shellcode) desencriptados.

    Prepara una estructura en la pila y llama a FUN_00401476, que probablemente inicializa algo (puede ser un socket, pipe o evento).

    Si esa inicializaci√≥n falla, entra en un bucle infinito tipo watchdog que:

        Llama a FUN_004011c9 (ejecuta el payload).

        Espera 30 segundos (Sleep(0x7530)).

        Vuelve a intentarlo si el resultado fue falso (0).

    Si no falla, llama a FUN_00401470 (que posiblemente termina o libera recursos).
    

üí° Este bucle se comporta como un watchdog thread que intenta ejecutar el payload continuamente hasta que tenga √©xito. Vuelve a intentar ejecutar el payload (FUN_004011c9) cada 30 segundos.

üîç Conclusi√≥n

Esta funci√≥n es el "dispatcher" o lanzador principal del malware. Controla:

    La carga del payload.

    Su ejecuci√≥n repetida hasta tener √©xito.

    Un bucle persistente (watchdog).

    Y la liberaci√≥n o continuaci√≥n si todo sale bien.


    


    
------------------------------
## FUN_00401681
[FUN_00401681](../decompilado/FUN_00401681.md)

Es el c√≥digo desempaquetador justo antes de saltar al c√≥digo real del binario (el OEP 0401681).

La funci√≥n FUN_00401681 es el punto de entrada real del malware, indica el comienzo de la ejecuci√≥n del malware tras el desempaquetado.

La funci√≥n FUN_00401681 es el punto de entrada principal del malware: se trata del main payload initializer o funci√≥n principal que realiza la inicializaci√≥n del entorno, ejecuci√≥n del c√≥digo malicioso y comunicaci√≥n con el C2.
üß† RESUMEN FUNCIONAL

La funci√≥n:

    Establece un manejador de excepciones estructurado (SEH).

    Inicializa variables internas y obtiene valores del sistema.

    Llama a varias funciones con funcionalidades de:

        Carga y decodificaci√≥n de ejecutable (FUN_00401300).

        Carga de estructuras (FUN_0040258a, FUN_004024d1).

        Configuraci√≥n o decodificaci√≥n de datos (FUN_004013ed).

    Ejecuta el payload real llamando a FUN_0040234d con punteros obtenidos din√°micamente.

    Evita crash silenciosamente y gestiona errores.
    
    
üîê FINALIDAD

El malware:

    Inicializa su entorno (registro de excepciones, buffers, config).

    Recoge info del sistema (versi√≥n, m√≥dulo base).

    Descifra un payload en memoria (FUN_004013ed).

    Llama a una funci√≥n obtenida din√°micamente desde ese payload (FUN_0040234d).

Este es el punto donde comienza la verdadera ejecuci√≥n maliciosa del binario.
‚úÖ CONCLUSI√ìN

FUN_00401681 es el orquestador principal del malware. Si est√°s analizando c√≥mo act√∫a esta muestra:

    Este punto marca la carga y ejecuci√≥n del c√≥digo cifrado en memoria.

    FUN_004013ed y FUN_0040234d son tus siguientes candidatos para an√°lisis de comportamiento detallado.

    Todo antes de eso es infraestructura (preparaci√≥n del entorno, evasi√≥n, carga de configuraci√≥n).
    
--------------------------------------

| Funci√≥n	| Rol |
| -- | -- |
| FUN_00401785	| Cierra el programa de forma controlada si falla la carga inicial. |
| FUN_004017a9	| Funci√≥n personalizada para leer un byte desde una estructura tipo stream. |
FUN_00401681	Entrypoint principal del malware
FUN_004013ed	Bucle de persistencia/control principal
FUN_0040224b	Rutina de limpieza antes de salir
FUN_00402333	Ejecuta listas de funciones (atexit-like)
FUN_00402278 ‚Üí FUN_0040229a	Maneja la terminaci√≥n segura del proceso
__exit	Mapeo al ExitProcess del sistema

-------------------------------------
## FUN_0040258a

Esta funci√≥n lee una ruta del entorno (C:\Users\usuario\Desktop\Lab_01-) y procesa alguna informaci√≥n relacionada con ese directorio o archivo. La ruta se copia, se utiliza como argumento en una funci√≥n llamada FUN_00402623, y luego se reserva memoria basada en los valores devueltos.

Con alta probabilidad, esta funci√≥n carga una tabla de excepciones, s√≠mbolos, o estructuras internas desde un archivo binario o estructura predefinida.

FUN_0040258a probablemente:

    Obtiene una ruta del sistema

    Llama a una funci√≥n FUN_00402623 que calcula tama√±o de datos y los carga

    Reserva memoria din√°mica

    Almacena punteros globales para que otras funciones accedan a esta tabla cargada

Esto encaja con una l√≥gica de loader o preparador de entorno. Podr√≠a estar cargando una tabla de s√≠mbolos, excepciones personalizadas o estructuras internas para el resto del ejecutable (posiblemente desempaquetado previamente).


--------------------------------------------

## FUN_0040234D
Esta funci√≥n tokeniza (parsea) una cadena tipo l√≠nea de comandos, separando argumentos como lo har√≠a un parser de argv de main(int argc, char **argv), respetando comillas, espacios, secuencias \\ y reglas de escape. Tambi√©n almacena resultados intermedios (conteo y punteros) en arrays din√°micos proporcionados por punteros externos.

üß† Relaci√≥n con el malware

Esta funci√≥n es clave para:

    Interpretar la l√≠nea de comandos que el malware se autoinyecta

    Leer argumentos de configuraci√≥n interna

    Preparar el entorno tras desempaquetarse (es habitual tras CreateProcess en packers)

    
    
--------------------------------------------
## FUN_00402ab4(int param_1)

La funci√≥n FUN_00402ab4(int param_1) que has mostrado es una funci√≥n sencilla pero cr√≠tica, porque reserva una regi√≥n de memoria y llama a una funci√≥n de inicializaci√≥n adicional. Aqu√≠ tienes un an√°lisis paso a paso:
üß† Prop√≥sito general

Esta funci√≥n intenta reservar memoria con VirtualAlloc (o una API similar) y, si tiene √©xito, inicializa esa regi√≥n llamando a FUN_00403ce5.

üõ°Ô∏è Comportamiento sospechoso en malware

Esta funci√≥n:

    Reserva memoria ejecutable o de datos para uso futuro (probablemente para shellcode o payload desencriptado).

    Llama a una funci√≥n de inicializaci√≥n que puede hacer:

        Desempaquetar c√≥digo

        Decodificar datos cifrados

        Parchar funciones

        Instalar hooks

Es t√≠pico en stubs de carga de malware o fases de stage 1 unpackers.

--------------------------------------------
## FUN_00402cf9

Esta es la funci√≥n clave que genera el mensaje "Runtime Error!" que se muestra al usuario.
üîç Flujo simplificado

    Busca el mensaje de error asociado a code en una tabla DAT_00406408.

    Si no lo encuentra o est√° mal configurado, termina.

    Si lo encuentra:

        Intenta obtener el nombre del programa.

        Si no puede, usa "<program name unknown>".

        Construye un mensaje completo como:

        Runtime Error!
        Program: C:\Path\malware.exe
        R6008
        - not enough space for arguments

    Llama a MessageBoxA() o equivalente para mostrarlo en ventana emergente.

üéØ ¬øQu√© indica esto sobre el malware?

Estas funciones:

    Son parte de la infraestructura del runtime, probablemente copiada de un binario leg√≠timo compilado con Visual Studio.

    Est√°n activas cuando algo sale mal (como una corrupci√≥n de heap o mal manejo de argumentos).

    Dan soporte a un sistema de control de errores personalizado ‚Äî muchas veces usado para ocultar la causa real de fallos al analista.

üìå Conclusi√≥n

Estas funciones no forman parte del payload malicioso directo, pero:

    Refuerzan que el ejecutable tiene un entorno SEH muy elaborado, probablemente por ser un packer, dropper o loader que necesita mantener el control incluso ante errores.

    Algunas llamadas como a FUN_00402cf9 sirven para mostrar un mensaje falso al usuario en caso de fallos, como distracci√≥n.

--------------------------------------------
## FUN_0040234D
[FUN_0040234D](../decompilado/FUN_0040234D.md)


Esta funci√≥n act√∫a como un int√©rprete de tareas: procesa estructuras, valida estados, y llama a funciones que probablemente fueron resueltas din√°micamente.

Podr√≠a estar vinculada a:
- Un loader de payloads.
- Un sistema de plugin malicioso.
- Un int√©rprete de comandos enviado desde un servidor C2.

--------------------------------------------
## FUN_004024D1
[FUN_004024D1](../decompilado/FUN_004024D1.md)

FUN_004024D1 prepara una tabla din√°mica con claves de entorno v√°lidas, limpiando las originales y dejando todo en una estructura interna para su uso posterior. Es muy probable que el malware use esa tabla para configurar sus conexiones, comportamiento o autenticaci√≥n.

------------------------------------------------

## FUN_004027D7

[FUN_004027D7](../decompilado/FUN_004027D7.md)

Extrae datos de recursos, memoria o strings ocultos.

Recorre memoria para calcular tama√±o din√°micamente.

Reserva memoria y copia el contenido para uso posterior.


--------------------------------------------------
## FUN_FUN_00404ff0

üß© Conclusi√≥n
Aspecto	Valor
üìõ Nombre	FUN_00404ff0
üìå Funci√≥n	Trampol√≠n hacia una direcci√≥n externa contenida en DAT_00405090
üì¶ Uso	Parte del mecanismo de excepciones (__global_unwind2)
üé≠ Posible prop√≥sito en malware	Redirecci√≥n din√°mica, hooking, evasi√≥n, control indirecto del flujo
üõ†Ô∏è T√©cnicas relacionadas	IAT hooking, forwarders CRT, ofuscaci√≥n


üß© Conclusi√≥n

Este bloque representa cadenas constantes usadas para mostrar errores de ejecuci√≥n cr√≠ticos al usuario, tanto por:

    fallos matem√°ticos (TLOSS, SING, DOMAIN),

    errores del runtime (R6025, R6002...),

    o problemas de inicializaci√≥n de heap, consola, entorno, etc.

No indican por s√≠ mismos que sea malware, pero la presencia completa de estos errores puede ser aprovechada por c√≥digo malicioso para mostrarse como un binario leg√≠timo ante herramientas de an√°lisis est√°tico, o para esconder su funcionalidad real detr√°s de errores aparentes.

-----------------------------------------------

üö© Posibles Indicadores de Comportamiento Malicioso
T√©cnica	Evidencia en funciones
Desempaquetado de payload en memoria	FUN_004039b0 (memcpy optimizado)
Anti-debug / evasi√≥n	Uso de funciones propias en lugar de memcpy
Singleton de inicializaci√≥n	FUN_00403994
Uso directo de VirtualAlloc	FUN_00403ce5
Copia controlada con STD/CLD	Evita detection v√≠a uso de APIs est√°ndar

