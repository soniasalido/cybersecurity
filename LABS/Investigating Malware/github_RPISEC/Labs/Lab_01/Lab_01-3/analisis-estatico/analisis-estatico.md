## Firma
```
file > sha256,212B29A8E36CCC8F65205122E33D84940A156A9A91329F747A713F988A157948
dos-stub > sha256,E9F12CE2F18E518C7373D057CA498BDD33A36F98C8C65554D99EF60C01AC4D4C
dos-header > sha256,3F4CA3CC0A0C57FAB2EAAE2F865502DCE5ABE084DC862052645EE362B87FEEDF
section > LOL1 > sha256,D9C0B93135D1A4A6E6DBCBF5DFE9501D6A5A75687BC89790BDB8B051E39DA3E3
section > .rsrc > sha256,64FCC1096B8875AF6608286AC8A3674B11CC272F3FB6C938E9E739B45D835EDF
```

------------------------------
## Info general

```
file > name,c:\users\usuario\desktop\lab_01-3.malware
file > signature,Microsoft Linker 6.0 | UPX v0.8X
file > sha256,212B29A8E36CCC8F65205122E33D84940A156A9A91329F747A713F988A157948
file > info,size: 14336 bytes, entropy: 7.508
file > type,executable, 32-bit, console
stamp > compiler,Tue Nov 08 23:03:23 2011
resource > file,signature: unknown, offset: 0xFFFFF660, size: 32 bytes
languages > names,English-US
resources > info,count: 1, size: 32 bytes, file-ratio: 0.22%
file > version,n/a
section > virtualized,name: LOL0
entry-point > location,0x0000AF60 (section: LOL1)
section > writable,name: LOL0
sections > self-modifying,name: LOL0 | LOL1
certificate,n/a
libraries > flag,WININET.dll (Internet Extensions for Win32 Library)
libraries > flag,WS2_32.dll (Windows Socket Library)
imports > ordinal > count,1
imports > flag,InternetOpenA | VirtualAlloc | VirtualProtect
imphash > md5,50D7F396EA527DD2ED138CD2F1DFD49D
exports,n/a
overlay,n/a
```

------------------------------
## VirusTotal
https://www.virustotal.com/gui/file/212b29a8e36ccc8f65205122e33d84940a156a9a91329f747a713f988a157948

-------------------------------
## ¬øEst√° el malware empaquetado?
```
PACKERS:
‚îî‚îÄ$ pepack Lab_01-3.malware -d db_packer.txt 
packer:                          UPX -> www.upx.sourceforge.net

Intentamos desempaquetar con UPX
‚îî‚îÄ$ upx -d Lab_01-3.malware -o Lab_01-3_unpacked.exe
                       Ultimate Packer for eXecutables
                          Copyright (C) 1996 - 2024
UPX 4.2.4       Markus Oberhumer, Laszlo Molnar & John Reiser    May 9th 2024

        File size         Ratio      Format      Name
   --------------------   ------   -----------   -----------
upx: Lab_01-3.malware: CantUnpackException: file is modified/hacked/protected; take care!!!

Unpacked 0 files.
```

La muestra fue empaquetada originalmente con UPX, pero fue modificada despu√©s, probablemente para dificultar el an√°lisis. Esto es com√∫n en malware: usan una versi√≥n de UPX modificada o alteran manualmente el encabezado despu√©s del empaquetado.


_______________________________________________

## üîé ¬øQu√© podemos hacer ahora?
‚úÖ 1. Verificar con Detect It Easy (DIE)

DIE puede confirmar si el ejecutable sigue teniendo una firma reconocible de UPX y en qu√© secciones.


‚úÖ 2. Forzar el desempaquetado manualmente

Ya que UPX no puede desempaquetar autom√°ticamente, podemos:

üõ†Ô∏è Opci√≥n A: Usar un desempaquetado manual en x64dbg

    C√°rgalo en x64dbg (en una VM).

    Pon un breakpoint en OEP (Original Entry Point):

        Busca una instrucci√≥n tipo JMP EAX, PUSHAD, CALL, etc., que salte al c√≥digo desempaquetado.

    Cuando llegue al c√≥digo desenpaquetado:

        Ejecuta hasta que veas llamadas a funciones API t√≠picas (GetProcAddress, LoadLibrary, etc.).

    Haz un dump de la memoria en ese punto con:

        x64dbg ‚Üí men√∫ contextual ‚Üí Dump memory ‚Üí Save .exe.

    Repara el dump con Scylla o ImpRec para reconstruir la Import Table.

üõ†Ô∏è Opci√≥n B: Usar herramientas autom√°ticas de dump

    Exeinfo PE (en Windows): te puede decir si es UPX modificado y sugerir herramientas para desempacar.

    unupx.py: script de Python para intentar recuperar binarios alterados.

    Qiling + LIEF: para an√°lisis din√°mico y reconstrucci√≥n de binarios.

üí° Pista: UPX alterado = trampa para analistas

El malware probablemente:

    Modific√≥ el encabezado UPX.

    Inyect√≥ basura o cifrado adicional.

    Protegi√≥ contra an√°lisis (anti-debug, anti-VM, etc.).

  
    
---------------------------------
## An√°lisis con DIE
```
Empaquetador: UPX [modified]
(Heur)Empaquetar: Compressed or packed data
EntryPoint + Imports like UPX (v2.90-3.XX)
Sections collision ("LOL1") + "pushal" at EP + High entropy + Section 1 ("LOL1") compressed
```
![Captura-DIE](packers/die.png)

UPX [modified]: El ejecutable fue empaquetado con UPX, pero el header o la estructura fue modificada posteriormente para evitar su desempaquetado con herramientas como upx -d. Este es un truco com√∫n en malware.

EntryPoint + Imports like UPX: El punto de entrada y los patrones de importaci√≥n se parecen mucho a los de un binario UPX cl√°sico, lo que confirma el origen.

Sections collision ("LOL1"): Esto sugiere que hay secciones que se solapan o est√°n manipuladas, lo que no es normal en un binario leg√≠timo. La secci√≥n llamada "LOL1" probablemente es inventada para confundir o romper herramientas de an√°lisis.

"pushal" at EP: Instrucci√≥n PUSHAD en ensamblador x86, t√≠pica en binarios empaquetados para guardar el estado antes de desempaquetar el c√≥digo en tiempo de ejecuci√≥n. Aparece justo al inicio del c√≥digo real que se ejecuta.

High entropy + compressed section: Alt√≠sima entrop√≠a = datos comprimidos o cifrados, muy posiblemente c√≥digo empaquetado en la secci√≥n LOL1.



------------------------------------------
## ü™õ Desempaquetar en x64dbg

### 1. Copiamos el binario a una VM Windows aislada.

### 2. Abrimos x64dbg y cargamos Lab_01-3.malware.

### 3.Ejecutamos hasta pasar el stub de UPX.
Pulsamos F9 --> Como est√° activado el break point en el EntryPoint, x64dbg se detendr√° directamente en el codigo empaquetado del ejecutable, el STUB UPX modificado, justo en el punto de entrada del binario empaquetado, como lo muestra esta l√≠nea:

```
0040AF60 | 60 | pushad
```
üß† Esto es t√≠pico del c√≥digo de desempaquetado: guarda los registros antes de modificar la memoria.


### üîç 4.FUNCI√ìN entry() ‚Äî An√°lisis estructurado
#### üü¶ 4.1. Desempaquetado en memoria (decrypted copy)
```
0040af60  PUSHAD
0040af61  MOV ESI, DAT_00408000       ; puntero al bloque de datos comprimido
0040af66  LEA EDI, [ESI - 0x7000]     ; destino donde se va a copiar/expandir

0040af70‚Äì0040b02a                     ; bucle complejo de descompresi√≥n
```
- Esta parte descomprime o copia el c√≥digo malicioso real desde ESI a EDI, usando un algoritmo tipo LZ o RLE (con muchos ADC, MOV, JNZ, etc.).
- El c√≥digo se desempaqueta din√°micamente y se coloca en una zona de memoria RWX.

#### üü® 4.2. Decodificaci√≥n de punteros y reubicaciones
```
0040b02a  POP ESI
0040b02b  MOV EDI, ESI
0040b037‚Äì0040b05c ; bucle que manipula punteros en el √°rea desempaquetada
```
- Se corrigen direcciones relativas, posiblemente para funciones API importadas manualmente.
- Usa c√°lculos complejos sobre punteros y direcciones relativas ‚Üí indica unloader manual o loader que prepara llamadas a funciones externas.

#### üü© 4.3. Resoluci√≥n de APIs (carga de DLLs + funciones)
```
0040b064‚Äì0040b0a9
```
- Lee nombres como "KERNEL32.DLL", "LoadLibraryA", "GetProcAddress".
- Usa llamadas a funciones ya resueltas (por direcci√≥n indirecta).
- Este bloque implementa un "resolver manual": carga din√°micamente DLLs (como KERNEL32.DLL, WININET.DLL) y obtiene punteros a funciones clave.
- Evita usar la IAT tradicional ‚Üí t√©cnica anti-an√°lisis muy com√∫n.

#### üü• 4.4. Limpieza de memoria, restauraci√≥n del entorno y salto al payload
```
0040b0af‚Äì0040b0ec
```
- Cambia protecciones con `VirtualProtect`
- Limpia la stack
- POPAD (restaura registros)
- JMP 00401681 ; salto al payload real
- Restaura permisos de memoria (probablemente para quitar RWX).
- Limpia la pila para evitar rastros.
- Usa JMP para transferir ejecuci√≥n al c√≥digo real del malware: FUN_00401681.


#### üéØ 4.5 CONCLUSI√ìN: ¬øQu√© hace la funci√≥n entry()?
| Etapa	 | Funci√≥n |
| -- | -- |
| Desempaquetado	| Copia y/o descomprime el cuerpo real del malware |
| Reubicaci√≥n interna	| Corrige direcciones y punteros en tiempo de ejecuci√≥n |
| Resoluci√≥n API	| Carga din√°micamente DLLs y obtiene funciones con LoadLibrary y GetProcAddress |
| Salto al payload	| Transfiere el control al binario real desempaquetado (00401681) |

Es un stub loader cl√°sico con capacidades anti-an√°lisis.


![Captura-DIE](packers/Stub-UPX-modificado.png)

### 5. Avanzar hasta el OEP (Original Entry Point):
Vamos a seguir el flujo del stub hasta encontrar el c√≥digo desempaquetado. Esto se hace paso a paso con F8 o avanzando hasta ver que el c√≥digo tiene sentido.
- Seguimos con F8 y F9 hasta llegar al c√≥digo "real" (desempaquetado en memoria).
- Se√±ales de que estamos en el OEP: ves llamadas a GetProcAddress, LoadLibraryA, etc.

XXXX Captura foto

El OEP real del ejecutable ya desempaquetado (0x00401681). üéØ

```
00401681 55             push ebp
00401682 8BEC           mov ebp, esp
...
004016A8 FF15 [...]     call dword ptr [<&GetVersion>]
```

Estas son instrucciones claras y limpias de un ejecutable normal, no de un stub de desempaquetado. Has llegado al c√≥digo real del malware. ‚úÖ

Adem√°s:
- Llamadas API (GetVersion)

- Estructura t√≠pica de pr√≥logo de funci√≥n (push ebp, mov ebp, esp)


Esto confirma 100% que estamos en el OEP.



### 6. El flujo de ejecuci√≥n probablemente terminar√° en una instrucci√≥n POPAD:
```
0040B0DE  POPAD
....
....
0040B0DF  ..... JMP LAB_00401681
```
üëâ Ese JMP es el salto al c√≥digo real desempaquetado.

![Captura-DIE](capturas/direcci√≥n-del-OEP.png)


**En la direccion 00401681 est√°n las instrucciones desempaquetadas.**

![Captura-DIE](capturas/comienzo-OEP-real-del-ejecutable-ya-desempaquetado.png)


### 7. Hacer un dump de memoria (para capturar el binario desempaquetado). Dump del binario desde memoria:
- Pesta√±a memory map.
- Nos situamos en el punto 00401000.
- Boton derecho: Dump to file.
- Guardamos esas instrucciones desempaquetadas como un nuevo fichero. Guardamos como Lab_01-3_dump.exe.

![Captura-DIE](capturas/memory-map.png)

‚úÖ Nuestro m√≥dulo desempaquetado est√° aqu√≠:

En la l√≠nea:
```
00400000    lab_01-3.malware    "LOLO" "LOL1" ".rsrc"
```
Direcci√≥n base: 00400000 ‚úÖ

Nombre del m√≥dulo: lab_01-3.malware ‚úÖ

Este es el ejecutable cargado, ya desempaquetado en memoria.



Haz clic derecho sobre esa l√≠nea (00400000 lab_01-3.malware):  
    - Selecciona: ‚úÖ Dump memory to file
    - Guarda el archivo como: Lab_01-3_dump.exe
    - Ya tenemos el volcado de memoria completo del binario desempaquetado.

    
    
En x64dbg:
- Ve al men√∫: File ‚Üí Dump memory
- En la ventana que aparece:
    - Base address: aseg√∫rate que sea 00400000.
    - Size: puede ser entre 0x10000 y 0x200000 seg√∫n el tama√±o del binario. Si no sabes, puedes dejar el valor por defecto.
    - Marca las casillas:
        - ‚úÖ Rebuild PE header
        - ‚úÖ Fix raw size
    - Guarda el archivo como Lab_01-3_dump.exe.



------------------------------
## Reconstruir Imports con Scylla

    Abre Scylla.

    Selecciona el proceso Lab_01-3.malware (si sigue abierto).

    En Scylla:

        Pulsa "IAT Autosearch"

        Luego: "Get Imports"

        Si todo est√° bien: pulsa "Fix Dump" y selecciona el archivo .dump.exe que acabas de guardar.

        Guarda como Lab_01-3_clean.exe.


------------------------------
## Ahora tenemos un binario:

    Desempaquetado ‚úîÔ∏è

    Con imports reconstruidos ‚úîÔ∏è

    Listo para an√°lisis con:

        üß† Ghidra

        üîç PE-bear

        üî¨ strings, die, pestudio

        üêõ Sandbox, procmon, wireshark si quieres an√°lisis din√°mico


------------------------------
## Obtenemos los strings del fichero con las instrucciones desempaquetadas

[Strings del malware desempaquetado](strings/Lab_01-3-copia_dump-desempaquetado-ascii.txt)


1. Indicadores de que el malware fue creado en Visual C++
```
Microsoft Visual C++ Runtime Library
Runtime Error!
R6025 - pure virtual function call
R6016 - not enough space for thread data
...
```

Esto indica que el binario se compil√≥ probablemente con Microsoft Visual C++, y tiene v√≠nculos con las librer√≠as est√°ndar de C++.

üåê 2. Capacidades de red detectadas
```
http://%s/%s/
Mozilla/4.0
InternetOpenA
InternetOpenUrlA
InternetCloseHandle
InternetReadFile
WININET.dll
WS2_32.dll
```
Este bloque indica que el malware:
- Puede realizar conexiones HTTP (probablemente a un C2).
- Simula un agente de usuario Mozilla/4.0.
- Usa WinINet, una API com√∫n de Windows para tr√°fico web.
- Usa funciones de bajo nivel (WS2_32.dll) para manejo de sockets.

üî∫ Conclusi√≥n: tiene capacidades de beaconing y comunicaci√≥n remota.

üì¶ 3. Carga din√°mica de funciones
```
LoadLibraryA
GetProcAddress
VirtualProtect
VirtualAlloc
VirtualFree
```
Estas funciones permiten:
- Cargar DLLs en tiempo de ejecuci√≥n.
- Obtener punteros a funciones en ellas.
- Reservar, modificar y liberar memoria virtual.

üî∫ Indica posible shellcode, desofuscaci√≥n din√°mica o self-injection.


üóÉÔ∏è 4. Manejo de recursos y posibles strings personalizados
```
FindResourceA
LoadResource
LockResource
GlobalAlloc
SizeofResource
```
Esto sugiere que:
- El malware probablemente extrae recursos embebidos (como ejecutables, DLLs, payloads secundarios o configuraciones).
- Podr√≠a estar autocontenida con payloads ocultos en la secci√≥n .rsrc.

üìå 5. Strings sospechosos / C2 / herramientas
```
http://%s/%s/
www.practicalmalwareanalysis.com
C:\Users\usuario\Desktop\Lab_01-3 - copia.exe
```
- Se detecta una plantilla para URLs ‚Üí probablemente reemplazada en tiempo de ejecuci√≥n.
- Referencia al entorno de an√°lisis (usuario\Desktop...) ‚Üí probablemente el entorno donde fue capturado el dump.

‚ö†Ô∏è 6. Otras funciones clave
```
ExitProcess
TerminateProcess
UnhandledExceptionFilter
GetCurrentProcess
SetHandleCount
GetStartupInfoA
HeapAlloc / HeapFree / HeapCreate
```
- Control de flujo, manejo de errores y heap manual ‚Üí t√≠pico de malware m√°s avanzado o ofuscado.

üß© Resumen del comportamiento detectado
| Componente	 | Evidencia |
| -- | -- |
| Comunicaci√≥n remota (C2)	 | InternetOpenUrlA, http://%s/%s/, Mozilla/4.0 |
| Carga din√°mica de c√≥digo	 | LoadLibraryA, GetProcAddress, VirtualProtect, VirtualAlloc |
| Desempaquetado / Shellcode	 | VirtualProtect, uso de .rsrc, SizeofResource, FlushFileBuffers |
| Autocontenidos / recursos	 | FindResourceA, LockResource, LoadResource, .rsrc |
| Persistencia o ejecuci√≥n	 |ExitProcess, TerminateProcess, GetStartupInfoA |

üö® Conclusi√≥n:  
La muestra desempaquetada tiene caracter√≠sticas t√≠picas de malware con payload embebido, cifrado en recursos o secciones, y capacidades de conexi√≥n remota para posiblemente contactar con un servidor C2.

Adem√°s, se apoya en t√©cnicas de evasi√≥n como carga din√°mica de funciones y uso de memoria protegida, lo que sugiere que pudo haber sido ofuscado o construido como dropper/injector.

------------------------------
## Comparativa muestra sin desempaquetar VS muestra empaquetada

**Muestra empaquetada:**
![Instrucciones sin desempaquetar](capturas/instrucciones-del-malware-sin-desempaquetar.png)

**Muestra desempaquetada:**
![Instrucciones desempaquetadas](capturas/instrucciones-del-malware-desempaquetadas.png)




------------------------------
## Analisis con Ghidra del malware desempaquetado

