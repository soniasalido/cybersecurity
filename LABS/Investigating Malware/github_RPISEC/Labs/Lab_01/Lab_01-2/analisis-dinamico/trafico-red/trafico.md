## RESUMEN GENERAL DE LA CAPTURA
| Campo |	Valor |
| --| -- |
| IP origen| 	192.168.100.5 (tu VM Windows) |
| IP destino| 	69.25.50.10 |
| Protocolo| 	TLSv1.2 |
| Tipo de paquete| 	Client Hello |
| Puerto destino| 	443 (HTTPS) |
| Hora relativa| 	28.583027 s |

Este paquete es un inicio de conexión segura desde la MV Windows hacia el servidor remoto.

Client Hello es el primer mensaje de la negociación TLS (handshake).

El malware está intentando iniciar una conexión cifrada con el servidor remoto 69.25.50.10.


En el Lab 1.2 de RPISEC, el malware simula un cliente que contacta con un servidor C2 (Command & Control). Usa TLS para cifrar la comunicación, lo que impide que veamoss directamente el contenido de los comandos sin desencriptar el tráfico.

### Para desencriptar el tráfico, podríamos:
- Hook de funciones: Usaríamos una herramienta como Frida o API Monitor para interceptar llamadas a funciones como:
    - InternetReadFile.
    - HttpSendRequestA.
    - send, recv.
    - WinINet.dll o WinHTTP.dll.
- Análisis de memoria: Usar herramientas como x64dbg o Procmon para ver qué comandos se envían o reciben antes del cifrado.
- FakeNet-NG: Usaríamos la opción -p para emular puertos. Podemos redirigir 69.25.50.10 a la MV Linux con FakeNet usando reglas DNS o en el hosts de Windows.
- TLS proxy / MITM: Podemos crear un entorno donde el malware confíe en nuestro certificado TLS para hacer un ataque man-in-the-middle (MITM), por ejemplo con:
    - mitmproxy.
    - Burp Suite.

🧨 ¿Y si el malware valida certificados?
Muchos malware verifican los certificados o usan certificate pinning. En ese caso, deberíamos usar hooking con Frida o instrumentación dinámica (x64dbg, Procmon, etc.).


## Desencriptar tráfico con Burpsuite
🧰 Requisitos
- Máquina Linux: con Burp Suite y FakeNet-NG
- Máquina Windows: donde ejecutarás la muestra
- Ambas conectadas a una red interna compartida
- Malware que no valide el certificado TLS (o puedas forzar que lo acepte)

