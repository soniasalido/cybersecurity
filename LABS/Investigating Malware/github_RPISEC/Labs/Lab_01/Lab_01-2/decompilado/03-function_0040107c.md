```
                             **************************************************************
                             *                          FUNCTION                          *
                             **************************************************************
                             undefined4 __stdcall FUN_0040107c(undefined4 param_1, ch
                               assume FS_OFFSET = 0xffdff000
             undefined4        EAX:4          <RETURN>
             undefined4        Stack[0x4]:4   param_1                                 XREF[1]:     0040108f(R)
             char *            Stack[0x8]:4   param_2                                 XREF[1]:     00401080(R)
             void *            Stack[0xc]:4   param_3                                 XREF[2]:     004010d8(R),
                                                                                                   004010f2(R)
             undefined4        Stack[0x10]:4  param_4
             size_t *          Stack[0x14]:4  param_5                                 XREF[2]:     00401086(R),
                                                                                                   004010e0(R)
                             FUN_0040107c                                    XREF[3]:     FUN_00401106:0040125c(c),
                                                                                          FUN_0040133a:00401408(c),
                                                                                          FUN_004014f4:00401787(c)
        0040107c 55              PUSH       EBP
        0040107d 8b ec           MOV        EBP,ESP
        0040107f 53              PUSH       EBX
        00401080 8b 5d 0c        MOV        EBX,dword ptr [EBP + param_2]
        00401083 57              PUSH       EDI
        00401084 8b f9           MOV        EDI,ECX
        00401086 ff 75 18        PUSH       dword ptr [EBP + param_5]
        00401089 68 ff 03        PUSH       0x3ff
                 00 00
        0040108e 53              PUSH       EBX
        0040108f ff 75 08        PUSH       dword ptr [EBP + param_1]
        00401092 ff 15 d8        CALL       dword ptr [->WININET.DLL::InternetReadFile]      = 000022cc
                 20 40 00
        00401098 85 c0           TEST       EAX,EAX
        0040109a 75 04           JNZ        LAB_004010a0
        0040109c 32 c0           XOR        AL,AL
        0040109e eb 60           JMP        LAB_00401100
                             LAB_004010a0                                    XREF[1]:     0040109a(j)
        004010a0 56              PUSH       ESI
        004010a1 6a 00           PUSH       0x0
        004010a3 68 9c 30        PUSH       s_<head>_0040309c                                = "<head>\r\n"
                 40 00
        004010a8 53              PUSH       EBX
        004010a9 8b cf           MOV        ECX,EDI
        004010ab e8 99 ff        CALL       FUN_00401049                                     int FUN_00401049(char * param_1,
                 ff ff
        004010b0 8b f0           MOV        ESI,EAX
        004010b2 8b cf           MOV        ECX,EDI
        004010b4 8d 46 08        LEA        EAX,[ESI + 0x8]
        004010b7 50              PUSH       EAX
        004010b8 68 90 30        PUSH       s_</head>_00403090                               = "</head>\r\n"
                 40 00
        004010bd 53              PUSH       EBX
        004010be e8 86 ff        CALL       FUN_00401049                                     int FUN_00401049(char * param_1,
                 ff ff
        004010c3 83 fe ff        CMP        ESI,-0x1
        004010c6 74 22           JZ         LAB_004010ea
        004010c8 83 f8 ff        CMP        EAX,-0x1
        004010cb 74 1d           JZ         LAB_004010ea
        004010cd 2b c6           SUB        EAX,ESI
        004010cf 8d 78 f6        LEA        EDI,[EAX + -0xa]
        004010d2 8d 44 1e 08     LEA        EAX,[ESI + EBX*0x1 + 0x8]
        004010d6 57              PUSH       EDI                                              size_t _Size for memcpy
        004010d7 50              PUSH       EAX                                              void * _Src for memcpy
        004010d8 ff 75 10        PUSH       dword ptr [EBP + param_3]                        void * _Dst for memcpy
        004010db e8 06 0b        CALL       MSVCRT.DLL::memcpy                               void * memcpy(void * _Dst, void
                 00 00
        004010e0 8b 45 18        MOV        EAX,dword ptr [EBP + param_5]
        004010e3 83 c4 0c        ADD        ESP,0xc
        004010e6 89 38           MOV        dword ptr [EAX],EDI
        004010e8 eb 13           JMP        LAB_004010fd
                             LAB_004010ea                                    XREF[2]:     004010c6(j), 004010cb(j)
        004010ea 53              PUSH       EBX                                              char * _Str for strlen
        004010eb e8 f0 0a        CALL       MSVCRT.DLL::strlen                               size_t strlen(char * _Str)
                 00 00
        004010f0 50              PUSH       EAX                                              size_t _Size for memcpy
        004010f1 53              PUSH       EBX                                              void * _Src for memcpy
        004010f2 ff 75 10        PUSH       dword ptr [EBP + param_3]                        void * _Dst for memcpy
        004010f5 e8 ec 0a        CALL       MSVCRT.DLL::memcpy                               void * memcpy(void * _Dst, void
                 00 00
        004010fa 83 c4 10        ADD        ESP,0x10
                             LAB_004010fd                                    XREF[1]:     004010e8(j)
        004010fd b0 01           MOV        AL,0x1
        004010ff 5e              POP        ESI
                             LAB_00401100                                    XREF[1]:     0040109e(j)
        00401100 5f              POP        EDI
        00401101 5b              POP        EBX
        00401102 5d              POP        EBP
        00401103 c2 14 00        RET        0x14

```

Esta funci√≥n FUN_0040107C representa una rutina de parsing de respuesta HTTP, probablemente de una comunicaci√≥n C2 (Command & Control), usada para extraer datos √∫tiles (como comandos o payloads) desde un cuerpo HTTP que contiene una estructura con <head>...</head>.

### üß† Firma reconstruida (en C aproximado)
bool __stdcall FUN_0040107C(HINTERNET hFile, char *buffer, void *output, size_t *output_size);

Donde:
- param_1: manejador de red (de InternetReadFile)
- param_2: buffer donde se almacenar√° la respuesta (probablemente char *)
- param_3: puntero a buffer destino (void *)
- param_5: puntero a variable para guardar el tama√±o (size_t *)

### üîç Paso a paso explicativo
üõ∞ 1. Lectura desde Internet:  
InternetReadFile(hFile, buffer, 0x3FF, output_size)  
‚Üí Lee hasta 1023 bytes desde la conexi√≥n de red (hFile) y guarda el resultado en buffer. El n√∫mero de bytes le√≠dos se guarda en *param_5.

Si falla, salta a LAB_00401100 y devuelve false.

üîé 2. Buscar delimitadores HTML (<head> y </head>)  
int start = FUN_00401049(buffer, "<head>\r\n", 0);      // buscar inicio  
int end   = FUN_00401049(buffer, "</head>\r\n", start + 8); // buscar final  

‚Üí Usa la funci√≥n de b√∫squeda parcial de subcadenas que analizamos antes.

‚úÖ 3. Si ambos delimitadores existen
```
if (start != -1 && end != -1) {
    size_t len = end - start - 10;
    memcpy(output, &buffer[start + 8], len);
    *output_size = len;
}
```
‚Üí Extrae el contenido entre <head>\r\n y </head>\r\n, lo guarda en param_3, y guarda el tama√±o en param_5.  
El -10 y +8 ajustan los delimitadores para no incluirlos.


‚ùå 4. Si no hay delimitadores:
memcpy(output, buffer, strlen(buffer));  
‚Üí Copia el contenido completo del buffer recibido tal cual.

üéØ 5. Devuelve true si todo fue bien

return 1; // (AL = 0x1)

‚úÖ Conclusi√≥n funcional: La funci√≥n FUN_0040107C:
- Lee una respuesta desde un canal HTTP usando InternetReadFile.
- Intenta localizar una secci√≥n delimitada por <head>\r\n y </head>\r\n.
- Si existe:
    - Extrae solo el contenido entre los delimitadores.
    - Lo guarda en el buffer de salida.
    - Es ideal para enviar instrucciones o datos ocultos dentro de respuestas HTML leg√≠timas.
- Si no existe:
    - Copia la respuesta completa.

ü¶† En contexto de malware: Esta funci√≥n encaja perfectamente con una infraestructura de malware basada en HTTP, que:
- Se comunica con un panel C2 disfrazado como p√°gina web.
- Recibe comandos en HTML camuflados.
- Usa delimitadores como <head> para separar el contenido real del ruido.
