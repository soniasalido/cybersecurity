**Nota Previa:**
El c√≥digo desemsamblado est√° en little endian, los bytes de un valor multibyte (por ejemplo, 2 o 4 bytes) se almacenan del menos significativo al m√°s significativo.
```
004000E4: 4C 01  ‚Üí  se interpreta como 0x014C
```
- 4C es el byte menos significativo
- 01 es el m√°s significativo


## Contenido desensamblado de la muestra de malware: Cabecera

```
                             //
                             // Headers
                             // ram:00400000-ram:004003ff
                             //
             assume DF = 0x0  (Default)
                             IMAGE_DOS_HEADER_00400000      XREF[1]:     00400114(*)
        00400000 4d 5a 90        IMAGE_DO
                 00 03 00
                 00 00 04
           00400000 4d 5a           char[2]   "MZ"        e_magic       XREF[1]:     00400114(*)
```
El encabezado DOS (DOS header) de un archivo PE (Portable Executable) de Windows, que es la estructura inicial de cualquier ejecutable .exe o .dll. Esta estructura se llama **IMAGE_DOS_HEADER**, y es la primera parte de un ejecutable en Windows. 

El **IMAGE_DOS_HEADER** es necesario para que Windows lo reconozca como ejecutable.

-------
### üìå 00400000 ‚Üí Campo e_magic

```
00400000 4D 5A           // "MZ"
```
Esto es el campo e_magic, que contiene "MZ", las iniciales de Mark Zbikowski, uno de los creadores del formato. Es una firma m√°gica que le dice al sistema: ‚Äúesto es un archivo ejecutable‚Äù.

-------

### üìå 0040003c ‚Üí Donde comienza la estructura PE
```
0040003c e0 00 00 00     ddw       E0h  e_lfanew      File address of ne
```
e_lfanew apunta a la offset donde comienza la estructura PE (Portable Executable) real. En este caso, es 0xE0, o sea, el encabezado PE est√° en 00400000 + 0xE0 = 004000E0.

-------

### üìå 00400040 ‚Üí Programa DOS "dummy"
```
00400040 0e 1f ba 0e 00  db[64]   e_program     Actual DOS program
         b4 09 cd 21 b8
         01 4c cd 21 54
```
Este bloque representa el programa DOS "dummy" que se ejecuta si alguien intenta lanzar este .exe en MS-DOS. Es una mini rutina en ensamblador x86 que imprime: "This program cannot be run in DOS mode."

Esto no tiene relevancia en reversing moderno, pero es necesario para cumplir con el formato PE.

-------


### üìå 004000E0 ‚Üí Inicio del encabezado PE
```
004000e0 50 45 00        IMAGE_NT      = 000022e0
         00 4c 01                      = 21D4h
         04 00 09
```

004000E0 50 45 00 00

‚úÖ Esto es clave:
- 50 45 = "PE"
- 00 00 = nulls para completar el identificador de 4 bytes: "PE\0\0"
- Marca el inicio del IMAGE_NT_HEADERS.

-------
### üìå PE\0\0  ‚Üí Firma m√°gica que marca el inicio del formato PE.
La firma m√°gica que marca el inicio del formato PE est√° formada por:

| Byte |	Valor hexadecimal |	Significado |
| -- | -- | -- |
| 'P' | 	0x50 | 	Letra "P" |
| 'E' | 	0x45 | 	Letra "E" |
| '\0' | 	0x00 | 	Byte nulo (null) |
| '\0' | 	0x00 | 	Otro byte nulo |

**¬øPor qu√© tiene dos ceros (\0\0)?**
Porque la especificaci√≥n PE exige que la firma tenga cuatro bytes en total:
- Dos letras: P y E.
- Dos bytes nulos: \0\0

Esto completa el campo de firma de 4 bytes que el sistema operativo necesita para validar que se trata de un archivo PE.

-------

### üìå 004000E4+ ‚Üí Cabecera de archivo (IMAGE_FILE_HEADER)
Encabezado PE (IMAGE_NT_HEADERS) y su contenido:
```
004000e0 50 45 00        IMAGE_NT        = 000022e0
         00 4c 01                        = 21D4h
         04 00 09
```



```
004000E4 4C 01        // M√°quina: 0x014C ‚Üí x86
004000E6 04 00        // N√∫mero de secciones: 4
004000E8 09 ...       // M√°s campos (timestamp, etc.)
```
- Tipo de arquitectura (x86 = 0x14C, x64 ser√≠a 0x8664)
- N√∫mero de secciones (.text, .data, etc.)
- Tama√±o del optional header
- Caracter√≠sticas del archivo

```
#define IMAGE_FILE_MACHINE_I386  0x014c  // x86
```

Valores T√≠picos para este campo:
| Valor	| Arquitectura |
|--|--|
| 0x014c	| 	x86 (32 bits) |
| 0x8664	| 	x86-64 (64 bits) |
| 0x01c0	| 	ARM |
| 0x0200	| 	IA64 (Itanium) |

--------

### üìå 004001D8, 00400200, 00400228, 00400250 ‚Üí Secciones del binario
```
004001d8 2e 74 65        IMAGE_SE   .text    // C√≥digo ejecutable
         78 74 00
         00 00 a6
00400200 2e 72 64        IMAGE_SE    .rdata  // Datos de solo lectura (strings, imports, etc.)
         61 74 61
         00 00 7e
00400228 2e 64 61        IMAGE_SE    .data   // Datos de lectura/escritura (variables globales)
         74 61 00
         00 00 28
00400250 2e 72 73        IMAGE_SE    .rsrc   // Recursos (√≠conos, men√∫s, etc.)
         72 63 00
         00 00 7c
```

Cada secci√≥n tiene:
- Nombre (".text", ".rdata", etc.)
- Direcci√≥n virtual (RVA)
- Tama√±o
- Offset f√≠sico en el archivo

-------
### üìå Secci√≥n .text ‚Üí
```
004001d8 2e 74 65        IMAGE_SE   .text    // C√≥digo ejecutable
         78 74 00
         00 00 a6
```
**La direcci√≥n 004001D8 no es el inicio real del c√≥digo .text, sino la ubicaci√≥n en el archivo donde est√° descrita la entrada de la secci√≥n .text** en la tabla de secciones del encabezado PE. Para ver el contenido de esta secci√≥n podemos usar Ghidra para ir a esta direcci√≥n y ver su contenido.

```
004001D8 2e 74 65 78 74 00 00 00   ‚Üí ".text\0\0\0"
```

### üìå ¬øD√≥nde est√° .text? ‚Üí
**Para saber d√≥nde saltar para ver .text, necesitamos saber:**
1. Localizar el e_lfanew: 0040003c e0 00 00 00 ‚Üí e_lfanew = 0xE0. Esto indica que el encabezado PE (que empieza con "PE\0\0") se encuentra en el offset 0xE0 del archivo.
2. Saltamos al encabezado PE: 004000E0 50 45 00 00 ‚Üí "PE\0\0".
3. Y justo despu√©s de este encabezado, vienen:
  - El IMAGE_FILE_HEADER (20 bytes).
  - El IMAGE_OPTIONAL_HEADER (habitualmente 0xE0 bytes).
  - Luego, la tabla de secciones, que empieza justo despu√©s del optional header.
4. Leemos la entrada .text en la tabla de secciones: 004001d8 2e 74 65 78 74 00 00 00 ‚Üí ".text". Esto es claramente la primera entrada de la tabla de secciones (40 bytes de tama√±o cada una).


**Cada entrada de secci√≥n ocupa 40 bytes, con esta distribuci√≥n:**
| Offset |	Campo |		Tama√±o |		Comentario |
| -- | -- | -- | --  |
| 0x00 |	Name | 8B	|	".text" |
| 0x08 |	VirtualSize |	4B	|	Tama√±o real en memoria |
| 0x0C |	VirtualAddress | 4B	|	Direcci√≥n virtual en memoria |
| 0x10 |	SizeOfRawData |	4B |	Tama√±o en el archivo |
| 0x14 |	PointerToRawData | 4B |	Offset en el archivo |


**Estructura .text:**  
Para ver el contenido de esta estructura, abrimos el malware con Ghidra.
![Contenido en memoria de la direcci√≥n 0041000 ](capturas/contenido-ghidra.png)

| Direcci√≥n | Bytes| Campo |
| ----------- | ---------------------------- |  ----------------------------- | 
| 004001D8 | 2e 74 65 78 74 00 00 00 | Name (".text") | 
| 004001E0 | a6 00 00 00 | VirtualSize (0x000000A6) | 
| 004001E4 | 00 10 00 00 | **VirtualAddress (0x00001000)** | 
| 004001E8 | 00 10 00 00 | SizeOfRawData (0x00000200) | 
| 004001EC | 00 04 00 00 | **PointerToRawData (0x000000E0)** | 
| 004001F0 | 00 00 00 00 | PointerToRelocations | 
| 004001F4 | 00 00 00 00 | PointerToLinenumbers | 
| 004001F8 | 00 00 | NumberOfRelocations | 
| 004001FA | 00 00 | NumberOfLinenumbers | 
| 004001FC | 20 00 00 60 | Characteristics (posiblemente ejecutable) | 


Los campos importantes en una entrada de secci√≥n (IMAGE_SECTION_HEADER) son:
| Offset relativo |	Campo |	Tama√±o |	Valor le√≠do (hex) |	Significado | Comentario |
| -- | -- | -- | -- | -- | -- |
| 0x00 | 	Name (.text) | 	8B | 2e 74 65 78 74 00 00 00 | ".text" | .text\0\0\0 |
| 0x08 | 	VirtualSize | 	4B | a6 00 00 00 | 0x000000A6 |  0xA6 |
| 0x0C | 	VirtualAddress | 	4B | 00 10 00 00 | 0x00001000 |  0x1000 |
| 0x10 | 	SizeOfRawData | 	4B | 00 10 00 00  | 0x00001000 | 0x1000 |
| 0x14 | 	PointerToRawData | 	4B | 00 04 00 00  | 0x00000400 | 0x400 |


5. VirtualAddrees: Se encuentra en 004001E4. En Ghidra buscamos esta direcci√≥n y vemos su contenido: 0X004001E4 ‚Üí **00 10 00 00**.
6. PointerToRawData: **0x00000400**	Offset en el archivo (donde comienza .text). 
7. SizeOfRawData: 0x00001000	Tama√±o de la secci√≥n en el archivo (4 KB).
8. VirtualSize	0x000000A6	Tama√±o real del c√≥digo.


‚úÖ **¬øD√≥nde est√° el c√≥digo ejecutable?**  
üìÅ En el archivo: Offset f√≠sico: 0x00000400. Ah√≠ comienzan los bytes de la secci√≥n .text en el disco. Para verlo usamos comando xxd.  
![Contenido en memoria de la direcci√≥n 0041000 ](capturas/contenido-text-crudo.png)

üíª En memoria (cuando se carga en ejecuci√≥n): Direcci√≥n virtual: 0x00401000. (asumiendo ImageBase = 0x00400000, que es est√°ndar para PE de 32 bits). Para verlo usamos ghidra  ‚Üí   

![Contenido en memoria de la direcci√≥n 0041000 ](capturas/direccion-00401000.png)

-------
üéØ Resumen funcional
|Campo |	Direcci√≥n |	Descripci√≥n |
|--|--|--|
| e_magic |	0x00400000 | Firma "MZ" ‚Üí indica que es ejecutable DOS/PE |
| e_lfanew |	0x0040003C |	Offset del encabezado PE (donde empieza lo importante para Windows) |
| e_program | 0x00400040 |	C√≥digo DOS que se ejecuta si se intenta abrir en MS-DOS |
| Program | 00400040| 	Programa DOS (relleno) |
| Firma PE  | 004000E0	Firma PE (PE\0\0) ‚Üí comienza el PE header |
| .text | 004001D8 |	.text section (c√≥digo ejecutable) |
| .rdata | 00400200 |	.rdata (strings, tabla de importaci√≥n) |
| .data | 00400228 |	.data (variables globales) |
| .rsrc | 00400250 |	.rsrc (recursos como √≠conos, GUI, etc) |


## Contenido desensamblado de la muestra de malware: .text ‚Üí Funci√≥n FUN_00401240

```
                             **************************************************************
                             *                          FUNCTION                          *
                             **************************************************************
                             undefined4 __stdcall FUN_00401240(HINSTANCE param_1)
                               assume FS_OFFSET = 0xffdff000
             undefined4        EAX:4          <RETURN>
             HINSTANCE         Stack[0x4]:4   param_1                                 XREF[1]:     00401240(R)
                             FUN_00401240                                    XREF[1]:     entry:00401e09(c)
        00401240 8b 44 24 04     MOV        EAX,dword ptr [ESP + param_1]
        00401244 68 ff 00        PUSH       0xff                                             int cchBufferMax for LoadStringA
                 00 00
        00401249 68 a0 30        PUSH       _Str_004030a0                                    LPSTR lpBuffer for LoadStringA
                 40 00
        0040124e 6a 01           PUSH       0x1                                              UINT uID for LoadStringA
        00401250 50              PUSH       EAX                                              HINSTANCE hInstance for LoadStri
        00401251 ff 15 e0        CALL       dword ptr [->USER32.DLL::LoadStringA]            = 000024de
                 20 40 00
        00401257 68 a0 30        PUSH       _Str_004030a0                                    = 00000000
                 40 00
        0040125c e8 5f 00        CALL       FUN_004012c0                                     undefined FUN_004012c0(void)
                 00 00
        00401261 83 c4 04        ADD        ESP,0x4
        00401264 33 c0           XOR        EAX,EAX
        00401266 c2 10 00        RET        0x10
        00401269 90 90 90        align      align(7)
                 90 90 90 90
        00401270 53              ??         53h    S
        00401271 55              ??         55h    U
        00401272 8b              ??         8Bh
        00401273 6c              ??         6Ch    l
        00401274 24              ??         24h    $
        00401275 14              ??         14h
        00401276 56              ??         56h    V
        00401277 85              ??         85h
        00401278 ed              ??         EDh
        00401279 57              ??         57h    W
        0040127a 8b              ??         8Bh
        0040127b f5              ??         F5h
        0040127c 7e              ??         7Eh    ~
        0040127d 20              ??         20h
        0040127e 8b              ??         8Bh
        0040127f 5c              ??         5Ch    \
        00401280 24              ??         24h    $
        00401281 14              ??         14h
        00401282 8b              ??         8Bh
        00401283 7c              ??         7Ch    |
        00401284 24              ??         24h    $
        00401285 18              ??         18h
        00401286 6a              ??         6Ah    j
        00401287 00              ??         00h
        00401288 56              ??         56h    V
        00401289 57              ??         57h    W
        0040128a 53              ??         53h    S
        0040128b e8              ??         E8h
        0040128c dc              ??         DCh
        0040128d 0b              ??         0Bh
        0040128e 00              ??         00h
        0040128f 00              ??         00h
        00401290 85              ??         85h
        00401291 c0              ??         C0h
        00401292 7c              ??         7Ch    |
        00401293 11              ??         11h
        00401294 74              ??         74h    t
        00401295 17              ??         17h
        00401296 2b              ??         2Bh    +
        00401297 f0              ??         F0h
        00401298 03              ??         03h
        00401299 f8              ??         F8h
        0040129a 85              ??         85h
        0040129b f6              ??         F6h
        0040129c 7f              ??         7Fh    
        0040129d e8              ??         E8h
        0040129e 5f              ??         5Fh    _
        0040129f 8b              ??         8Bh
        004012a0 c5              ??         C5h
        004012a1 5e              ??         5Eh    ^
        004012a2 5d              ??         5Dh    ]
        004012a3 5b              ??         5Bh    [
        004012a4 c3              ??         C3h
        004012a5 5f              ??         5Fh    _
        004012a6 5e              ??         5Eh    ^
        004012a7 5d              ??         5Dh    ]
        004012a8 83              ??         83h
        004012a9 c8              ??         C8h
        004012aa ff              ??         FFh
        004012ab 5b              ??         5Bh    [
        004012ac c3              ??         C3h
        004012ad 8b              ??         8Bh
        004012ae c5              ??         C5h
        004012af 5f              ??         5Fh    _
        004012b0 2b              ??         2Bh    +
        004012b1 c6              ??         C6h
        004012b2 5e              ??         5Eh    ^
        004012b3 5d              ??         5Dh    ]
        004012b4 5b              ??         5Bh    [
        004012b5 c3              ??         C3h
        004012b6 90              ??         90h
        004012b7 90              ??         90h
        004012b8 90              ??         90h
        004012b9 90              ??         90h
        004012ba 90              ??         90h
        004012bb 90              ??         90h
        004012bc 90              ??         90h
        004012bd 90              ??         90h
        004012be 90              ??         90h
        004012bf 90              ??         90h
```
üëâ Esto es una llamada a LoadStringA(), una funci√≥n de la API de Windows:
```
int LoadStringA(
  HINSTANCE hInstance,
  UINT uID,
  LPSTR lpBuffer,
  int cchBufferMax
);
```
Intenta cargar una cadena (string) del segmento de recursos del ejecutable, usando el ID 1, y la escribe en el buffer 0x4030a0.

