Investigamos el Import CreateProcessA

[0x00401cda]> ii~CreateProcessA
13  0x00402030 NONE FUNC KERNEL32.dll CreateProcessA

[0x00401cda]> ii~CreateProcessA   # Encuentramos la direcci√≥n del import
13  0x00402030 NONE FUNC KERNEL32.dll CreateProcessA
‚Üí Esto te dice que CreateProcessA est√° importado en 0x00402030


AXT es un comando  que muestra todas las referencias cruzadas (XREFs) a una direcci√≥n concreta. Es decir, muestra qu√© instrucciones dentro del binario apuntan o saltan a esa direcci√≥n.
¬øQui√©n est√° llamando (o saltando a) la direcci√≥n 0x00402030, que es la importaci√≥n de CreateProcessA?
[0x00401cda]> axt 0x00402030  # Encuentramos las llamadas al import
fcn.00401860 0x401910 [CALL:--x] call dword [sym.imp.KERNEL32.dll_CreateProcessA]   # Apunta la direcci√≥n 0x401910

Esto significa que en la direcci√≥n 0x00401910 hay una instrucci√≥n call [0x00402030], es decir, se llama a CreateProcessA.



[0x00401cda]> s 0x401910    # Vamos a la direcci√≥n 0x401910
[0x00401910]> pd20          # Desensambla y muestra 20 l√≠neas del import
‚îÇ           0x00401910      ff1530204000   call dword [sym.imp.KERNEL32.dll_CreateProcessA] ; 0x402030 ; BOOL CreateProcessA(LPCSTR lpApplicationName, LPSTR lpCommandLine, LPSECURITY_ATTRIBUTES lpProcessAttributes, LPSECURITY_ATTRIBUTES lpThreadAttributes, BOOL bInheritHandles, DWORD dwCreationFlags, LPVOID lpEnvironment, LPCSTR lpCurrentDirectory, LPSTARTUPINFOA lpStartupInfo, LPPROCESS_INFORMATION lpProcessInformation)
‚îÇ           0x00401916      85c0           test eax, eax
‚îÇ       ‚îå‚îÄ< 0x00401918      7418           je 0x401932
‚îÇ       ‚îÇ   0x0040191a      8b4c241c       mov ecx, dword [var_1ch]
‚îÇ       ‚îÇ   0x0040191e      8b742418       mov esi, dword [var_18h_2]
‚îÇ       ‚îÇ   0x00401922      51             push ecx                    ; HANDLE hObject
‚îÇ       ‚îÇ   0x00401923      ff1500204000   call dword [sym.imp.KERNEL32.dll_CloseHandle] ; 0x402000 ; BOOL CloseHandle(HANDLE hObject)
‚îÇ       ‚îÇ   0x00401929      8bc6           mov eax, esi
‚îÇ       ‚îÇ   0x0040192b      5f             pop edi
‚îÇ       ‚îÇ   0x0040192c      5e             pop esipd -20 @ 0x004018e7
‚îÇ       ‚îÇ   0x0040192d      5b             pop ebx
‚îÇ       ‚îÇ   0x0040192e      83c460         add esp, 0x60
‚îÇ       ‚îÇ   0x00401931      c3             ret
‚îÇ       ‚îÇ   ; CODE XREF from fcn.00401860 @ 0x401918(x)
‚îÇ       ‚îî‚îÄ> 0x00401932      5f             pop edi
‚îÇ           0x00401933      8bc3           mov eax, ebx
‚îÇ           0x00401935      5e             pop esi
‚îÇ           0x00401936      5b             pop ebx
‚îÇ           0x00401937      83c460         add esp, 0x60
‚îî           0x0040193a      c3             ret
            0x0040193b      90             nop
[0x00401910]>


Hemos encontrado la instrucci√≥n call dword [sym.imp.KERNEL32.dll_CreateProcessA] en la direcci√≥n 0x00401910.
CreateProcessA recibe 10 argumentos, empujados en orden de derecha a izquierda (√∫ltimo primero):
push lpProcessInformation        ; +36
push lpStartupInfo              ; +32
push lpCurrentDirectory         ; +28
push lpEnvironment              ; +24
push dwCreationFlags            ; +20
push bInheritHandles            ; +16
push lpThreadAttributes         ; +12
push lpProcessAttributes        ; +8
push lpCommandLine              ; +4 ‚Üê lo que m√°s te interesa
push lpApplicationName          ; +0
call CreateProcessA


_____________________________________

Ya que estamos en 0x00401910, debemos desensamblar hacia atr√°s (unas 10‚Äì15 instrucciones antes) para ver los push que preparan esos par√°metros.


[0x0040193b]> pd -20
‚îÇ           0x0040190f      53             push ebx                    ; LPCSTR lpApplicationName
‚îÇ           0x00401910      ff1530204000   call dword [sym.imp.KERNEL32.dll_CreateProcessA] ; 0x402030 ; BOOL CreateProcessA(LPCSTR lpApplicationName, LPSTR lpCommandLine, LPSECURITY_ATTRIBUTES lpProcessAttributes, LPSECURITY_ATTRIBUTES lpThreadAttributes, BOOL bInheritHandles, DWORD dwCreationFlags, LPVOID lpEnvironment, LPCSTR lpCurrentDirectory, LPSTARTUPINFOA lpStartupInfo, LPPROCESS_INFORMATION lpProcessInformation)
‚îÇ           0x00401916      85c0           test eax, eax
‚îÇ       ‚îå‚îÄ< 0x00401918      7418           je 0x401932
‚îÇ       ‚îÇ   0x0040191a      8b4c241c       mov ecx, dword [var_1ch]
‚îÇ       ‚îÇ   0x0040191e      8b742418       mov esi, dword [var_18h_2]
‚îÇ       ‚îÇ   0x00401922      51             push ecx                    ; HANDLE hObject
‚îÇ       ‚îÇ   0x00401923      ff1500204000   call dword [sym.imp.KERNEL32.dll_CloseHandle] ; 0x402000 ; BOOL CloseHandle(HANDLE hObject)
‚îÇ       ‚îÇ   0x00401929      8bc6           mov eax, esi
‚îÇ       ‚îÇ   0x0040192b      5f             pop edi
‚îÇ       ‚îÇ   0x0040192c      5e             pop esi
‚îÇ       ‚îÇ   0x0040192d      5b             pop ebx
‚îÇ       ‚îÇ   0x0040192e      83c460         add esp, 0x60
‚îÇ       ‚îÇ   0x00401931      c3             ret
‚îÇ       ‚îÇ   ; CODE XREF from fcn.00401860 @ 0x401918(x)
‚îÇ       ‚îî‚îÄ> 0x00401932      5f             pop edi
‚îÇ           0x00401933      8bc3           mov eax, ebx
‚îÇ           0x00401935      5e             pop esi
‚îÇ           0x00401936      5b             pop ebx
‚îÇ           0x00401937      83c460         add esp, 0x60
‚îî           0x0040193a      c3             ret


_______________________
_____________________________
üîß Desglose por instrucciones:
Direcci√≥n	Instrucci√≥n	Significado
0x0040161d	mov ebx, [sym.imp.KERNEL32.dll_CreatePipe]	Guarda la direcci√≥n de CreatePipe en ebx.
0x00401623	add esp, 4	Limpia algo anterior en el stack.
0x00401626	mov esi, eax	Guarda eax en esi, posiblemente un puntero a una estructura propia.
0x00401628	lea eax, [var_14h_2]	Apunta a un espacio local donde guardar un handle de lectura.
0x0040162c	push 0	√öltimo argumento: lpSecurityAttributes = NULL.
0x0040162e	lea ecx, [var_14h]	Apunta a un espacio local donde guardar el handle de escritura.
0x00401632	lea edi, [esi + 4]	Se prepara para guardar el segundo handle en edi.
0x00401635	push eax	3¬∫ argumento: direcci√≥n de hReadPipe.
0x00401636	push ecx	2¬∫ argumento: direcci√≥n de hWritePipe.
0x00401637	mov [esi], 0	Inicializa a cero el valor de hReadPipe.
0x0040163d	mov [edi], 0	Inicializa a cero el valor de hWritePipe.
0x00401643	push esi	1¬∫ argumento: lpSecurityAttributes = esi. Pero aqu√≠ parece haber confusi√≥n, ya que en 0x0040162c tambi√©n se hace push 0, habr√≠a que mirar el stack con m√°s detalle.
0x0040165c	call ebx	Llamada real a CreatePipe.
0x0040165e	test eax, eax	Verifica si CreatePipe devolvi√≥ √©xito.
0x00401660	je 0x401675	Si fall√≥, salta a 0x401675 (error/cleanup).
0x00401662	lea edx, [var_14h_3]	Contin√∫a la ejecuci√≥n si fue exitosa.





____________________________

 la instrucci√≥n justo antes del call CreateProcessA es un √∫nico push ebx, lo cual significa que se est√° pasando solo 1 argumento, y est√° incompleto seg√∫n la convenci√≥n est√°ndar de 10 argumentos para CreateProcessA



push ebx                    ; LPCSTR lpApplicationName
call dword [CreateProcessA]

‚úÖ nos dice que el binario est√° usando solo el primer par√°metro, lo cual es totalmente v√°lido porque:

    El primer par√°metro (lpApplicationName) puede ser NULL

    El segundo par√°metro (lpCommandLine) puede usarse solo si contiene el nombre del ejecutable y sus argumentos


Lo importante est√° en el valor de ebx ‚Üí eso contiene la direcci√≥n del nombre del ejecutable (o cadena de comando).


-------------------------------------------------------

üìå Recordatorio: c√≥mo funciona CreateProcessA

BOOL CreateProcessA(
  LPCSTR lpApplicationName,       // ‚Üê Primer par√°metro (push √∫ltimo)
  LPSTR lpCommandLine,            // ‚Üê Segundo
  LPSECURITY_ATTRIBUTES ...
  ...
);

En total: 10 par√°metros, empujados en orden de derecha a izquierda, por lo que:

    El √∫ltimo push antes del call es el primer par√°metro (lpApplicationName).

    El pen√∫ltimo push es el segundo (lpCommandLine), que es el importante.

üîç ¬øQu√© viste t√∫?

0x0040190f   push ebx                  ; lpApplicationName
0x00401910   call [CreateProcessA]

‚ùó Solo hay un push antes del call.
ü§Ø ¬øPor qu√© esto es v√°lido?

Windows permite que algunos par√°metros sean NULL. En concreto:

    Si lpApplicationName == NULL, el sistema usa lpCommandLine para determinar qu√© ejecutable lanzar (extrae el primer token).

    Si lpCommandLine == NULL, pero lpApplicationName est√° bien formado, tambi√©n funciona.

üß† Pero aqu√≠, solo se empuja ebx. Entonces‚Ä¶ ¬øqu√© par√°metros se est√°n usando?

üëâ Por convenci√≥n, el √∫ltimo push antes del call es el primer par√°metro (lpApplicationName).

Como solo hay un push, y est√° pasando ebx, y el call es inmediato...
üîé Podemos inferir:

    Que CreateProcessA est√° siendo llamado solo con el par√°metro lpApplicationName

    Todos los dem√°s par√°metros se est√°n pasando como NULL impl√≠citamente, ya que no se empujaron a la pila

Esto es legal y funcional en C si el binario est√° compilado con convenci√≥n stdcall (como suelen estar los PE de 32 bits). En ese caso, el sistema tolera que se pasen menos argumentos y que queden como basura o NULL en memoria si el uso es trivial (como cmd.exe sin argumentos).


‚úÖ Entonces:

    Al ver solo 1 push antes del call, podemos asumir que el malware solo est√° usando lpApplicationName, y est√° dejando los otros 9 argumentos como nulos o basura.

    Como lpCommandLine no se empuj√≥, y la llamada sigue adelante, sabemos que el sistema solo usar√° lpApplicationName.

    Y como ebx se llen√≥ previamente con la direcci√≥n de "cmd.exe" (Lo veremos en el pr√≥ximo punto), podemos concluir que el binario est√° ejecutando cmd.exe directamente, sin argumentos.

üéØ En resumen:
Hecho observado	Inferencia razonada
Solo un push ebx antes del call	Se est√° pasando solo lpApplicationName
lpCommandLine no se empuja	Se asume como NULL o sin uso
ebx apunta a "cmd.exe"	El binario lanza directamente cmd.exe, sin argumentos

--------------------------------
‚úÖ Pr√≥ximo paso: ver qu√© contiene ebx antes del push
Ya que est√°s en 0x0040190f, mu√©strate 20 instrucciones antes de ese punto, para ver c√≥mo se carga ebx -->
0x0040193b]> pd -20 @ 0x0040190f
‚îÇ           0x004018e7      8bc1           mov eax, ecx
‚îÇ           0x004018e9      8bf7           mov esi, edi
‚îÇ           0x004018eb      8bfa           mov edi, edx
‚îÇ           0x004018ed      8d542428       lea edx, [var_28h]
‚îÇ           0x004018f1      c1e902         shr ecx, 2
‚îÇ           0x004018f4      f3a5           rep movsd dword es:[edi], dword [esi]
‚îÇ           0x004018f6      8bc8           mov ecx, eax
‚îÇ           0x004018f8      8d44240c       lea eax, [var_ch]
‚îÇ           0x004018fc      83e103         and ecx, 3
‚îÇ           0x004018ff      f3a4           rep movsb byte es:[edi], byte [esi]
‚îÇ           0x00401901      8d4c2418       lea ecx, [var_18h]
‚îÇ           0x00401905      51             push ecx
‚îÇ           0x00401906      52             push edx
‚îÇ           0x00401907      53             push ebx
‚îÇ           0x00401908      53             push ebx
‚îÇ           0x00401909      53             push ebx
‚îÇ           0x0040190a      6a01           push 1                      ; 1
‚îÇ           0x0040190c      53             push ebx
‚îÇ           0x0040190d      53             push ebx                    ; LPSECURITY_ATTRIBUTES lpProcessAttributes
‚îÇ           0x0040190e      50             push eax                    ; LPSTR lpCommandLine
[0x0040193b]>

____________________________



----------------------

üß† Lo que est√°s viendo:

...
0x0040190d  push ebx     ; lpProcessAttributes
0x0040190e  push eax     ; lpCommandLine ‚¨ÖÔ∏è este es el par√°metro que nos interesa
0x0040190f  push ebx     ; lpApplicationName
0x00401910  call [CreateProcessA]

Esto nos dice:

    El primer par√°metro (lpApplicationName) ‚Üí contenido de ebx

    El segundo par√°metro (lpCommandLine) ‚Üí contenido de eax

‚û°Ô∏è El par√°metro realmente interesante es eax, que contiene la cadena del comando que se va a ejecutar (y posiblemente tambi√©n sus argumentos).


-------------------------------------------------------------
üîç Siguiente paso: ver el valor de eax

Justo antes, ves esto:

0x004018f8  lea eax, [var_ch]

Esto significa que la cadena est√° almacenada en una variable local ([esp + 0xC] o similar) ‚Üí y hab√≠a sido copiada all√≠ justo antes, en esta secuencia:

0x004018f4  f3a5         rep movsd
0x004018ff  f3a4         rep movsb

Estas instrucciones copian una cadena o estructura desde otra parte de la memoria hacia la pila (probablemente desde .rdata o .data).

_____________________________________

‚úÖ Estrategia para recuperar la cadena

Ahora, buscamos de d√≥nde se copiaron los datos a [var_ch]. Para eso mira antes del rep movsd:

0x004018e7  mov eax, ecx
0x004018e9  mov esi, edi
0x004018eb  mov edi, edx

    edi (destino) se llena con edx

    esi (origen) se llena con edi

    ecx tiene el tama√±o en bytes a copiar

As√≠ que necesitas ver el valor original de edi (o esi) justo antes de esto.

Mira las instrucciones antes del mov esi, edi, o incluso antes de mov eax, ecx. Ah√≠ se debe estar haciendo algo como:

mov edi, offset some_string

‚û°Ô∏è Ejecuta ahora en Radare2:
pd -20 @ 0x004018e7

As√≠ veremos c√≥mo se llena edi con la direcci√≥n real de la cadena. Una vez tengas la direcci√≥n (por ejemplo 0x403050):
[0x004018f8]> pd -20 @ 0x004018e7
‚îÇ           0x004018a4      66895c2468     mov word [var_68h], bx
‚îÇ           0x004018a9      895c246c       mov dword [var_6ch], ebx
‚îÇ           0x004018ad      66895c246a     mov word [var_6ah], bx
‚îÇ           0x004018b2      c744246401..   mov dword [var_64h], 0x101  ; [0x101:4]=-1 ; 257
‚îÇ           0x004018ba      89442470       mov dword [var_70h_2], eax
‚îÇ           0x004018be      89742474       mov dword [var_74h], esi
‚îÇ           0x004018c2      89742478       mov dword [var_70h], esi
‚îÇ           0x004018c6      ffd7           call edi
‚îÇ           0x004018c8      50             push eax                    ; HANDLE hTargetProcessHandle
‚îÇ           0x004018c9      56             push esi                    ; HANDLE hSourceHandle
‚îÇ           0x004018ca      ffd7           call edi
‚îÇ           0x004018cc      50             push eax                    ; HANDLE hSourceProcessHandle
‚îÇ           0x004018cd      ff1534204000   call dword [sym.imp.KERNEL32.dll_DuplicateHandle] ; 0x402034 ; BOOL DuplicateHandle(HANDLE hSourceProcessHandle, HANDLE hSourceHandle, HANDLE hTargetProcessHandle, LPHANDLE lpTargetHandle, DWORD dwDesiredAccess, BOOL bInheritHandle, DWORD dwOptions)
‚îÇ           0x004018d3      bf68304000     mov edi, str.cmd.exe        ; 0x403068 ; "cmd.exe"
‚îÇ           0x004018d8      83c9ff         or ecx, 0xffffffff          ; -1
‚îÇ           0x004018db      33c0           xor eax, eax
‚îÇ           0x004018dd      8d54240c       lea edx, [var_ch]
‚îÇ           0x004018e1      f2ae           repne scasb al, byte es:[edi]
‚îÇ           0x004018e3      f7d1           not ecx
‚îÇ           0x004018e5      2bf9           sub edi, ecx



üß† PUNTO CLAVE

0x004018d3  mov edi, str.cmd.exe    ; 0x403068 ; "cmd.exe"

‚û°Ô∏è Esto significa que la direcci√≥n 0x403068 contiene la cadena cmd.exe.



üîé Lo que hace el c√≥digo

Despu√©s de mover "cmd.exe" a edi, el malware hace lo siguiente:

repne scasb         ; cuenta la longitud de la cadena
not ecx
sub edi, ecx        ; ajusta puntero para copiar
rep movsb/movsd     ; copia la cadena a la pila
lea eax, [var_ch]   ; eax apunta a la cadena copiada
push eax            ; se pasa como segundo par√°metro a CreateProcessA

‚û°Ô∏è Ese cmd.exe se pasa como par√°metro lpCommandLine a CreateProcessA, lo que indica que el malware lanza una consola de comandos.


----------------------------
‚úÖ Confirma el contenido directamente

Puedes validar la cadena en Radare2 con:
[0x004018f8]> psz @ 0x403068
cmd.exe


-----------------------------------------
üìå Conclusi√≥n

La muestra:

    Usa CreateProcessA para lanzar cmd.exe

    Copia la cadena desde .rdata a la pila

    Pasa esa direcci√≥n como par√°metro de ejecuci√≥n

üîç Esto indica que el malware tiene intenciones de ejecutar comandos arbitrarios, ya sea desde otro proceso, desde una pipe, o esperando entrada desde alg√∫n canal.
