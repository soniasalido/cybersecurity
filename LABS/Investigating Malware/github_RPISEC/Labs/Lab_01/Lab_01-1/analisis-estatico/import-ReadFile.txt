





____________________________________________________________
[0x0040161d]> ii~ReadFile
16  0x0040203c NONE FUNC KERNEL32.dll ReadFile
[0x0040161d]> axt @ 0x0040203c
(nofunc) 0x40198c [ICOD:r--] mov esi, dword [sym.imp.KERNEL32.dll_ReadFile]
[0x0040161d]> s 0x40198c
[0x0040198c]> pd 20
            0x0040198c      8b353c204000   mov esi, dword [sym.imp.KERNEL32.dll_ReadFile] ; [0x40203c:4]=0x23ea reloc.KERNEL32.dll_ReadFile
            ; CODE XREF from fcn.00401860 @ +0x1ee(x)
            0x00401992      8b44240c       mov eax, dword [esp + 0xc]
            0x00401996      85c0           test eax, eax
        â”Œâ”€< 0x00401998      0f868d000000   jbe 0x401a2b
        â”‚   0x0040199e      8b5500         mov edx, dword [ebp]
        â”‚   0x004019a1      8d44240c       lea eax, [esp + 0xc]
        â”‚   0x004019a5      6a00           push 0
        â”‚   0x004019a7      50             push eax
        â”‚   0x004019a8      8d4c2428       lea ecx, [esp + 0x28]
        â”‚   0x004019ac      6800040000     push 0x400                  ; 1024
        â”‚   0x004019b1      51             push ecx
        â”‚   0x004019b2      52             push edx
        â”‚   0x004019b3      ffd6           call esi
        â”‚   0x004019b5      8b44240c       mov eax, dword [esp + 0xc]
        â”‚   0x004019b9      6814304000     push 0x403014               ; '\x140@'
        â”‚   0x004019be      c644042400     mov byte [esp + eax + 0x24], 0
        â”‚   0x004019c3      40             inc eax
        â”‚   0x004019c4      89442410       mov dword [esp + 0x10], eax
        â”‚   0x004019c8      8d442418       lea eax, [esp + 0x18]
        â”‚   0x004019cc      50             push eax
[0x0040198c]>




ğŸ“Resumen de ReadFile

La API de Windows ReadFile tiene la siguiente firma:

BOOL ReadFile(
  HANDLE       hFile,
  LPVOID       lpBuffer,
  DWORD        nNumberOfBytesToRead,
  LPDWORD      lpNumberOfBytesRead,
  LPOVERLAPPED lpOverlapped
);

ğŸ” AnÃ¡lisis del CÃ³digo Ensamblador

0x0040198c      8b353c204000   mov esi, dword [0x40203c] ; direcciÃ³n de ReadFile

â†’ Guarda la direcciÃ³n de ReadFile (API de Windows) en esi.

0x00401992      8b44240c       mov eax, dword [esp + 0xc]
0x00401996      85c0           test eax, eax
0x00401998      0f868d000000   jbe 0x401a2b

â†’ Carga en eax un parÃ¡metro de la pila (probablemente tamaÃ±o o puntero) y salta si eax <= 0 a 0x401a2b.
ğŸ”½ PreparaciÃ³n de parÃ¡metros para ReadFile (en orden inverso de la llamada estÃ¡ndar)

0x0040199e      8b5500         mov edx, dword [ebp]        ; HANDLE hFile
0x004019a1      8d44240c       lea eax, [esp + 0xc]         ; LPDWORD lpNumberOfBytesRead
0x004019a5      6a00           push 0                       ; LPOVERLAPPED lpOverlapped = NULL
0x004019a7      50             push eax                     ; LPDWORD lpNumberOfBytesRead
0x004019a8      8d4c2428       lea ecx, [esp + 0x28]        ; LPVOID lpBuffer
0x004019ac      6800040000     push 0x400                   ; DWORD nNumberOfBytesToRead = 1024
0x004019b1      51             push ecx                     ; LPVOID lpBuffer
0x004019b2      52             push edx                     ; HANDLE hFile
0x004019b3      ffd6           call esi                     ; llama a ReadFile

AquÃ­ estÃ¡ la llamada real:

ReadFile(
  hFile = edx,
  lpBuffer = ecx (esp + 0x28),
  nNumberOfBytesToRead = 0x400 (1024 bytes),
  lpNumberOfBytesRead = [esp + 0xc],
  lpOverlapped = NULL
);

ğŸ” Posprocesamiento

0x004019b5      8b44240c       mov eax, dword [esp + 0xc]   ; eax = bytes leÃ­dos
0x004019b9      6814304000     push 0x403014                ; direcciÃ³n base para buffer
0x004019be      c644042400     mov byte [esp + eax + 0x24], 0 ; null-terminate
0x004019c3      40             inc eax
0x004019c4      89442410       mov dword [esp + 0x10], eax
0x004019c8      8d442418       lea eax, [esp + 0x18]
0x004019cc      50             push eax

Estas instrucciones probablemente estÃ¡n preparando el contenido leÃ­do (de hasta 1024 bytes) para su posterior uso o anÃ¡lisis, incluyendo un null-terminator (para usarlo como string C).
âœ… ConclusiÃ³n

Este bloque de cÃ³digo:

    Llama a ReadFile para leer 1024 bytes desde un archivo en hFile a un buffer.

    Guarda los bytes leÃ­dos en una variable temporal ([esp+0xc]).

    Asegura que el buffer tenga null-terminator, probablemente para tratarlo como un string.

    Prepara informaciÃ³n adicional en la pila, posiblemente para otro procesamiento o funciÃ³n.

----------------------------------------






[0x004019b3]> s 0x00401860
[0x00401860]> pd
            ; CALL XREF from fcn.00401600 @ 0x4016bf(x)
â”Œ 219: fcn.00401860 (int32_t arg_64h, int32_t arg_70h);
â”‚ `- args(sp[0x4..0x8]) vars(20:sp[0x4..0x98])
â”‚           0x00401860      83ec60         sub esp, 0x60
â”‚           0x00401863      8b442464       mov eax, dword [arg_64h]
â”‚           0x00401867      53             push ebx
â”‚           0x00401868      56             push esi
â”‚           0x00401869      8b742470       mov esi, dword [arg_70h]
â”‚           0x0040186d      33db           xor ebx, ebx
â”‚           0x0040186f      57             push edi
â”‚           0x00401870      8b3d38204000   mov edi, dword [sym.imp.KERNEL32.dll_GetCurrentProcess] ; [0x402038:4]=0x23d6 reloc.KERNEL32.dll_GetCurrentProcess
â”‚           0x00401876      53             push ebx                    ; DWORD dwOptions
â”‚           0x00401877      6a01           push 1                      ; 1 ; BOOL bInheritHandle
â”‚           0x00401879      8d4c2470       lea ecx, [var_70h]
â”‚           0x0040187d      6a02           push 2                      ; 2 ; DWORD dwDesiredAccess
â”‚           0x0040187f      51             push ecx                    ; LPHANDLE lpTargetHandle
â”‚           0x00401880      c744243844..   mov dword [var_38h], 0x44   ; 'D'
â”‚                                                                      ; [0x44:4]=-1 ; 68
â”‚           0x00401888      895c243c       mov dword [var_3ch], ebx
â”‚           0x0040188c      895c2444       mov dword [var_44h], ebx
â”‚           0x00401890      895c2440       mov dword [var_40h], ebx
â”‚           0x00401894      895c2454       mov dword [var_54h], ebx
â”‚           0x00401898      895c2450       mov dword [var_50h], ebx
â”‚           0x0040189c      895c244c       mov dword [var_4ch], ebx
â”‚           0x004018a0      895c2448       mov dword [var_48h], ebx
â”‚           0x004018a4      66895c2468     mov word [var_68h], bx
â”‚           0x004018a9      895c246c       mov dword [var_6ch], ebx
â”‚           0x004018ad      66895c246a     mov word [var_6ah], bx
â”‚           0x004018b2      c744246401..   mov dword [var_64h], 0x101  ; [0x101:4]=-1 ; 257
â”‚           0x004018ba      89442470       mov dword [var_70h_2], eax
â”‚           0x004018be      89742474       mov dword [var_74h], esi
â”‚           0x004018c2      89742478       mov dword [var_70h], esi
â”‚           0x004018c6      ffd7           call edi
â”‚           0x004018c8      50             push eax                    ; HANDLE hTargetProcessHandle
â”‚           0x004018c9      56             push esi                    ; HANDLE hSourceHandle
â”‚           0x004018ca      ffd7           call edi
â”‚           0x004018cc      50             push eax                    ; HANDLE hSourceProcessHandle
â”‚           0x004018cd      ff1534204000   call dword [sym.imp.KERNEL32.dll_DuplicateHandle] ; 0x402034 ; BOOL DuplicateHandle(HANDLE hSourceProcessHandle, HANDLE hSourceHandle, HANDLE hTargetProcessHandle, LPHANDLE lpTargetHandle, DWORD dwDesiredAccess, BOOL bInheritHandle, DWORD dwOptions)
â”‚           0x004018d3      bf68304000     mov edi, str.cmd.exe        ; 0x403068 ; "cmd.exe"
â”‚           0x004018d8      83c9ff         or ecx, 0xffffffff          ; -1
â”‚           0x004018db      33c0           xor eax, eax
â”‚           0x004018dd      8d54240c       lea edx, [var_ch]
â”‚           0x004018e1      f2ae           repne scasb al, byte es:[edi]
â”‚           0x004018e3      f7d1           not ecx
â”‚           0x004018e5      2bf9           sub edi, ecx
â”‚           0x004018e7      8bc1           mov eax, ecx
â”‚           0x004018e9      8bf7           mov esi, edi
â”‚           0x004018eb      8bfa           mov edi, edx
â”‚           0x004018ed      8d542428       lea edx, [var_28h]
â”‚           0x004018f1      c1e902         shr ecx, 2
â”‚           0x004018f4      f3a5           rep movsd dword es:[edi], dword [esi]
â”‚           0x004018f6      8bc8           mov ecx, eax
â”‚           0x004018f8      8d44240c       lea eax, [var_ch]
â”‚           0x004018fc      83e103         and ecx, 3
â”‚           0x004018ff      f3a4           rep movsb byte es:[edi], byte [esi]
â”‚           0x00401901      8d4c2418       lea ecx, [var_18h]
â”‚           0x00401905      51             push ecx
â”‚           0x00401906      52             push edx
â”‚           0x00401907      53             push ebx
â”‚           0x00401908      53             push ebx
â”‚           0x00401909      53             push ebx
â”‚           0x0040190a      6a01           push 1                      ; 1
â”‚           0x0040190c      53             push ebx
â”‚           0x0040190d      53             push ebx                    ; LPSECURITY_ATTRIBUTES lpProcessAttributes
â”‚           0x0040190e      50             push eax                    ; LPSTR lpCommandLine
â”‚           0x0040190f      53             push ebx                    ; LPCSTR lpApplicationName
â”‚           0x00401910      ff1530204000   call dword [sym.imp.KERNEL32.dll_CreateProcessA] ; 0x402030 ; BOOL CreateProcessA(LPCSTR lpApplicationName, LPSTR lpCommandLine, LPSECURITY_ATTRIBUTES lpProcessAttributes, LPSECURITY_ATTRIBUTES lpThreadAttributes, BOOL bInheritHandles, DWORD dwCreationFlags, LPVOID lpEnvironment, LPCSTR lpCurrentDirectory, LPSTARTUPINFOA lpStartupInfo, LPPROCESS_INFORMATION lpProcessInformation)
â”‚           0x00401916      85c0           test eax, eax




âœ… ConclusiÃ³n: el binario estÃ¡ duplicando un handle de un proceso hijo (cmd.exe) y usando ese handle para leer datos.
ğŸ§  Â¿QuÃ© estÃ¡ haciendo el cÃ³digo?
Paso a paso:

    Recibe dos argumentos:

mov eax, dword [arg_64h]   ; primero
mov esi, dword [arg_70h]   ; segundo

Luego realiza una llamada a:

DuplicateHandle(
  GetCurrentProcess(),    // source process
  esi,                    // source handle
  GetCurrentProcess(),    // target process
  &lpTargetHandle,        // out: duplicated handle
  ...
);

Esta llamada clona un handle (esi), que le fue pasado como argumento (posiblemente un pipe, archivo o stdin de otro proceso).

Posteriormente:

mov [var_70h], esi
...
call ReadFile

El handle duplicado (guardado en [ebp] mÃ¡s adelante) es el que se usa en ReadFile.

TambiÃ©n lanza cmd.exe con CreateProcessA:

    mov edi, str.cmd.exe ; 0x403068 ; "cmd.exe"
    ...
    call sym.imp.KERNEL32.dll_CreateProcessA

    Esto probablemente se hace con herencia de handles activada (bInheritHandles = 1) para redirigir entrada/salida.

ğŸ’¡ Â¿QuÃ© archivo estÃ¡ leyendo realmente?

No estÃ¡ leyendo un archivo del sistema de ficheros. EstÃ¡ leyendo la salida estÃ¡ndar (stdout) o entrada estÃ¡ndar (stdin) del proceso cmd.exe.

Esto es tÃ­pico de malware o droppers que lanzan procesos (cmd, powershell, etc.) y capturan su salida para:

    Ejecutar comandos arbitrarios.

    Capturar la respuesta.

    Enviar esa respuesta a un C2 (send se usa despuÃ©s de ReadFile en tu cÃ³digo).

âœ… En resumen

ğŸ” ReadFile estÃ¡ leyendo desde un handle duplicado pasado como argumento, que apunta a cmd.exe.

ğŸ“¦ No hay acceso a un archivo real en el disco. El "archivo" es en realidad un stream desde un proceso hijo.



ğŸ”„ FLUJO GENERAL: LECTURA DESDE CMD.EXE
```
         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
         â”‚  [Inicio de funciÃ³n 0x401860]â”‚
         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                      â”‚
                      â–¼
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚ Recibe 2 argumentos:        â”‚
        â”‚  arg_64h â†’ usado como cmd   â”‚
        â”‚  arg_70h â†’ handle a duplicarâ”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                     â”‚
                     â–¼
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚ Llama a GetCurrentProcess() â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                     â”‚
                     â–¼
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚ Llama a DuplicateHandle     â”‚
        â”‚ duplica el handle recibido  â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                     â”‚
                     â–¼
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚ Crea proceso hijo "cmd.exe" â”‚
        â”‚ con CreateProcessA          â”‚
        â”‚ y hereda handles            â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                     â”‚
                     â–¼
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚ Usa ReadFile con el handle  â”‚â—„â”€â”€â”€â”€â”
        â”‚ duplicado para leer datos   â”‚     â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â”‚
                     â”‚                      â”‚
                     â–¼                      â”‚
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”‚
        â”‚ EnvÃ­a datos con send()      â”‚â”€â”€â”€â”€â”€â”˜
        â”‚ (posible C2 o exfiltraciÃ³n) â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

```

ğŸ§  InterpretaciÃ³n tÃ©cnica

    arg_70h es el handle de algo como un pipe o stdin de cmd.exe.

    Se clona ese handle con DuplicateHandle, lo que le permite usarlo localmente.

    Luego llama a ReadFile, que actÃºa sobre ese handle (leyendo la salida de cmd.exe).

    Posteriormente, lo que lee lo envÃ­a con send() â€” esto sugiere una conexiÃ³n de red activa, como parte de un C2 (Command and Control).
