

üîé ¬øQu√© es WSAStartup?

Es la funci√≥n de Winsock que inicializa el sistema de red de Windows. Todo malware que se comunique por red tiene que llamarla antes de usar socket, connect, recv, etc.
üß† Qu√© significa lo que has visto

ii~WSAStartup
115 0x004020f4 NONE FUNC WS2_32.dll   WSAStartup

‚û°Ô∏è Esto te dice que WSAStartup est√° importado en la direcci√≥n 0x004020f4

Luego haces:

axt 0x004020f4

Y Radare2 te responde:

sub.WS2_32.dll_WSAStartup 0x401e96 [CODE:--x] jmp dword [sym.imp.WS2_32.dll_WSAStartup]

‚û°Ô∏è Esto significa que en 0x401e96 hay una funci√≥n que hace:

jmp dword [0x004020f4]  ; <- direcci√≥n del import de WSAStartup

üìå ¬øQu√© es esto?

Es un trampol√≠n o wrapper autom√°tico creado por el compilador o linker. En vez de que el c√≥digo llame directamente a [0x004020f4], hay una funci√≥n local (en 0x401e96) que simplemente salta a esa direcci√≥n.
üí° ¬øPor qu√© se usa un jmp en lugar de call directo?

    Porque el compilador puede generar un wrapper o thunk con nombre local (sub.WS2_32.dll_WSAStartup)

    Porque otras funciones pueden referenciar esta funci√≥n local en vez del import directamente (√∫til para modularidad o instrumentaci√≥n)

    En algunos casos, esto facilita hooking o redirecci√≥n de funciones din√°micamente

‚úÖ ¬øY c√≥mo saber D√ìNDE se llama WSAStartup de verdad?

[0x00401e96]> afl~WSAStartup
0x00401e96    1      6 sub.WS2_32.dll_WSAStartup
[0x00401e96]>



El nombre real de la funci√≥n en Radare2 es:
 ‚úÖ sub.WS2_32.dll_WSAStartup

‚úÖ Paso siguiente: encontrar qui√©n llama a esa funci√≥n
[0x00401e96]> axt sub.WS2_32.dll_WSAStartup
fcn.00401320 0x4013fa [CALL:--x] call sub.WS2_32.dll_WSAStartup
[0x00401e96]>


üß≠ ¬øQu√© significa esto?
‚û°Ô∏è La funci√≥n WSAStartup se llama desde la direcci√≥n 0x004013fa, dentro de la funci√≥n que empieza en 0x00401320.


-----------------------------
‚úÖ Siguiente paso: analizar esa llamada
[0x00401e96]> s 0x004013fa
[0x004013fa]> pd10
‚îÇ           0x004013fa      e8970a0000     call sub.WS2_32.dll_WSAStartup ; int WSAStartup(WORD wVersionRequested, LPWSADATA lpWSAData)
‚îÇ           0x004013ff      53             push ebx                    ; int protocol
‚îÇ           0x00401400      6a01           push 1                      ; 1 ; int type
‚îÇ           0x00401402      6a02           push 2                      ; 2 ; int af
‚îÇ           0x00401404      e8870a0000     call sub.WS2_32.dll_socket  ; SOCKET socket(int af, int type, int protocol)
‚îÇ           0x00401409      8be8           mov ebp, eax
‚îÇ           0x0040140b      83fdff         cmp ebp, 0xffffffff
‚îÇ       ‚îå‚îÄ< 0x0040140e      7521           jne 0x401431
‚îÇ       ‚îÇ   0x00401410      50             push eax                    ; SOCKET s
‚îÇ       ‚îÇ   0x00401411      e8740a0000     call sub.WS2_32.dll_closesocket ; int closesocket(SOCKET s)
[0x004013fa]>

üîç Instrucciones analizadas

0x004013fa   call sub.WS2_32.dll_WSAStartup

‚úÖ Inicializa la pila Winsock. Obligatorio antes de usar cualquier funci√≥n de red.

0x004013ff   push ebx          ; protocol
0x00401400   push 1            ; type = SOCK_STREAM
0x00401402   push 2            ; af = AF_INET
0x00401404   call sub.WS2_32.dll_socket

‚úÖ Est√° creando un socket TCP IPv4:

    AF_INET = 2 ‚Üí IPv4

    SOCK_STREAM = 1 ‚Üí TCP

    protocol = ebx ‚Üí si vale 0, se usar√° el protocolo predeterminado

0x00401409   mov ebp, eax
0x0040140b   cmp ebp, 0xffffffff

‚úÖ Comprueba si socket() fall√≥ (INVALID_SOCKET = -1 = 0xFFFFFFFF).

0x0040140e   jne 0x401431

‚úÖ Si no fall√≥, salta a 0x401431 ‚Üí probablemente sigue la conexi√≥n.

0x00401410   push eax
0x00401411   call sub.WS2_32.dll_closesocket

‚ùå Si el socket fall√≥, lo cierra (aunque esto no tiene sentido real: cerrar un socket inv√°lido puede ser un placeholder o dummy).
üß† ¬øQu√© has aprendido?

Este malware:

    Inicializa la red con WSAStartup

    Crea un socket TCP IPv4 con:

        Tipo: SOCK_STREAM ‚Üí conexi√≥n orientada (probable backdoor, C2, etc.)

        Protocolo: contenido en ebx (lo puedes rastrear)

    Verifica si falla y, si no, contin√∫a.

-----------------------------------------------------------
‚úÖ Paso 1: ¬øD√≥nde va tras el socket()?

Ya hab√≠as visto esto:

0x0040140e   jne 0x401431

Esto significa: si socket() tiene √©xito, salta a 0x00401431.
üìç Ve a esa direcci√≥n:
[0x004013fa]> s 0x00401431
[0x00401431]> pd 20
‚îÇ           ; CODE XREF from fcn.00401320 @ 0x40140e(x)
‚îÇ           0x00401431      8d542430       lea edx, [var_30h]
‚îÇ           0x00401435      66c7442414..   mov word [var_14h], 2
‚îÇ           0x0040143c      52             push edx                    ; const char *str
‚îÇ           0x0040143d      e880080000     call sub.MSVCRT.dll_atol    ; long atol(const char *str)
‚îÇ           0x00401442      83c404         add esp, 4
‚îÇ           0x00401445      50             push eax                    ; u_short hostshort
‚îÇ           0x00401446      e8390a0000     call sub.WS2_32.dll_htons   ; u_short htons(u_short hostshort)
‚îÇ           0x0040144b      6689442416     mov word [var_16h], ax
‚îÇ           0x00401450      8d442444       lea eax, [var_44h]
‚îÇ           0x00401454      50             push eax                    ; const char *cp
‚îÇ           0x00401455      e8240a0000     call sub.WS2_32.dll_inet_addr ; unsigned long inet_addr(const char *cp)
‚îÇ           0x0040145a      8d4c2414       lea ecx, [var_14h_2]
‚îÇ           0x0040145e      6a10           push 0x10                   ; 16 ; int namelen
‚îÇ           0x00401460      51             push ecx                    ; const sockaddr *name
‚îÇ           0x00401461      55             push ebp                    ; SOCKET s
‚îÇ           0x00401462      89442424       mov dword [var_24h], eax
‚îÇ           0x00401466      e80d0a0000     call sub.WS2_32.dll_connect ; int connect(SOCKET s, const sockaddr *name, int namelen)
‚îÇ           0x0040146b      83f8ff         cmp eax, 0xffffffff
‚îÇ       ‚îå‚îÄ< 0x0040146e      750d           jne 0x40147d
‚îÇ       ‚îÇ   0x00401470      55             push ebp                    ; SOCKET s
[0x00401431]>


üß† An√°lisis detallado de las instrucciones

0x00401431  lea edx, [var_30h]

‚Üí Se apunta a una variable local (probablemente contiene una cadena).

0x0040143c  push edx
0x0040143d  call atol

‚Üí Convierte una cadena de texto a n√∫mero (puerto). Esa cadena est√° en [var_30h].

0x00401445  push eax
0x00401446  call htons

‚Üí El puerto convertido se pasa a formato de red.


0x0040144b  mov word [var_16h], ax

‚Üí Guarda el puerto ya convertido en la estructura sockaddr.


0x00401450  lea eax, [var_44h]
0x00401454  push eax
0x00401455  call inet_addr

‚Üí Convierte la IP almacenada en [var_44h] (probablemente un string tipo "192.168.1.100") en una in_addr.

0x0040145a  lea ecx, [var_14h_2]
push 0x10
push ecx
push ebp     ; SOCKET s
call connect

‚úÖ Aqu√≠ est√° la conexi√≥n real:

connect(socket, sockaddr_in *, 16);


Vimos por los strings una direccion ip del tipo 60....
Busquemos una cadena ip que coincida con 60
[0x00401431]> iz~60
53  0x00001a06 0x00402606 14  15   .rdata  ascii   __set_app_type
60  0x00001a78 0x00402678 5   6    .rdata  ascii   _itoa
65  0x00001c60 0x00403060 7   8    .data   ascii   *(SY)#
72  0x00001e5c 0x0040405c 210 420  .rsrc   utf16le 60.248.52.95:443‰Öê‰ëÑ‰πâÂ°áÂÅò‰ëÅ‰•Ñ‰ùé‰Öê‰ëÑ‰πâÂ°áÂÅò‰ëÅ‰•Ñ‰ùé‰Öê‰ëÑ‰πâÂ°áÂÅò‰ëÅ‰•Ñ‰ùé‰Öê‰ëÑ‰πâÂ°áÂÅò‰ëÅ‰•Ñ‰ùé‰Öê‰ëÑ‰πâÂ°áÂÅò‰ëÅ‰•Ñ‰ùé‰Öê‰ëÑ‰πâÂ°áÂÅò‰ëÅ‰•Ñ‰ùé‰Öê‰ëÑ‰πâÂ°áÂÅò‰ëÅ‰•Ñ‰ùé‰Öê‰ëÑ‰πâÂ°áÂÅò‰ëÅ‰•Ñ‰ùé‰Öê‰ëÑ‰πâÂ°áÂÅò‰ëÅ‰•Ñ‰ùé‰Öê‰ëÑ‰πâÂ°áÂÅò‰ëÅ‰•Ñ‰ùé‰Öê‰ëÑ‰πâÂ°áÂÅò‰ëÅ‰•Ñ‰ùé‰Öê‰ëÑ‰πâÂ°áÂÅò‰ëÅ‰•Ñ‰ùé‰Öê‰ëÑ‰πâÂ°áÂÅò‰ëÅ‰•Ñ‰ùé‰Öê‰ëÑ‰πâÂ°áÂÅò‰ëÅ‰•Ñ‰ùé‰Öê‰ëÑ‰πâÂ°áÂÅò‰ëÅ‰•Ñ‰ùé‰Öê‰ëÑ‰πâÂ°áÂÅò‰ëÅ‰•Ñ‰ùé‰Öê‰ëÑ‰πâÂ°áÂÅò‰ëÅ‰•Ñ‰ùé‰Öê‰ëÑ‰πâÂ°áÂÅò‰ëÅ‰•Ñ‰ùé‰Öê‰ëÑ‰πâÂ°áÂÅò‰ëÅ‰•Ñ‰ùé‰Öê‰ëÑ‰πâÂ°áÂÅò‰ëÅ‰•Ñ‰ùé‰Öê‰ëÑ‰πâÂ°áÂÅò‰ëÅ‰•Ñ‰ùé‰Öê‰ëÑ‰πâÂ°áÂÅò‰ëÅ‰•Ñ‰ùé‰Öê‰ëÑ‰πâÂ°áÂÅò‰ëÅ‰•Ñ‰ùé‰Öê‰ëÑ‰πâÂ°áÂÅò‰ëÅ‰•Ñ‰ùé‰Öê‰ëÑ
[0x00401431]>

üéØ Cadena localizada en .rsrc
60.248.52.95:443



Offset en memoria: 0x0040405c
Secci√≥n: .rsrc
Tama√±o: 210 (bytes UTF-16LE)



60.248.52.95:443 es una direcci√≥n IP p√∫blica, y el puerto 443 es el est√°ndar para HTTPS. Esto sugiere que el malware podr√≠a:

    Hacer conexi√≥n directa con esa IP v√≠a socket TCP

    Estar contactando con un servidor de comando y control (C2)

    Utilizar t√©cnicas de evasi√≥n haci√©ndose pasar por tr√°fico HTTPS



[0x00401431]> axt 0x0040405c
[0x00401431]> ps @ 0x0040405c
6
[0x00401431]> psu @ 0x0040405c
6\u00000\u0000.\u00002\u00004\u00008\u0000.\u00005\u00002\u0000.\u00009\u00005\u0000:\u00004\u00004\u00003\u0000PADDINGXXPADDINGPADDINGXXPADDINGPADDINGXXPADDINGPADDINGXXPADDINGPADDINGXXPADDINGPADDINGXXPADDINGPADDINGXXPADDINGPADDINGXXPADDINGPADDINGXXPADDINGPADDINGXXPADDINGPADDINGXXPADDINGPADDINGXXPADDINGPADDINGXXPADDINGPADDINGXXPADDING
[0x00401431]>


Esta IP y puerto est√°n codificados como texto Unicode y almacenados en .rsrc. La salida psu te lo muestra con escapes tipo \u0000 porque est√° en formato UTF-16 (cada car√°cter seguido de un 0x00):

6\u00000\u0000.\u00002\u00004\u00008\u0000.\u00005\u00002\u0000.\u00009\u00005\u0000:\u00004\u00004\u00003\u0000

üîç ¬øQu√© implica esto?

    La IP y puerto est√°n ocultos como string Unicode, algo com√∫n en malware para evitar detecci√≥n por reglas simples ASCII.

    Luego probablemente esa string se convierte en ASCII o se parsea a partes (IP y puerto) en tiempo de ejecuci√≥n.



üß™ 1. Buscar referencias al uso de esa direcci√≥n

Haz:

axt 0x0040405c

Si no sale nada, probablemente se est√° accediendo de forma indirecta (por ejemplo, copiando con mov, memcpy, lstrcpy, etc.).
