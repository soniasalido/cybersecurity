
004020F8    __imp_send    WS2_32

Paso 1: Buscar las referencias a send


[0x00401e90]> axt 0x004020F8
sub.WS2_32.dll_send 0x401e6c [CODE:--x] jmp dword [sym.imp.WS2_32.dll_send]
[0x00401e90]>


sub.WS2_32.dll_send 0x401e6c [CODE:--x] jmp dword [sym.imp.WS2_32.dll_send]

indica que send está importado en 0x004020F8, y la función sub.WS2_32.dll_send es simplemente un trampolín que hace:

0x00401e6c    jmp dword [0x004020F8] ; llamada real a send

Ahora necesitamos buscar quién llama a sub.WS2_32.dll_send.
Paso 2: Buscar llamadas a send

En Radare2:

axt sub.WS2_32.dll_send

Esto listará todos los call sub.WS2_32.dll_send, es decir, los puntos reales en los que el malware envía datos por el socket.
[0x00401e90]> axt sub.WS2_32.dll_send
fcn.00401270 0x40128b [CALL:--x] call sub.WS2_32.dll_send
fcn.00401320 0x401507 [CALL:--x] call sub.WS2_32.dll_send
(nofunc) 0x401a06 [CALL:--x] call sub.WS2_32.dll_send

Vemos que el malware llama a send desde tres ubicaciones distintas:
1. 0x40128b (en fcn.00401270)
[0x00401e90]> s 0x40128b
[0x0040128b]> pd 20
│       ╎   0x0040128b      e8dc0b0000     call sub.WS2_32.dll_send    ; int send(SOCKET s, const char *buf, int len, int flags)
│       ╎   0x00401290      85c0           test eax, eax
│      ┌──< 0x00401292      7c11           jl 0x4012a5
│     ┌───< 0x00401294      7417           je 0x4012ad
│     ││╎   0x00401296      2bf0           sub esi, eax
│     ││╎   0x00401298      03f8           add edi, eax
│     ││╎   0x0040129a      85f6           test esi, esi
│     ││└─< 0x0040129c      7fe8           jg 0x401286
│     ││    ; CODE XREF from fcn.00401270 @ 0x40127c(x)
│     ││    0x0040129e      5f             pop edi
│     ││    0x0040129f      8bc5           mov eax, ebp
│     ││    0x004012a1      5e             pop esi
│     ││    0x004012a2      5d             pop ebp
│     ││    0x004012a3      5b             pop ebx
│     ││    0x004012a4      c3             ret
│     ││    ; CODE XREF from fcn.00401270 @ 0x401292(x)
│     │└──> 0x004012a5      5f             pop edi
│     │     0x004012a6      5e             pop esi
│     │     0x004012a7      5d             pop ebp
│     │     0x004012a8      83c8ff         or eax, 0xffffffff          ; -1
│     │     0x004012ab      5b             pop ebx
│     │     0x004012ac      c3             ret
[0x0040128b]>


📍 En 0x0040128b — call sub.WS2_32.dll_send

Se está llamando a send(SOCKET s, const char *buf, int len, int flags).



🔎 Interpretación

Esto es una función de envío con bucle que:

    Intenta enviar todos los datos del buffer (edi) de tamaño esi.

    Si send devuelve menos bytes de los esperados, ajusta el puntero y tamaño y repite (jg a 0x401286).

    Si todo va bien, devuelve eax = ebp.


Lógica completa de la función fcn.00401270, que se encarga únicamente de enviar datos por un socket en varios bloques si es necesario.
[0x00401286]> s 0x00401270
[0x00401270]> pd 40
            ; CALL XREF from fcn.00401860 @ +0x1bd(x)
┌ 70: fcn.00401270 (int32_t arg_14h_2, int32_t arg_18h, int32_t arg_14h);
│ `- args(sp[0x4..0xc])
│           0x00401270      53             push ebx
│           0x00401271      55             push ebp
│           0x00401272      8b6c2414       mov ebp, dword [arg_14h]
│           0x00401276      56             push esi
│           0x00401277      85ed           test ebp, ebp
│           0x00401279      57             push edi
│           0x0040127a      8bf5           mov esi, ebp
│       ┌─< 0x0040127c      7e20           jle 0x40129e
│       │   0x0040127e      8b5c2414       mov ebx, dword [arg_14h_2]
│       │   0x00401282      8b7c2418       mov edi, dword [arg_18h]
│       │   ; CODE XREF from fcn.00401270 @ 0x40129c(x)
│      ┌──> 0x00401286      6a00           push 0
│      ╎│   0x00401288      56             push esi                    ; int len
│      ╎│   0x00401289      57             push edi                    ; const char *buf
│      ╎│   0x0040128a      53             push ebx                    ; SOCKET s
│      ╎│   0x0040128b      e8dc0b0000     call sub.WS2_32.dll_send    ; int send(SOCKET s, const char *buf, int len, int flags)
│      ╎│   0x00401290      85c0           test eax, eax
│     ┌───< 0x00401292      7c11           jl 0x4012a5
│    ┌────< 0x00401294      7417           je 0x4012ad
│    ││╎│   0x00401296      2bf0           sub esi, eax
│    ││╎│   0x00401298      03f8           add edi, eax
│    ││╎│   0x0040129a      85f6           test esi, esi
│    ││└──< 0x0040129c      7fe8           jg 0x401286
│    ││ │   ; CODE XREF from fcn.00401270 @ 0x40127c(x)
│    ││ └─> 0x0040129e      5f             pop edi
│    ││     0x0040129f      8bc5           mov eax, ebp
│    ││     0x004012a1      5e             pop esi
│    ││     0x004012a2      5d             pop ebp
│    ││     0x004012a3      5b             pop ebx
│    ││     0x004012a4      c3             ret
│    ││     ; CODE XREF from fcn.00401270 @ 0x401292(x)
│    │└───> 0x004012a5      5f             pop edi
│    │      0x004012a6      5e             pop esi
│    │      0x004012a7      5d             pop ebp
│    │      0x004012a8      83c8ff         or eax, 0xffffffff          ; -1
│    │      0x004012ab      5b             pop ebx
│    │      0x004012ac      c3             ret
│    │      ; CODE XREF from fcn.00401270 @ 0x401294(x)
│    └────> 0x004012ad      8bc5           mov eax, ebp
│           0x004012af      5f             pop edi
│           0x004012b0      2bc6           sub eax, esi
│           0x004012b2      5e             pop esi
│           0x004012b3      5d             pop ebp
│           0x004012b4      5b             pop ebx
[0x00401270]>

✅ Ahora: ¿Quién llama a fcn.00401270?

Para rastrear el origen del buffer y saber qué datos se están enviando, debemos ver desde qué funciones se llama a fcn.00401270, es decir:
[0x00401270]> axt 0x00401270
(nofunc) 0x401a1d [CALL:--x] call fcn.00401270

Vemos que la única llamada a fcn.00401270 se realiza desde la dirección 0x401a1d, que no está dentro de una función definida aún (nofunc), pero podemos inspeccionarla directamente.

🔍 Próximo paso:

Vamos a desensamblar a partir de esa dirección para rastrear los argumentos que se pasan a fcn.00401270 y así entender qué datos se están enviando por la red.
[0x00401270]> s 0x401a1d
[0x00401a1d]> pd 30
        ╎   0x00401a1d      e84ef8ffff     call fcn.00401270
        ╎   0x00401a22      83c40c         add esp, 0xc
        ╎   0x00401a25      85c0           test eax, eax
       ┌──< 0x00401a27      7e2b           jle 0x401a54
      ┌───< 0x00401a29      eb08           jmp 0x401a33
      ││╎   ; CODE XREF from fcn.00401860 @ +0x138(x)
      ││╎   0x00401a2b      6a32           push 0x32                   ; '2' ; 50
      ││╎   0x00401a2d      ff1510204000   call dword [sym.imp.KERNEL32.dll_Sleep] ; 0x402010 ; "\"#" ; VOID Sleep(DWORD dwMilliseconds)
      ││╎   ; CODE XREF from fcn.00401860 @ +0x1c9(x)
      └───> 0x00401a33      8b4500         mov eax, dword [ebp]
       │╎   0x00401a36      6a00           push 0
       │╎   0x00401a38      8d4c2410       lea ecx, [esp + 0x10]
       │╎   0x00401a3c      6a00           push 0
       │╎   0x00401a3e      51             push ecx
       │╎   0x00401a3f      8d54242c       lea edx, [esp + 0x2c]
       │╎   0x00401a43      6800040000     push 0x400                  ; 1024
       │╎   0x00401a48      52             push edx
       │╎   0x00401a49      50             push eax
       │╎   0x00401a4a      ffd7           call edi
       │╎   0x00401a4c      85c0           test eax, eax
       │└─< 0x00401a4e      0f853effffff   jne 0x401992
       │    ; CODE XREFS from fcn.00401860 @ +0x126(x), +0x1ad(x), +0x1c7(x)
       └──> 0x00401a54      55             push ebp
            0x00401a55      e874020000     call sub.MSVCRT.dll_free    ; void free(void *ptr)
            0x00401a5a      83c404         add esp, 4
            0x00401a5d      6a00           push 0
            0x00401a5f      ff150c204000   call dword [sym.imp.KERNEL32.dll_ExitThread] ; 0x40200c ; VOID ExitThread(DWORD dwExitCode)
            0x00401a65      5f             pop edi
            0x00401a66      5e             pop esi
            0x00401a67      5d             pop ebp
            0x00401a68      90             nop
            0x00401a69      90             nop
            0x00401a6a      90             nop





2. 0x401507 (en fcn.00401320)
[0x0040128b]> s 0x401507
[0x00401507]> pd20
│           0x00401507      e860090000     call sub.WS2_32.dll_send    ; int send(SOCKET s, const char *buf, int len, int flags)
│           0x0040150c      8bf0           mov esi, eax
│           0x0040150e      8d7c2458       lea edi, [var_58h_2]
│           0x00401512      83c9ff         or ecx, 0xffffffff          ; -1
│           0x00401515      33c0           xor eax, eax
│           0x00401517      f2ae           repne scasb al, byte es:[edi]
│           0x00401519      f7d1           not ecx
│           0x0040151b      49             dec ecx
│           0x0040151c      51             push ecx
│           0x0040151d      8d4c2428       lea ecx, [var_28h]
│           0x00401521      6854304000     push str.send___d           ; 0x403054 ; "send = %d"
│           0x00401526      51             push ecx                    ; char *s
│           0x00401527      e890070000     call sub.MSVCRT.dll_sprintf ; int sprintf(char *s, const char *format, ...)
│           0x0040152c      56             push esi
│           0x0040152d      8d542434       lea edx, [var_28h]
│           0x00401531      6854304000     push str.send___d           ; 0x403054 ; "send = %d"
│           0x00401536      52             push edx                    ; char *s
│           0x00401537      e880070000     call sub.MSVCRT.dll_sprintf ; int sprintf(char *s, const char *format, ...)
│           0x0040153c      83c418         add esp, 0x18
│           0x0040153f      83feff         cmp esi, 0xffffffff
[0x00401507]>
🧠 Análisis del flujo en 0x00401a1d

La instrucción:

0x00401a1d      e84ef8ffff     call fcn.00401270

llama a la función que realiza el envío. Justo antes de esa instrucción deberían estar los push de los argumentos, que como vimos en la función fcn.00401270, son:

fcn.00401270(SOCKET s, const char *buf, int len);

Es decir, se esperan tres valores en la pila antes del call.
✅ Próximo paso

Para reconstruir los argumentos, debemos ver lo que hay inmediatamente antes de 0x401a1d.
Ejecuta:[0x00401a1d]> pd -10
            0x00401a05      50             push eax
            0x00401a06      e861040000     call sub.WS2_32.dll_send    ; int send(SOCKET s, const char *buf, int len, int flags)
            0x00401a0b      85c0           test eax, eax
        ┌─< 0x00401a0d      7e45           jle 0x401a54
        │   0x00401a0f      8b4c240c       mov ecx, dword [esp + 0xc]
        │   0x00401a13      8b450c         mov eax, dword [ebp + 0xc]
        │   0x00401a16      8d542420       lea edx, [esp + 0x20]
        │   0x00401a1a      51             push ecx
        │   0x00401a1b      52             push edx
        │   0x00401a1c      50             push eax



🔍 Análisis detallado del flujo de ejecución y red
🧩 1. Función de envío de datos (send)

Hay dos llamadas a send:

    0x00401a06 → llamada directa a send(), usando eax como argumento (probablemente el SOCKET s).

    0x00401a1d → llamada a la función fcn.00401270, que es un wrapper de send() con control de errores y bucle de reintento.

📦 Argumentos de la función fcn.00401270 en 0x00401a1d:

Antes del call, vemos:

0x00401a1a      51             push ecx    ; arg_14h_2 → socket
0x00401a1b      52             push edx    ; arg_18h → buffer
0x00401a1c      50             push eax    ; arg_14h → length

Por tanto, la llamada es equivalente a:

fcn_00401270(eax /* len */, edx /* buf */, ecx /* socket */);

Lo interesante: edx = lea [esp + 0x20] → apunta a una dirección en la pila, probablemente donde se ha escrito el contenido a enviar.
🧠 Lógica de envío (en fcn.00401270)

    Intenta enviar los datos con send.

    Si no se completa el envío (parcial o error), reintenta enviando lo restante.

    Si el envío falla (send < 0), devuelve -1.

    Si se completa parcialmente, ajusta punteros y reintenta.

🔐 Comportamiento malicioso evidente

Este patrón es típico de stealers, backdoors o Trojans que:

    Se conectan a un servidor.

    Reciben instrucciones (recv).

    Envían datos robados (send).

    Ejecutan comandos o manipulan el entorno (como vimos antes con /c del, ShellExecuteExA, etc.).

----------------------------
📥 ¿Qué hay en [esp + 0x20]?

[0x00401a1d]> px 64 @ esp+0x20
- offset -  2021 2223 2425 2627 2829 2A2B 2C2D 2E2F  0123456789ABCDEF
0x00178020  0000 0000 0000 0000 0000 0000 0000 0000  ................
0x00178030  0000 0000 0000 0000 0000 0000 0000 0000  ................
0x00178040  0000 0000 0000 0000 0000 0000 0000 0000  ................
0x00178050  0000 0000 0000 0000 0000 0000 0000 0000  ................

🧠 ¿Qué significa esto?

Esto puede tener distintos significados según el momento exacto de ejecución:
✅ 1. Aún no se ha rellenado

El contenido que se iba a enviar por send() todavía no ha sido copiado a la pila. Quizá el malware prepara el contenido justo después.
✅ 2. Está enviando padding, keep-alive o señal

Muchos protocolos personalizados o malware mandan mensajes con solo ceros para:

    Comprobar que la conexión sigue viva.

    Sincronizar con el servidor.

    Hacer "keep-alive pings".

✅ 3. Buffer limpiado como medida antianálisis

A veces el contenido se borra deliberadamente tras enviarlo, o se cifra justo antes.

------------------------------------------




3. 0x401a06 (fuera de función)
