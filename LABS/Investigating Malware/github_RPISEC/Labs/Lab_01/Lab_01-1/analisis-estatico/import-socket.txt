

ANALISIS DEL IMPORT SOCKET

[0x00401c51]> ii~socket
23  0x004020f0 NONE FUNC WS2_32.dll   socket
3   0x00402104 NONE FUNC WS2_32.dll   closesocket
[0x00401c51]> axt 0x004020f0
sub.WS2_32.dll_socket 0x401e90 [CODE:--x] jmp dword [sym.imp.WS2_32.dll_socket]
[0x00401c51]> s 0x401e90
[0x00401e90]> pd20
            ; CALL XREF from fcn.00401320 @ 0x401404(x)
â”Œ 6: SOCKET sub.WS2_32.dll_socket (int af, int type, int protocol);
â””           0x00401e90      ff25f0204000   jmp dword [sym.imp.WS2_32.dll_socket] ; 0x4020f0
            ; CALL XREF from fcn.00401320 @ 0x4013fa(x)
â”Œ 6: int sub.WS2_32.dll_WSAStartup (WORD wVersionRequested, LPWSADATA lpWSAData);
â””           0x00401e96      ff25f4204000   jmp dword [sym.imp.WS2_32.dll_WSAStartup] ; 0x4020f4 ; "s"
            0x00401e9c      cc             int3
            0x00401e9d      cc             int3
            0x00401e9e      cc             int3
            0x00401e9f      cc             int3
            ; CALL XREF from fcn.00401860 @ +0x199(x)
â”Œ 6: sub.MSVCRT.dll__itoa ();
â””           0x00401ea0      ff25cc204000   jmp dword [sym.imp.MSVCRT.dll__itoa] ; 0x4020cc ; "v&"
            0x00401ea6      0000           add byte [eax], al
            0x00401ea8      0000           add byte [eax], al
            0x00401eaa      0000           add byte [eax], al
            0x00401eac      0000           add byte [eax], al
            0x00401eae      0000           add byte [eax], al
            0x00401eb0      0000           add byte [eax], al
            0x00401eb2      0000           add byte [eax], al
            0x00401eb4      0000           add byte [eax], al
            0x00401eb6      0000           add byte [eax], al
            0x00401eb8      0000           add byte [eax], al
            0x00401eba      0000           add byte [eax], al
            0x00401ebc      0000           add byte [eax], al
            0x00401ebe      0000           add byte [eax], al
[0x00401e90]>


ğŸ§  Contexto general

    Has visto antes que se llama a WSAStartup â†’ eso inicializa Winsock, asÃ­ que el binario estÃ¡ preparando una comunicaciÃ³n de red.

    Luego, se llama a socket(af=2, type=1, protocol=ebx) en 0x00401404, y el resultado se guarda en ebp.

ğŸ” Paso a paso del uso de socket

Ya viste esto anteriormente:

0x004013ff      53             push ebx            ; protocolo (0 normalmente)
0x00401400      6a01           push 1              ; tipo: SOCK_STREAM (TCP)
0x00401402      6a02           push 2              ; AF_INET (IPv4)
0x00401404      e8870a0000     call sub.WS2_32.dll_socket
0x00401409      8be8           mov ebp, eax        ; guarda el SOCKET

Este cÃ³digo crea un socket TCP IPv4 (AF_INET, SOCK_STREAM) y guarda el descriptor en ebp.
ğŸ¯ Â¿QuÃ© hace con ese socket?

Ya lo seguiste despuÃ©s:

0x00401431      lea edx, [var_30h]         ; Estructura `sockaddr_in`
...
0x00401445      push eax                   ; puerto (conversiÃ³n htons)
0x00401455      call inet_addr             ; direcciÃ³n IP (de cadena)
...
0x00401460      push ecx                   ; sockaddr *
0x00401461      push ebp                   ; SOCKET s
0x00401466      call connect               ; conecta con IP:puerto

Esto establece una conexiÃ³n con un servidor remoto.
ğŸŒ Â¿A dÃ³nde se conecta?

En iz~60 encontraste:

60.248.52.95:443

Y luego confirmaste que esa cadena estÃ¡ en .rsrc y es leÃ­da desde 0x0040405c.

AsÃ­ que:

    El malware convierte esa direcciÃ³n (60.248.52.95) usando inet_addr().

    El puerto (443) lo convierte con atol() y luego htons().

    DespuÃ©s llena la estructura sockaddr_in y realiza un connect().

ğŸ§  IP destino: 60.248.52.95
ğŸ” Puerto destino: 443 (HTTPS, pero no necesariamente usa TLS)
ğŸ“¦ Posible funcionalidad

Dado que:

    Abre un socket TCP

    Se conecta a un C2 (command and control)

    Tiene funciones de borrado de sÃ­ mismo (/c del)

    Ejecuta cosas vÃ­a ShellExecuteExA

Esto muy probablemente es un dropper o un malware con capacidades de ejecuciÃ³n remota, que:

    Se autoelimina para dificultar el anÃ¡lisis

    Se conecta a un servidor remoto para:

        Descargar mÃ¡s cÃ³digo

        Recibir Ã³rdenes

-------------------------------------
 el binario importa recv y send de WS2_32.dll, por lo que sÃ­ tiene la capacidad de enviar y recibir datos a travÃ©s del socket TCP que abre.
ğŸ§  ActualizaciÃ³n del AnÃ¡lisis
âœ… Confirmado:

El binario:

    Establece conexiÃ³n a 60.248.52.95:443

    Tiene funciones importadas para:

        send: envÃ­o de datos

        recv: recepciÃ³n de datos

Esto sugiere que puede actuar como un:

    Backdoor

    C2 client (Command & Control)

    Downloader

    Exfiltrador de datos

ğŸ” Â¿QuÃ© sigue?

Podemos:

    ğŸ” Buscar llamadas a recv y send en el cÃ³digo para ver quÃ© datos intercambia (payloads, comandos, etc.).

    ğŸ§¾ Preparar un informe en formato PDF o Markdown.

    ğŸ“Š Hacer un diagrama de flujo visual del comportamiento.
