

ANALISIS DEL IMPORT SOCKET

[0x00401c51]> ii~socket
23  0x004020f0 NONE FUNC WS2_32.dll   socket
3   0x00402104 NONE FUNC WS2_32.dll   closesocket
[0x00401c51]> axt 0x004020f0
sub.WS2_32.dll_socket 0x401e90 [CODE:--x] jmp dword [sym.imp.WS2_32.dll_socket]
[0x00401c51]> s 0x401e90
[0x00401e90]> pd20
            ; CALL XREF from fcn.00401320 @ 0x401404(x)
┌ 6: SOCKET sub.WS2_32.dll_socket (int af, int type, int protocol);
└           0x00401e90      ff25f0204000   jmp dword [sym.imp.WS2_32.dll_socket] ; 0x4020f0
            ; CALL XREF from fcn.00401320 @ 0x4013fa(x)
┌ 6: int sub.WS2_32.dll_WSAStartup (WORD wVersionRequested, LPWSADATA lpWSAData);
└           0x00401e96      ff25f4204000   jmp dword [sym.imp.WS2_32.dll_WSAStartup] ; 0x4020f4 ; "s"
            0x00401e9c      cc             int3
            0x00401e9d      cc             int3
            0x00401e9e      cc             int3
            0x00401e9f      cc             int3
            ; CALL XREF from fcn.00401860 @ +0x199(x)
┌ 6: sub.MSVCRT.dll__itoa ();
└           0x00401ea0      ff25cc204000   jmp dword [sym.imp.MSVCRT.dll__itoa] ; 0x4020cc ; "v&"
            0x00401ea6      0000           add byte [eax], al
            0x00401ea8      0000           add byte [eax], al
            0x00401eaa      0000           add byte [eax], al
            0x00401eac      0000           add byte [eax], al
            0x00401eae      0000           add byte [eax], al
            0x00401eb0      0000           add byte [eax], al
            0x00401eb2      0000           add byte [eax], al
            0x00401eb4      0000           add byte [eax], al
            0x00401eb6      0000           add byte [eax], al
            0x00401eb8      0000           add byte [eax], al
            0x00401eba      0000           add byte [eax], al
            0x00401ebc      0000           add byte [eax], al
            0x00401ebe      0000           add byte [eax], al
[0x00401e90]>


🧠 Contexto general

    Has visto antes que se llama a WSAStartup → eso inicializa Winsock, así que el binario está preparando una comunicación de red.

    Luego, se llama a socket(af=2, type=1, protocol=ebx) en 0x00401404, y el resultado se guarda en ebp.

🔍 Paso a paso del uso de socket

Ya viste esto anteriormente:

0x004013ff      53             push ebx            ; protocolo (0 normalmente)
0x00401400      6a01           push 1              ; tipo: SOCK_STREAM (TCP)
0x00401402      6a02           push 2              ; AF_INET (IPv4)
0x00401404      e8870a0000     call sub.WS2_32.dll_socket
0x00401409      8be8           mov ebp, eax        ; guarda el SOCKET

Este código crea un socket TCP IPv4 (AF_INET, SOCK_STREAM) y guarda el descriptor en ebp.
🎯 ¿Qué hace con ese socket?

Ya lo seguiste después:

0x00401431      lea edx, [var_30h]         ; Estructura `sockaddr_in`
...
0x00401445      push eax                   ; puerto (conversión htons)
0x00401455      call inet_addr             ; dirección IP (de cadena)
...
0x00401460      push ecx                   ; sockaddr *
0x00401461      push ebp                   ; SOCKET s
0x00401466      call connect               ; conecta con IP:puerto

Esto establece una conexión con un servidor remoto.
🌍 ¿A dónde se conecta?

En iz~60 encontraste:

60.248.52.95:443

Y luego confirmaste que esa cadena está en .rsrc y es leída desde 0x0040405c.

Así que:

    El malware convierte esa dirección (60.248.52.95) usando inet_addr().

    El puerto (443) lo convierte con atol() y luego htons().

    Después llena la estructura sockaddr_in y realiza un connect().

🧠 IP destino: 60.248.52.95
🔐 Puerto destino: 443 (HTTPS, pero no necesariamente usa TLS)
📦 Posible funcionalidad

Dado que:

    Abre un socket TCP

    Se conecta a un C2 (command and control)

    Tiene funciones de borrado de sí mismo (/c del)

    Ejecuta cosas vía ShellExecuteExA

Esto muy probablemente es un dropper o un malware con capacidades de ejecución remota, que:

    Se autoelimina para dificultar el análisis

    Se conecta a un servidor remoto para:

        Descargar más código

        Recibir órdenes

-------------------------------------
 el binario importa recv y send de WS2_32.dll, por lo que sí tiene la capacidad de enviar y recibir datos a través del socket TCP que abre.
🧠 Actualización del Análisis
✅ Confirmado:

El binario:

    Establece conexión a 60.248.52.95:443

    Tiene funciones importadas para:

        send: envío de datos

        recv: recepción de datos

Esto sugiere que puede actuar como un:

    Backdoor

    C2 client (Command & Control)

    Downloader

    Exfiltrador de datos

🔍 ¿Qué sigue?

Podemos:

    🔎 Buscar llamadas a recv y send en el código para ver qué datos intercambia (payloads, comandos, etc.).

    🧾 Preparar un informe en formato PDF o Markdown.

    📊 Hacer un diagrama de flujo visual del comportamiento.
