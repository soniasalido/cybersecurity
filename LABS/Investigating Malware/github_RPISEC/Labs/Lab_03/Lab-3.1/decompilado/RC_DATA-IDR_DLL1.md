# RC_DATA / IDR_DLL1 en una DLL incrustada como recurso:

```
ðŸ“ SecciÃ³n .rsrc (recursos del binario)

// .rsrc 
// ram:00404000-ram:004093ff

ðŸ“ Entrada RC_DATA / IDR_DLL1

**************************************************************
* Rsrc_RC_DATA_IDR_DLL1_409 Size of resource: 0x5000 bytes   *
**************************************************************
Rsrc_RC_DATA_IDR_DLL1_409
004040d0 4d 5a 90 00 ...

    RC_DATA es el tipo de recurso para datos arbitrarios binarios.

    IDR_DLL1 es el identificador simbÃ³lico del recurso.

    0x004040D0 contiene datos que empiezan con la firma:

    4D 5A 90 00   â†’  "MZ"  (cabecera DOS de un ejecutable PE/DLL)
```

- Comienza con MZ, por lo que se trata de un ejecutable PE (Portable Executable), en este caso probablemente una DLL.
- TamaÃ±o del recurso: Size of resource: 0x5000 bytes â†’ 20 KB. Este tamaÃ±o es razonable para una DLL maliciosa compacta que contenga payloads (por ejemplo: backdoors, downloaders o mÃ³dulos cifrados).

## Resumiendo
- El dropper contiene embebida una DLL en formato PE dentro de los recursos del ejecutable.
- EstÃ¡ empaquetada bajo el tipo RC_DATA con el nombre IDR_DLL1.
- El ejecutable principal probablemente extrae este recurso a disco o lo carga directamente en memoria para ejecutarlo.
    

## Usamos Resource Hacker para extraer la dll
Abrimos la muestra de malware con Resorce Hacker
![resource-hacker](../analisis-estatico/capturas/resource-hacker.png)


Al abrir Resource Hacker vemos el recurso RC_DATA â†’ IDR_DLL1 : 1033, que es exactamente donde estÃ¡ la DLL incrustada. ðŸ‘‰ El nÃºmero 1033 es el identificador del idioma (en este caso, inglÃ©s - EE.UU.), que Resource Hacker muestra como parte de la ruta al recurso:
RC_DATA â†’ IDR_DLL1 : 1033 = RC_DATA/IDR_DLL1/409 (porque 1033 decimal = 0x409 hexadecimal).

![RC_DATA â†’ IDR_DLL1](../analisis-estatico/capturas/dll-IDR_DLL1-1033.png)

Hacemos clic derecho sobre IDR_DLL1 : 1033 y guardamos con extensiÃ³n *.bin o *.dll.
     
        
## Verificamos que la extracciÃ³n se realizÃ³ correctamente
```
â””â”€$ file IDR_DLL1.bin 
IDR_DLL1.bin: PE32 executable for MS Windows 6.00 (DLL), Intel i386, 5 sections
```

## Analizamos la dll extraida con x32dbg

### Abrimos la dll extraida con x32dbg
Observamos que nos nuestra el **Punto 77BB1C13**:

![Punto 77BB1C13](../analisis-estatico/capturas/ntdll1.dll-77BB1C13.png)

Esta **direcciÃ³n 77BB1C13** no es el OEP de la DLL, sino una direcciÃ³n de ejecuciÃ³n del sistema operativo. En concreto pertenece a ntdll.dll que es un componente fundamental de Windows. El cÃ³digo que vemos en la captura pertenece a funciones como RtInitializeProcess, LdrInitalizeThunk, LdrInitialize, etc, que son funciones de inicializaciÃ³n del sistema para procesos/DLLs, pero no del malware en sÃ­.

**Cuando cargamos una DLL con x32dbg:**
- x32dbg no ejecuta automÃ¡ticamente el cÃ³digo de la DLL como si fuera un EXE.
- En vez de eso, carga el proceso en pausa en el punto de inicializaciÃ³n del sistema (como LdrInitializeProcess).
- La ejecuciÃ³n aÃºn no ha llegado al verdadero Entry Point de tu DLL.
- Estamos viendo cÃ³digo del loader de Windows (ntdll), no el cÃ³digo malicioso aÃºn.

El cÃ³digo que vemos pertenece a **ntdll.dll**, concretamente a la funciÃ³n **LdrInitializeProcess**. Esto indica que estamos en una fase muy temprana de la carga del proceso (dentro de las rutinas del sistema para inicializar una DLL o EXE). 

Hemos cargado correctamente la DLL, pero el cÃ³digo en ejecuciÃ³n ahora aÃºn no es el nuestro, **es de ntdll.dll, el cual Windows llama automÃ¡ticamente al cargar cualquier mÃ³dulo PE**. Es una seÃ±al de que la DLL estÃ¡ esperando llegar a su propio **DllMain o punto de entrada.**


### Punto 69F626CD
![dll von x32dbg](../analisis-estatico/capturas/ntdll1.dll-69F626CD.png)




## Ir al punto de entrada real (OEP) de la DLL
Hemos visto en el punto anterior que estÃ¡bamos en la IDR_DLL1 cargada como ntdll1.dll, pero no estÃ¡bamos en la entrada real de esa DLL oculta en el malware (OEP). Para ir al punto de entrada real (OEP) de la DLL -->


### Analizamos los mÃ³dulos cargados
Para ver los mÃ³dulos: ALt + E  
![lista de modulo](../analisis-estatico/capturas/lista-de-modulos-1.png)

Vemos la direcciÃ³n que tiene el modulo ntdll.dll: 77B00000

Vamos a la pestaÃ±a "Memory Map" y buscamos el mÃ³dulo ntdll.dll:
![ntdll1.dll en memoria](../analisis-estatico/capturas/ntdll1.dll-memoria-1.png)


**Nota:** Hacemos click derecho sobre el mÃ³dulo en la pestaÃ±a de Memory Map --> Dump Memory to File. Para despuÃ©s analiazarlo con Ghidra.

Cargamos el mÃ³dulo ntdll.dll - 77B00000 en la vista CPU haciendo doble click sobre el.
![ntdll1.dll vista cpu](../analisis-estatico/capturas/ntdll1.dll-vista-cpu-1.png)


### Cargamos la dll extraida con DIE:
![ntdll1.dll detect it easy](../analisis-estatico/capturas/ntdll1.dll-die.png)

Con la informaciÃ³n de Detect It Easy (DiE) ya podemos **calcular la direcciÃ³n absoluta del OEP (Original Entry Point)** y saltar directamente desde x32dbg:
- DirecciÃ³n base (Image Base): 0x10000000
- Punto de entrada (Entry Point RVA): 0x00026CD


#### ðŸŽ¯ðŸŽ¯ðŸŽ¯ðŸŽ¯ Â¿Por quÃ© esta direcciÃ³n 77B00000 y no la original 0x10000000 del binario?
Esto significa que el sistema ha cargado el mÃ³dulo ntdll1.dll en la direcciÃ³n virtual 0x77B00000:
- El campo ImageBase del PE es una sugerencia.
- Windows puede reubicar la DLL en otro sitio (relocation) si la direcciÃ³n sugerida ya estÃ¡ ocupada.
- AsÃ­, aunque el binario fue compilado para 0x10000000, Windows lo cargÃ³ en 0x77B00000 en la sesiÃ³n.


#### ðŸŽ¯ðŸŽ¯ðŸŽ¯ðŸŽ¯  Â¿Por quÃ© nos importa tanto esta base?
Porque si vemos, por ejemplo, que el EntryPoint RVA es 0x26CD, entonces el OEP real en memoria es:
```
OEP = Base real en memoria + RVA = 0x77B00000 + 0x000026CD = 0x77B026CD
```
Y no 0x100026CD, que solo es vÃ¡lido si el binario sÃ­ se cargÃ³ en 0x10000000, lo cual no suele ser el caso al hacer DLL injection o analizar dumps en memoria.


**OEP RELATIVO A LA BASE ORIGINAL** = 0x10000000 + 0x26CD = 0x100026CD

Para obtener la direcciÃ³n absoluta del punto de entrada (OEP), usamos:
```
OEP = ImageBase + EntryPoint RVA
OEP = 0x10000000 + 0x00026CD = 0x100026CD
```

**No hay que confundir:**
```
RVA (Relative Virtual Address): 0x00026CD

VA (Virtual Address): 0x10000000 + 0x00026CD = 0x100026CD
```

**âœ… FÃ³rmula para convertir el Entry Point RVA a la direcciÃ³n real en x32dbg:**
```
Real_OEP = Carga_real + OEP_RVA
Real_OEP = 0x77B00000 + 0x00026CD
         = 0x77B026CD
```

### Direccion 77B026CD

![ntdll1.dll En el punto 77B026CD](../analisis-estatico/capturas/ntdll1.dll-77B026CD.png)


### Direccion 77D036CD

![ntdll1.dll En el punto 77D036CD](../analisis-estatico/capturas/ntdll1.dll-77D036CD.png)


## Step Over:

![ntdll1.dll En el punto 77DB1C1C](../analisis-estatico/capturas/ntdll1.dll-77DB1C1C.png)


## Carga de otra dll en 77CD1C32
![ntdll1.dll En el punto 77DB1C1C](../analisis-estatico/capturas/ntdll1.dll-77CD1C32.png)


## De 77CD1C32 Salta a 77CCC16B

![ntdll1.dll En el punto 77DB1C1C](../analisis-estatico/capturas/ntdll1.dll-77CCC16B.png)




## De 77CCC218

![ntdll1.dll En el punto 77DB1C1C](../analisis-estatico/capturas/ntdll1.dll-77CCC218.png)



## De 77CCC249

![ntdll1.dll En el punto 77DB1C1C](../analisis-estatico/capturas/ntdll1.dll-77CCC249.png)




## De 77CCC24F

![ntdll1.dll En el punto 77DB1C1C](../analisis-estatico/capturas/ntdll1.dll-77CCC24F.png)



## De 77CCC284

![ntdll1.dll En el punto 77DB1C1C](../analisis-estatico/capturas/ntdll1.dll-77CCC284.png)


## De 77CCC2D9

![ntdll1.dll En el punto 77DB1C1C](../analisis-estatico/capturas/ntdll1.dll-77CCC2D9.png)


## De 77CCC3B1

![ntdll1.dll En el punto 77DB1C1C](../analisis-estatico/capturas/ntdll1.dll-77CCC3B1.png)



## De 77CCC3E5

![ntdll1.dll En el punto 77DB1C1C](../analisis-estatico/capturas/ntdll1.dll-77CCC3E5.png)
