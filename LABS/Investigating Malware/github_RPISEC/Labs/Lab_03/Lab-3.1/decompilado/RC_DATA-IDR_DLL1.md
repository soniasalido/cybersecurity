### RC_DATA / IDR_DLL1 en una DLL incrustada como recurso:

```
ðŸ“ SecciÃ³n .rsrc (recursos del binario)

// .rsrc 
// ram:00404000-ram:004093ff

ðŸ“ Entrada RC_DATA / IDR_DLL1

**************************************************************
* Rsrc_RC_DATA_IDR_DLL1_409 Size of resource: 0x5000 bytes   *
**************************************************************
Rsrc_RC_DATA_IDR_DLL1_409
004040d0 4d 5a 90 00 ...

    RC_DATA es el tipo de recurso para datos arbitrarios binarios.

    IDR_DLL1 es el identificador simbÃ³lico del recurso.

    0x004040D0 contiene datos que empiezan con la firma:

    4D 5A 90 00   â†’  "MZ"  (cabecera DOS de un ejecutable PE/DLL)
```

- Comienza con MZ, por lo que se trata de un ejecutable PE (Portable Executable), en este caso probablemente una DLL.
- TamaÃ±o del recurso: Size of resource: 0x5000 bytes â†’ 20 KB. Este tamaÃ±o es razonable para una DLL maliciosa compacta que contenga payloads (por ejemplo: backdoors, downloaders o mÃ³dulos cifrados).

### Resumiendo
- El dropper contiene embebida una DLL en formato PE dentro de los recursos del ejecutable.
- EstÃ¡ empaquetada bajo el tipo RC_DATA con el nombre IDR_DLL1.
- El ejecutable principal probablemente extrae este recurso a disco o lo carga directamente en memoria para ejecutarlo.
    

### Usamos Resource Hacker para extraer la dll
Abrimos la muestra de malware con Resorce Hacker
![resource-hacker](../analisis-estatico/capturas/resource-hacker.png)


Al abrir Resource Hacker vemos el recurso RC_DATA â†’ IDR_DLL1 : 1033, que es exactamente donde estÃ¡ la DLL incrustada. ðŸ‘‰ El nÃºmero 1033 es el identificador del idioma (en este caso, inglÃ©s - EE.UU.), que Resource Hacker muestra como parte de la ruta al recurso:
RC_DATA â†’ IDR_DLL1 : 1033 = RC_DATA/IDR_DLL1/409 (porque 1033 decimal = 0x409 hexadecimal).

![RC_DATA â†’ IDR_DLL1](../analisis-estatico/capturas/dll-IDR_DLL1-1033.png)

Hacemos clic derecho sobre IDR_DLL1 : 1033 y guardamos con extensiÃ³n *.bin o *.dll.
     
        
### Verificamos que la extracciÃ³n se realizÃ³ correctamente
```
â””â”€$ file IDR_DLL1.bin 
IDR_DLL1.bin: PE32 executable for MS Windows 6.00 (DLL), Intel i386, 5 sections
```

## Analizamos la dll extraida con x32dbg
![dll von x32dbg](../analisis-estatico/capturas/dll-IDR_DLL1-x32dbg.png)


El cÃ³digo que vemos pertenece a **ntdll.dll**, concretamente a la funciÃ³n **LdrInitializeProcess**. Esto indica que estamos en una fase muy temprana de la carga del proceso (dentro de las rutinas del sistema para inicializar una DLL o EXE). Lo que significa que hemos cargado correctamente la DLL, pero el cÃ³digo en ejecuciÃ³n ahora aÃºn no es nuestro, es de ntdll.dll, el cual Windows llama automÃ¡ticamente al cargar cualquier mÃ³dulo PE. Es una seÃ±al de que la DLL estÃ¡ esperando llegar a su propio **DllMain o punto de entrada.**


### Analizamos los mÃ³dulos

![lista de modulo](../analisis-estatico/capturas/lista-de-modulos.png)

### Vamos a encontrar el OEP ( Original Entry Point) de esta DLL --> IDR_DLL1 cargada como ntdll1.dll




