#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import socket, struct, sys, time

HOST = "0.0.0.0"
PORT = 443                 # usa sudo si dejas 443
RECV_TIMEOUT_S = 10.0
IDLE_CLOSE_S   = 15.0      # espera de inactividad tras enviar el comando

HELLO_CLIENT = b"fxftest"              # 7 bytes que envía el malware
HELLO_SERVER = HELLO_CLIENT + b"\x00"  # eco de 8 bytes que espera el malware

CMD_LEN = 0x104
# IMPORTANTE: el opcode es ASCII
OPCODE_ASCII = b"1"        # <- '1' = 0x31 (opcode listar directorios)

def hexdump(data: bytes, width: int = 16) -> str:
    tochar = lambda b: chr(b) if 32 <= b <= 126 else "."
    lines = []
    for off in range(0, len(data), width):
        chunk = data[off:off+width]
        hexpart = " ".join(f"{b:02x}" for b in chunk)
        asciip  = "".join(tochar(b) for b in chunk)
        lines.append(f"{off:08x}  {hexpart:<{width*3}}  {asciip}")
    return "\n".join(lines) if lines else "(vacío)"

def recv_exact(sock: socket.socket, n: int) -> bytes:
    sock.settimeout(RECV_TIMEOUT_S)
    buf = bytearray()
    while len(buf) < n:
        chunk = sock.recv(n - len(buf))
        if not chunk:
            raise ConnectionError("Conexión cerrada por el cliente")
        buf += chunk
    return bytes(buf)

def recv_until_idle(sock: socket.socket, idle_s: float) -> bytes:
    sock.settimeout(0.2)
    buf = bytearray()
    last = time.time()
    while True:
        try:
            chunk = sock.recv(8192)
            if chunk:
                buf += chunk
                last = time.time()
            else:
                break
        except socket.timeout:
            if time.time() - last > idle_s:
                break
        except ConnectionResetError:
            break
    return bytes(buf)

def send_all(sock: socket.socket, data: bytes, desc: str):
    sock.sendall(data)
    print(f"[*] Enviado {desc} ({len(data)} bytes)")
    print("    ASCII:", repr(data[:256]))
    print("    HEX:\n" + hexdump(data))

def handle_client(conn: socket.socket, addr):
    print(f"[+] Conexión de {addr[0]}:{addr[1]}")
    try:
        # 1) hello del cliente
        hello = recv_exact(conn, len(HELLO_CLIENT))
        print(f"[*] Recibido hello ({len(hello)}): {hello!r}")
        print("    HEX:\n" + hexdump(hello))

        # 2) eco del servidor
        send_all(conn, HELLO_SERVER, "handshake/eco")

        # 3) sysinfo (512 bytes)
        sysinfo = recv_exact(conn, 512)
        print("[*] Recibido sysinfo (512 bytes)")
        print("    HEX:\n" + hexdump(sysinfo))

        # 4) comando 0x104 con opcode ASCII en el primer byte
        cmd = bytearray(CMD_LEN)
        cmd[0:1] = OPCODE_ASCII  # '1' = 0x31
        # el resto de bytes a 0
        time.sleep(0.2)          # pequeña pausa para asegurar que el cliente está listo
        send_all(conn, bytes(cmd), f"comando (opcode ASCII={OPCODE_ASCII!r})")

        # 5) recibir la salida del opcode
        print(f"[*] Esperando respuesta del opcode {OPCODE_ASCII!r} (inactividad {IDLE_CLOSE_S}s)...")
        data = recv_until_idle(conn, IDLE_CLOSE_S)
        if data:
            print(f"[*] Recibidos {len(data)} bytes de respuesta")
            preview = data if len(data) <= 8192 else data[:8192]
            print("    ASCII (truncada):", repr(preview[:512]))
            print("    HEX (truncada):\n" + hexdump(preview))
            if len(data) > 8192:
                print(f"    ... ({len(data)-8192} bytes adicionales)")
        else:
            print("[*] No llegó salida del opcode dentro del tiempo de inactividad.")

    except (socket.timeout, ConnectionError) as e:
        print(f"[!] Error/timeout: {e}")
    finally:
        try:
            conn.shutdown(socket.SHUT_RDWR)
        except Exception:
            pass
        conn.close()
        print("[*] Conexión cerrada.\n")

def main():
    port = PORT
    if len(sys.argv) == 2:
        port = int(sys.argv[1])
    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
        s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        s.bind((HOST, port))
        s.listen(5)
        print(f"[*] Escuchando en {HOST}:{port}")
        while True:
            conn, addr = s.accept()
            handle_client(conn, addr)

if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        print("\n[+] Saliendo por Ctrl+C")
