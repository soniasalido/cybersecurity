
```
# Cuando reciba fxftest responde al instante con b"fxftest\x00" (8 bytes)
# A continuación envía el opcode 1 como DWORD little-endian (b"\x01\x00\x00\x00").
# Además se queda (lee y responde en bucle por conexión) para que el binario no cuelgue.

#!/usr/bin/env python3
import socket, binascii, datetime, struct

HOST = ''           # 0.0.0.0
PORT = 443          # puerto de escucha
RECV_SZ = 65535     # tamaño máximo a recibir
KEEP_ALIVE = True   # mantener la conexión abierta tras responder

# Respuesta por defecto (si no se dispara ninguna regla)
DEFAULT_RESPONSE = b'12345678'  # placeholder seguro

def hexdump(b: bytes) -> str:
    hx = binascii.hexlify(b).decode()
    return ' '.join(hx[i:i+2] for i in range(0, len(hx), 2))

def rule_engine(data: bytes) -> bytes:
    """
    Reglas simples para responder al malware del Lab 3.2:
    - Si el cliente envía 'fxftest', devolvemos:
        1) 8 bytes: 'fxftest\\x00'  (strncmp compara solo los 7 primeros)
        2) 4 bytes: opcode 1 (DWORD LE)
       Enviamos ambos seguidos; el cliente hará dos recv y los consumirá bien.
    - HTTP demo: responde 200 OK.
    - Por defecto: DEFAULT_RESPONSE.
    """
    if b'fxftest' in data:
        handshake = b'fxftest\x00'           # 8 bytes; primeros 7 = 'fxftest'
        opcode = struct.pack('<I', 1)        # DWORD little-endian -> 0x00000001
        return handshake + opcode

    # ejemplo: si empieza por GET/POST, contesta 200 OK mínimo
    if data.startswith(b'GET ') or data.startswith(b'POST '):
        body = b'OK'
        headers = (
            b'HTTP/1.1 200 OK\r\n'
            b'Content-Type: text/plain\r\n'
            b'Content-Length: ' + str(len(body)).encode() + b'\r\n'
            b'Connection: close\r\n\r\n'
        )
        return headers + body

    return DEFAULT_RESPONSE

def handle_client(c: socket.socket, addr):
    ts = datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')
    print(f'\n[+] {ts} Connection from {addr[0]}:{addr[1]}')
    try:
        c.settimeout(10.0)
        while True:
            data = c.recv(RECV_SZ)
            if not data:
                print('    [*] Client closed connection.')
                break

            print(f'    [*] Received ({len(data)} bytes):')
            try:
                print(f'        ASCII: {data!r}')
            except Exception:
                pass
            print(f'        HEX  : {hexdump(data)}')

            resp = rule_engine(data)
            if resp:
                c.sendall(resp)
                print(f'    [*] Sent   ({len(resp)} bytes):')
                print(f'        HEX  : {hexdump(resp)}')
            else:
                print('    [*] No response (rule_engine returned empty).')

            if not KEEP_ALIVE:
                break

    except Exception as e:
        print(f'    [!] Error: {e}')
    finally:
        try:
            c.shutdown(socket.SHUT_RDWR)
        except Exception:
            pass
        c.close()
        print('    [*] Connection closed.')

def main():
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    s.bind((HOST, PORT))
    s.listen(5)
    print(f'[*] Listening on 0.0.0.0:{PORT}')
    try:
        while True:
            c, addr = s.accept()
            handle_client(c, addr)
    except KeyboardInterrupt:
        print('\n[!] Interrupted, shutting down.')
    finally:
        s.close()

if __name__ == "__main__":
    main()

```
