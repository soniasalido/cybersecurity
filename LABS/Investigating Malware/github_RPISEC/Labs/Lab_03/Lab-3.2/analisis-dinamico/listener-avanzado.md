#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import socket
import struct
import sys
import time

HOST = "0.0.0.0"
PORT = 443            # usa sudo para puertos <1024, o cambia a 8443, etc.
IDLE_CLOSE_S = 5.0    # cierra si no llega nada en N segundos tras mandar el comando
RECV_TIMEOUT_S = 10.0 # timeout general de lectura

HELLO_CLIENT = b"fxftest"                 # el malware envía esto (7 bytes)
HELLO_SERVER = HELLO_CLIENT + b"\x00"     # el malware espera 8 bytes y compara solo 7

CMD_LEN = 0x104                           # 260 bytes
OPCODE = 1                                # opcode 1 = listado

def hexdump(data: bytes, width: int = 16) -> str:
    def to_printable(b):
        return chr(b) if 32 <= b <= 126 else "."
    lines = []
    for off in range(0, len(data), width):
        chunk = data[off:off+width]
        hexpart = " ".join(f"{b:02x}" for b in chunk)
        asciip = "".join(to_printable(b) for b in chunk)
        lines.append(f"{off:08x}  {hexpart:<{width*3}}  {asciip}")
    return "\n".join(lines) if lines else "(vacío)"

def recv_exact(sock: socket.socket, n: int) -> bytes:
    """Recibe exactamente n bytes o lanza Timeout/ConnectionError."""
    sock.settimeout(RECV_TIMEOUT_S)
    buf = bytearray()
    while len(buf) < n:
        chunk = sock.recv(n - len(buf))
        if not chunk:
            raise ConnectionError("Conexión cerrada por el cliente mientras se esperaba datos")
        buf += chunk
    return bytes(buf)

def recv_until_idle(sock: socket.socket, idle_s: float) -> bytes:
    """Lee todo lo que vaya llegando hasta que no llegue nada durante idle_s segundos."""
    sock.settimeout(0.2)
    buf = bytearray()
    last = time.time()
    while True:
        try:
            chunk = sock.recv(4096)
            if chunk:
                buf += chunk
                last = time.time()
            else:
                # socket cerrado ordenadamente por el peer
                break
        except socket.timeout:
            if time.time() - last > idle_s:
                break
        except ConnectionResetError:
            break
    return bytes(buf)

def send_all(sock: socket.socket, data: bytes, desc: str):
    sock.sendall(data)
    print(f"[*] Enviado {desc} ({len(data)} bytes)")
    print("    ASCII:", repr(data[:256]))
    print("    HEX:\n" + hexdump(data))

def handle_client(conn: socket.socket, addr):
    print(f"[+] Conexión de {addr[0]}:{addr[1]}")
    try:
        # 1) HELLO del cliente (7 bytes)
        hello = recv_exact(conn, len(HELLO_CLIENT))
        print(f"[*] Recibido hello ({len(hello)}):", repr(hello))
        print("    HEX:\n" + hexdump(hello))

        # 2) Eco del servidor (8 bytes: 'fxftest\\x00')
        send_all(conn, HELLO_SERVER, "handshake/eco")

        # 3) Sysinfo (512 bytes) desde el cliente
        sysinfo = recv_exact(conn, 512)
        print(f"[*] Recibido sysinfo (512 bytes)")
        print("    HEX:\n" + hexdump(sysinfo))

        # 4) Comando de 0x104 bytes con opcode=1
        cmd = struct.pack("<I", OPCODE) + b"\x00" * (CMD_LEN - 4)
        send_all(conn, cmd, f"comando (opcode={OPCODE})")

        # 5) Recibir respuesta(s) del opcode hasta inactividad
        print(f"[*] Esperando respuesta del opcode {OPCODE} (inactividad {IDLE_CLOSE_S}s)...")
        data = recv_until_idle(conn, IDLE_CLOSE_S)
        if data:
            print(f"[*] Recibidos {len(data)} bytes de respuesta")
            # Muestra primeras 4KB para no inundar; ajusta si quieres
            preview = data if len(data) <= 4096 else data[:4096]
            print("    ASCII (truncada):", repr(preview[:256]))
            print("    HEX (truncada):\n" + hexdump(preview))
            if len(data) > 4096:
                print(f"    ... ({len(data)-4096} bytes adicionales)")
        else:
            print("[*] No llegó salida del opcode dentro del tiempo de inactividad.")

    except (socket.timeout, ConnectionError) as e:
        print(f"[!] Error/timeout de recepción: {e}")
    finally:
        try:
            conn.shutdown(socket.SHUT_RDWR)
        except Exception:
            pass
        conn.close()
        print("[*] Conexión cerrada.\n")

def main():
    port = PORT
    if len(sys.argv) == 2:
        port = int(sys.argv[0])

    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
        s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        s.bind((HOST, port))
        s.listen(5)
        print(f"[*] Escuchando en {HOST}:{port}")
        while True:
            conn, addr = s.accept()
            handle_client(conn, addr)

if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        print("\n[+] Saliendo por Ctrl+C")
