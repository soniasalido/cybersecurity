#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#
# Listener mínimo para Lab_03-2 (opcode 1: listar directorios)
# Protocolo según FUN_004012f0 (bucle principal) y FUN_004018C0 (opcode 1).
#
import argparse
import socket
import struct
import time
import re
from typing import List

HELLO = b"fxftest"          # 7 bytes
OP_LIST_DIR = 1             # opcode 1
CMD_LEN = 0x104             # 4 (opcode) + 0x100 (ruta)
SYSINFO_LEN = 0x200         # 512 bytes
ENTRY_CHUNK = 0x330         # tamaño que envía FUN_004018C0 (observado en ws2_32.send)

def hexdump(data: bytes, width: int = 16) -> str:
    out = []
    for i in range(0, len(data), width):
        chunk = data[i:i+width]
        hexpart = " ".join(f"{b:02x}" for b in chunk)
        asciipart = "".join(chr(b) if 32 <= b < 127 else "." for b in chunk)
        out.append(f"{i:06x}: {hexpart:<{width*3}} {asciipart}")
    return "\n".join(out)

def find_strings(data: bytes, minlen: int = 3) -> List[str]:
    # extrae cadenas ASCII imprimibles (útil para sacar nombres/paths del WIN32_FIND_DATA)
    return re.findall(rb"[ -~]{%d,}" % minlen, data)

def recv_exact(sock: socket.socket, n: int, timeout: float = 10.0) -> bytes:
    sock.settimeout(timeout)
    buf = bytearray()
    while len(buf) < n:
        chunk = sock.recv(n - len(buf))
        if not chunk:
            break
        buf.extend(chunk)
    return bytes(buf)

def main():
    ap = argparse.ArgumentParser(description="Listener C2 para opcode 1 (listar directorios)")
    ap.add_argument("-b", "--bind", default="0.0.0.0", help="IP de escucha (por defecto 0.0.0.0)")
    ap.add_argument("-p", "--port", type=int, default=443, help="Puerto (por defecto 443)")
    ap.add_argument("-d", "--dir", default=r"C:\", help=r"Directorio a listar (MAX 0x100 bytes)")
    ap.add_argument("--idle", type=float, default=2.0, help="Segundos de inactividad para cortar (2s)")
    args = ap.parse_args()

    # prepara servidor
    ls = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    ls.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    ls.bind((args.bind, args.port))
    ls.listen(1)
    print(f"[*] Escuchando en {args.bind}:{args.port}")

    conn, addr = ls.accept()
    print(f"[+] Conexión de {addr[0]}:{addr[1]}")

    try:
        # 1) Recibe hello del malware (7 bytes)
        hello = recv_exact(conn, len(HELLO), timeout=5)
        print(f"[*] Recibido hello ({len(hello)}): {hello!r}")

        # 2) Responde hello + opcode (12 bytes en total)
        pkt = HELLO + b"\x00" + struct.pack("<I", OP_LIST_DIR)
        conn.sendall(pkt)
        print(f"[*] Enviado handshake/opcode: HEX: {' '.join(f'{b:02x}' for b in pkt)}")

        # 3) Recibe sysinfo (512 bytes que el malware envía tras el handshake)
        sysinfo = recv_exact(conn, SYSINFO_LEN, timeout=5)
        print(f"[*] Sysinfo ({len(sysinfo)}):\n{hexdump(sysinfo)}\n")

        # 4) Envía comando 0x104: [opcode (LE dword)] + [ruta (0x100, null-terminated)]
        raw_path = args.dir.encode("ascii", "ignore")[:0x100]
        path_field = raw_path + b"\x00" + b"\x00"*(0x100 - len(raw_path) - 1) if len(raw_path) < 0x100 else raw_path
        cmd = struct.pack("<I", OP_LIST_DIR) + path_field
        assert len(cmd) == CMD_LEN
        conn.sendall(cmd)
        print(f"[*] Enviado comando ({len(cmd)} bytes), opcode={OP_LIST_DIR}, ruta={args.dir!r}")

        # 5) Recibe bloques de listado (0x330) hasta inactividad; decodifica nombres si se puede
        conn.settimeout(args.idle)
        total = 0
        last_print_time = time.time()
        entry_idx = 0
        buffer = bytearray()

        while True:
            try:
                chunk = conn.recv(ENTRY_CHUNK)
            except socket.timeout:
                print("[*] Inactividad: fin de la sesión.")
                break

            if not chunk:
                print("[*] Cierre remoto.")
                break

            total += len(chunk)
            buffer.extend(chunk)

            # procesamos por bloques de 0x330
            while len(buffer) >= ENTRY_CHUNK:
                block = bytes(buffer[:ENTRY_CHUNK])
                del buffer[:ENTRY_CHUNK]
                entry_idx += 1

                # Si es todo 0x55 (relleno), ignora
                if all(b == 0x55 for b in block):
                    print(f"[{entry_idx:03d}] bloque de relleno (0x55), ignorado")
                    continue

                # Busca posibles nombres de archivo/carpeta dentro del bloque
                strs = [s.decode("ascii", "ignore") for s in find_strings(block, 3)]
                # heuristic: el/los nombres largos suelen ir al final del WIN32_FIND_DATA
                guess = ""
                if strs:
                    # quita cadenas demasiado largas de U's o espacios
                    cleaned = [s for s in strs if "UUUU" not in s]
                    if cleaned:
                        guess = cleaned[-1]
                print(f"[{entry_idx:03d}] Bloque {len(block)} bytes"
                      + (f"  -> posible nombre: {guess!r}" if guess else ""))
                # puedes descomentar para ver el hex completo:
                # print(hexdump(block), "\n")

        # 6) Cierre contundente para que el malware no se quede en recv esperando el siguiente comando
        #    (provoca WSAECONNABORTED y sale limpio del bucle en x32dbg)
        try:
            conn.setsockopt(socket.SOL_SOCKET, socket.SO_LINGER, struct.pack("ii", 1, 0))
        except Exception:
            pass
        try:
            conn.shutdown(socket.SHUT_RDWR)
        except Exception:
            pass
        conn.close()
        ls.close()
        print(f"[*] Conexión cerrada. Recibidos totales: {total} bytes")

    except KeyboardInterrupt:
        print("\n[!] Cancelado por el usuario")
    finally:
        try:
            conn.close()
        except Exception:
            pass
        try:
            ls.close()
        except Exception:
            pass

if __name__ == "__main__":
    main()
