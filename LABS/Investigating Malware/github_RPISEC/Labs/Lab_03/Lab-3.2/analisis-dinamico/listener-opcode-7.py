#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import socket, struct, datetime, binascii

HOST = ""     # 0.0.0.0
PORT = 443
RECV_SZ = 65535
TIMEOUT_S = 60

def hexdump(b: bytes) -> str:
    hx = binascii.hexlify(b).decode()
    return " ".join(hx[i:i+2] for i in range(0, len(hx), 2))

def xor55(b: bytes) -> bytes:
    return bytes([x ^ 0x55 for x in b])

def recv_exact(c: socket.socket, n: int) -> bytes:
    out = bytearray()
    while len(out) < n:
        chunk = c.recv(n - len(out))
        if not chunk:
            raise ConnectionError(f"peer cerró (queríamos {n}, recibimos {len(out)})")
        out += chunk
    return bytes(out)

def make_handshake_reply() -> bytes:
    return b"fxftest\x00"

def make_cmd(opcode: int) -> bytes:
    return struct.pack("<I", opcode) + b"\x00" * 0x100  # 0x104 en total

def run_server():
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    s.bind((HOST, PORT))
    s.listen(5)
    print(f"[*] Escuchando en 0.0.0.0:{PORT}")

    while True:
        c, addr = s.accept()
        ts = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        print(f"\n[+] {ts} Conexión de {addr[0]}:{addr[1]}")
        c.settimeout(TIMEOUT_S)
        try:
            # 1) HELLO
            hello = c.recv(RECV_SZ)
            if b"fxftest" not in hello:
                print(f"[!] Hello inesperado: {hello!r}")
                c.close(); continue
            c.sendall(make_handshake_reply())
            print("[TX handshake 8B]")

            # 2) SYSINFO
            sysinfo = c.recv(RECV_SZ)
            print(f"[RX {len(sysinfo)} B] SYSINFO")

            # 3) Enviar opcode 7
            c.sendall(make_cmd(7))
            print("[TX opcode=7 (0x104 B)]")

            # 4) Recibir registros de 0x108 B hasta sentinela
            idx = 0
            while True:
                rec = recv_exact(c, 0x108)
                xname = rec[:0x100]
                tail  = rec[0x100:0x108]
                t0, t1 = struct.unpack("<II", tail)  # típicamente PID y PPID/flags

                name = xor55(xname).split(b"\x00", 1)[0].decode("ascii", "ignore")

                # --- detección de fin correcta ---
                # el sentinela trae nombre vacío (des-XOR) y suele poner t0==0
                if name == "" and t0 == 0:
                    print("[*] Fin de enumeración (sentinela recibido).")
                    break

                print(f"[RX proc #{idx:03d}] name='{name}'  PID=0x{t0:08X}  extra=0x{t1:08X}")
                # ACK de 2 bytes que la muestra espera (strcmp("ok"))
                c.sendall(b"ok")
                idx += 1

        except Exception as e:
            print(f"[!] Error: {e}")
        finally:
            try:
                c.shutdown(socket.SHUT_RDWR)
            except Exception:
                pass
            c.close()
            print("[*] Conexión cerrada.")

if __name__ == "__main__":
    run_server()
