#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import socket, struct, binascii, datetime

HOST = ''          # 0.0.0.0
PORT = 443
RECV_SZ = 65535
TIMEOUT_S = 60

def hexdump(b: bytes) -> str:
    hx = binascii.hexlify(b).decode()
    return ' '.join(hx[i:i+2] for i in range(0, len(hx), 2))

def safe_ascii(b: bytes) -> bytes:
    return bytes(ch if 32 <= ch < 127 else 0x2E for ch in b)

def xor55(b: bytes) -> bytes:
    return bytes([x ^ 0x55 for x in b])

def recv_exact(c: socket.socket, n: int) -> bytes:
    out = bytearray()
    while len(out) < n:
        chunk = c.recv(n - len(out))
        if not chunk:
            raise ConnectionError(f"peer cerró antes (queríamos {n}, recibimos {len(out)})")
        out += chunk
    return bytes(out)

def make_handshake_reply() -> bytes:
    return b"fxftest\x00"  # eco de 8B (la muestra compara 7)

def make_cmd_7() -> bytes:
    # Comando de 0x104: [opcode=7 LE] + 0x100 ceros (no hay parámetro)
    return struct.pack("<I", 7) + b"\x00" * 0x100

def run_server():
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    s.bind((HOST, PORT))
    s.listen(5)
    print(f"[*] Escuchando en 0.0.0.0:{PORT}")

    while True:
        c, addr = s.accept()
        ts = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        print(f"\n[+] {ts} Conexión de {addr[0]}:{addr[1]}")
        c.settimeout(TIMEOUT_S)
        try:
            # 1) HELLO
            d = c.recv(RECV_SZ)
            print(f"[RX {len(d)} B] HELLO ASCII={safe_ascii(d)!r}")
            if b"fxftest" not in d:
                print("[!] Hello inesperado. Cierro.")
                c.close(); continue
            c.sendall(make_handshake_reply())
            print("[TX handshake 8B]")

            # 2) SYSINFO (~512B de la muestra)
            d = c.recv(RECV_SZ)
            print(f"[RX {len(d)} B] SYSINFO")

            # 3) Enviar opcode 7
            cmd7 = make_cmd_7()
            c.sendall(cmd7)
            print("[TX opcode=7 (0x104 B)]")

            # 4) Recibir registros de procesos (0x108 B cada uno)
            idx = 0
            while True:
                hdr = recv_exact(c, 0x108)
                xor_name = hdr[:0x100]
                tail = hdr[0x100:0x108]         # 8B = dos DWORD LE
                t0, t1 = struct.unpack("<II", tail)

                name_clear = xor55(xor_name).split(b"\x00", 1)[0].decode("ascii", "ignore")
                print(f"[RX proc #{idx:03d}] name='{name_clear}'  "
                      f"tail0=0x{t0:08X} tail1=0x{t1:08X}")

                # Fin de listado (LAB_004023F8): envía un registro con tail0 == 0
                if t0 == 0:
                    print("[*] Fin de enumeración (sentinela).")
                    break

                # ACK de 2 bytes. Para avanzar, la muestra espera que strcmp == 0 → “ok”
                c.sendall(b"ok")
                print("[TX ack 'ok']")
                idx += 1

        except Exception as e:
            print(f"[!] Error: {e}")
        finally:
            try:
                c.shutdown(socket.SHUT_RDWR)
            except Exception:
                pass
            c.close()
            print("[*] Conexión cerrada.")

if __name__ == "__main__":
    run_server()

