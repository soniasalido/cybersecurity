
#!/usr/bin/env python3
import socket, binascii, datetime, struct, time

HOST      = ""          # 0.0.0.0
PORT      = 443
RECV_SZ   = 65535
IDLE_MAXS = 40          # cerrar si no hay tráfico en 40 s

# Cabecera que observaste antes del bloque de 'U'
DIR_REQ_HDR = b"v\x16od\x11og\x0fofv"  # 10 bytes

def hexdump(b: bytes) -> str:
    hx = binascii.hexlify(b).decode()
    return " ".join(hx[i:i+2] for i in range(0, len(hx), 2))

def make_handshake_reply() -> bytes:
    # 8 bytes; el cliente compara sólo los 7 primeros "fxftest"
    return b"fxftest\x00"

def make_opcode_packet_ascii_one() -> bytes:
    """
    Paquete de 0x104 (260) bytes. El switch en el cliente compara
    el primer byte como carácter ASCII ('1'..'d'). Ponemos '1' y
    rellenamos a cero hasta 0x104.
    """
    pkt = b"1" + b"\x00" * (0x104 - 1)
    return pkt

def make_dir_payload_utf16le(path_str: str) -> bytes:
    """
    Devuelve EXACTAMENTE 256 bytes: ruta UTF-16LE + padding 0x00.
    Si la ruta codificada excede 256, se trunca (el cliente sólo
    lee 256 bytes).
    """
    raw = path_str.encode("utf-16le", errors="ignore")
    if len(raw) > 256:
        raw = raw[:256]
    if len(raw) < 256:
        raw = raw + b"\x00" * (256 - len(raw))
    return raw  # len == 256

def log_recv(data: bytes):
    print(f"    [*] Recibido ({len(data)} bytes):")
    # Mostrar ASCII "seguro"
    try:
        ascii_preview = data[:64].decode("latin1", errors="replace")
    except Exception:
        ascii_preview = repr(data[:64])
    print(f"        ASCII: {data!r}")
    print(f"        HEX  : {hexdump(data)}")

def handle_client(c: socket.socket, addr):
    ts = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    print(f"\n[+] {ts} Conexión de {addr[0]}:{addr[1]}")
    c.settimeout(2.0)  # pequeño timeout de lectura
    last_activity = time.time()
    state = "WAIT_HELLO"
    buf = b""

    # Pre-construimos respuestas
    opcode_pkt = make_opcode_packet_ascii_one()
    dir_path   = r"C:\Users\usuario\Desktop"
    dir_resp   = make_dir_payload_utf16le(dir_path)  # EXACTAMENTE 256 B

    print(f"    [DBG] Respuesta de directorio preparada: len={len(dir_resp)} bytes (debe ser 256)")

    try:
        while True:
            # Idle timeout global
            if time.time() - last_activity > IDLE_MAXS:
                print(f"    [*] Inactividad > {IDLE_MAXS}s. Cerrando conexión.")
                break

            try:
                chunk = c.recv(RECV_SZ)
            except socket.timeout:
                continue

            if not chunk:
                print("    [*] Cliente cerró la conexión.")
                break

            last_activity = time.time()
            buf += chunk

            # Procesado por estados
            if state == "WAIT_HELLO":
                if b"fxftest" in buf:
                    log_recv(buf)
                    reply = make_handshake_reply()
                    c.sendall(reply)
                    print(f"    [*] Enviado handshake ({len(reply)} bytes)")
                    buf = b""
                    state = "WAIT_SYSINFO"
                continue

            if state == "WAIT_SYSINFO":
                if len(buf) >= 512:
                    sysinfo = buf[:512]
                    log_recv(sysinfo)
                    buf = buf[512:]
                    c.sendall(opcode_pkt)
                    print(f"    [*] Enviado comando opcode='1' (len={len(opcode_pkt)} bytes)")
                    state = "ACTIVE"
                continue

            if state == "ACTIVE":
                # Esperamos el “pedido de directorio”: normalmente 256 bytes
                # que empiezan por DIR_REQ_HDR y van llenos de 'U'
                if len(buf) >= 256:
                    pkt = buf[:256]
                    buf = buf[256:]

                    log_recv(pkt)

                    # Heurística: si empieza con la cabecera conocida o si es exactamente 256
                    if pkt.startswith(DIR_REQ_HDR) or len(pkt) == 256:
                        c.sendall(dir_resp)
                        print(f"    [*] Enviada ruta (len={len(dir_resp)} bytes) -> {dir_path}")
                        print(f"        HEX: {hexdump(dir_resp)}")
                        # después de contestar, seguimos en ACTIVE por si vienen más comandos
                    else:
                        print("    [!] Paquete de 256 bytes no coincide con cabecera esperada; ignorado.")
                # si tenemos menos de 256 bytes, seguimos acumulando
                continue

    except Exception as e:
        print(f"    [!] Error: {e}")
    finally:
        try:
            c.shutdown(socket.SHUT_RDWR)
        except Exception:
            pass
        c.close()
        print("    [*] Conexión cerrada.")

def main():
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    s.bind((HOST, PORT))
    s.listen(5)
    print(f"[*] Escuchando en 0.0.0.0:{PORT}")
    try:
        while True:
            c, addr = s.accept()
            handle_client(c, addr)
    except KeyboardInterrupt:
        print("\n[!] Interrumpido. Saliendo.")
    finally:
        s.close()

if __name__ == "__main__":
    main()
