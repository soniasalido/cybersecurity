#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import socket, struct, datetime, binascii, argparse

HOST = ""     # 0.0.0.0
PORT = 443
RECV_SZ = 65535
TIMEOUT_S = 60

def hexdump(b: bytes) -> str:
    hx = binascii.hexlify(b).decode()
    return " ".join(hx[i:i+2] for i in range(0, len(hx), 2))

def xor55(b: bytes) -> bytes:
    return bytes([x ^ 0x55 for x in b])

def recv_exact(c: socket.socket, n: int) -> bytes:
    out = bytearray()
    while len(out) < n:
        chunk = c.recv(n - len(out))
        if not chunk:
            raise ConnectionError(f"peer cerró (queríamos {n}, recibimos {len(out)})")
        out += chunk
    return bytes(out)

def make_handshake_reply() -> bytes:
    return b"fxftest\x00"

def make_cmd(opcode: int) -> bytes:
    return struct.pack("<I", opcode) + b"\x00" * 0x100  # 0x104 en total

def make_cmd8(pid_dec: int) -> bytes:
    pid_ascii = str(pid_dec).encode("ascii") + b"\x00"
    if len(pid_ascii) > 0x100:
        raise ValueError("PID demasiado largo")
    payload = pid_ascii.ljust(0x100, b"\x00")
    return struct.pack("<I", 8) + payload  # total 0x104

def run_server(port: int, dry_run: bool, target_pid: int | None):
    # *** FIX: crear el socket del servidor aquí ***
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)  # <- antes faltaba esta línea
    s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    s.bind((HOST, port))
    s.listen(5)
    print(f"[*] Escuchando en 0.0.0.0:{port}")

    while True:
        c, addr = s.accept()
        ts = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        print(f"\n[+] {ts} Conexión de {addr[0]}:{addr[1]}")
        c.settimeout(TIMEOUT_S)
        try:
            # 1) HELLO
            hello = c.recv(RECV_SZ)
            print(f"[RX hello {len(hello)} B] {hexdump(hello)}")
            if b"fxftest" not in hello:
                print(f"[!] Hello inesperado: {hello!r}")
                c.close(); continue
            c.sendall(make_handshake_reply())
            print("[TX handshake 8B] 'fxftest\\0'")

            # 2) SYSINFO
            sysinfo = c.recv(RECV_SZ)
            print(f"[RX SYSINFO {len(sysinfo)} B] {hexdump(sysinfo)}")

            # 3) Enumeración con opcode 7 (opcional pero útil)
            pkt7 = make_cmd(7)
            if dry_run:
                print(f"[DRY] opcode=7 listo (0x{len(pkt7):X} B)")
            else:
                c.sendall(pkt7)
                print("[TX opcode=7 (0x104 B)]")

                # 4) Recibir registros de 0x108 B hasta sentinela
                idx = 0
                last_pids = []
                while True:
                    rec = recv_exact(c, 0x108)
                    xname = rec[:0x100]
                    tail  = rec[0x100:0x108]
                    t0, t1 = struct.unpack("<II", tail)  # típicamente PID y extra
                    name = xor55(xname).split(b"\x00", 1)[0].decode("ascii", "ignore")
                    if name == "" and t0 == 0:
                        print("[*] Fin de enumeración (sentinela recibido).")
                        break
                    print(f"[RX proc #{idx:03d}] name='{name}'  PID=0x{t0:08X} ({t0})  extra=0x{t1:08X}")
                    # ACK esperado por la muestra
                    c.sendall(b"ok")
                    idx += 1
                    last_pids.append((name, t0))

            # 5) Preparar opcode 8
            if target_pid is None:
                # Si no se pasa PID, usa un placeholder para validar framing
                target_pid = 1234

            pkt8 = make_cmd8(target_pid)
            print(f"[*] opcode=8 preparado para PID={target_pid} (len={len(pkt8)} B)")
            print(f"    preview: {hexdump(pkt8[:16])} …")

            if dry_run:
                print("[DRY] No se envía opcode 8 (modo seguro).")
            else:
                # *** ATENCIÓN: Esto enviará la orden a la muestra ***
                c.sendall(pkt8)
                print("[TX opcode=8 (0x104 B) con PID ASCII\\0 en payload]")

                # 6) Leer respuesta de 2 bytes: '0\\x00' o '1\\x00'
                resp = recv_exact(c, 2)
                print(f"[RX 2B] Respuesta opcode 8: {hexdump(resp)}  ({resp!r})")
                if resp[:1] == b"0":
                    print("[✓] TerminateProcess: ÉXITO (la muestra devolvió '0\\x00').")
                elif resp[:1] == b"1":
                    print("[x] TerminateProcess: FALLO (la muestra devolvió '1\\x00').")
                else:
                    print("[?] Respuesta inesperada; esperaba 0x30 00 o 0x31 00.")

        except Exception as e:
            print(f"[!] Error: {e}")
        finally:
            try:
                c.shutdown(socket.SHUT_RDWR)
            except Exception:
                pass
            c.close()
            print("[*] Conexión cerrada.")

if __name__ == "__main__":
    ap = argparse.ArgumentParser(description="Harness seguro para analizar framing de opcode 8")
    ap.add_argument("--port", type=int, default=PORT, help="Puerto local de escucha")
    ap.add_argument("--pid", type=int, default=None, help="PID objetivo (solo para framing)")
    ap.add_argument("--dry-run", action="store_true", default=True,
                    help="No enviar comandos a la muestra; solo validar framing/longitudes")
    ap.add_argument("--live", dest="dry_run", action="store_false",
                    help="(Peligroso) Enviar opcode 7/8 a la muestra en un entorno controlado")
    args = ap.parse_args()

    run_server(args.port, args.dry_run, args.pid)
