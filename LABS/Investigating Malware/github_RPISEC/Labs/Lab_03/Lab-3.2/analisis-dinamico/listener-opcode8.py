Arrancamos el script indicando el PIP del proceso que se va a cerrar:  
python3 listener.py --dry-run --pid 5678


``` 
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import socket, struct, datetime, binascii, argparse
from typing import Optional

HOST = ""     # 0.0.0.0
PORT = 443
RECV_SZ = 65535
TIMEOUT_S = 60

def hexdump(b: bytes) -> str:
    hx = binascii.hexlify(b).decode()
    return " ".join(hx[i:i+2] for i in range(0, len(hx), 2))

def xor55(b: bytes) -> bytes:
    return bytes([x ^ 0x55 for x in b])

def recv_exact(c: socket.socket, n: int) -> bytes:
    out = bytearray()
    while len(out) < n:
        chunk = c.recv(n - len(out))
        if not chunk:
            raise ConnectionError(f"peer cerró (queríamos {n}, recibimos {len(out)})")
        out += chunk
    return bytes(out)

def make_handshake_reply() -> bytes:
    return b"fxftest\x00"

def make_cmd(opcode: int) -> bytes:
    return struct.pack("<I", opcode) + b"\x00" * 0x100  # 0x104 en total

def make_cmd8(pid_dec: int) -> bytes:
    pid_ascii = str(pid_dec).encode("ascii") + b"\x00"
    if len(pid_ascii) > 0x100:
        raise ValueError("PID demasiado largo")
    payload = pid_ascii.ljust(0x100, b"\x00")
    return struct.pack("<I", 8) + payload  # total 0x104

def run_server(port: int, dry_run: bool, target_pid: Optional[int]):
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    s.bind((HOST, port))
    s.listen(5)
    print(f"[*] Escuchando en 0.0.0.0:{port}")

    while True:
        c, addr = s.accept()
        ts = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        print(f"\n[+] {ts} Conexión de {addr[0]}:{addr[1]}")
        c.settimeout(TIMEOUT_S)
        try:
            # 1) HELLO
            hello = c.recv(RECV_SZ)
            print(f"[RX hello {len(hello)} B] {hexdump(hello)}")
            if b"fxftest" not in hello:
                print(f"[!] Hello inesperado: {hello!r}")
                c.close(); continue
            c.sendall(make_handshake_reply())
            print("[TX handshake 8B] 'fxftest\\0'")

            # 2) SYSINFO
            sysinfo = c.recv(RECV_SZ)
            print(f"[RX SYSINFO {len(sysinfo)} B] {hexdump(sysinfo)}")

            # 3) Preparar opcode 8
            if target_pid is None:
                target_pid = 1234  # placeholder seguro
            pkt8 = make_cmd8(target_pid)
            print(f"[*] opcode=8 preparado para PID={target_pid} (len={len(pkt8)} B)")
            print(f"    preview: {hexdump(pkt8[:16])} …")

            if dry_run:
                print("[DRY] No se envía opcode 8 (modo seguro).")
            else:
                c.sendall(pkt8)
                print("[TX opcode=8 (0x104 B) con PID ASCII\\0 en payload]")
                resp = recv_exact(c, 2)
                print(f"[RX 2B] Respuesta opcode 8: {hexdump(resp)}  ({resp!r})")
                if resp[:1] == b"0":
                    print("[✓] TerminateProcess: ÉXITO")
                elif resp[:1] == b"1":
                    print("[x] TerminateProcess: FALLO")
                else:
                    print("[?] Respuesta inesperada")

        except Exception as e:
            print(f"[!] Error: {e}")
        finally:
            try:
                c.shutdown(socket.SHUT_RDWR)
            except Exception:
                pass
            c.close()
            print("[*] Conexión cerrada.")

if __name__ == "__main__":
    ap = argparse.ArgumentParser(description="Harness para validar framing del opcode 8")
    ap.add_argument("--port", type=int, default=PORT, help="Puerto local de escucha")
    ap.add_argument("--pid", type=int, default=None, help="PID objetivo (solo para framing)")
    ap.add_argument("--dry-run", action="store_true", default=True,
                    help="No enviar comandos a la muestra; solo validar framing")
    ap.add_argument("--live", dest="dry_run", action="store_false",
                    help="(Peligroso) Enviar opcode 8 a la muestra en sandbox")
    args = ap.parse_args()

    run_server(args.port, args.dry_run, args.pid)


```
