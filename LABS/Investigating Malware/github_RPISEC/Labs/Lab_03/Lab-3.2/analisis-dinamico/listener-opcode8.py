#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import socket, struct, datetime, binascii

HOST = ""     # 0.0.0.0
PORT = 443
RECV_SZ = 65535
TIMEOUT_S = 60

def hexdump(b: bytes) -> str:
    hx = binascii.hexlify(b).decode()
    return " ".join(hx[i:i+2] for i in range(0, len(hx), 2))

def xor55(b: bytes) -> bytes:
    return bytes([x ^ 0x55 for x in b])

def recv_exact(c: socket.socket, n: int) -> bytes:
    out = bytearray()
    while len(out) < n:
        chunk = c.recv(n - len(out))
        if not chunk:
            raise ConnectionError(f"peer cerró (queríamos {n}, recibimos {len(out)})")
        out += chunk
    return bytes(out)

def make_handshake_reply() -> bytes:
    return b"fxftest\x00"

def make_cmd(opcode: int) -> bytes:
    return struct.pack("<I", opcode) + b"\x00" * 0x100  # 0x104 en total
  

def make_cmd8(pid_dec: int) -> bytes:
    pid_ascii = str(pid_dec).encode("ascii") + b"\x00"
    if len(pid_ascii) > 0x100:
        raise ValueError("PID demasiado largo")
    payload = pid_ascii.ljust(0x100, b"\x00")
    return struct.pack("<I", 8) + payload  # total 0x104

def run_server():
    # ... (setup igual)
    while True:
        c, addr = s.accept()
        # ... (timeout y try igual)
        try:
            # 1) HELLO
            hello = c.recv(RECV_SZ)
            if b"fxftest" not in hello:
                print(f"[!] Hello inesperado: {hello!r}")
                c.close(); continue
            c.sendall(make_handshake_reply())
            print("[TX handshake 8B]")

            # 2) SYSINFO
            sysinfo = c.recv(RECV_SZ)
            print(f"[RX {len(sysinfo)} B] SYSINFO")

            # === OPCIÓN A: enumerar con opcode 7 (tu flujo actual) ===
            # (puedes comentar este bloque si no necesitas enumerar)
            c.sendall(make_cmd(7))
            print("[TX opcode=7 (0x104 B)]")
            idx = 0
            last_pids = []   # <- guarda pares (name, pid) para elegir luego
            while True:
                rec = recv_exact(c, 0x108)
                xname = rec[:0x100]
                tail  = rec[0x100:0x108]
                t0, t1 = struct.unpack("<II", tail)  # PID y extra
                name = xor55(xname).split(b"\x00", 1)[0].decode("ascii", "ignore")
                if name == "" and t0 == 0:
                    print("[*] Fin de enumeración (sentinela recibido).")
                    break
                print(f"[RX proc #{idx:03d}] name='{name}'  PID=0x{t0:08X} ({t0})  extra=0x{t1:08X}")
                last_pids.append((name, t0))
                c.sendall(b"ok")  # ACK esperado por la muestra
                idx += 1

            # === Elegir el PID objetivo ===
            # Elige uno manualmente aquí (p. ej., el primero que no sea el propio proceso de la muestra)
            target_pid = next((pid for (nm, pid) in last_pids if pid != 0), 0)
            if target_pid == 0:
                print("[!] No hay PID válido de la enumeración; pon uno manualmente.")
                target_pid = 1234  # <-- sustituye por el PID que quieras probar

            print(f"[*] Objetivo para opcode 8: PID={target_pid}")

            # 3) Enviar opcode 8 con el PID ASCII NUL-terminado en el payload de 0x100
            pkt = make_cmd8(target_pid)
            c.sendall(pkt)
            print("[TX opcode=8 (0x104 B) con PID ASCII\\0 en payload]")

            # 4) Leer respuesta de 2 bytes: '0\\x00' (éxito) o '1\\x00' (fallo)
            resp = recv_exact(c, 2)
            print(f"[RX 2B] Respuesta opcode 8: {hexdump(resp)}  ({resp!r})")
            if resp[:1] == b"0":
                print("[✓] TerminateProcess: ÉXITO (la muestra devolvió '0\\x00').")
            elif resp[:1] == b"1":
                print("[x] TerminateProcess: FALLO (la muestra devolvió '1\\x00').")
            else:
                print("[?] Respuesta inesperada; esperaba 0x30 00 o 0x31 00.")

        except Exception as e:
            print(f"[!] Error: {e}")
        finally:
            # ... (cierre igual)
            pass

if __name__ == "__main__":
    run_server()
