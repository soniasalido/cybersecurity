#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import socket, struct, binascii, datetime

HOST = ''           # 0.0.0.0
PORT = 443
RECV_SZ = 65535
TIMEOUT_S = 60

# === AJUSTA ESTO ===
DEST_PATH   = r"C:\Users\usuario\Desktop\upload_test.bin"  # ruta en la VM
FILE_CONTENT = b"Hello from C2!\r\nThis file came via opcode 5.\r\n"

# -------------------

def hexdump(b: bytes) -> str:
    hx = binascii.hexlify(b).decode()
    return ' '.join(hx[i:i+2] for i in range(0, len(hx), 2))

def safe_ascii(b: bytes) -> bytes:
    return bytes(ch if 32 <= ch < 127 else 0x2E for ch in b)

def make_handshake_reply() -> bytes:
    return b"fxftest\x00"  # eco/handshake de 8B

def make_cmd(opcode: int) -> bytes:
    # Paquete de mando 0x104: [opcode(LE)] + 0x100 de ceros
    pkt = struct.pack("<I", opcode) + b"\x00" * (0x104 - 4)
    return pkt

def make_opcode5_header(path: str, total_len: int) -> bytes:
    """
    Layout que espera el malware (FUN_004020f0):
      - Recibe 0x214 bytes en un único recv.
      - Luego XOR 0x55 sobre los 0x200 bytes que empiezan en +0x14.
      - Usa la cadena en [ESP+0x28] (=> offset 0x14 dentro del buffer) como lpFileName.
      - Usa DWORD en [ESP+0x214] (=> offset 0x200) como tamaño total del contenido.
    Por tanto:
      * buffer[0x00..0x13]  : relleno (sin XOR)
      * buffer[0x14..]     : path NUL-terminado (con XOR)
      * buffer[0x200..0x203]: tamaño LE (sin XOR)
    """
    buf = bytearray(0x214)
    # path en offset 0x14
    p = path.encode('ascii', errors='ignore') + b'\x00'
    if len(p) > (0x200 - 0x14):
        p = p[:0x200 - 0x14 - 1] + b'\x00'
    buf[0x14:0x14 + len(p)] = p
    # tamaño en 0x200 (sin XOR)
    buf[0x200:0x204] = struct.pack("<I", total_len)
    # XOR 0x55 sobre [0x14..0x213]
    for i in range(0x14, 0x214):
        buf[i] ^= 0x55
    return bytes(buf)

def run_server():
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    s.bind((HOST, PORT))
    s.listen(5)
    print(f"[*] Escuchando en 0.0.0.0:{PORT}")

    while True:
        c, addr = s.accept()
        ts = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        print(f"\n[+] {ts} Conexión de {addr[0]}:{addr[1]}")
        c.settimeout(TIMEOUT_S)

        try:
            # 1) HELLO
            d = c.recv(RECV_SZ)
            print(f"[RX {len(d)} B] ASCII={safe_ascii(d)!r}\nHEX = {hexdump(d)}")
            if b"fxftest" not in d:
                print("[!] No es el hello esperado.")
                c.close()
                continue
            c.sendall(make_handshake_reply())
            print("[TX handshake 8B]")

            # 2) SYSINFO (512B)
            d = c.recv(RECV_SZ)
            print(f"[RX {len(d)} B] ASCII={safe_ascii(d)!r}\nHEX = {hexdump(d)}")

            # 3) Enviar comando opcode 5
            cmd = make_cmd(5)
            c.sendall(cmd)
            print("[TX opcode=5 0x104B]")

            # 4) Enviar header 0x214 con path y tamaño (con XOR correcto)
            header = make_opcode5_header(DEST_PATH, len(FILE_CONTENT))
            c.sendall(header)
            print(f"[TX header 0x214] path={DEST_PATH!r}, size={len(FILE_CONTENT)}")

            # 5) Enviar contenido del fichero (en tantos trozos como quieras)
            #    El malware hace recv() de hasta 0x400 (1024) cada vez.
            sent = 0
            CHUNK = 512
            while sent < len(FILE_CONTENT):
                chunk = FILE_CONTENT[sent:sent+CHUNK]
                c.sendall(chunk)
                sent += len(chunk)
            print(f"[TX data] {sent} bytes enviados")

            # 6) Recibir respuesta: "upfileok" (longitud ~9 con NUL) o "upfileer"
            resp = c.recv(32)
            print(f"[RX status] {resp!r}  HEX={hexdump(resp)}")
            if b"upfileok" in resp:
                print("[OK] El cliente escribió el archivo correctamente.")
            elif b"upfileer" in resp:
                print("[FAIL] Error de creación/escritura en el cliente.")
            else:
                print("[?] Respuesta inesperada.")

        except socket.timeout:
            print("[!] Timeout.")
        except Exception as e:
            print(f"[!] Error: {e}")
        finally:
            try:
                c.shutdown(socket.SHUT_RDWR)
            except Exception:
                pass
            c.close()
            print("[*] Conexión cerrada.")

if __name__ == "__main__":
    run_server()
