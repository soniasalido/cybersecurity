

## El malware resuelve la dirección del servidor
**Flujo_**
- El host C2 es claramente us.tz8.net.
- El puerto lo ves en la sockaddr_in de la llamada a connect: En la captura de ws2_32.connect, [ESP+8] apunta a la estructura sockaddr_in, y en [+2] (sin_port) tienes 0x0A03 → en orden de red esto es 0x030A en host order → 778 decimal.
  En hex:
  ```
  ntohs(0x0A03) = 0x030A = 778
  ```
  Así que el malware intenta conectar a us.tz8.net:778.
  
- En el send justo antes de esa conexión, se ve que envía la cadena ASCII "fxftest".


___________________________________________________________________
## Bucle de conexión de red FALLIDA - Sin Remnux Activado

### Gethostbyname
![Gethostbyname](capturas/gethostbyname.png)
Llama a gethostbyname con el host us.tz8.net.


### WSAGetLastError: No obtiene el servicio que espera
![WSAGetLastError](capturas/wsagetlasterror.png)


### Inet_ntoa
![Inet_ntoa](capturas/inet_ntoa.png)

inet_ntoa es otra función de la API de sockets (también en ws2_32.dll en Windows) y su nombre viene de:
```
inet = internet
n = network (orden de red)
to = a
a = ASCII
```
Inet_nto convierte una dirección IPv4 que está en binario (estructura in_addr, 4 bytes en orden de red) a una cadena ASCII con el formato habitual de “punto decimal”.

El malware usa inet_ntoa para imprimir/guardar/usar en texto la IP que había obtenido de gethostbyname. De esa forma puede loguear o mostrar la IP “humana” (10.0.0.3) que va a usar para conectarse.



### Socktet
![Socktet](capturas/socket.png)



### Htons
![Htons](capturas/htons-conexion-fallida.png)

Htons significa host to network short. Convierte un entero de 16 bits (short / uint16_t) del orden de bytes del host (little-endian en PC Intel) al orden de bytes de red (big-endian, estándar en TCP/IP). Cuando el malware quiere enviar un número de puerto por la red, la CPU lo tiene en su orden de bytes interno. Pero el protocolo TCP/IP exige que todos los números vayan en big-endian. htons hace esa conversión antes de ponerlo en estructuras como sockaddr_in.

En esa screenshot estamos parados en ws2_32.htons y a la derecha se ve:
- edi: "&us.tz8.net"
- ebx: "10.0.0.3"
- EAX = 0x000001BB → eso es 443 (estás viendo una llamada a htons con puerto 443 en ese momento concreto).

Así que el malware intenta conectar a us.tz8.net:443.


### Inet_addr
![Inet_addr](capturas/inet_addr.png)

Inet_addr Convierte una dirección IPv4 en formato de cadena de texto (ASCII) al formato binario de 32 bits (in_addr) en orden de red (big-endian).

En esta muestra de malware, inet_addr se usa para:
- Convertir un texto de IP que tenga embebido (p. ej. "10.0.0.3") a binario antes de guardarlo en la estructura sockaddr_in para un connect.
- Es el paso inverso a inet_ntoa (que convierte de binario a cadena legible).

### Connect
![Connect](capturas/connect.png)

[ESP+8] → puntero a una sockaddr_in (IPv4).

Seguimos ese puntero: clic derecho sobre [ESP+8] → Follow in Dump.

![Connect](capturas/connect-follow-in-dump.png)

```
0040AA70:  02 00  01 BB  0A 00 00 03  ...
            ^^^^  ^^^^^  ^^^^^^^^^^^
          AF_INET  puerto    IP (10.0.0.3)
```

- +0 → 02 00 = AF_INET
- +2 → 01 BB = puerto en orden de red (big‑endian)
- 0x01BB ⇒ 443 (HTTPS)
- +4 → 0A 00 00 03 = 10.0.0.3

Así que en esa llamada a connect el malware intenta ir a us.tz8.net:443 (resuelto a 10.0.0.3).

Si queremos atraparlo en REMnux, escucha en 443 (necesita sudo y que no haya otro servicio usando 443):
```
sudo ncat -l 0.0.0.0 443 --keep-open --verbose
```
Cuando conecte, veremos que envía fxftest; le responderemos con algo (p.ej. OK) para que avance.


### Closesocket
![Closesocket](capturas/closesocket-conexion-fallida.png)


### Gethostbyname
![Gethostbyname](capturas/gethostbyname-2.png)


### WSAGetLastError: No obtiene el servicio que espera
![WSAGetLastError](capturas/wsagetlasterror.png)

.... Continúa en bucle.

___________________________________________________________________


### WSAStartup: Inicia la conexión
![wsastartup](capturas/wsastartup.png)


### WSAGetLastError: No obtiene el servicio que espera
![WSAGetLastError](capturas/wsagetlasterror.png)

WSAGetLastError devolviendo WSASERVICE_NOT_FOUND (0x277C) → o no resuelve o no obtiene el servicio que espera.

### Gethostbyname
![Gethostbyname](capturas/gethostbyname.png)
Llama a gethostbyname con el host us.tz8.net.


### WSAGetLastError: No obtiene el servicio que espera
![WSAGetLastError](capturas/wsagetlasterror.png)


### Inet_ntoa
![Inet_ntoa](capturas/inet_ntoa.png)


### Gethostbyname
![Gethostbyname](capturas/gethostbyname.png)



#### WSAGetLastError: No obtiene el servicio que espera
![WSAGetLastError](capturas/wsagetlasterror.png)


### WSAStartup: Inicia la conexión
![wsastartup](capturas/wsastartup.png)


### Htons
![Htons](capturas/htons.png)


### Closesocket
![Cierre del socket](capturas/closesocket.png)
Espera respuesta; si no la recibe, cierra el socket y termina la fase de red.

___________________________________________________________
## Bucle de conexión de red FALLIDA - CON Remnux Activado
### Arrancamos MV Remnux para que de respuesta.
Hacer que la MV INetSim responda
En nuestro REMnux:
```
# Redirige us.tz8.net a REMnux en el Windows (hosts o DNS)
echo "<IP_REMNUX> us.tz8.net" | sudo tee -a /etc/hosts

# Levanta listener TCP en el puerto 778
```
nc -lnvp 778
```
Cuando conecte, veremos "fxftest". Responderemos con lo algo que valida, como por ejemplo "OK" o repetir "fxftest".
```

### Hacemos que la MV Windows resuelva el DNS
Hacemos que el malware hable con nuestra MV REMnux: Hacemos que la MV Windows resuelva us.tz8.net hacia la MV REMnux:
- En la VM Windows, editamos C:\Windows\System32\drivers\etc\hosts y añadimos:
  ```
  <IP_MV_REMnux>   us.tz8.net
  ```



#### WSAStartup: Inicia la conexión
![wsastartup](capturas/wsastartup.png)



#### 2. Se conecta al puerto 778.

#### 3. Envía "fxftest".
![Envío fxftest](capturas/send-fxftest.png)

#### 4. Espera respuesta; si no la recibe, cierra el socket y termina la fase de red.
![Cierre del socket](captura/closesocket.png)

## Hacer que la MV INetSim responda
En nuestro REMnux:
```
# Redirige us.tz8.net a REMnux en el Windows (hosts o DNS)
echo "<IP_REMNUX> us.tz8.net" | sudo tee -a /etc/hosts

# Levanta listener TCP en el puerto 778
nc -lnvp 778
```
Cuando conecte, veremos "fxftest". Responderemos con lo algo que valida, como por ejemplo "OK" o repetir "fxftest".


## Resulto el dns intenta conectar al servidor

![Intento conexion](capturas/intento-conexion.png)

Llamada a WSAGetLastError dentro de ws2_32.dll, y el resultado (EAX = 0x277C) corresponde a:
```
WSASERVICE_NOT_FOUND (0x277C)
```
Eso ocurre cuando WSALookupServiceBeginW no encuentra el servicio/host que se solicitó. En el Call Stack se ve que venimos precisamente de WSALookupServiceBeginW.

El malware intenta localizar el servicio asociado al dominio/IP que resolvió (en este caso us.tz8.net a 10.0.0.3), pero la consulta falla → devuelve “servicio no encontrado”.

Como no obtiene datos, el flujo tomará la rama de error de red y no pasará a la parte que queremos (recibir y procesar respuesta del C2).

Tenemos que activar la MV Remnux para que dé respuesta.



## El malware resuelve la dirección del servidor

![Resolucion DNS](capturas/resolucion-dns.png)

- El hilo está dentro de la sección principal del binario (lab_03-2.malware), en la dirección 0x00401626.
- Justo antes hay un call Sleep (API de Windows para pausar el hilo).
- En los registros:
  - EDI apunta a la cadena "us.tz8.net" → host C2.
  - EBX contiene "10.0.0.3" → la IP a la que ha resuelto el dominio.
  - En el stack [ESP+8] está 0x00030E00 que corresponde a un timeout en milisegundos (probablemente para operaciones de red).
  - EAX está a 0 → parece que la última operación de red no devolvió datos útiles.
- LastError es ERROR_SUCCESS y LastStatus es STATUS_TIMEOUT (0x00000005) → Esto indica que alguna llamada de red (probablemente recv o similar) ha esperado a que llegue algo y ha expirado.
- En memoria cerca de 0x0040A120 está la cadena "fxftest", que vimos que el malware envía al servidor tras conectar.


**Interpretación del flujo:**
- El malware resolvió us.tz8.net → 10.0.0.3 (REMnux).
- Se conectó al puerto que descubrimos antes (778).
- Envió "fxftest".
- Ahora está en un bucle de espera (Sleep + comprobar algo) esperando recibir respuesta del C2.
- Al no llegar datos, la operación de espera caduca (STATUS_TIMEOUT) y vuelve a intentarlo.
