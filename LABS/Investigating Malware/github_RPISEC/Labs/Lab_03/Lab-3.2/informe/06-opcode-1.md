# 06 – Opcode 1: Enumeración de Unidades de Disco  
**Muestra:** Lab_03-2.malware  
**Curso/Lab:** RPISEC – Investigating Malware – Lab 3.2

---

## 1. Introducción

El **Opcode 1** implementa la funcionalidad de **enumeración de unidades lógicas** del sistema comprometido.  
Esta información es recopilada por el malware, ofuscada mediante una operación XOR simple y enviada al servidor de **Command & Control (C2)**.

Desde el punto de vista funcional, este opcode forma parte de la fase de **descubrimiento del host (host enumeration)** y permite al operador remoto conocer la estructura básica de almacenamiento del sistema víctima.

---

## 2. Función principal asociada

- **Función:** [FUN_004018C0](../decompilado/FUN_004018C0-opcode1.md)
- **Invocada desde:** dispatcher principal (`FUN_004012F0`)
- **Parámetro principal:** socket activo hacia el C2

Esta función se ejecuta cuando el servidor envía el opcode con valor **1**.

---

## 3. Resumen funcional

Cuando se ejecuta el Opcode 1, el malware realiza las siguientes acciones:

1. Enumera las unidades lógicas disponibles en el sistema.
2. Obtiene el tipo de cada unidad (fija, extraíble, red, CD-ROM, etc.).
3. Construye una representación interna de las unidades detectadas.
4. Ofusca los datos recopilados mediante XOR `0x55`.
5. Envía un bloque de datos de **256 bytes** al servidor C2.

---

## 4. Enumeración de unidades lógicas

La función utiliza la API de Windows:

- `GetLogicalDrives`

Esta API devuelve un **bitmask de 32 bits**, donde cada bit representa la existencia de una unidad de la A: a la Z:.

Ejemplo observado durante el análisis dinámico:
- Unidades detectadas: **C:**, **D:** y **Z:**
- La unidad **Z:** corresponde a un recurso remoto (unidad de red, típica en entornos virtualizados).

---

## 5. Identificación del tipo de unidad

Para cada unidad detectada, el malware llama a:

- `GetDriveTypeA("X:\\")`

Valores relevantes devueltos por la API:

| Valor WinAPI | Tipo de unidad |
|-------------|---------------|
| 2 | Removible |
| 3 | Fija |
| 4 | Remota |
| 5 | CD-ROM |

El malware traduce estos valores a **códigos internos propios**, por ejemplo:

| Tipo WinAPI | Código interno |
|------------|---------------|
| DRIVE_REMOVABLE (2) | 0 |
| DRIVE_FIXED (3) | 1 |
| DRIVE_CDROM (5) | 2 |
| DRIVE_REMOTE (4) | 3 |

---

## 6. Construcción del bloque de datos

Para cada unidad, el malware:

- Construye una cadena con la letra de unidad y su tipo interno.
- Utiliza funciones personalizadas de formateo (`FUN_004034AA`, `FUN_00404F0D`) en lugar de `sprintf`.

Este sistema de formateo:
- Evita funciones estándar fácilmente detectables
- Reduce la eficacia de firmas estáticas
- Centraliza toda la salida textual del malware

---

## 7. Ofuscación mediante XOR

Antes de enviar la información al C2, el malware aplica una ofuscación:

- **Algoritmo:** XOR
- **Clave:** `0x55`
- **Longitud:** 256 bytes

Cada byte del buffer se transforma mediante:
```byte ^= 0x55```


Este mecanismo es trivial desde el punto de vista criptográfico, pero suficiente para:
- Evitar cadenas en claro en tráfico de red
- Dificultar detección basada en firmas simples

---

## 8. Envío al servidor C2

El bloque ofuscado se envía mediante:

- `WS2_32.DLL::Ordinal_19` (equivalente a `send()`)

Parámetros observados:
- **Buffer:** datos ofuscados
- **Longitud:** `0x100` (256 bytes)
- **Flags:** 0

Tras el envío, la función retorna al bucle principal de recepción de opcodes.

---

## 9. Análisis dinámico del tráfico

Durante la captura de tráfico se observó:

- Envío de un bloque de 256 bytes tras ejecutar el opcode.
- Contenido no legible directamente debido al XOR.
- Tras aplicar XOR `0x55`, el contenido revela información como:
```#C:1D:2Z:3#``` 


Esto confirma que el malware está reportando:
- Letras de unidad
- Tipos de dispositivo asociados

---

## 10. Relación con otras funciones auxiliares

El Opcode 1 depende de varias funciones internas:

- `FUN_004034AA`: formateo de strings tipo `sprintf`
- `FUN_00404F0D`: parser de formato personalizado
- `FUN_00404DF8`: escritura de caracteres a stream interno

Estas funciones forman parte de una **infraestructura propia de salida**, reutilizada por otros opcodes.

---

## 11. Impacto y utilidad para el atacante

Desde el punto de vista del operador C2, este opcode permite:

- Identificar unidades locales y remotas
- Detectar unidades de red (posibles recursos compartidos)
- Inferir si el sistema es físico o virtualizado
- Preparar acciones posteriores (exfiltración, exploración de rutas, etc.)

---

## 12. Conclusiones

El Opcode 1 implementa una funcionalidad clásica de **reconocimiento del host**, ejecutada de forma controlada por el servidor C2.

Aunque la técnica empleada es simple, su integración en un protocolo basado en opcodes y su dependencia del C2 refuerzan la naturaleza del malware como **backdoor interactivo**.

Este opcode sirve como base para operaciones más intrusivas, y su análisis facilita la comprensión de:
- El formato de datos intercambiados
- El sistema de ofuscación
- La arquitectura modular del malware

---

## 13. Transición al siguiente opcode

Una vez completada la enumeración de unidades, el malware retorna al bucle principal y queda a la espera de un nuevo comando del C2.


## 14. Opcode1 en crudo
- [FUN_004018C0-opcode1](../decompilado/FUN_004018C0-opcode1.md)


