# 04 – Comunicación con el Servidor C2  
**Muestra:** Lab_03-2.malware  
**Curso/Lab:** RPISEC – Investigating Malware – Lab 3.2

---

## 1. Introducción

Este documento describe en detalle el **mecanismo de comunicación C2 (Command & Control)** utilizado por la muestra Lab 3.2.  
El objetivo es comprender cómo el malware:

- Resuelve el servidor remoto
- Establece la conexión
- Intercambia datos
- Reacciona ante fallos de red
- Progresa únicamente cuando recibe respuestas válidas

El análisis se ha realizado combinando **depuración en x32dbg**, **captura de tráfico** y **simulación activa del C2 en REMnux**.

---

## 2. Identificación del servidor C2

A partir del análisis estático y dinámico se identifica:

- **Dominio C2:** `us.t28.net`
- **Puerto:** `443/TCP`
- **Protocolo:** TCP en texto plano (no TLS real)

El uso del puerto 443 tiene como objetivo **camuflar el tráfico** como HTTPS, aunque no se observa negociación TLS.

---

## 3. Resolución del dominio

El malware resuelve el dominio mediante la API de Winsock:

- `gethostbyname("us.t28.net")`

En el entorno de laboratorio, la resolución se fuerza mediante el archivo `hosts` de Windows:

```10.0.0.3 us.t28.net```


Tras la resolución, el malware convierte la dirección IP entre formatos:

- `inet_ntoa` → binario a ASCII
- `inet_addr` → ASCII a binario

Estas conversiones se utilizan para preparar la estructura `sockaddr_in`.

---

## 4. Preparación de la conexión

Antes de llamar a `connect`, el malware construye la estructura `sockaddr_in`:

```
struct sockaddr_in {
sin_family = AF_INET
sin_port = htons(443)
sin_addr = inet_addr("10.0.0.3")
}
``` 


La conversión del puerto se realiza mediante:

- `htons(0x01BB)` → 443 en orden de red (big-endian)

---

## 5. Establecimiento de conexión

La conexión se realiza mediante:

- `ws2_32.connect`

### 5.1 Sin servidor C2 activo

Cuando no existe un servidor escuchando:

- `connect` falla o
- la conexión se cierra inmediatamente (`closesocket`)
- `recv` devuelve timeout (`STATUS_TIMEOUT`)
- el malware entra en un **bucle de reintento**

Este comportamiento impide que el malware avance a fases posteriores.

---

## 6. Handshake inicial

Cuando la conexión se establece correctamente, el malware envía inmediatamente:
```fxftest```



Características del mensaje:

- Longitud: 7 bytes
- Texto plano
- Actúa como **handshake u opcode inicial**

Tras enviar este mensaje, el malware espera una **respuesta válida del servidor**.

---

## 7. Espera de respuesta y control del flujo

El malware realiza una llamada a:

- `recv`

Condiciones observadas:

- Si no recibe datos → timeout → cierre de socket → reintento
- Si recibe datos incorrectos → cierre de sesión
- **Solo progresa si recibe una respuesta válida**

Durante el análisis se determinó que el malware espera **una respuesta de 8 bytes**.

---

## 8. Simulación del servidor C2 en REMnux

Para permitir el avance del malware se implementó un **servidor C2 simulado** en REMnux:

- Escucha en `0.0.0.0:443`
- Acepta conexiones TCP
- Registra el tráfico recibido
- Responde con datos controlados

Ejemplo de interacción exitosa:
```
Cliente (malware) → fxftest
Servidor (REMnux) → 8 bytes válidos
``` 


Una vez recibida la respuesta correcta, el malware continúa con el envío de información del sistema y la recepción de opcodes.

---

## 9. Comunicación C2 exitosa

Durante una sesión válida se observó el siguiente comportamiento:

1. Conexión TCP establecida
2. Envío de `fxftest`
3. Recepción de respuesta válida
4. Envío de información del sistema (≈512 bytes)
5. Recepción de opcode desde el servidor
6. Ejecución de la acción correspondiente
7. Retorno de resultados al C2

Esto confirma la existencia de un **canal C2 interactivo**.

---

## 10. Diagrama del flujo C2

El flujo completo de comunicación puede representarse de la siguiente forma:
``` 
TCP/443 (sin TLS). Cliente = Malware (Windows). Servidor = C2 simulado (REMnux).

┌────────────────────────────────┐                         ┌──────────────────────────────┐
│ Malware (Win)                  │                         │ C2 (REMnux)                  │
│ socket/connect -> us.t28.net   │                         │ listen 0.0.0.0:443           │
└───────────────┬────────────────┘                         └───────────────┬──────────────┘
                │ 1) CONNECT (TCP 3-way handshake)                         │
                │─────────────────────────────────────────────────────────>│
                │                                                          │
                │ 2) HANDSHAKE / IDENTIFICACIÓN                            │
                │    send: "fxftest" (ASCII)                               │
                │    LEN = 7 bytes                                         │
                │─────────────────────────────────────────────────────────>│
                │                                                          │
                │ 3) TOKEN / ACK DEL SERVIDOR                              │
                │    recv: 8 bytes exactos                                 │
                │    LEN = 8 bytes                                         │
                │<─────────────────────────────────────────────────────────│
                │                                                          │
                │ 4) BLOQUE INICIAL (observado como ~512 bytes)            │
                │    send: SYSINFO / metadatos del host                    │
                │    LEN ≈ 512 bytes (observado)                           │
                │    (estructura exacta: pendiente de confirmar)           │
                │─────────────────────────────────────────────────────────>│
                │                                                          │
                │ 5) CICLO DE COMANDOS (opcodes)                           │
                │    recv: comando/opcode + parámetros                     │
                │    LEN = variable (no fijado)                            │
                │<─────────────────────────────────────────────────────────│
                │                                                          │
                │ 6) RESPUESTA / RESULTADO                                 │
                │    send: salida/estado/datos exfil                       │
                │    LEN = variable                                        │
                │─────────────────────────────────────────────────────────>│
                │                                                          │
                │ (repite pasos 5-6)                                       │
                │                                                          │
                │ 7) CIERRE                                                │
                │    close / WSACleanup                                    │
                │─────────────────────────────────────────────────────────X│

``` 


---

## 11. Conclusiones

El análisis de la comunicación C2 demuestra que:

- El malware depende completamente del servidor remoto
- Sin respuesta válida, el binario no ejecuta acciones
- El protocolo es simple pero efectivo
- El uso del puerto 443 es puramente evasivo
- El diseño corresponde a un **backdoor interactivo clásico**

Este comportamiento valida y complementa los hallazgos del análisis estático y dinámico previos.

---

## 12. Relación con documentos posteriores

Este documento sirve como base directa para:

- `05-protocolo-y-opcodes.md`
- Análisis individuales de cada opcode
- Estudio detallado del intercambio de datos y estructuras


---

## 13. Comunicación C2 en crudo:
[Comunicación C2](../analisis-dinamico/comunicacion-c2.md)
