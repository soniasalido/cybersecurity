# 03 – Análisis Dinámico  
**Muestra:** Lab_03-2.malware  
**Curso/Lab:** RPISEC – Investigating Malware – Lab 3.2

---

## 1. Objetivo del análisis dinámico

El objetivo del análisis dinámico es **observar el comportamiento real del malware en ejecución**, validar las hipótesis planteadas durante el análisis estático y comprender el flujo completo de ejecución, especialmente en lo relativo a:

- Comunicación con el servidor C2
- Protocolo propietario basado en opcodes
- Dependencia de respuestas remotas
- Uso efectivo de funcionalidades internas (enumeración, ejecución, persistencia)

Para ello se emplearon técnicas de depuración interactiva y simulación controlada del servidor remoto.

---

## 2. Entorno de ejecución

### 2.1 Sistema Windows (víctima)

- Sistema operativo Windows (x86)
- Ejecución del malware bajo **x32dbg**
- Resolución del dominio C2 forzada mediante `hosts`

Ejemplo:
```10.0.0.3 us.t28.net```


### 2.2 Sistema Linux (REMnux)

- Simulación del servidor C2
- Captura de tráfico con `tcpdump`
- Listener TCP personalizado en Python escuchando en el puerto 443

---

## 3. Ejecución inicial del malware

Al ejecutar la muestra, se observa que el malware:

1. Inicializa Winsock (`WSAStartup`)
2. Resuelve el dominio C2 (`gethostbyname`)
3. Intenta establecer una conexión TCP al puerto 443
4. Entra en un bucle de espera dependiente de la red

Sin un servidor accesible, el malware **no progresa** más allá de esta fase.

---

## 4. Análisis del bucle de espera

### 4.1 Función crítica: `recv`

Bajo depuración, el flujo de ejecución queda atrapado en llamadas repetidas a:

- `ws2_32.recv`

El malware espera recibir datos desde el servidor remoto. Si `recv` devuelve 0 bytes o un error, el flujo vuelve al inicio del bucle.

### 4.2 Consecuencia

Este comportamiento confirma que:

- El malware **depende directamente del C2**
- No ejecuta sus funcionalidades internas sin recibir datos válidos
- El C2 controla el ritmo y las acciones del malware

---

## 5. Identificación del handshake inicial

Mediante depuración y captura de tráfico se observó que, tras establecer la conexión, el malware envía el siguiente mensaje:
```fxftest```



Este mensaje actúa como un **handshake u opcode inicial**, identificado previamente en el análisis estático.

Tras enviar esta cadena, el malware espera una **respuesta de exactamente 8 bytes**.

---

## 6. Simulación del servidor C2

### 6.1 Listener TCP personalizado

Para permitir que el malware avance en su ejecución, se desarrolló un listener TCP en Python que:

- Escucha en `0.0.0.0:443`
- Acepta conexiones entrantes
- Registra los datos recibidos
- Responde con 8 bytes (`12345678`)

Este listener permite simular el comportamiento mínimo del C2 real.

### 6.2 Resultado

Tras recibir la respuesta correcta:

- El malware abandona el bucle inicial
- El flujo de ejecución progresa
- Se activan nuevas rutas de código asociadas a opcodes

---

## 7. Validación de hipótesis del análisis estático

| Hipótesis | Resultado |
|---------|----------|
| Uso de C2 por TCP | Confirmado |
| Puerto 443 como camuflaje | Confirmado |
| Protocolo propietario | Confirmado |
| `fxftest` como opcode | Confirmado |
| Dependencia del servidor | Confirmado |

---

## 8. Observación del flujo principal

Una vez superada la fase de handshake, el malware:

1. Entra en un bucle principal controlado por opcodes
2. Espera nuevos datos del servidor (`recv`)
3. Interpreta el opcode recibido
4. Ejecuta la función asociada
5. Envía la respuesta al C2 (`send`)
6. Vuelve a esperar instrucciones

Este diseño corresponde a un **backdoor interactivo** clásico.

---

## 9. Uso de breakpoints clave

Durante el análisis se colocaron breakpoints estratégicos en:

- `connect`
- `send`
- `recv`
- Funciones internas asociadas a opcodes

Esto permitió:
- Inspeccionar buffers
- Modificar respuestas
- Forzar rutas de ejecución específicas

---

## 10. Inyección manual de datos

En determinados puntos, se inyectaron manualmente datos en memoria (buffers de `recv`) para:

- Simular respuestas del C2
- Evitar dependencias de red
- Forzar la ejecución de código interno

Esta técnica resultó especialmente útil cuando el malware entraba en bucles persistentes.

---

## 11. Captura y análisis de tráfico

La captura de tráfico en REMnux confirmó que:

- El tráfico es **TCP en texto plano**
- No se observa negociación TLS
- El contenido coincide con los buffers observados en x32dbg

Esto refuerza la conclusión de que el uso del puerto 443 es únicamente un mecanismo de evasión superficial.

---

## 12. Relación con el análisis de opcodes

El análisis dinámico permitió:

- Correlacionar opcodes con funciones internas
- Identificar el orden real de ejecución
- Confirmar qué opcodes son alcanzables
- Preparar el análisis detallado de cada opcode (documentos 06–17)

---

## 13. Conclusiones del análisis dinámico

El análisis dinámico demuestra que:

- El malware está diseñado para ser **completamente controlado por el C2**
- Sin un servidor funcional, el binario permanece inactivo
- El protocolo es simple pero efectivo
- La simulación del C2 es esencial para el análisis completo

Este comportamiento es consistente con un **backdoor remoto interactivo**, y valida todas las hipótesis planteadas en el análisis estático.

---

## 14. Transición a fases posteriores

Los resultados de este análisis sirven como base directa para:

- `04-comunicacion-c2.md`
- `05-protocolo-y-opcodes.md`
- Análisis individuales de cada opcode
- Estudio del overlay y payloads secundarios



---

## 15. Análisis dinámico en crudo:
[Análisis Dinámico](../analisis-dinamico/)
