# 05 – Protocolo y Opcodes  
**Muestra:** Lab_03-2.malware  
**Curso/Lab:** RPISEC – Investigating Malware – Lab 3.2

---

## 1. Introducción

Este documento describe el **protocolo de comunicación propietario** implementado por la muestra Lab 3.2 y el **mecanismo de despacho de comandos (opcodes)** controlado por el servidor C2.

El análisis se basa principalmente en el estudio de la función principal del malware (`FUN_004012F0`), que actúa como **coordinador central** de:
- inicialización,
- comunicación de red,
- validación del handshake,
- y ejecución de comandos remotos.

---

## 2. Rol de la función main (`FUN_004012F0`)

La función `FUN_004012F0` implementa el **bucle principal del bot**, encargándose de:

1. Inicializar el entorno y recopilar información local.
2. Establecer persistencia mediante autocopiado.
3. Resolver y validar el servidor C2.
4. Establecer una conexión TCP.
5. Realizar un handshake obligatorio.
6. Entrar en un bucle de recepción y ejecución de opcodes.
7. Cerrar la sesión cuando ocurre un error o se recibe un opcode de salida.

Desde el punto de vista de diseño, esta función equivale al **motor del protocolo C2**.

---

## 3. Fase de inicialización y persistencia

Durante la fase inicial, el malware:

- Obtiene rutas críticas mediante:
  - `GetModuleFileNameA`
  - `GetSystemDirectoryA`
  - `GetUserNameA`
- Construye una ruta del tipo:

```C:\DOCUME~1<usuario>\java.exe```

- Se autocopia en dicha ruta si no se está ejecutando ya desde ella.
- Registra el nombre lógico `"sysinfo"` mediante una función auxiliar (`FUN_004012a0`).

Esta fase no forma parte directa del protocolo, pero **prepara el entorno antes de establecer comunicación**.

---

## 4. Resolución del servidor y validación anti-loopback

Antes de conectar, el malware realiza una resolución DNS del dominio C2 (`us.t28.net`) usando `gethostbyname`.

### Comprobación anti-loopback

La IP resuelta se convierte a cadena mediante `inet_ntoa` y se compara con el literal:

```127.0.0.1```


Si el dominio resuelve a loopback:
- El malware duerme 30 segundos (`Sleep(30000)`)
- Reintenta indefinidamente

**Conclusión:**  
Esta lógica actúa como **protección frente a sinkholes simples y entornos de análisis**, y es una causa frecuente de “conexión que se corta” durante el análisis dinámico.

---

## 5. Establecimiento de la conexión TCP

Si la IP resuelta no es loopback, el malware:

1. Crea un socket:
```socket(AF_INET, SOCK_STREAM, IPPROTO_TCP)```

2. Construye una estructura `sockaddr_in` con:
- `sin_family = AF_INET`
- `sin_port = htons(443)`
- `sin_addr = inet_addr(ip_resuelta)`
3. Intenta conectar mediante `connect`

Si la conexión falla:
- Cierra el socket (`closesocket`)
- Duerme 30 segundos
- Reintenta

---

## 6. Handshake obligatorio del protocolo

Una vez establecida la conexión, el malware ejecuta un **handshake obligatorio**:

### Mensaje enviado al servidor
```fxftest```


- Longitud enviada: 8 bytes (`fxftest\0`)
- Enviado mediante `send`

### Respuesta esperada del servidor

El malware espera:
- **8 bytes**
- Los **primeros 7 bytes deben coincidir con `"fxftest"`**

La comparación se realiza con:

```strncmp(buf, "fxftest", 7)```


Si la comparación falla:
- El malware cierra la conexión
- Reinicia el ciclo de conexión

**Conclusión:**  
El handshake es **estrictamente simétrico**: el servidor debe devolver `"fxftest"` para que el cliente continúe.

---

## 7. Bloque inicial de información del sistema

Tras un handshake exitoso, el malware envía inmediatamente un bloque adicional:

- Tamaño observado: **0x200 bytes (512 bytes)**
- Contenido: información del sistema (hostname, entorno, datos internos)

Este bloque puede considerarse una forma de **registro inicial del bot ante el C2**.

---

## 8. Bucle principal de comandos (dispatcher)

Tras el envío del bloque inicial, el malware entra en un bucle infinito controlado por el C2.

### Recepción de comandos

En cada iteración:
- Se ejecuta:
```recv(sock, buffer, 0x104, 0)```

- El malware espera **exactamente hasta 0x104 bytes**
- El **primer DWORD (little-endian)** del buffer representa el opcode

Si `recv` devuelve ≤ 0:
- Se cierra la conexión
- Se sale del bucle

---

## 9. Estructura general de un mensaje de comando

```
Offset Tamaño Descripción

0x00 4 Opcode (DWORD, little-endian)
0x04 ... Parámetros / datos del comando
... ... Padding / datos adicionales
Total ≤ 0x104 bytes
``` 


**Conclusión clave:**  
Tras el handshake, el servidor **debe enviar al menos 4 bytes** con un opcode válido (1–13), o el malware cerrará la sesión.

---

## 10. Dispatcher de opcodes

El malware implementa un `switch` que despacha **13 opcodes distintos**, cada uno asociado a una función concreta:

| Opcode | Función | Descripción |
|------|--------|-------------|
| 1 | `FUN_004018C0` | Enumeración de unidades lógicas |
| 2 | `FUN_00401A20` | Listado de archivos (ruta XOR) |
| 3 | `FUN_00402050` | Ejecución de binario |
| 4 | `FUN_004020A0` | Eliminación de archivo |
| 5 | `FUN_004020F0` | Recepción de archivo |
| 6 | `FUN_00402210` | Creación de archivo |
| 7 | `FUN_00402310` | Enumeración de procesos |
| 8 | `FUN_00402440` | Terminación de proceso |
| 9 | `FUN_00402490` | Ejecución de comandos y captura de salida |
| 10 | `FUN_00402660` | Interpretación de comandos de texto |
| 11 | `FUN_00402620` | Cierre de sesión |
| 12 | `FUN_00402880` | Recepción genérica de datos |
| 13 | `FUN_004028C0` | Control remoto de `Sleep` |

Cualquier opcode fuera de este rango provoca la salida del bucle.

---

## 11. Ejemplo práctico: disparar el opcode 1

Para activar el opcode 1 (enumeración de discos), el servidor debe enviar:
```01 00 00 00 [padding hasta 0x104 bytes]```



El malware entonces ejecutará `FUN_004018C0` y enviará los resultados al C2 mediante `send`.

---

## 12. Motivos frecuentes de caída de la conexión

El análisis del flujo permite identificar tres causas principales de desconexión:

1. **Resolución DNS a 127.0.0.1**  
   → el malware duerme y reintenta indefinidamente.
2. **Handshake inválido**  
   → la respuesta del servidor no comienza por `"fxftest"`.
3. **Ausencia de opcode válido**  
   → no se reciben 4 bytes con un valor entre 1 y 13.

---

## 13. Conclusiones

El protocolo implementado por la muestra:

- Es **simple pero estricto**
- Está completamente controlado por el servidor C2
- Utiliza un handshake fijo como autenticación básica
- Implementa un dispatcher clásico de opcodes
- Permite control remoto completo del sistema comprometido

Desde el punto de vista didáctico y técnico, este diseño refleja fielmente la arquitectura de **backdoors reales basados en comandos**, y justifica la necesidad de simular correctamente el servidor C2 para un análisis completo.

---

## 14. Relación con documentos posteriores

Este documento sirve como base directa para:
- Análisis individuales de cada opcode (`opcode1.md` … `opcode13.md`)
- Simulación avanzada del C2
- Comprensión del flujo completo de ejecución del malware


## 15. Opcodes en crudo:
- [FUN_004018C0-opcode1](../decompilado/FUN_004018C0-opcode1.md)
- [FUN_00401A20-opcode2](../decompilado/FUN_00401A20-opcode2.md)
- [FUN_00402050-opcode3](../decompilado/FUN_00402050-opcode3.md)
- [FUN_004020A0-opcode4](../decompilado/FUN_004020A0-opcode4.md)
- [FUN_004020F0-opcode5](../decompilado/FUN_004020F0-opcode5.md)
- [FUN_00402210-opcode6](../decompilado/FUN_00402210-opcode6.md)
- [FUN_00402310-opcode7](../decompilado/FUN_00402310-opcode7.md)
- [FUN_00402440-opcode8](../decompilado/FUN_00402440-opcode8.md)
- [FUN_00402490-opcode9](../decompilado/FUN_00402490-opcode9.md)
- [FUN_00402660-opcode10](../decompilado/FUN_00402660-opcode10.md)
- [FUN_00402620-opcode11](../decompilado/FUN_00402620-opcode11.md)
- [FUN_00402880-opcode12](../decompilado/FUN_00402880-opcode12.md)
- [FUN_004028C0-opcode13](../decompilado/FUN_004028C0-opcode13.md)
