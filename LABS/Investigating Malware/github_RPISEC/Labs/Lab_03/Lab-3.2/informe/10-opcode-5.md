# Opcode 5 – Recepción y escritura remota de archivos (Upload)  
**Muestra:** Lab_03-2.malware  
**Curso/Lab:** RPISEC – Investigating Malware – Lab 3.2

---

## 1. Introducción

El **Opcode 5** implementa la funcionalidad de **recepción remota de archivos desde el servidor C2 y su escritura en disco** en el sistema comprometido.

A diferencia del Opcode 2 (listado de archivos) y Opcode 3 (ejecución), este opcode permite al operador **transferir contenido arbitrario al host víctima**, lo que habilita capacidades de **dropper**, **actualización de payloads** o **instalación de herramientas adicionales**.

---

## 2. Función principal asociada

- **Función:** [FUN_004012F0](../decompilado/FUN_004020F0-opcode5.md)
- **Opcode:** `0x05`
- **Invocada desde:** dispatcher principal (`FUN_004012F0`)
- **Objetivo:** recibir un archivo desde el C2 y guardarlo localmente

---

## 3. Resumen funcional

Cuando se ejecuta el Opcode 5, el malware realiza las siguientes acciones:

1. Recibe una **cabecera inicial de 0x204 bytes** desde el C2.
2. Descifra los primeros **0x200 bytes** aplicando XOR `0x55`.
3. Extrae de la cabecera:
   - Ruta del archivo destino
   - Tamaño total del archivo a recibir
4. Crea el archivo local en modo escritura.
5. Entra en un bucle de recepción de bloques de datos.
6. Escribe cada bloque recibido en disco.
7. Finaliza enviando un mensaje de estado al C2 (`upfileok` o `upfileer`).

---

## 4. Cabecera inicial (0x204 bytes)

### Recepción
El malware ejecuta:
```recv(sock, buffer, 0x204, 0)``` 


De esta cabecera:
- **0x200 bytes** están ofuscados con XOR `0x55`
- **4 bytes finales** contienen información adicional (tamaño total esperado)

### Contenido lógico tras descifrado

| Offset | Tamaño | Descripción |
|------|-------|------------|
| 0x00 | 256   | Ruta del archivo destino (ASCIIZ) |
| 0x100 | 256 | Padding / datos auxiliares |
| 0x200 | 4   | Tamaño total del archivo (DWORD LE) |

La ruta del archivo se localiza en:
```[ESP + 0x28]```


---

## 5. Creación del archivo destino

Una vez descifrada la cabecera, el malware intenta crear el archivo con:
```
CreateFileA(
lpFileName = ruta_descifrada,
dwDesiredAccess = GENERIC_WRITE,
dwCreationDisposition = CREATE_ALWAYS,
...
)
```


Resultados:
- **Fallo** → se envía inmediatamente `upfileer` al C2.
- **Éxito** → se guarda el handle y continúa la recepción del contenido.

---

## 6. Recepción y escritura del contenido

### Bucle de recepción

El malware mantiene un contador (`EBX`) con el **número de bytes restantes** por recibir.

En cada iteración:
1. Llama a:
```recv(sock, buffer, 0x400, 0)```

2. Escribe los bytes recibidos en disco mediante:
```WriteFile(hFile, buffer, bytes_recibidos)```

3. Resta los bytes escritos al contador restante.
4. Continúa hasta que el contador llega a 0.

### Observaciones dinámicas
- El tamaño típico de bloque observado es **0x400 bytes (1024)** o menor en el último bloque.
- El contenido del archivo **no está cifrado ni ofuscado**.
- El relleno con `0x55` observado en el stack es residual, no parte del archivo final.

---

## 7. Manejo de errores durante la escritura

Si ocurre cualquiera de los siguientes errores:
- `recv` devuelve `-1`
- `WriteFile` falla
- El handle del archivo no es válido

El malware:
- Aborta la operación
- Cierra el handle (si existe)
- Reporta error al C2 mediante `upfileer`

No se observan reintentos ni recuperación parcial.

---

## 8. Finalización y reporte al C2

### Cierre del archivo
Una vez recibido el total de bytes esperados:
```CloseHandle(hFile)```



### Mensaje de estado
El malware notifica el resultado al servidor:

- **Éxito:**  
```"upfileok" (9 bytes)```

- **Error:**  
```"upfileer" (9 bytes)```


El mensaje se envía mediante `send()` sobre el socket activo.

---

## 9. Análisis dinámico observado

Durante pruebas controladas se verificó que:

- El archivo es creado correctamente en la ruta indicada.
- El contenido recibido coincide exactamente con el enviado por el C2.
- El tamaño final del archivo corresponde al DWORD especificado en la cabecera.
- El malware no valida el tipo de archivo ni su contenido.

Ejemplo observado:
```
Hello from C2!
This file came via opcode 5.
```


---

## 10. Implicaciones para el operador C2

El Opcode 5 permite al atacante:

- Subir binarios adicionales
- Actualizar el propio malware
- Instalar herramientas auxiliares
- Depositar scripts o ficheros de configuración

Combinado con:
- **Opcode 3** (ejecución)
- **Opcode 4** (eliminación)

se obtiene un **ciclo completo de drop–execute–cleanup**.

---

## 11. Relación con otros opcodes

Flujo típico observado:

1. Opcode 2 → localizar rutas
2. Opcode 5 → subir archivo
3. Opcode 3 → ejecutar archivo
4. Opcode 4 → borrar rastros

Este encadenamiento confirma un **diseño modular y coherente del protocolo C2**.

---

## 12. Conclusiones

El Opcode 5 implementa una funcionalidad crítica de **transferencia de archivos desde el C2 al host víctima**, utilizando:

- Cabeceras estructuradas
- Ofuscación simple para metadatos
- Escritura directa a disco

Aunque la implementación es básica, resulta completamente funcional y suficiente para habilitar **control remoto avanzado del sistema**.

Este opcode refuerza la clasificación de la muestra como un **backdoor interactivo con capacidades de dropper**.

---

## 13. Transición al siguiente opcode

Tras completar la subida del archivo y reportar el estado, el malware retorna al bucle principal y queda a la espera de nuevas instrucciones del C2.



## 14. Opcode5 en crudo:
- [FUN_004020F0-opcode5](../decompilado/FUN_004020F0-opcode5.md)
