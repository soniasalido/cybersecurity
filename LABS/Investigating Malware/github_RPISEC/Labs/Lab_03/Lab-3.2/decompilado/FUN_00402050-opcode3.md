# FUN_00402050 - Opcode 3

La funci√≥n FUN_00402050 es el funcionamiento t√≠pico de un dropper / downloader:
- Decodifica un buffer de 256 bytes (0x100) usando XOR 0x55.
- Intenta ejecutar ese buffer como comando con WinExec().
- WinExec es una API antigua de Windows que ejecuta comandos o aplicaciones con nombre, sin redirecci√≥n de consola.
- Reporta el resultado al servidor C2, dependiendo de si la ejecuci√≥n fue exitosa o no.

## An√°lisis paso a paso:

### 1. Inicializaci√≥n:
- `MOV ECX, dword ptr [ESP + param_2]`: Carga en el registro ECX la direcci√≥n de memoria de una cadena de caracteres (el segundo par√°metro de la funci√≥n). Esta cadena est√° actualmente cifrada.
- `XOR EAX, EAX`: Pone a cero el registro `EAX`, que se usar√° como contador del bucle.

### 2. Bucle de decodificaci√≥n (LAB_00402056):
- El bucle se ejecuta 256 veces (desde `EAX=0` hasta `EAX=0xFF`, ya que `CMP EAX`, `0x100 y JL` significa "saltar si es menor").
- `MOV DL, byte ptr [EAX + ECX*0x1]`: Coge un byte de la cadena cifrada.
- `XOR DL, 0x55`: Esta es la clave. Realiza una operaci√≥n XOR entre el byte del malware y la clave est√°tica 0x55. Esta es una t√©cnica de cifrado sim√©trico muy simple y com√∫n.
- `MOV byte ptr [EAX + ECX*0x1]`, DL: Sobrescribe el byte cifrado original con el nuevo byte decodificado.
- `INC EAX`: Incrementa el contador para pasar al siguiente byte.

### 3. Ejecuci√≥n del comando:
- `PUSH 0x0 y PUSH ECX`: Prepara los argumentos para la funci√≥n `WinExec`. `ECX` ahora apunta a la cadena reci√©n decodificada y `0x0 (SW_HIDE)` le dice a Windows que ejecute el comando en una ventana oculta.
- `CALL dword ptr [->KERNEL32.DLL::WinExec]`: Llama a la funci√≥n `WinExec` de la API de Windows, que ejecuta la cadena decodificada. Esta cadena podr√≠a ser cualquier cosa, como `"calc.exe", "cmd.exe /c net user admin pass /add"` o una ruta a otro malware.

### 4. Comprobaci√≥n y acci√≥n secundaria:
- `CMP EAX, 0x1f`: Comprueba el valor de retorno de `WinExec`. Un valor mayor que `31 (0x1f) significa que la ejecuci√≥n fue exitosa.
- Si la ejecuci√≥n no fue exitosa (JLE salta si es menor o igual), el c√≥digo llama a una funci√≥n de la librer√≠a de sockets de Windows (`WS2_32.DLL`). Esto sugiere que si no puede ejecutar el comando local, podr√≠a intentar realizar una acci√≥n de red, como conectarse a un servidor de Comando y Control (C2) para reportar el error o descargar otra carga √∫til.


## Resumiendo
El malware no exfiltra la salida est√°ndar del comando (lo que imprimir√≠a whoami o ipconfig). Lo que hace es:
- Recibir el bloque de 256 B XOR-eado desde el C2.
- Decodificarlo (XOR 0x55) ‚Üí obtiene el comando (ej. "cmd.exe /c whoami").
- Llamar a WinExec(cmd, 0).
- Revisar el valor de retorno de WinExec:
        - > 31h (49 decimal) = √©xito.
        - ‚â§ 31h = error.
- Reportar s√≥lo 2 bytes de estado al servidor (por lo que ves en el listener b'0\x00' con HEX=30 00).

Es decir:  
üîπ Ejecuta el comando en la VM infectada.  
üîπ Pero solo manda de vuelta al C2 un estado binario (ejecutado correctamente o error), nunca el output.  

Por eso en el listener lo √∫nico que recibe son esos 2 bytes de estado (0x30 00, que corresponde al √©xito en whoami).



# An√°lisis din√°mico de Opcode 3

## Listener en python para poder probar este opcode
[listener-opcode3.py](../analisis-dinamico/listener-opcode-3.py)

Probaremos un listener que env√≠a un buffer de 256 bytes (0x100) usando XOR 0x55.  
Activamos en la MV Remnux un listener para probar este opcode en x32dbg y hacemos una captura de los paquetes que circulan por la red:
```
sudo tcpdump -i any host 10.0.0.4
sudo pythom3 listener-opcode3.py
```


## Inicio de funci√≥n (0x00402050)
- Ver qu√© direcci√≥n llega en param_2 (‚Üí contiene el comando XOReado).
- Nos permite hacer Follow in Dump ‚Üí Address ECX para ver el buffer antes de descifrarlo.
[Inicio Funcion](../analisis-dinamico/capturas/00402050-opcode3.png)

## Dentro del bucle XOR (0x00402056)
- Avanzamos en el bucle hasta que salga del bucle (0x00402065 ‚Üí JNZ) ‚Üí comparamos el buffer antes/despu√©s del XOR.
[Fin del bucle XOR](../analisis-dinamico/capturas/00402056-opcode3.png)


## Antes de WinExec (0x0040206A)
- Aqu√≠ ECX apunta ya a la cadena descifrada (ej. "calc.exe" o el comando que el C2 ordena ejecutar).
- Hacemos Follow in Dump ‚Üí ECX para ver el comando en claro.


# Despu√©s de WinExec (0x00402070)
- EAX contiene el c√≥digo de retorno de WinExec.
- Si EAX > 0x1F ‚Üí ejecuci√≥n exitosa, salta a enviar resultado con send.
- Si no, cae en el branch de error (0x00402077).
[Despu√©s de WinExec](../analisis-dinamico/capturas/00402070-opcode3.png)


## Llamada a send (0x00402083)
- Si hubo √©xito, aqu√≠ podemos ver lo que reporta al C2.
- El argumento [esp+8] es el buffer con la info que manda.
[Llamada a send](../analisis-dinamico/capturas/00402083-opcode3.png)


## Desde el Host C2
![opcode-3-2](../analisis-dinamico/capturas/opcode3-2.png)

______________________________________________________________
![opcode-3](../analisis-dinamico/capturas/opcode-3.png)


![opcode-3-2](../analisis-dinamico/capturas/opcode3-2.png)

_____________________________________________________________
```
        00402043 90 90 90        align      align(13)
                 90 90 90 
                 90 90 90 
                             **************************************************************
                             *                          FUNCTION                          *
                             **************************************************************
                             undefined __cdecl FUN_00402050(undefined4 param_1, LPCST
                               assume FS_OFFSET = 0xffdff000
             undefined         <UNASSIGNED>   <RETURN>
             undefined4        Stack[0x4]:4   param_1
             LPCSTR            Stack[0x8]:4   param_2                                 XREF[1]:     00402050(R)  
                             FUN_00402050                                    XREF[1]:     FUN_004012f0:00401740(c)  
        00402050 8b 4c 24 08     MOV        ECX,dword ptr [ESP + param_2]
        00402054 33 c0           XOR        EAX,EAX
                             LAB_00402056                                    XREF[1]:     00402065(j)  
        00402056 8a 14 08        MOV        DL,byte ptr [EAX + ECX*0x1]
        00402059 80 f2 55        XOR        DL,0x55
        0040205c 88 14 08        MOV        byte ptr [EAX + ECX*0x1],DL
        0040205f 40              INC        EAX
        00402060 3d 00 01        CMP        EAX,0x100
                 00 00
        00402065 7c ef           JL         LAB_00402056
        00402067 6a 00           PUSH       0x0
        00402069 51              PUSH       ECX
        0040206a ff 15 30        CALL       dword ptr [->KERNEL32.DLL::WinExec]              = 0000990a
                 90 40 00
        00402070 83 f8 1f        CMP        EAX,0x1f
        00402073 6a 00           PUSH       0x0
        00402075 6a 02           PUSH       0x2
        00402077 7e 11           JLE        LAB_0040208a
        00402079 8b 44 24 0c     MOV        EAX,dword ptr [ESP + 0xc]
        0040207d 68 94 a1        PUSH       DAT_0040a194                                     = 30h    0
                 40 00
        00402082 50              PUSH       EAX
        00402083 ff 15 68        CALL       dword ptr [->WS2_32.DLL::Ordinal_19]             = 80000013
                 91 40 00
        00402089 c3              RET
```

