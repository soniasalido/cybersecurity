# An√°lisis del c√≥digo fuente

```
#include <stdio.h>

void call_me() {
	printf("You cannot call me, noob!\n");
}

void parse_file(char* filename){
	char buffer[512];

	printf("Abriendo fichero %s ...\n", filename);

	FILE *f = fopen(filename, "r");
	if(f == NULL){
		printf("Fallo al abrir el fichero :(\n");
		return;
	}
	printf("Leyendo fichero %s ...\n", filename);

	fread(buffer, 1, 1024, f);
	printf("Fichero leido! Contenido: \n");
	printf(buffer);

	fclose(f);
	return;
}

int main(int argc, char** argv) {
	if(argc != 2){
		printf("Uso: %s <fichero>\n", argv[0]);
		return -1;
	}

	parse_file(argv[1]);
	return 0;
}
```
donde:
- El c√≥digo tiene tres funciones:
  - `call_me()` ‚Üí no se llama desde ning√∫n punto del programa. El objetivo es forzar su ejecuci√≥n mediante un exploit (por ejemplo, modificando la direcci√≥n de retorno en la pila).
  - `parse_file(char* filename)` ‚Üí abre y lee un fichero.
  - `main()` ‚Üí comprueba argumentos y llama a parse_file.
- `buffer[512]` ‚Üí reserva 512 bytes en la pila.
- `fread(buffer, 1, 1024, f);` ‚Üí Error de seguridad cr√≠tica: Se est√° leyendo 1024 bytes en un buffer de solo 512 bytes ‚û°Ô∏è Esto provoca un desbordamiento de buffer (stack overflow).
- Un atacante puede escribir m√°s all√° del l√≠mite de buffer y sobrescribir la direcci√≥n de retorno de `parse_file()`, pudiendo hacer que el programa salte a `call_me()`.
- ‚ûü‚ûü‚ûü `buffer [512 bytes] + EBP + RET` ‚ûü‚ûü‚ûü Si el atacante introduce 512 bytes de relleno + direcci√≥n de `call_me()` (en little-endian), al retornar de `parse_file()` se ejecutar√° `call_me()`.
- üß® Vulnerabilidad adicional ‚ûü‚ûü‚ûü Formato de cadena: `printf(buffer);` ‚ûü‚ûü‚ûü Esto abre una vulnerabilidad de formato de cadena (format string vulnerability). `printf()` intentar√° leer del stack como si hubiera par√°metros adicionales, lo que puede filtrar direcciones de memoria o incluso permitir escritura arbitraria (mediante %n).

| Tipo de vulnerabilidad                              | Descripci√≥n                                                          | Consecuencia posible                                         |
| --------------------------------------------------- | -------------------------------------------------------------------- | ------------------------------------------------------------ |
| **Desbordamiento de buffer (stack overflow)**       | `fread(buffer, 1, 1024, f)` escribe m√°s all√° del l√≠mite de 512 bytes | Ejecuci√≥n arbitraria de c√≥digo (p. ej. saltar a `call_me()`) |
| **Formato de cadena (format string vulnerability)** | `printf(buffer);` sin especificar formato                            | Filtraci√≥n o modificaci√≥n de memoria                         |
