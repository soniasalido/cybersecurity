
## C√≥digo del programa
```c
#include <stdio.h>

void call_me() {
    printf("You cannot call me, noob!\n");
}

void try_to_call_me() {
    char input[120];
    printf("Call ");
    gets(input);
    printf("Maybe...\n");
}

int main(int argc, char** argv) {
    try_to_call_me();
    return 0;
}
```

donde:
- Entra a try_to_call_me().
- Muestra Call , lee una l√≠nea con gets(input) y luego imprime Maybe....
- Termina.
- La funci√≥n call_me() no se llama en el flujo normal.

Lo interesante es que usa gets, que es insegura: no comprueba el tama√±o del buffer (input[120]). Con una entrada suficientemente larga, se puede provocar un desbordamiento de pila y sobrescribir la direcci√≥n de retorno para desviar la ejecuci√≥n hacia call_me() (o a cualquier otra parte). Este es el t√≠pico ejercicio ‚Äústack0‚Äù para demostrar c√≥mo explotar un buffer overflow.


----------------------------------------

# An√°lisis con IDA 
## La funci√≥n main
![ida-main](capturas/ida-main.png)

### La firma de la funci√≥n main: `int __cdecl main(int argc, const char **argv, const char **envp)`:
- argc (tipo int): n√∫mero de argumentos posicionales pasados al programa desde la l√≠nea de comandos. Incluye el nombre del programa.
- argv (tipo char ** o const char **): puntero a un array de cadenas C (array de char *).
    - argv[0] normalmente es el nombre (o ruta) del ejecutable.
    - argv[1] es el primer argumento, etc.
    - El array est√° terminado con argv[argc] == NULL.
- envp (tipo char ** o const char **): puntero a un array de cadenas que representan las variables de entorno.

### Pr√≥logo/stack frame (cdecl, 32-bit):
``` 
push ebp
mov  ebp, esp
and  esp, 0FFFFFFF0h
```
Crea el frame de pila y alinea ESP a 16 bytes (√∫til para SSE/ABI de MSVC/GCC).

### IDA anota los par√°metros que podr√≠an llegar:
```
argc = [ebp+8]
argv = [ebp+0Ch]
envp = [ebp+10h]
```
Estos argumentos No se usan.

### Runtime init de GCC:
```
call __main
```
Stub del runtime (inicializa constructores est√°ticos, etc.).


### L√≥gica real del programa:
```
call _try_to_call_me
mov  eax, 0
```

Llama a try_to_call_me() y carga 0 en EAX como valor de retorno de main.


### Ep√≠logo:
```
leave
retn
```

Restaura EBP, devuelve al SO.


## La funci√≥n try_to_call_me
![ida-fun-try_to_call_me](capturas/ida-fun-try_to_call_me.png)

```
push ebp
mov  ebp, esp
sub  esp, 98h           ; reserva espacio en la pila para variables locales
mov  dword ptr [esp], offset Format  ; "Call "
call _printf

lea  eax, [ebp-80h]     ; direcci√≥n del buffer local
mov  dword ptr [esp], eax
call _gets              ; gets(buffer)

mov  dword ptr [esp], offset aMaybe ; "Maybe..."
call _puts

leave
retn
```

### Donde
- `push ebp / mov ebp, esp` ü†Æ prologo habitual: guarda el frame anterior y marca el nuevo ebp.
- `sub esp, 98h` ü†Æ reserva 0x98 (152) bytes en la pila para variables locales / alineaci√≥n.
- `mov [esp], offset Format y call _printf` ü†Æ prepara el argumento (puntero al string "Call ") en la cima de la pila y llama a printf. El compilador usa mov [esp], ... en lugar de push (una forma de pasar argumentos cuando ya se ha hecho la reserva).
- `lea eax, [ebp-80h]` ü†Æ obtiene la direcci√≥n de la variable local que IDA llama var_80. Es decir, el buffer empieza en ebp - 0x80.
- `mov [esp], eax y call _gets` ü†Æ pasa la direcci√≥n del buffer a gets. Importante: gets no comprueba tama√±os, por eso es insegura.
- Luego prepara el string "Maybe..." y llama a puts, termina la funci√≥n.

Se usa la funci√≥n insegura `gets` para escribir por pantalla un mensaje que se almacena en la variable local `var_80`. Esta variable tiene un espacio reservado de 0x80 que son 128 bytes en decimal. ¬øPorqu√© 128 bytes si en el c√≥digo de main se han reservado s√≥lo 120? Porque el compilador ha decidido reservar 8 bytes m√°s para mantener el alineamiento de la pila a 16 bytes (0x10). Esto quiere decir que como m√≠nimo, necesitaremos escribir 128 bytes para poder comenzar a sobreescribir informaci√≥n en la pila.



### Layout de pila (conceptual)
```css
[ direcci√≥n m√°s alta ]
... (stack del llamador)
ret address  <-- [ebp + 4]
saved EBP    <-- [ebp]
local buffer (comienza en [ebp - 0x80])  <-- espacio reservado para vars
[ direcciones m√°s bajas ]
```
donde:
- El buffer comienza en ebp - 0x80 (IDA lo marca como var_80).
- La funci√≥n reserv√≥ 0x98 bytes totales; el buffer ocupa parte de ese espacio (el compilador puede a√±adir padding por alineaci√≥n).
- gets escribe datos a partir de la direcci√≥n ebp - 0x80 sin l√≠mite.


### ¬øD√≥nde est√° la vulnerabilidad?
Porque gets(buffer) puede leer m√°s bytes de los que el buffer puede almacenar y, por tanto, sobrescribir la memoria adyacente dentro del frame: primero sobreescribe el contenido del buffer, luego el saved EBP, y despu√©s la direcci√≥n de retorno (la que est√° encima de saved EBP). Si un atacante controla la entrada, puede cambiar la direcci√≥n de retorno para desviar la ejecuci√≥n cuando la funci√≥n termine.

### Consecuencias
En ejecuci√≥n normal no ocurre nada extra√±o: imprime "Call ", lee la entrada y luego "Maybe...".

Con una entrada suficientemente larga, es posible corromper el saved EBP y la direcci√≥n de retorno y as√≠ redirigir la ejecuci√≥n (por ejemplo, saltar a call_me() o a otro sitio). Ese es el comportamiento t√≠pico que se estudia en ejercicios de buffer overflow.


--------------------------

# Ghidra
## An√°lisis con Ghidra

