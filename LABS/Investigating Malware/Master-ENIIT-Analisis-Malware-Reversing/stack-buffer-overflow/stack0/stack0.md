
## Código del programa
```c
#include <stdio.h>

void call_me() {
    printf("You cannot call me, noob!\n");
}

void try_to_call_me() {
    char input[120];
    printf("Call ");
    gets(input);
    printf("Maybe...\n");
}

int main(int argc, char** argv) {
    try_to_call_me();
    return 0;
}
```

donde:
- Entra a try_to_call_me().
- Muestra Call , lee una línea con gets(input) y luego imprime Maybe....
- Termina.
- La función call_me() no se llama en el flujo normal.

Lo interesante es que usa gets, que es insegura: no comprueba el tamaño del buffer (input[120]). Con una entrada suficientemente larga, se puede provocar un desbordamiento de pila y sobrescribir la dirección de retorno para desviar la ejecución hacia call_me() (o a cualquier otra parte). Este es el típico ejercicio “stack0” para demostrar cómo explotar un buffer overflow.

----------------------------------------

# Análisis con IDA 
## La función main
![ida-main](capturas/ida-main.png)

### La firma de la función main: `int __cdecl main(int argc, const char **argv, const char **envp)`:
- argc (tipo int): número de argumentos posicionales pasados al programa desde la línea de comandos. Incluye el nombre del programa.
- argv (tipo char ** o const char **): puntero a un array de cadenas C (array de char *).
    - argv[0] normalmente es el nombre (o ruta) del ejecutable.
    - argv[1] es el primer argumento, etc.
    - El array está terminado con argv[argc] == NULL.
- envp (tipo char ** o const char **): puntero a un array de cadenas que representan las variables de entorno.

### Prólogo/stack frame (cdecl, 32-bit):
``` 
push ebp
mov  ebp, esp
and  esp, 0FFFFFFF0h
```
Crea el frame de pila y alinea ESP a 16 bytes (útil para SSE/ABI de MSVC/GCC).

### IDA anota los parámetros que podrían llegar:
```
argc = [ebp+8]
argv = [ebp+0Ch]
envp = [ebp+10h]
```
Estos argumentos No se usan.

### Runtime init de GCC:
```
call __main
```
Stub del runtime (inicializa constructores estáticos, etc.).


### Lógica real del programa:
```
call _try_to_call_me
mov  eax, 0
```

Llama a try_to_call_me() y carga 0 en EAX como valor de retorno de main.


## La función try_to_call_me


### Epílogo:
```
leave
retn
```

Restaura EBP, devuelve al SO.



--------------------------

# Ghidra
## Análisis con Ghidra
![ida-fun-try_to_call_me.png]
