
## Código del programa
```c
#include <stdio.h>

void call_me() {
    printf("You cannot call me, noob!\n");
}

void try_to_call_me() {
    char input[120];
    printf("Call ");
    gets(input);
    printf("Maybe...\n");
}

int main(int argc, char** argv) {
    try_to_call_me();
    return 0;
}
```

donde:
- Entra a try_to_call_me().
- Muestra Call , lee una línea con gets(input) y luego imprime Maybe....
- Termina.
- La función call_me() no se llama en el flujo normal.

Lo interesante es que usa gets, que es insegura: no comprueba el tamaño del buffer (input[120]). Con una entrada suficientemente larga, se puede provocar un desbordamiento de pila y sobrescribir la dirección de retorno para desviar la ejecución hacia call_me() (o a cualquier otra parte). Este es el típico ejercicio “stack0” para demostrar cómo explotar un buffer overflow.

## Análisis con IDA



## Análisis con Ghidra
