
## C√≥digo del programa
```c
#include <stdio.h>

void call_me() {
    printf("You cannot call me, noob!\n");
}

void try_to_call_me() {
    char input[120];
    printf("Call ");
    gets(input);
    printf("Maybe...\n");
}

int main(int argc, char** argv) {
    try_to_call_me();
    return 0;
}
```

donde:
- Entra a try_to_call_me().
- Muestra Call , lee una l√≠nea con gets(input) y luego imprime Maybe....
- Termina.
- La funci√≥n call_me() no se llama en el flujo normal.

Lo interesante es que usa gets, que es insegura: no comprueba el tama√±o del buffer (input[120]). Con una entrada suficientemente larga, se puede provocar un desbordamiento de pila y sobrescribir la direcci√≥n de retorno para desviar la ejecuci√≥n hacia call_me() (o a cualquier otra parte). Este es el t√≠pico ejercicio ‚Äústack0‚Äù para demostrar c√≥mo explotar un buffer overflow.


----------------------------------------

# An√°lisis con IDA 
## La funci√≥n main
![ida-main](capturas/ida-main.png)

### La firma de la funci√≥n main: `int __cdecl main(int argc, const char **argv, const char **envp)`:
- argc (tipo int): n√∫mero de argumentos posicionales pasados al programa desde la l√≠nea de comandos. Incluye el nombre del programa.
- argv (tipo char ** o const char **): puntero a un array de cadenas C (array de char *).
    - argv[0] normalmente es el nombre (o ruta) del ejecutable.
    - argv[1] es el primer argumento, etc.
    - El array est√° terminado con argv[argc] == NULL.
- envp (tipo char ** o const char **): puntero a un array de cadenas que representan las variables de entorno.

### Pr√≥logo/stack frame (cdecl, 32-bit):
``` 
push ebp
mov  ebp, esp
and  esp, 0FFFFFFF0h
```
Crea el frame de pila y alinea ESP a 16 bytes (√∫til para SSE/ABI de MSVC/GCC).

### IDA anota los par√°metros que podr√≠an llegar:
```
argc = [ebp+8]
argv = [ebp+0Ch]
envp = [ebp+10h]
```
Estos argumentos No se usan.

### Runtime init de GCC:
```
call __main
```
Stub del runtime (inicializa constructores est√°ticos, etc.).


### L√≥gica real del programa:
```
call _try_to_call_me
mov  eax, 0
```

Llama a try_to_call_me() y carga 0 en EAX como valor de retorno de main.


### Ep√≠logo:
```
leave
retn
```

Restaura EBP, devuelve al SO.


## La funci√≥n try_to_call_me
![ida-fun-try_to_call_me](capturas/ida-fun-try_to_call_me.png)

```
push ebp
mov  ebp, esp
sub  esp, 98h           ; reserva espacio en la pila para variables locales
mov  dword ptr [esp], offset Format  ; "Call "
call _printf

lea  eax, [ebp-80h]     ; direcci√≥n del buffer local
mov  dword ptr [esp], eax
call _gets              ; gets(buffer)

mov  dword ptr [esp], offset aMaybe ; "Maybe..."
call _puts

leave
retn
```

### Donde
- `push ebp / mov ebp, esp` ü†Æ prologo habitual: guarda el frame anterior y marca el nuevo ebp.
- `sub esp, 98h` ü†Æ reserva 0x98 (152) bytes en la pila para variables locales / alineaci√≥n.
- `mov [esp], offset Format y call _printf` ü†Æ prepara el argumento (puntero al string "Call ") en la cima de la pila y llama a printf. El compilador usa mov [esp], ... en lugar de push (una forma de pasar argumentos cuando ya se ha hecho la reserva).
- `lea eax, [ebp-80h]` ü†Æ obtiene la direcci√≥n de la variable local que IDA llama var_80. Es decir, el buffer empieza en ebp - 0x80.
- `mov [esp], eax y call _gets` ü†Æ pasa la direcci√≥n del buffer a gets. Importante: gets no comprueba tama√±os, por eso es insegura.
- Luego prepara el string "Maybe..." y llama a puts, termina la funci√≥n.

Se usa la funci√≥n insegura `gets` para escribir por pantalla un mensaje que se almacena en la variable local `var_80`. Esta variable tiene un espacio reservado de 0x80 que son 128 bytes en decimal. ¬øPorqu√© 128 bytes si en el c√≥digo de main se han reservado s√≥lo 120? Porque el compilador ha decidido reservar 8 bytes m√°s para mantener el alineamiento de la pila a 16 bytes (0x10). Esto quiere decir que como m√≠nimo, necesitaremos escribir 128 bytes para poder comenzar a sobreescribir informaci√≥n en la pila.



### Layout de pila (conceptual)
```css
[ direcci√≥n m√°s alta ]
... (stack del llamador)
ret address  <-- [ebp + 4]
saved EBP    <-- [ebp]
local buffer (comienza en [ebp - 0x80])  <-- espacio reservado para vars
[ direcciones m√°s bajas ]
```
donde:
- El buffer comienza en ebp - 0x80 (IDA lo marca como var_80).
- La funci√≥n reserv√≥ 0x98 bytes totales; el buffer ocupa parte de ese espacio (el compilador puede a√±adir padding por alineaci√≥n).
- gets escribe datos a partir de la direcci√≥n ebp - 0x80 sin l√≠mite.


### ¬øD√≥nde est√° la vulnerabilidad?
Porque gets(buffer) puede leer m√°s bytes de los que el buffer puede almacenar y, por tanto, sobrescribir la memoria adyacente dentro del frame: primero sobreescribe el contenido del buffer, luego el saved EBP, y despu√©s la direcci√≥n de retorno (la que est√° encima de saved EBP). Si un atacante controla la entrada, puede cambiar la direcci√≥n de retorno para desviar la ejecuci√≥n cuando la funci√≥n termine.

### Consecuencias
En ejecuci√≥n normal no ocurre nada extra√±o: imprime "Call ", lee la entrada y luego "Maybe...".

Con una entrada suficientemente larga, es posible corromper el saved EBP y la direcci√≥n de retorno y as√≠ redirigir la ejecuci√≥n (por ejemplo, saltar a call_me() o a otro sitio). Ese es el comportamiento t√≠pico que se estudia en ejercicios de buffer overflow.


### Diagrama con offsets. Direcci√≥n inicial del buffer ([ebp - 0x80]) que muestra IDA.
```
Alto (direcciones mayores)
+---------------------------+  <-- (ebp + 8) ...
|  (argumentos del llamador)|
+---------------------------+
| return address  ‚Üê ebp+4   |  ‚Üê offset desde buffer_start = 0x84 (132)
+---------------------------+
| saved EBP       ‚Üê ebp     |  ‚Üê offset desde buffer_start = 0x80 (128)
+---------------------------+
|  (padding / otros)        |
|  ...                      |
|  buffer (input) starts ‚Üí  |  ‚Üê ebp - 0x80   (offset 0x00)
|  [ebp - 0x80] (byte 0)    |
|  [ebp - 0x7F] (byte 1)    |
|      ...                  |
|  [ebp - 0x01] (byte 0x7F) |
+---------------------------+  <-- (direcciones m√°s bajas)
Bajo (direcciones menores)
```
donde:
- Direcci√≥n base del buffer (LEA): ebp - 0x80 ‚Üí offset 0x00 desde el comienzo del buffer.
- Saved EBP (saved frame pointer) est√° en ebp ‚Üí offset 0x80 (hex) = 128 (dec) bytes desde el inicio del buffer.
- Return address est√° en ebp + 4 ‚Üí offset 0x84 (hex) = 132 (dec) bytes desde el inicio del buffer.

Para sobrescribir por completo los 4 bytes de la direcci√≥n de retorno necesitamos que la entrada escrita alcance hasta offset 0x84..0x87. Eso significa que el tama√±o total m√≠nimo de entrada para sobreescribir completamente la return address es:
- 0x84 (bytes hasta el inicio de la return addr) + 4 (bytes de la return addr) = 0x88 (hex) = 136 (dec) bytes.

En pr√°ctica de explotaci√≥n t√≠pica se usan:
- padding = 128 bytes ‚Üí relleno para alcanzar saved EBP
- 4 bytes ‚Üí sobrescriben saved EBP (pueden ser basura o un valor controlado)
- 4 bytes ‚Üí sobrescriben return address (valor que se quiere poner)


--------------------------

# Ghidra
## An√°lisis con Ghidra

