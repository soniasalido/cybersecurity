
# Análisis del código del binario
```c
#include <stdio.h>
#include <string.h>

void call_me() {
	printf("You cannot call me, noob!\n");
}

void parse_file(char* filename){
	char url[16];
	char buffer[512];

	printf("Abriendo fichero %s ...\n", filename);

	FILE *f = fopen(filename, "r");
	if(f == NULL){
		printf("Fallo al abrir el fichero :(\n");
		return;
	}
	printf("Leyendo fichero %s ...\n", filename);

	fread(buffer, 1, 256, f);
	printf("Fichero leido! Contenido: \n");
	//printf(buffer);

	printf("\nBuscando URL en el fichero..\n");

	char* url_start = strstr(buffer, "http://");
	if(url_start == NULL){
		printf("URL no encontrada :(\n");
		return;
	}

	memcpy(url, url_start, 512);

	printf("URL: %s\n", url);

	fclose(f);
	return;
}

int main(int argc, char** argv) {
	if(argc != 2){
		printf("Uso: %s <fichero>\n", argv[0]);
		return -1;
	}

	parse_file(argv[1]);
	return 0;
}
```

Este binario amplia el binario [stack1](https://github.com/soniasalido/cybersecurity/blob/main/LABS/Investigating%20Malware/Master-ENIIT-Analisis-Malware-Reversing/stack-buffer-overflow/stack1/stack1.md). Lee el fichero que se pasa como parámetro y busca en el contenido la subcadena `"http://"`. 
- Si no la encuentra: muestra en pantalla: `URL no encontrada :(` y vuelve.
- Si la encuentra, hace:
  ```c
  memcpy(url, url_start, 512);
  printf("URL: %s\n", url);
  ```
  - Copia desde donde empieza "http://" hasta 512 bytes (esto está mal, porque url solo tiene 16 bytes) y,
  - luego intenta imprimirlo como cadena.

El programa lee los primeros 256 bytes de un fichero, busca dentro de ellos una cadena que empiece por "http://", y si la encuentra intenta copiarla a url y mostrarla por pantalla (aunque lo hace de forma insegura y con desbordamiento de buffer).

## Problemas de seguridad
### 1. buffer no está terminado en '\0'
```c
char buffer[512];
...
fread(buffer, 1, 256, f);
...
char* url_start = strstr(buffer, "http://");
```
donde:
- fread lee hasta 256 bytes sin añadir '\0'.
- strstr espera una cadena C terminada en '\0'.
- Como buffer no está terminado, strstr puede leer más allá de esos 256 bytes (memoria basura) → comportamiento indefinido.

### 2. Desbordamiento de `url`
```c
char url[16];
...
memcpy(url, url_start, 512);
```
donde:
- `url` tiene tamaño 16 bytes.
- Estamos copiando 512 bytes desde `url_start` a `url`.
- Es un stack-based buffer overflow de manual: pisamos todo lo que haya después de url en la pila (variables locales, puntero de retorno, etc.).

Además:
- No se añade '\0' a url, así que luego:
```c
printf("URL: %s\n", url);
```
donde:
- espera que `url` esté terminada en '\0', y volverá a leer memoria fuera del buffer.

### 3. Posible format string (aunque está comentado)
```c
//printf(buffer);
```
donde:
- Si esto se descomenta, tendremos una format string vulnerability:
	- `printf` interpreta el contenido de buffer como formato, no como texto plano.
	- Si el fichero contiene cosas como `%x`, `%n`, etc., podemos leer/escribir memoria.

 ### 4. Fugas de recurso (fichero sin cerrar)
Si no se encuentra la URL:
```c
if(url_start == NULL){
    printf("URL no encontrada :(\n");
    return;
}
```
donde:
- Ese return sale de la función sin hacer `fclose(f)`, así que el fichero queda abierto.


# Primera ejecución del binario

```python
import struct

CALL_ME = 0x00401530

p = bytearray(b'http://')
p += b'A' * 600
p += struct.pack("<I", 0)
p += struct.pack("<I", 0)
p += struct.pack("<I", 0)
p += struct.pack("<I", 0x42424242)
p += struct.pack("<I", CALL_ME)

with open("exp.txt", "wb") as f:
    f.write(p)
```
![stack2-encuentra-cadena](capturas/stack2-encuentra-cadena.png)
donde:
- El EIP está en 00401620 que x32dbg rotula como: `<JMP.&memcpy>`. En ensamblador estamos viendo el momento exacto en que va a ocurrir eso:
  ```c
  memcpy va a copiar 256 bytes (0x100)
  ```
- Pero el buffer de destino `(url)` solo tiene 16 bytes.


**Resultado:**
- memcpy empieza a escribir las A en url
- sigue escribiendo más allá: pisa otras variables locales, el EBP guardado y, si sigues, el ret de la función (dirección de retorno).
- eso es el stack-based buffer overflow que estamos intentando observar.

![stack2-encuentra-cadena](capturas/stack2-encuentra-cadena-2.png)
donde:
- EAX = 0022FE88
- [ebp-20] (la variable local url) es la dirección 0x0022FE88.
- En esa dirección el contenido es 0x70747468 = "http" en little endian.
  ![stack2-encuentra-cadena](capturas/stack2-encuentra-cadena-3.png)

**Conclusión:**
- memcpy ya ha copiado la cadena que empezaba en `url_start ("http://AAAAAA...")` encima del `buffer url`.


![stack2-encuentra-cadena](capturas/stack2-encuentra-cadena-4.png)



![stack2-encuentra-cadena](capturas/stack2-encuentra-cadena-5.png)



![stack2-encuentra-cadena](capturas/stack2-encuentra-cadena-6.png)



![stack2-encuentra-cadena](capturas/stack2-encuentra-cadena-7.png)
donde:
- EIP = 0040163E → estamos en el `call <JMP.&fclose>`.
- En el panel de registros: `EAX = 41414141`.
- En el Default (stdcall): `[esp] = 41414141` → es decir, el argumento que se va a pasar a `fclose` es `0x41414141`.
- Eso significa que nuestro overflow:
	- Ha sobrescrito la variable local `f` (el FILE * devuelto por fopen),
	- de manera que cuando el código hace `fclose(f)`, en realidad está haciendo: `fclose((FILE*)0x41414141);` Es un puntero totalmente inválido → cuando entremos en msvcrt!fclose, en cuanto intente dereferenciar ese puntero, lo normal es que se produzca una violación de acceso y el programa se estrelle antes incluso de hacer el `ret` de `parse_file`.
