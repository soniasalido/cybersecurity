
# Analisis punto 0040160B
![stack2-00401613](capturas/stack2-00401613.png)
```c
00401608  C74424 08 00010000   mov dword ptr ss:[esp+8], 100h	; 0x100 = 256 - Esto tercer argumento de memcpy ‚Üí el tama√±o - Escribe el valor 0x100 (256d) en [esp+8]

```

Ese bloque es la preparaci√≥n de la llamada a memcpy que viene de:
```c
memcpy(url, url_start, 512);   // el compilador la ha dejado en 256 (0x100)
```


**<mark>En el v√≠deo de tutor√≠a, aparece un cambio en este punto:</mark>**
```c
00401608  C74424 08 00010000   mov dword ptr ss:[esp+8], 200h
```
![stack2-00401613-video-clase](capturas/stack2-00401613-video-clase.png)

**<mark>Este detalle ¬øcambia significativamente la explotacion? Si no de edita manualmente ese valor y se cambia por 200, no se puede explotar la vulnerabilidad.</mark>**
![stack2-00401613-edicion-manual](capturas/stack2-00401613-edicion-manual.png)

En mi binario copia 256 bytes:
```c
mov [esp+8], 100h   ; 256 bytes
```

En el binario del v√≠deo copia 512 bytes:
```c
mov [esp+8], 200h   ; 512 bytes
```

En este ejercicio se hace una explotaci√≥n basada en SEH (Structured Exception Handler), es decir, manipulando la cadena de manejadores de excepciones que Windows almacena en la pila. La posici√≥n del SEH en la pila es fija para ese binario.
Pero el desbordamiento tiene que alcanzar esa posici√≥n para afectarlo.

**Conceptualmente podr√≠amos ver la explotaci√≥n de este binario:** Un binario Windows 32-bit organiza la pila as√≠:
```
+------------------+
| Variables locales |
+------------------+
| Saved EBP         |
+------------------+
| SEH Frame:        |
|   nSEH            |
|   SEH             |
+------------------+
| m√°s cosas...      |
```
donde:
- url est√° al principio de la zona local: 16 bytes.
- Luego variables intermedias.
- Luego EBP.
- Luego la estructura SEH.

En el v√≠deo de la tutor√≠a: `distancia(url ‚Üí SEH) ‚âà 400 bytes`  
‚Üí Necesita 512 bytes para alcanzarlo.  
‚Üí Con 256 no llega.  

En mi binario con `mov [esp+8], 100h`:
- First chance exception on 6FF63D9D (C0000005, EXCEPTION_ACCESS_VIOLATION) y a la derecha: ESI = 41414141 --> el overflow ha sobreescrito registros y memoria, pero‚Ä¶
	- üí• **NO ha sobreescrito SEH.**
	- üí• La cadena SEH sigue intacta (En el panel SEH: ‚ÄúEnd of SEH chain‚Äù).
	- La excepci√≥n ocurre dentro de msvcrt.dll (fclose, printf‚Ä¶), pero Windows no est√° llamando al ‚ÄúSEH modificado‚Äù porque NO est√° modificado.
 	- Resultado: **No podemos explotar el SEH.**
![stack2-00401613-mi-binario](capturas/stack2-00401613-mi-binario-100.png)
![stack2-00401613-mi-binario](capturas/stack2-00401613-mi-binario-100-2.png)



En el binario con mov `[esp+8], 200h`:
- S√ç SE SOBREESCRIBE EL SEH.
- El overflow s√≠ alcanza el registro SEH y lo corrompe.
- Resultado: Se puede hacer explotaci√≥n SEH tal como muestra el profesor en el v√≠deo de la tutor√≠a.
![stack2-00401613-mi-binario-dato-200](capturas/stack2-00401613-mi-binario-dato-200.png)
![stack2-00401613-mi-binario-dato-200](capturas/stack2-00401613-mi-binario-dato-200-1.png)
![stack2-00401613-mi-binario-dato-200](capturas/stack2-00401613-mi-binario-dato-200-2.png)

