
# Buffer-Overflow-2
```
#include <stdlib.h>
#include <stdio.h>

void special(void)
{
    printf("this is the special function\n");
    printf("you did this, friend!\n");
}

void normal(void)
{
    printf("this is the normal function\n");
}

void other(void)
{
    printf("why is this here?\n");
}

int main(int argc, char **argv)
{
    volatile void (*new_ptr)(void) = normal;  // <- firma correcta
    char buffer[14];
    gets(buffer);
    new_ptr();
    return 0;
}

```
donde:
- `volatile`: Indica al compilador que no optimice la variable `new_ptr`, asegurando que el desbordamiento funcione como se espera en entornos educativos. Este programa es un ejemplo clásico de una vulnerabilidad de desbordamiento de búfer (buffer overflow). Está diseñado para demostrar cómo un atacante puede alterar el flujo de ejecución de un programa para ejecutar código que, en teoría, no debería ejecutarse.

## Explicación paso a paso lo que sucede
**- El flujo esperado:**
- En condiciones normales, el programa hace lo siguiente:
- Declara un puntero a una función llamado new_ptr y lo apunta a la función normal.
- Reserva un espacio en memoria (un array) llamado buffer con capacidad para 14 caracteres.
- Usa la función gets(buffer) para recibir una entrada del usuario.
- Llama a la función a la que apunta new_ptr (que debería ser normal).

**- El fallo de seguridad:** gets(): El problema crítico es el uso de la función gets(). Esta función es extremadamente peligrosa porque no verifica cuántos datos introduce el usuario. Si escribimos más de 14 caracteres, gets() seguirá escribiendo en la memoria, invadiendo el espacio de otras variables.

**- ¿Qué haría un atacante?**
    - Si un usuario conoce la dirección de memoria de la función special(), puede enviar una cadena de texto larga que termine con esa dirección específica.
    - El programa llena el buffer.
    - El exceso de datos cambia el valor de new_ptr de normal a special.
    - Al final, el programa ejecuta new_ptr(), pero en lugar de imprimir "this is the normal function", ejecutará special() y dirá: "you did this, friend!".


![tryhackme-stack-overflow-2-main-1](capturas/tryhackme-stack-overflow-2-main-1.png)


# Buffer-Overflow-3
```
#include <stdio.h>
#include <stdlib.h>

void copy_arg(char *string)
{
    char buffer[140];
    strcpy(buffer, string);
    printf("%s\n", buffer);
    return 0;
}

int main(int argc, char **argv)
{
    printf("Here's a program that echo's out your input\n");
    copy_arg(argv[1]);
}
```

# Buffer-Overflow-4
```
#include <stdio.h>
#include <stdlib.h>

void copy_arg(char *string)
{
    char buffer[140];
    strcpy(buffer, string);
    printf("%s\n", buffer);
    return 0;
}

int main(int argc, char **argv)
{
    printf("Here's a program that echo's out your input\n");
    copy_arg(argv[1]);
}
```

