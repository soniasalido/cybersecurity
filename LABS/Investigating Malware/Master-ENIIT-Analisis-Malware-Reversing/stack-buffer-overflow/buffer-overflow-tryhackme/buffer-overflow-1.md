# Buffer-Overflow-1
```
#include <stdlib.h>
#include <unistd.h>
#include <stdio.h>

int main(int argc, char **argv)
{
    volatile int variable = 0;
    char buffer[14];

    gets(buffer);

    if(variable != 0) {
        printf("You have changed the value of the variable\n");
    } else {
        printf("Try again?\n");
    }
}
```
El desbordamiento se produce en la llamada a `gets(buffer)`; cuando se introducen más de 14 caracteres, porque buffer solo reserva 14 bytes en la pila y gets no hace comprobación de tamaño, escribiendo por encima del límite del array y sobreescribiendo datos adyacentes en el stack (incluido variable o metadatos del frame).


# Buffer-Overflow-2
```
#include <stdlib.h>
#include <unistd.h>
#include <stdio.h>

void special()
{
    printf("this is the special function\n");
    printf("you did this, friend!\n");
}

void normal()
{
    printf("this is the normal function\n");
}

void other()
{
    printf("why is this here?\n");
}

int main(int argc, char **argv)
{
    volatile int (*new_ptr)() = normal;
    char buffer[14];
    gets(buffer);
    new_ptr();
}
```

# Buffer-Overflow-3
```
#include <stdio.h>
#include <stdlib.h>

void copy_arg(char *string)
{
    char buffer[140];
    strcpy(buffer, string);
    printf("%s\n", buffer);
    return 0;
}

int main(int argc, char **argv)
{
    printf("Here's a program that echo's out your input\n");
    copy_arg(argv[1]);
}
```

# Buffer-Overflow-4
```
#include <stdio.h>
#include <stdlib.h>

void copy_arg(char *string)
{
    char buffer[140];
    strcpy(buffer, string);
    printf("%s\n", buffer);
    return 0;
}

int main(int argc, char **argv)
{
    printf("Here's a program that echo's out your input\n");
    copy_arg(argv[1]);
}
```
