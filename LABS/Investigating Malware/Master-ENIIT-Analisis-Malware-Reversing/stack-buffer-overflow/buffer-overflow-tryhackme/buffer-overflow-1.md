# Buffer-Overflow-1
```
#include <stdlib.h>
#include <unistd.h>
#include <stdio.h>

int main(int argc, char **argv)
{
    volatile int variable = 0;
    char buffer[14];

    gets(buffer);

    if(variable != 0) {
        printf("You have changed the value of the variable\n");
    } else {
        printf("Try again?\n");
    }
}
```
El desbordamiento se produce en la llamada a `gets(buffer)`; cuando se introducen más de 14 caracteres, porque buffer solo reserva 14 bytes en la pila y gets no hace comprobación de tamaño, escribiendo por encima del límite del array y sobreescribiendo datos adyacentes en el stack (incluido variable o metadatos del frame).

Se compila: `gcc -g -O0 -Wno-implicit-function-declaration programa.c -o programa`. 


El programa es un ejemplo clásico para practicar buffer overflow y cambiar el valor de una variable en la pila.

**Flujo general:**
- Declara una variable entera variable inicializada a 0 y un buffer de 14 bytes en el stack: `char buffer[14];`.
- Lee una línea de entrada con `gets(buffer);`, copiando lo que se escriba en stdin dentro de buffer sin comprobar el tamaño.
- Comprueba si variable sigue valiendo 0. Si conseguimos que cambie, entonces mostrará un mensaje distinto.

**Detalle paso a paso**
- `volatile int variable = 0;`: Variable se guarda en la pila y se marca como volatile para evitar que el compilador la optimice, garantizando que realmente exista en memoria y pueda ser sobreescrita por el overflow.
- `char buffer[14];`: Reserva 14 bytes contiguos en el stack, justo al lado de variable (dependiendo del compilador/ABI), lo que permite que un desbordamiento de buffer sobrescriba variable.
- `gets(buffer);`: Lee caracteres desde la entrada estándar hasta que encuentre un \n o EOF y los escribe en buffer, sin límite de longitud.
- Si introducimos más de 14 caracteres, se escribirá fuera de los límites del array, corrompiendo memoria adyacente en la pila, típicamente incluyendo variable.
- `if(variable != 0) { ... } else { ... }`


Si el exploit de overflow ha conseguido que variable deje de ser 0 (por ejemplo, escribiendo suficientes bytes con un patrón adecuado), se imprime: `You have changed the value of the variable.`

Si no, se imprime:
Try again?.


# Buffer-Overflow-2
```
#include <stdlib.h>
#include <unistd.h>
#include <stdio.h>

void special()
{
    printf("this is the special function\n");
    printf("you did this, friend!\n");
}

void normal()
{
    printf("this is the normal function\n");
}

void other()
{
    printf("why is this here?\n");
}

int main(int argc, char **argv)
{
    volatile int (*new_ptr)() = normal;
    char buffer[14];
    gets(buffer);
    new_ptr();
}
```

# Buffer-Overflow-3
```
#include <stdio.h>
#include <stdlib.h>

void copy_arg(char *string)
{
    char buffer[140];
    strcpy(buffer, string);
    printf("%s\n", buffer);
    return 0;
}

int main(int argc, char **argv)
{
    printf("Here's a program that echo's out your input\n");
    copy_arg(argv[1]);
}
```

# Buffer-Overflow-4
```
#include <stdio.h>
#include <stdlib.h>

void copy_arg(char *string)
{
    char buffer[140];
    strcpy(buffer, string);
    printf("%s\n", buffer);
    return 0;
}

int main(int argc, char **argv)
{
    printf("Here's a program that echo's out your input\n");
    copy_arg(argv[1]);
}
```
