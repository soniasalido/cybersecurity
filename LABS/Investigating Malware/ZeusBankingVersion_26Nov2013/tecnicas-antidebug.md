
# T√©cnicas anti debug


## 0. GetTickCount

```
                             **************************************************************
                             *                          FUNCTION                          *
                             **************************************************************
                             int __cdecl entry(undefined4 param_1, undefined4 param_2
                               assume FS_OFFSET = 0xffdff000
             int               EAX:4          <RETURN>
             undefined4        Stack[0x4]:4   param_1                                 XREF[2]:     0040a9ef(R), 
                                                                                                   0040b169(R)  
             undefined4        Stack[0x8]:4   param_2                                 XREF[2]:     0040a9f7(R), 
                                                                                                   0040b166(R)  
             byte *            Stack[0xc]:4   param_3                                 XREF[1]:     0040b16c(R)  
             undefined4        Stack[-0x40]:4 local_40                                XREF[2]:     0040a4b0(W), 
                                                                                                   0040a4b4(R)  
             undefined4        Stack[-0x5c]:4 local_5c                                XREF[1]:     0040a445(W)  
             undefined4        Stack[-0x7c]:4 local_7c                                XREF[3]:     0040a44e(W), 
                                                                                                   0040a4a2(RW), 
                                                                                                   0040a4b8(R)  
             undefined2        Stack[-0x80]:2 local_80                                XREF[1]:     0040a430(W)  
             undefined4        Stack[-0x84]:4 local_84                                XREF[2]:     0040a46a(W), 
                                                                                                   0040a46e(R)  
                             entry                                           XREF[2]:     Entry Point(*), 00400100(*)  
        0040a3b6 55              PUSH       EBP
        0040a3b7 8b ec           MOV        EBP,ESP
        0040a3b9 83 e4 f8        AND        ESP,0xfffffff8
        0040a3bc 83 ec 7c        SUB        ESP,0x7c
        0040a3bf a1 94 fc        MOV        EAX,[DAT_0040fc94]                               = 00006A95h
                 40 00
.....
.....
                 00 00
        0040a445 89 44 24 34     MOV        dword ptr [ESP + local_5c],EAX
        0040a449 a1 e8 00        MOV        EAX,[->USER32.DLL::GetSysColor]                  = 000206f8
                 42 00
        0040a44e 89 44 24 14     MOV        dword ptr [ESP + local_7c],EAX
        0040a452 a1 ac fc        MOV        EAX,[DAT_0040fcac]                               = 0000006Ah
                 40 00
        0040a457 8b 0d a8        MOV        ECX,dword ptr [DAT_0040fca8]                     = 00007119h
                 fc 40 00
        0040a45d 05 ca 00        ADD        EAX,0xca
                 00 00
        0040a462 c1 e8 04        SHR        EAX,0x4
        0040a465 23 c8           AND        ECX,EAX
        0040a467 83 e9 10        SUB        ECX,0x10
        0040a46a 89 4c 24 0c     MOV        dword ptr [ESP + local_84],ECX
        0040a46e 8b 44 24 0c     MOV        EAX,dword ptr [ESP + local_84]
        0040a472 8b 0c 85        MOV        ECX,dword ptr [EAX*0x4 + 0x40fcb0]=>DAT_0040fcb4 = 00001616h
                 b0 fc 40 00
        0040a479 33 d2           XOR        EDX,EDX
        0040a47b b8 29 6b        MOV        EAX,0x6b29
                 00 00
        0040a480 f7 f1           DIV        ECX
        0040a482 8a 0d a4        MOV        CL,byte ptr [DAT_0040fca4]                       = 0Ah
                 fc 40 00
        0040a488 a1 c0 fc        MOV        EAX,[DAT_0040fcc0]                               = 00002A1Ah
                 40 00
        0040a48d 35 00 4f        XOR        EAX,0x4f00
                 00 00
        0040a492 05 02 c5        ADD        EAX,0xffffc502
                 ff ff
        0040a497 d3 ea           SHR        EDX,CL
        0040a499 8b 0d bc        MOV        ECX,dword ptr [DAT_0040fcbc]                     = 0000030Eh
                 fc 40 00
        0040a49f 83 f2 04        XOR        EDX,0x4
        0040a4a2 01 54 24 14     ADD        dword ptr [ESP + local_7c],EDX
        0040a4a6 33 d2           XOR        EDX,EDX
        0040a4a8 f7 f1           DIV        ECX
        0040a4aa 81 c2 85        ADD        EDX,0x2915cc85
                 cc 15 29
        0040a4b0 89 54 24 50     MOV        dword ptr [ESP + local_40],EDX
        0040a4b4 ff 74 24 50     PUSH       dword ptr [ESP + local_40]
        0040a4b8 8b 44 24 18     MOV        EAX,dword ptr [ESP + local_7c]
        0040a4bc ff d0           CALL       EAX
        0040a4be be 00 00        MOV        ESI,0x80000
                 08 00
                             LAB_0040a4c3                                    XREF[1]:     0040a4ca(j)  
        0040a4c3 ff 15 4c        CALL       dword ptr [->KERNEL32.DLL::GetTickCount]         = 000204d4
                 00 42 00
        0040a4c9 4e              DEC        ESI
        0040a4ca 75 f7           JNZ        LAB_0040a4c3
        0040a4cc f6 05 98        TEST       byte ptr [DAT_00410b98],0x1
                 0b 41 00 01
        0040a4d3 75 11           JNZ        LAB_0040a4e6
        0040a4d5 a1 38 01        MOV        EAX,[->USER32.DLL::AllowSetForegroundWindow]     = 000206c0
                 42 00
        0040a4da 83 0d 98        OR         dword ptr [DAT_00410b98],0x1
                 0b 41 00 01
        0040a4e1 a3 3c 07        MOV        [DAT_0041073c],EAX
                 41 00
```

1) 0040a449 --> en GetSysColor: Eso es call-target obfuscation: parte de una API v√°lida y le suma un delta para acabar llamando a ‚Äúalgo‚Äù (a veces un thunk propio, a veces otra funci√≥n dentro de la misma DLL si el delta cuadra). Forensemente, esto se trata como resoluci√≥n din√°mica/indirect call, muy com√∫n en loaders.

Ojo: ese CALL EAX tras modificar el puntero ‚ÄúGetSysColor + delta‚Äù es sospechoso de ser anti-analysis (romper heur√≠sticas) o simplemente una forma de saltar a un thunk propio reubicado.


Call EAX llama a 7674D750 --> la dll GetsSysColor




2) 0040a4c3 --> GetTickCount: 

En 0040A4BE --> Inicializa ESI = 0x80000 (~524.288 iteraciones).

En cada iteraci√≥n llama a GetTickCount y tira el resultado (no lo guarda, no lo compara).

Decrementa contador y repite.

Interpretaci√≥n forense (lo importante)

Esto NO es el timing-check cl√°sico (el de ‚Äúmido delta y si es grande hay debugger‚Äù).
Aqu√≠ no hay comparaci√≥n ni umbral. Por tanto, lo m√°s probable es:

A) Delay activo / anti-sandbox por consumo de tiempo

Introduce una demora real sin usar Sleep (que muchas sandboxes aceleran o ‚Äúhookean‚Äù f√°cil).

Llamar a una API del sistema cientos de miles de veces fuerza cambios de contexto y overhead del kernel/user.



## 1. Sentinel global 0xFFF7ABFE como ‚Äúflag de estado‚Äù (gating de ramas)

Usa una constante sentinela y comparaciones:
- En FUN_00407436
    - 004075D2‚Äì004075F3
        - MOV EAX, [DAT_0040E5A8]
        - CMP EAX, 0xFFF7ABFE
        - Si igual: carga puntero v√≠a PTR_PTR_0040D008 y lo copia a DAT_0040E590
        - Si distinto: fuerza DAT_0040E590 = 0

Por qu√© es relevante anti-analysis: ese sentinela est√° actuando como interruptor de ‚Äúmodo v√°lido‚Äù. Si algo cambia ese valor (por inicializaci√≥n distinta, ejecuci√≥n bajo ciertas condiciones, o por manipulaci√≥n), el flujo entra por la ruta que invalida DAT_0040E590 y luego aparecen cortes tempranos m√°s adelante.


## 2 ‚ÄúKill-switch‚Äù temprano por valor cr√≠tico (cierre/abort)

En FUN_00407436:
    - 00407806‚Äì00407810
        - CMP [DAT_0040E590], 0
        - JZ LAB_00407EE5 (salta a una ruta alternativa ‚Äúcorta‚Äù)

Lectura forense: DAT_0040E590 es una especie de ‚Äúhandle/ptr v√°lido‚Äù que, si no est√° inicializado correctamente, manda a una rama distinta. Este tipo de gate se usa mucho para:
    - abortar l√≥gica sensible si algo no cuadra,
    - impedir avanzar si el entorno no es el esperado,
    - o separar ‚Äúruta normal‚Äù vs ‚Äúruta anti-analysis‚Äù.


## 3 Auto-modificaci√≥n / parcheo en memoria como fase protegida (mencionaste FUN_0040142F)

Hemos intentando ‚Äúver el dump‚Äù en 0x0040142F pero ‚Äúse borra antes‚Äù. Eso encaja con dos patrones anti-analysis cl√°sicos:
- Self-modifying code (descifra/parchea un stub en memoria, lo usa y luego lo pisa/borra).
- Ventana de tiempo estrecha (solo es visible durante unos pocos cientos de instrucciones).

Aunque no tengamoss el byte-dump, el hecho operacional ya lo tenemos:
- hay una fase de ‚Äúparcheo/uso/limpieza‚Äù que dificulta inspeccionar est√°ticamente.
- Esto es anti-analysis, aunque no sea ‚Äúanti-debug check‚Äù tipo IsDebuggerPresent.


## 4 Resoluci√≥n din√°mica de APIs/funciones (anti-IAT + anti-breakpoints)

En FUN_00407436 y en el bloque de LAB_00408C63, aparece repetidamente:
- punteros a APIs guardados en globals (ej. DAT_004106cc, DAT_004106d0, DAT_004106d4, DAT_004106d8, DAT_004106dc, DAT_004106e0, etc.)
- llamadas indirectas tipo:
    - MOV EAX, [DAT_004106FC]
    - CALL EAX

Por qu√© es anti-analysis: no es ‚Äúdetectar debugger‚Äù directamente, pero s√≠:
- evita que veamos un import table limpio,
- hace m√°s dif√≠cil poner breakpoints en KERNEL32!X porque no hay call directo,
- permite cambiar de destino din√°micamente (incluso hacia stubs internos),
- y complica el tracing lineal.


## 5. Rama ‚Äúcaminar el PE‚Äù (parseo manual) usada como ruta alternativa (potencial anti-debug)

Cuando se toma la rama que empieza a leer:
- base = ...
- e_lfanew = [base + 0x3C]
- campos del NT Header / Optional Header

Ese patr√≥n es PE parsing manual. En malware se usa mucho para:
- localizar directorios sin llamar a APIs,
- inspeccionar IMAGE_DIRECTORY_ENTRY_DEBUG (debug directory),
- inspeccionar imports/exports,
- validar que la imagen ‚Äúes la esperada‚Äù (anti-tamper),
- o derivar offsets para stubs protegidos.

Importante: PE parsing no es autom√°ticamente anti-debug, pero en este caso est√° claramente en una rama de control (cuando el ‚Äúsentinela‚Äù no cuadra / o el flujo decide ir por ruta alternativa). Eso la vuelve sospechosa como l√≥gica de ‚Äúsi no est√°s en condiciones normales, ve por ruta X‚Äù.



Esta rama hace PE-walking al principio ([base+0x3C], etc.).
- Si base (00792274) no es un PE v√°lido o ni siquiera es memoria legible, ese read rompe con AV.
- En muchas familias eso se usa como control flow basado en excepci√≥n (SEH): bajo ejecuci√≥n normal lo absorbe un handler y contin√∫a; en debugger, si paras en first-chance, parece ‚Äúcrash‚Äù.

No te digo ‚Äúc√≥mo‚Äù configurarlo ni c√≥mo ‚Äúsaltarlo‚Äù, pero forensemente: es muy plausible que NO sea un crash ‚Äúreal‚Äù, sino un nodo de flujo intencional.

![alt text](capturas/parseo.png)





## 6. Anti-debug basado en excepciones (SEH / KiUserExceptionDispatcher)

Esto es de lo m√°s claro por las capturas:
- Llegas a un punto (00408E39) y al seguir con F9 te da excepci√≥n que te corta la ejecuci√≥n.
- Por qu√© una lectura del tipo:
  ```
  mov eax, dword ptr [ecx+3C] con ECX=00400000
  acabar√≠a en KiUserException...
  ```

Aunque en teor√≠a [0x00400000+0x3C] deber√≠a ser legible si la imagen est√° mapeada normalmente, en muestras protegidas esto se usa de dos maneras:
- ‚ÄúException-as-signal‚Äù: provocan un acceso inv√°lido solo bajo ciertas condiciones (p.ej. ECX no es realmente 00400000 en el momento efectivo, o el page mapping no es el ‚Äúnormal‚Äù, o hay trampas de guard page).
- SEH control-flow: el programa espera la excepci√≥n y la maneja para seguir; pero el debugger, dependiendo de configuraci√≥n (‚Äúbreak on first chance‚Äù), interrumpe antes de que el handler la consuma, y el usuario cree que ‚Äúse cae‚Äù.

Esto s√≠ es anti-debug muy t√≠pico: ‚Äúsi est√°s debuggeando, te freno con excepciones‚Äù.


## 7. Comparaciones/ramas con ‚Äúchecks opacos‚Äù (valores calculados + saltos)

Ejemplos visibles:
- bucles tipo:
    - CMP ...
    - JBE / JA / JNZ hacia un loop (p.ej. 004074FD vuelve a 004074AD, o 00408331 vuelve a 00408289)

Estos bucles con constantes y tablas suelen ser:
- opaque predicates (condiciones dif√≠ciles de simplificar),
- delay loops / ‚Äúnoise‚Äù,
- o gating para que el flujo ‚Äúbueno‚Äù ocurra solo si ciertos estados internos cuadran.

De nuevo: no es un ‚ÄúIsDebuggerPresent‚Äù, pero es anti-an√°lisis porque complica el reasoning y el stepping.


## 8 FUN_004012DF: validaci√≥n de imagen / sanity check (m√°s anti-tamper que anti-debug)

FUN_004012DF(param_1) hace:
- chequeo del primer byte: `AL = [param_1] ; AL += 0x32 ; AL ^= 0xBE ; CMP AL, 0xC1`
    - Si falla ‚Üí ruta alternativa (LAB_0040140D)

- calcula `ECX = param_1 + [param_1+0x3C]` (otra vez e_lfanew)
- compara un dword en `[ECX+0x54]` contra un valor derivado de constantes.

Eso parece validaci√≥n del PE (o de un buffer con estructura similar a PE) + gating. Es √∫til para anti-analysis porque:
- si el ‚Äúobjeto PE‚Äù no es el esperado (por dumping parcial, reconstrucci√≥n incompleta, o manipulaci√≥n), no deja avanzar por la ruta ‚Äúnormal‚Äù.

No se puede afirmar que sea anti-debug directo, pero s√≠ anti-tamper/anti-dump.


-----


# Mapa de flujo: ‚Äúruta normal‚Äù vs ‚Äúruta alternativa (PE-walk / excepci√≥n)‚Äù

## A) FUN_00407436 (00407436) ‚Äî gate de sentinela y bifurcaci√≥n temprana
### A1) Inicializaci√≥n + gate de DAT_0040E590

#### 1. 004075D2‚Äì004075F3
- Lee DAT_0040E5A8 y compara con 0xFFF7ABFE.
- Si igual: escribe un puntero/valor en DAT_0040E590.
- Si distinto: pone DAT_0040E590 = 0.

#### 2. 00407806‚Äì00407810
- CMP [DAT_0040E590], 0
- Si 0 ‚Üí salta a LAB_00407EE5 (ruta ‚Äúcorta/alternativa‚Äù dentro de la funci√≥n).
- Si no es 0 ‚Üí contin√∫a la ruta ‚Äúcentral‚Äù (la larga).


üìå Interpretaci√≥n forense: aqu√≠ DAT_0040E590 act√∫a como ‚Äúflag/handle v√°lido‚Äù. Si no est√° bien, FUN_00407436 se va a una ruta distinta antes de ejecutar parte de la l√≥gica ‚Äúsensible‚Äù.


## En el bloque alrededor de 00408C38‚Äì00409220 ‚Äî el gran ‚Äúsplit‚Äù por sentinela en ctx+0x1D4
### B1) Gate clave (check de sentinela)

En 00408C38:
- Condici√≥n: `dword ptr [ctx + 0x1D4] == 0xFFF7ABFE`.
- Si NO es igual (JNZ) ‚Üí salta a LAB_00408E31 (ruta alternativa).
- Si S√ç es igual ‚Üí sigue por la ruta ‚Äúcentral‚Äù (ruta normal).

Esto separa:
- Ruta 1 --> (normal / ‚Äúcentral‚Äù): la que suele llevar a la parte √∫til (incluido parcheo/descifrado)
- Ruta 2 --> (alternativa / LAB_00408E31): PE-walking + excepciones (anti-analysis)


-------

## Ruta 1 (normal / ‚Äúcentral‚Äù): la que suele llevar a la parte √∫til (incluido parcheo/descifrado)
## C1) Qu√© hace (a alto nivel)

En esta ruta se ve el patr√≥n:
1. Actualiza punteros din√°micos de API
- Ejemplo: en el snippet, en LAB_00408C63:
    - calcula valores desde DAT_004104F8..
    - termina haciendo:
        - ADD dword ptr [DAT_004106FC], ECX (00408CB3)
        - MOV EAX, [DAT_004106FC]
        - CALL EAX (00408CFB)


2. Escritura a una estructura global tipo ‚Äúcontexto‚Äù
    - 00408D00‚Äì00408D0C
        - ECX = [PTR_DAT_00410AB0]
        - ECX = [ECX + 0x1D0]
        - MOV [ECX], EAX

    - Esto parece ‚Äúguardar resultado/ptr‚Äù en una estructura global (muy t√≠pico de loader/dispatcher interno).


3. Preparaci√≥n de llamada grande (muchos pushes)
    - 00408D43‚Äì00408E02
    - Termina en:
        - CALL FUN_0040C181 (00408E02)


4. Salta hacia:
    - JMP LAB_00409220 (00408E2C)

## C2) ¬øEsta ruta lleva a FUN_0040142F?

Es la candidata m√°s probable a terminar invocando la parte de:
- descifrado/parcheo,
- o ejecuci√≥n de stub temporal,
- que estamos intentando observar en 0x0040142F.

Raz√≥n: es la ruta donde ves resoluci√≥n din√°mica + llamadas indirectas + ‚Äúmontaje de argumentos‚Äù; eso es el patr√≥n t√≠pico previo a stubs tipo FUN_0040592C / FUN_0040142F que comentabas antes.

‚úÖ Conclusi√≥n √∫til: si existe una ruta que ‚Äúgana‚Äù y llega a lo interesante (incluido el parcheo que luego se borra), normalmente es esta ruta 1.



## Ruta 2 (alternativa / LAB_00408E31): PE-walking + excepciones (anti-analysis)
## D) Qu√© se observa

En esa rama:
- toma una base (probablemente ImageBase o un puntero sacado del ‚Äúctx‚Äù),
- hace:
    - e_lfanew = [base + 0x3C]
    - luego lee campos dentro del NT header.

Esto es parseo manual del PE. Forensemente se usa para:
- encontrar directorios (import/debug/relocs),
- validar estructura (anti-tamper),
- o localizar offsets sin APIs.

## D2) ¬øDesde esta rama se llega a FUN_0040142F?

No se sabe aun. En muchas muestras, esa rama se usa para:
- validar/chequear (y si algo ‚Äúhuele a debug‚Äù, aborta),
- o desviar hacia una ruta que acaba en excepci√≥n/cierre.

El s√≠ntoma (‚Äúsi continuo, salta excepci√≥n y se para‚Äù) encaja m√°s con:
- ruta 2 como ruta de castigo/anti-debug, o ruta que depende de manejar una excepci√≥n por SEH (y el debugger te corta antes de que el handler la consuma).

üîé Conclusi√≥n prudente: lo m√°s probable es que la ruta 2 NO sea la que nos lleva a FUN_0040142F, sino la que te saca del camino normal (o te mete en exception-driven control flow que en debug se vuelve molesto).



-----


# C√≥mo verificarlo de forma ‚Äúforense‚Äù (sin bypass)

Para saber si la ruta 2 puede llegar a FUN_0040142F, podemos hacer una verificaci√≥n observacional, no ‚Äúforzada‚Äù:
- Breakpoint en el/los CALL site(s) reales a FUN_0040142F
    - No necesitamos saber c√≥mo llegar: si llega, lo ver√°s.
    - Cuando se dispare, miramos el call stack: eso nos dir√° si ven√≠amos de la ruta 1 o 2.

- Breakpoint en FUN_0040142F (entrada)
    - Si jam√°s rompe ah√≠ mientras est√°s en la rama LAB_00408E31, esa rama no te conduce.

- Trace ligero con ‚Äúlog de ramas‚Äù
    - Solo registramos: ‚Äú¬øtom√© el JNZ a LAB_00408E31?‚Äù y ‚Äú¬øvi ejecuci√≥n en 0040142F?‚Äù
    - Con eso cerramos la duda sin tocar nada.


# Resumen ejecutivo
- Gates grandes vistos:
    - DAT_0040E5A8 == 0xFFF7ABFE ‚Üí controla DAT_0040E590
    - DAT_0040E590 == 0 ‚Üí manda a ruta alternativa dentro de FUN_00407436
    - [ctx+0x1D4] == 0xFFF7ABFE ‚Üí separa ruta 1 (central) vs ruta 2 (PE-walk)
- Ruta 1 (central) = m√°s probable que lleve a la fase de parcheo/descifrado (donde esperas ver FUN_0040142F).
- Ruta 2 (LAB_00408E31) = m√°s probable que sea validaci√≥n/anti-analysis (y donde te ‚Äúcae‚Äù la excepci√≥n).