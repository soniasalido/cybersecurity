
# TÃ©cnicas anti debug

## 1. Sentinel global 0xFFF7ABFE como â€œflag de estadoâ€ (gating de ramas)

Usa una constante sentinela y comparaciones:
- En FUN_00407436
    - 004075D2â€“004075F3
        - MOV EAX, [DAT_0040E5A8]
        - CMP EAX, 0xFFF7ABFE
        - Si igual: carga puntero vÃ­a PTR_PTR_0040D008 y lo copia a DAT_0040E590
        - Si distinto: fuerza DAT_0040E590 = 0

Por quÃ© es relevante anti-analysis: ese sentinela estÃ¡ actuando como interruptor de â€œmodo vÃ¡lidoâ€. Si algo cambia ese valor (por inicializaciÃ³n distinta, ejecuciÃ³n bajo ciertas condiciones, o por manipulaciÃ³n), el flujo entra por la ruta que invalida DAT_0040E590 y luego aparecen cortes tempranos mÃ¡s adelante.


## 2 â€œKill-switchâ€ temprano por valor crÃ­tico (cierre/abort)

En FUN_00407436:
    - 00407806â€“00407810
        - CMP [DAT_0040E590], 0
        - JZ LAB_00407EE5 (salta a una ruta alternativa â€œcortaâ€)

Lectura forense: DAT_0040E590 es una especie de â€œhandle/ptr vÃ¡lidoâ€ que, si no estÃ¡ inicializado correctamente, manda a una rama distinta. Este tipo de gate se usa mucho para:
    - abortar lÃ³gica sensible si algo no cuadra,
    - impedir avanzar si el entorno no es el esperado,
    - o separar â€œruta normalâ€ vs â€œruta anti-analysisâ€.


## 3 Auto-modificaciÃ³n / parcheo en memoria como fase protegida (mencionaste FUN_0040142F)

Hemos intentando â€œver el dumpâ€ en 0x0040142F pero â€œse borra antesâ€. Eso encaja con dos patrones anti-analysis clÃ¡sicos:
- Self-modifying code (descifra/parchea un stub en memoria, lo usa y luego lo pisa/borra).
- Ventana de tiempo estrecha (solo es visible durante unos pocos cientos de instrucciones).

Aunque no tengamoss el byte-dump, el hecho operacional ya lo tenemos:
- hay una fase de â€œparcheo/uso/limpiezaâ€ que dificulta inspeccionar estÃ¡ticamente.
- Esto es anti-analysis, aunque no sea â€œanti-debug checkâ€ tipo IsDebuggerPresent.


## 4 ResoluciÃ³n dinÃ¡mica de APIs/funciones (anti-IAT + anti-breakpoints)

En FUN_00407436 y en el bloque de LAB_00408C63, aparece repetidamente:
- punteros a APIs guardados en globals (ej. DAT_004106cc, DAT_004106d0, DAT_004106d4, DAT_004106d8, DAT_004106dc, DAT_004106e0, etc.)
- llamadas indirectas tipo:
    - MOV EAX, [DAT_004106FC]
    - CALL EAX

Por quÃ© es anti-analysis: no es â€œdetectar debuggerâ€ directamente, pero sÃ­:
- evita que veamos un import table limpio,
- hace mÃ¡s difÃ­cil poner breakpoints en KERNEL32!X porque no hay call directo,
- permite cambiar de destino dinÃ¡micamente (incluso hacia stubs internos),
- y complica el tracing lineal.


## 5. Rama â€œcaminar el PEâ€ (parseo manual) usada como ruta alternativa (potencial anti-debug)

Cuando se toma la rama que empieza a leer:
- base = ...
- e_lfanew = [base + 0x3C]
- campos del NT Header / Optional Header

Ese patrÃ³n es PE parsing manual. En malware se usa mucho para:
- localizar directorios sin llamar a APIs,
- inspeccionar IMAGE_DIRECTORY_ENTRY_DEBUG (debug directory),
- inspeccionar imports/exports,
- validar que la imagen â€œes la esperadaâ€ (anti-tamper),
- o derivar offsets para stubs protegidos.

Importante: PE parsing no es automÃ¡ticamente anti-debug, pero en este caso estÃ¡ claramente en una rama de control (cuando el â€œsentinelaâ€ no cuadra / o el flujo decide ir por ruta alternativa). Eso la vuelve sospechosa como lÃ³gica de â€œsi no estÃ¡s en condiciones normales, ve por ruta Xâ€.



Esta rama hace PE-walking al principio ([base+0x3C], etc.).
- Si base (00792274) no es un PE vÃ¡lido o ni siquiera es memoria legible, ese read rompe con AV.
- En muchas familias eso se usa como control flow basado en excepciÃ³n (SEH): bajo ejecuciÃ³n normal lo absorbe un handler y continÃºa; en debugger, si paras en first-chance, parece â€œcrashâ€.

No te digo â€œcÃ³moâ€ configurarlo ni cÃ³mo â€œsaltarloâ€, pero forensemente: es muy plausible que NO sea un crash â€œrealâ€, sino un nodo de flujo intencional.

![alt text](capturas/parseo.png)





## 6. Anti-debug basado en excepciones (SEH / KiUserExceptionDispatcher)

Esto es de lo mÃ¡s claro por las capturas:
- Llegas a un punto (00408E39) y al seguir con F9 te da excepciÃ³n que te corta la ejecuciÃ³n.
- Por quÃ© una lectura del tipo:
  ```
  mov eax, dword ptr [ecx+3C] con ECX=00400000
  acabarÃ­a en KiUserException...
  ```

Aunque en teorÃ­a [0x00400000+0x3C] deberÃ­a ser legible si la imagen estÃ¡ mapeada normalmente, en muestras protegidas esto se usa de dos maneras:
- â€œException-as-signalâ€: provocan un acceso invÃ¡lido solo bajo ciertas condiciones (p.ej. ECX no es realmente 00400000 en el momento efectivo, o el page mapping no es el â€œnormalâ€, o hay trampas de guard page).
- SEH control-flow: el programa espera la excepciÃ³n y la maneja para seguir; pero el debugger, dependiendo de configuraciÃ³n (â€œbreak on first chanceâ€), interrumpe antes de que el handler la consuma, y el usuario cree que â€œse caeâ€.

Esto sÃ­ es anti-debug muy tÃ­pico: â€œsi estÃ¡s debuggeando, te freno con excepcionesâ€.


## 7. Comparaciones/ramas con â€œchecks opacosâ€ (valores calculados + saltos)

Ejemplos visibles:
- bucles tipo:
    - CMP ...
    - JBE / JA / JNZ hacia un loop (p.ej. 004074FD vuelve a 004074AD, o 00408331 vuelve a 00408289)

Estos bucles con constantes y tablas suelen ser:
- opaque predicates (condiciones difÃ­ciles de simplificar),
- delay loops / â€œnoiseâ€,
- o gating para que el flujo â€œbuenoâ€ ocurra solo si ciertos estados internos cuadran.

De nuevo: no es un â€œIsDebuggerPresentâ€, pero es anti-anÃ¡lisis porque complica el reasoning y el stepping.


## 8 FUN_004012DF: validaciÃ³n de imagen / sanity check (mÃ¡s anti-tamper que anti-debug)

FUN_004012DF(param_1) hace:
- chequeo del primer byte: `AL = [param_1] ; AL += 0x32 ; AL ^= 0xBE ; CMP AL, 0xC1`
    - Si falla â†’ ruta alternativa (LAB_0040140D)

- calcula `ECX = param_1 + [param_1+0x3C]` (otra vez e_lfanew)
- compara un dword en `[ECX+0x54]` contra un valor derivado de constantes.

Eso parece validaciÃ³n del PE (o de un buffer con estructura similar a PE) + gating. Es Ãºtil para anti-analysis porque:
- si el â€œobjeto PEâ€ no es el esperado (por dumping parcial, reconstrucciÃ³n incompleta, o manipulaciÃ³n), no deja avanzar por la ruta â€œnormalâ€.

No se puede afirmar que sea anti-debug directo, pero sÃ­ anti-tamper/anti-dump.


-----


# Mapa de flujo: â€œruta normalâ€ vs â€œruta alternativa (PE-walk / excepciÃ³n)â€

## A) FUN_00407436 (00407436) â€” gate de sentinela y bifurcaciÃ³n temprana
### A1) InicializaciÃ³n + gate de DAT_0040E590

#### 1. 004075D2â€“004075F3
- Lee DAT_0040E5A8 y compara con 0xFFF7ABFE.
- Si igual: escribe un puntero/valor en DAT_0040E590.
- Si distinto: pone DAT_0040E590 = 0.

#### 2. 00407806â€“00407810
- CMP [DAT_0040E590], 0
- Si 0 â†’ salta a LAB_00407EE5 (ruta â€œcorta/alternativaâ€ dentro de la funciÃ³n).
- Si no es 0 â†’ continÃºa la ruta â€œcentralâ€ (la larga).


ğŸ“Œ InterpretaciÃ³n forense: aquÃ­ DAT_0040E590 actÃºa como â€œflag/handle vÃ¡lidoâ€. Si no estÃ¡ bien, FUN_00407436 se va a una ruta distinta antes de ejecutar parte de la lÃ³gica â€œsensibleâ€.


## En el bloque alrededor de 00408C38â€“00409220 â€” el gran â€œsplitâ€ por sentinela en ctx+0x1D4
### B1) Gate clave (check de sentinela)

En 00408C38:
- CondiciÃ³n: `dword ptr [ctx + 0x1D4] == 0xFFF7ABFE`.
- Si NO es igual (JNZ) â†’ salta a LAB_00408E31 (ruta alternativa).
- Si SÃ es igual â†’ sigue por la ruta â€œcentralâ€ (ruta normal).

Esto separa:
- Ruta 1 --> (normal / â€œcentralâ€): la que suele llevar a la parte Ãºtil (incluido parcheo/descifrado)
- Ruta 2 --> (alternativa / LAB_00408E31): PE-walking + excepciones (anti-analysis)


-------

## Ruta 1 (normal / â€œcentralâ€): la que suele llevar a la parte Ãºtil (incluido parcheo/descifrado)
## C1) QuÃ© hace (a alto nivel)

En esta ruta se ve el patrÃ³n:
1. Actualiza punteros dinÃ¡micos de API
- Ejemplo: en el snippet, en LAB_00408C63:
    - calcula valores desde DAT_004104F8..
    - termina haciendo:
        - ADD dword ptr [DAT_004106FC], ECX (00408CB3)
        - MOV EAX, [DAT_004106FC]
        - CALL EAX (00408CFB)


2. Escritura a una estructura global tipo â€œcontextoâ€
    - 00408D00â€“00408D0C
        - ECX = [PTR_DAT_00410AB0]
        - ECX = [ECX + 0x1D0]
        - MOV [ECX], EAX

    - Esto parece â€œguardar resultado/ptrâ€ en una estructura global (muy tÃ­pico de loader/dispatcher interno).


3. PreparaciÃ³n de llamada grande (muchos pushes)
    - 00408D43â€“00408E02
    - Termina en:
        - CALL FUN_0040C181 (00408E02)


4. Salta hacia:
    - JMP LAB_00409220 (00408E2C)

## C2) Â¿Esta ruta lleva a FUN_0040142F?

Es la candidata mÃ¡s probable a terminar invocando la parte de:
- descifrado/parcheo,
- o ejecuciÃ³n de stub temporal,
- que estamos intentando observar en 0x0040142F.

RazÃ³n: es la ruta donde ves resoluciÃ³n dinÃ¡mica + llamadas indirectas + â€œmontaje de argumentosâ€; eso es el patrÃ³n tÃ­pico previo a stubs tipo FUN_0040592C / FUN_0040142F que comentabas antes.

âœ… ConclusiÃ³n Ãºtil: si existe una ruta que â€œganaâ€ y llega a lo interesante (incluido el parcheo que luego se borra), normalmente es esta ruta 1.



## Ruta 2 (alternativa / LAB_00408E31): PE-walking + excepciones (anti-analysis)
## D) QuÃ© se observa

En esa rama:
- toma una base (probablemente ImageBase o un puntero sacado del â€œctxâ€),
- hace:
    - e_lfanew = [base + 0x3C]
    - luego lee campos dentro del NT header.

Esto es parseo manual del PE. Forensemente se usa para:
- encontrar directorios (import/debug/relocs),
- validar estructura (anti-tamper),
- o localizar offsets sin APIs.

## D2) Â¿Desde esta rama se llega a FUN_0040142F?

No se sabe aun. En muchas muestras, esa rama se usa para:
- validar/chequear (y si algo â€œhuele a debugâ€, aborta),
- o desviar hacia una ruta que acaba en excepciÃ³n/cierre.

El sÃ­ntoma (â€œsi continuo, salta excepciÃ³n y se paraâ€) encaja mÃ¡s con:
- ruta 2 como ruta de castigo/anti-debug, o ruta que depende de manejar una excepciÃ³n por SEH (y el debugger te corta antes de que el handler la consuma).

ğŸ” ConclusiÃ³n prudente: lo mÃ¡s probable es que la ruta 2 NO sea la que nos lleva a FUN_0040142F, sino la que te saca del camino normal (o te mete en exception-driven control flow que en debug se vuelve molesto).



-----


# CÃ³mo verificarlo de forma â€œforenseâ€ (sin bypass)

Para saber si la ruta 2 puede llegar a FUN_0040142F, podemos hacer una verificaciÃ³n observacional, no â€œforzadaâ€:
- Breakpoint en el/los CALL site(s) reales a FUN_0040142F
    - No necesitamos saber cÃ³mo llegar: si llega, lo verÃ¡s.
    - Cuando se dispare, miramos el call stack: eso nos dirÃ¡ si venÃ­amos de la ruta 1 o 2.

- Breakpoint en FUN_0040142F (entrada)
    - Si jamÃ¡s rompe ahÃ­ mientras estÃ¡s en la rama LAB_00408E31, esa rama no te conduce.

- Trace ligero con â€œlog de ramasâ€
    - Solo registramos: â€œÂ¿tomÃ© el JNZ a LAB_00408E31?â€ y â€œÂ¿vi ejecuciÃ³n en 0040142F?â€
    - Con eso cerramos la duda sin tocar nada.


# Resumen ejecutivo
- Gates grandes vistos:
    - DAT_0040E5A8 == 0xFFF7ABFE â†’ controla DAT_0040E590
    - DAT_0040E590 == 0 â†’ manda a ruta alternativa dentro de FUN_00407436
    - [ctx+0x1D4] == 0xFFF7ABFE â†’ separa ruta 1 (central) vs ruta 2 (PE-walk)
- Ruta 1 (central) = mÃ¡s probable que lleve a la fase de parcheo/descifrado (donde esperas ver FUN_0040142F).
- Ruta 2 (LAB_00408E31) = mÃ¡s probable que sea validaciÃ³n/anti-analysis (y donde te â€œcaeâ€ la excepciÃ³n).