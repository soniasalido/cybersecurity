
## SHA-1
**<mark>Las siglas SHA corresponden a Algoritmo de Hash Seguro</mark>**, un algoritmo de resumen propuesto por la `NSA` y adoptado como estÃ¡ndar Federal por el `NIST` (National Institute of Standards and Technology) en 1993. Antes de los 2 aÃ±os se detectan vulnerabilidades por lo en 1995 proponen un nuevo algoritmo conocido como `SHA 1`, pasando el anterior a denominarse `SHA 0`, y no recomendarse su uso.

**<mark>El diseÃ±o de `SHA 1` es muy similar al de `md5`</mark>**. MD5 y SHA-1 son funciones hash criptogrÃ¡ficas. Toman un mensaje de cualquier tamaÃ±o (un archivo, un texto, etc.) y devuelven una `â€œhuellaâ€ fija llamada resumen o digest.`
- **TamaÃ±o del digest (resumen):**
  - MD5 produce 128 bits â†’ 16 bytes â†’ 32 caracteres hexadecimales.
  - SHA-1 produce 160 bits â†’ 20 bytes â†’ 40 caracteres hexadecimales.
    
  MÃ¡s bits = mÃ¡s combinaciones posibles de huellas. Cuantas mÃ¡s combinaciones tengamos, mÃ¡s difÃ­cil es encontrar dos mensajes distintos con la misma huella (colisiÃ³n) o recuperar el mensaje original (preimagen).

**<mark>Paradoja del cumpleaÃ±os:</mark>** la dificultad de colisiÃ³n crece como 2<sup>(n/2)</sup>, siendo n los bits del hash.
- MD5 (128 bits) â‰ˆ 2<sup>64</sup> intentos.
- SHA-1 (160 bits) â‰ˆ 2<sup>80</sup> intentos.
Por eso, SHA-1 era considerado mÃ¡s robusto que MD5: su digest es mÃ¡s largo y, en diseÃ±o, mejora algunas partes.


## Esquema del algoritmo SHA-1
Al igual que en md5, el mensaje se agrupa en bloques de 512 bits con 16 palabras de 32 bits. Para completar el Ãºltimo bloque de 512 bits, se aplicarÃ¡ un relleno de un 1, seguido de tantos 0 como sea necesario, reservando los Ãºltimos 64 bits para indicar el tamaÃ±o del mensaje o archivo. Internamente SHA1 trata las palabras en representaciÃ³n Big Endian, es decir, primero se leen los bytes mÃ¡s significativos y despuÃ©s, los bytes menos significativos, que en el fondo es la forma natural de hacerlo. 

Por ejemplo la palabra de 32 bits "amor", que en hexadecimal es: `41 6D 6F 72`, se leerÃ¡: `41 6D 6F 72`.

SHA1 usa 5 vectores pÃºblicos de 32 bits, conocidos como `A, B, C, D y E` que se mezclarÃ¡n con las palabras del texto en claro, tambiÃ©n de 32 bits. Realizando para cada bloque de entrada de 512 bits, un total de 80 vueltas. Terminadas las primeras 80 vueltas, los vectores iniciales `A, B, C, D y E` habrÃ¡n cambiado varias veces de valor y serÃ¡n los nuevos 5 vectores que se mezclarÃ¡n con el segundo bloque de 512 bits de entrada. Esta acciÃ³n se va encadenando con los siguientes bloques, hasta que el Ãºltimo valor de los vectores `A, B, C, D y E` es el resumen de 160 bits de todo el documento.

## Las 80 vueltas de SHA1
A cada bloque del texto de entrada se le aplicarÃ¡n 20 vueltas con 4 funciones distintas, de forma tal que el nÃºmero total de vueltas por bloque serÃ¡ igual a 20 *4 = 80.

Pero, Â¿cÃ³mo podemos generar 80 palabras de 32 bits a partir sÃ³lo de los 512 bits de entrada? Cada bloque de 16 palabras del mensaje se expandirÃ¡ en 80 palabras, de forma que las palabras 0 a 15 se corresponden a los 512 bits del bloque y las 64 palabras restantes, de la 16 a la 79, se obtienen mediante una operaciÃ³n lÃ³gica entre las palabras anteriores.

## La fortaleza de SHA1

### Â¿QuÃ© es â€œparadoja del cumpleaÃ±osâ€ en hashes?
Para un hash de n bits, el coste esperado de encontrar una colisiÃ³n por fuerza bruta (dos mensajes cualesquiera con el mismo hash) no es 2<sup>ğ‘›</sup>, sino ~2<sup>ğ‘›/2</sup>.  A esto se le llama lÃ­mite de cumpleaÃ±os.

Para SHA-1, ğ‘› = 160 â†’ lÃ­mite ideal â‰ˆ 2<sup>80</sup> evaluaciones del hash.

### QuÃ© pasÃ³ con SHA-1 en la prÃ¡ctica

La criptoanÃ¡lisis redujo ese coste muy por debajo de 2<sup>80</sup>:
- 2017 (SHAttered): colisiÃ³n prÃ¡ctica con complejidad ~2<sup>63</sup> (orden de magnitud), muy inferior al ideal.
- 2020 (â€œSHA-1 is a Shamblesâ€): colisiÃ³n de prefijo elegido tambiÃ©n con coste ~2<sup>63</sup> (orden de magnitud).

Es decir: no bajÃ³ â€œa menos de 2<sup>50</sup>â€ en ataques reales al SHA-1 completo; los mejores ataques prÃ¡cticos estÃ¡n en torno a 2<sup>63</sup> (en equivalentes de evaluaciones de la funciÃ³n de compresiÃ³n), que ya es devastador para seguridad.

### ConclusiÃ³n 
- Fortaleza de colisiÃ³n de SHA-1: cayÃ³ de ~2<sup>80</sup> (ideal) a ~2<sup>63</sup> (ataques prÃ¡cticos).
- Eso es preocupante (y suficiente para retirar SHA-1 de usos de seguridad: firmas, certificados, integridad con adversario).
- Se pasÃ³ a SHA-256 (colisiÃ³n ideal ~2<sup>128</sup> o SHA-3-256/BLAKE2/3.

### Tabla rÃ¡pida (coste ideal por paradoja del cumpleaÃ±os)
| Algoritmo               | Bits del hash (n) | ColisiÃ³n ideal â‰ˆ (2<sup>n/2</sup>) | Nota prÃ¡ctica conocida                                                              |
| ----------------------- | ----------------: | -------------------------: | ----------------------------------------------------------------------------------- |
| **SHA-1**               |               160 |                   (2<sup>80</sup>) | Colisiones **prÃ¡cticas** â‰ˆ (2<sup>63</sup>) (SHAttered, 2017; CPC 2020) â†’ **desaconsejado** |
| **SHA-256** (SHA-2)     |               256 |                  (2<sup>128</sup>) | Sin colisiones conocidas                                                            |
| **SHA-3-256** (Keccak)  |               256 |                  (2<sup>128</sup>) | Sin colisiones conocidas                                                            |
| **SHA-512/256** (SHA-2) |               256 |                  (2<sup>128</sup>) | Sin colisiones conocidas                                                            |
| **BLAKE2s/BLAKE3-256**  |               256 |                  (2<sup>128</sup>) | Sin colisiones conocidas                                                            |


## DemostraciÃ³n de colisiÃ³n en SHA-1
Una funciÃ³n hash no cifra, sino que crea un resumen o Â«firmaÂ» de un conjunto de datos, que es pasado como parÃ¡metro a esta funciÃ³n.SHA1 es Ãºtil para verificar la integridad, por ejemplo, de un archivo. Tan solo tenemos que aplicar dicha funciÃ³n sobre el archivo recibido y verificar que el hash obtenido es el mismo que el anunciado por el emisor.

Un Â«hashÂ» es una funciÃ³n criptogrÃ¡fica que produce una salida de longitud fija a partir de una entrada arbitrariamente larga. Un buen Â«hashÂ» debe cumplir las siguientes propiedades:
- El resultado final no debe dejar traslucir ninguna informaciÃ³n sobre los datos originales.
- Dado un resultado determinado, no hay otro sistema aparte de la fuerza bruta que genere datos de entrada capaces de producir dicho resultado.
- Dados unos datos de entrada y su Â«hashÂ«, no debe haber un atajo (aparte de la fuerza bruta) para generar otros datos de entrada distintos y con el mismo Â«hashÂ«.

### SHAttered
10 aÃ±os despuÃ©s de la introducciÃ³n del algoritmo SHA-1 como funciÃ³n hash, se ha anunciado la primera tÃ©cnica prÃ¡ctica para generar una colisiÃ³n. Esto es dado un Â«archivo AÂ«, generar otro Â«archivo BÂ» que produzca el mismo hash que el del Â«archivo AÂ«.

Tras dos aÃ±os de investigaciÃ³n y la colaboraciÃ³n del CWI Institute en Amsterdamy Google, este equipo de investigadores ha conseguido crear un mÃ©todo para generar colisiones. Como prueba del ataque, publican dos archivos PDF que tienen hash SHA-1 idÃ©nticos pero con contenido diferente (PDF 1 y PDF 2).


## Referencias
[PÃ­ldora 45 - CÃ³mo funciona el hash SHA-1]https://www.youtube.com/watch?v=pG8785ZEFuM&list=PL8bSwVy8_IcNNS5QDLjV7gUg8dIeMFSER&index=45


https://unaaldia.hispasec.com/2017/02/demostracion-practica-de-colision-en-sha-1.html
