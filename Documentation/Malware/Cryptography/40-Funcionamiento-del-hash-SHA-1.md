
## SHA-1
**<mark>Las siglas SHA corresponden a Algoritmo de Hash Seguro</mark>**, un algoritmo de resumen propuesto por la `NSA` y adoptado como estándar Federal por el `NIST` (National Institute of Standards and Technology) en 1993. Antes de los 2 años se detectan vulnerabilidades por lo en 1995 proponen un nuevo algoritmo conocido como `SHA 1`, pasando el anterior a denominarse `SHA 0`, y no recomendarse su uso.

**<mark>El diseño de `SHA 1` es muy similar al de `md5`</mark>**. MD5 y SHA-1 son funciones hash criptográficas. Toman un mensaje de cualquier tamaño (un archivo, un texto, etc.) y devuelven una `“huella” fija llamada resumen o digest.`
- **Tamaño del digest (resumen):**
  - MD5 produce 128 bits → 16 bytes → 32 caracteres hexadecimales.
  - SHA-1 produce 160 bits → 20 bytes → 40 caracteres hexadecimales.
    
  Más bits = más combinaciones posibles de huellas. Cuantas más combinaciones tengamos, más difícil es encontrar dos mensajes distintos con la misma huella (colisión) o recuperar el mensaje original (preimagen).

**<mark>Paradoja del cumpleaños:</mark>** la dificultad de colisión crece como 2<sup>(n/2)</sup>, siendo n los bits del hash.
- MD5 (128 bits) ≈ 2<sup>64</sup> intentos.
- SHA-1 (160 bits) ≈ 2<sup>80</sup> intentos.
Por eso, SHA-1 era considerado más robusto que MD5: su digest es más largo y, en diseño, mejora algunas partes.


## Esquema del algoritmo SHA-1
Al igual que en md5, el mensaje se agrupa en bloques de 512 bits con 16 palabras de 32 bits. Para completar el último bloque de 512 bits, se aplicará un relleno de un 1, seguido de tantos 0 como sea necesario, reservando los últimos 64 bits para indicar el tamaño del mensaje o archivo. Internamente SHA1 trata las palabras en representación Big Endian, es decir, primero se leen los bytes más significativos y después, los bytes menos significativos, que en el fondo es la forma natural de hacerlo. 

Por ejemplo la palabra de 32 bits "amor", que en hexadecimal es: `41 6D 6F 72`, se leerá: `41 6D 6F 72`.

SHA1 usa 5 vectores públicos de 32 bits, conocidos como `A, B, C, D y E` que se mezclarán con las palabras del texto en claro, también de 32 bits. Realizando para cada bloque de entrada de 512 bits, un total de 80 vueltas. Terminadas las primeras 80 vueltas, los vectores iniciales `A, B, C, D y E` habrán cambiado varias veces de valor y serán los nuevos 5 vectores que se mezclarán con el segundo bloque de 512 bits de entrada. Esta acción se va encadenando con los siguientes bloques, hasta que el último valor de los vectores `A, B, C, D y E` es el resumen de 160 bits de todo el documento.

## Las 80 vueltas de SHA1
A cada bloque del texto de entrada se le aplicarán 20 vueltas con 4 funciones distintas, de forma tal que el número total de vueltas por bloque será igual a 20 *4 = 80.

Pero, ¿cómo podemos generar 80 palabras de 32 bits a partir sólo de los 512 bits de entrada? Cada bloque de 16 palabras del mensaje se expandirá en 80 palabras, de forma que las palabras 0 a 15 se corresponden a los 512 bits del bloque y las 64 palabras restantes, de la 16 a la 79, se obtienen mediante una operación lógica entre las palabras anteriores.

## La fortaleza de SHA1

### ¿Qué es “paradoja del cumpleaños” en hashes?
Para un hash de n bits, el coste esperado de encontrar una colisión por fuerza bruta (dos mensajes cualesquiera con el mismo hash) no es 2<sup>𝑛</sup>, sino ~2<sup>𝑛/2</sup>.  A esto se le llama límite de cumpleaños.

Para SHA-1, 𝑛 = 160 → límite ideal ≈ 2<sup>80</sup> evaluaciones del hash.

### Qué pasó con SHA-1 en la práctica

La criptoanálisis redujo ese coste muy por debajo de 2<sup>80</sup>:
- 2017 (SHAttered): colisión práctica con complejidad ~2<sup>63</sup> (orden de magnitud), muy inferior al ideal.
- 2020 (“SHA-1 is a Shambles”): colisión de prefijo elegido también con coste ~2<sup>63</sup> (orden de magnitud).

Es decir: no bajó “a menos de 2<sup>50</sup>” en ataques reales al SHA-1 completo; los mejores ataques prácticos están en torno a 2<sup>63</sup> (en equivalentes de evaluaciones de la función de compresión), que ya es devastador para seguridad.

### Conclusión 
- Fortaleza de colisión de SHA-1: cayó de ~2<sup>80</sup> (ideal) a ~2<sup>63</sup> (ataques prácticos).
- Eso es preocupante (y suficiente para retirar SHA-1 de usos de seguridad: firmas, certificados, integridad con adversario).
- Se pasó a SHA-256 (colisión ideal ~2<sup>128</sup> o SHA-3-256/BLAKE2/3.

### Tabla rápida (coste ideal por paradoja del cumpleaños)
| Algoritmo               | Bits del hash (n) | Colisión ideal ≈ (2<sup>n/2</sup>) | Nota práctica conocida                                                              |
| ----------------------- | ----------------: | -------------------------: | ----------------------------------------------------------------------------------- |
| **SHA-1**               |               160 |                   (2<sup>80</sup>) | Colisiones **prácticas** ≈ (2<sup>63</sup>) (SHAttered, 2017; CPC 2020) → **desaconsejado** |
| **SHA-256** (SHA-2)     |               256 |                  (2<sup>128</sup>) | Sin colisiones conocidas                                                            |
| **SHA-3-256** (Keccak)  |               256 |                  (2<sup>128</sup>) | Sin colisiones conocidas                                                            |
| **SHA-512/256** (SHA-2) |               256 |                  (2<sup>128</sup>) | Sin colisiones conocidas                                                            |
| **BLAKE2s/BLAKE3-256**  |               256 |                  (2<sup>128</sup>) | Sin colisiones conocidas                                                            |


## Demostración de colisión en SHA-1
Una función hash no cifra, sino que crea un resumen o «firma» de un conjunto de datos, que es pasado como parámetro a esta función.SHA1 es útil para verificar la integridad, por ejemplo, de un archivo. Tan solo tenemos que aplicar dicha función sobre el archivo recibido y verificar que el hash obtenido es el mismo que el anunciado por el emisor.

Un «hash» es una función criptográfica que produce una salida de longitud fija a partir de una entrada arbitrariamente larga. Un buen «hash» debe cumplir las siguientes propiedades:
- El resultado final no debe dejar traslucir ninguna información sobre los datos originales.
- Dado un resultado determinado, no hay otro sistema aparte de la fuerza bruta que genere datos de entrada capaces de producir dicho resultado.
- Dados unos datos de entrada y su «hash«, no debe haber un atajo (aparte de la fuerza bruta) para generar otros datos de entrada distintos y con el mismo «hash«.

### SHAttered
10 años después de la introducción del algoritmo SHA-1 como función hash, se ha anunciado la primera técnica práctica para generar una colisión. Esto es dado un «archivo A«, generar otro «archivo B» que produzca el mismo hash que el del «archivo A«.

Tras dos años de investigación y la colaboración del CWI Institute en Amsterdamy Google, este equipo de investigadores ha conseguido crear un método para generar colisiones. Como prueba del ataque, publican dos archivos PDF que tienen hash SHA-1 idénticos pero con contenido diferente (PDF 1 y PDF 2).


## Referencias
[Píldora 45 - Cómo funciona el hash SHA-1]https://www.youtube.com/watch?v=pG8785ZEFuM&list=PL8bSwVy8_IcNNS5QDLjV7gUg8dIeMFSER&index=45


https://unaaldia.hispasec.com/2017/02/demostracion-practica-de-colision-en-sha-1.html
