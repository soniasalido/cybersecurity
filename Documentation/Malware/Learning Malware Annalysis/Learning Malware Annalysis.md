https://tutorials.ophion.feralhosting.com/Tutorials/Malware%20Analysis/UD-Reverse-Engineering-And-Malware-Analysis-Fundamentals/

https://elhacker.info/manuales/An%c3%a1lisis%20de%20malware/

https://elhacker.info/manuales/An%C3%A1lisis%20de%20malware/Learning%20Malware%20Analysis_%20Explore%20the%20concepts,%20tools,%20and%20techniques%20to%20analyze%20and%20investigate%20Windows%20malware%20(%20PDFDrive.com%20).pdf

https://www.wolf.university/masteringmalwareanalysis/ebook/masteringmalwareanalysis.pdf

https://www.wolf.university/cybersecuritythreatsmalwaretrendsandstrategies/ebook/cybersecuritythreatsmalwaretrendsandstrategies.pdf

https://elhacker.info/manuales/An%c3%a1lisis%20de%20malware/Practical_Malware_Analysis.pdf


https://elhacker.info/manuales/An%c3%a1lisis%20de%20malware/Windows%20Malware%20Analysis%20Essentials_%20Master%20the%20fundamentals%20of%20malware%20analysis%20for%20the%20Windows%20platform%20and%20enhance%20your%20anti-malware%20skill%20set%20(%20PDFDrive.com%20).pdf

https://www.wolf.university/ghidrasoftwarereverseengineeringforbeginners/ebook/ghidrasoftwarereverseengineeringforbeginners.pdf

https://elhacker.info/manuales/An%c3%a1lisis%20de%20malware/intro-reverseeng.pdf


https://github.com/Neo23x0/signature-base/tree/master/yara


https://github.com/baynam1995/MalwareAnalysiBook/blob/master/Learning.Malware.Analysis.Techniques.Investigate.pdf

https://elhacker.info/manuales/Virus/Rootkits%20and%20Bootkits_%20Reversing%20Modern%20Malware%20and%20Next%20Generation%20Threats%20Early%20Access.pdf


https://ftp.idu.ac.id/wp-content/uploads/ebook/tdg/MILITARY%20REFERENCE%20AND%20REVERSE%20ENGINEERING/Mastering%20Reverse%20Engineering%20Re-engineer%20your%20ethical%20hacking%20skills%20by%20Reginald%20Wong%20(z-lib.org).pdf

https://ccdcoe.org/uploads/2020/07/Malware_Reverse_Engineering_Handbook.pdf

https://github.com/Dump-GUY/Malware-analysis-and-Reverse-engineering

https://github.com/gabimarti/ingenieria_inversa_a_partir_del_codigo_fuente/tree/master


Binary Ninja is an interactive decompiler, disassembler, debugger, and binary analysis platform built by reverse engineers, for reverse engineers: https://binary.ninja/


https://rada.re/n/


# CHAPTER 1
## 1. 쯈u칠 es el malware?
El malware es un c칩digo que realiza acciones maliciosas; puede tomar la forma de un ejecutable, un script, un c칩digo o cualquier otro software. Los atacantes utilizan malware para robar informaci칩n confidencial, espiar el sistema infectado o tomar el control del sistema. Por lo general, ingresa a su sistema sin su consentimiento y puede entregarse a trav칠s de varios canales de comunicaci칩n, como correo electr칩nico, web o unidades USB.


The following are some of the malicious actions performed by malware:
- Disrupting computer operations
- Stealing sensitive information, including personal, business, and financial data
- Unauthorized access to the victim's system
- Spying on the victims
- Sending spam emails
- Engaging in distributed-denial-of-service attacks (DDOS)
- Locking up the files on the computer and holding them for ransom

Malware is a broad term that refers to different types of malicious programs such as trojans, viruses, worms, and rootkits. While performing malware analysis, you will often come across various types of malicious programs; some of these malicious programs are categorized based on their functionality and attack vectors as mentioned here:
- Virus or Worm: Malware that is capable of copying itself and spreading to other computers. A virus needs user intervention, whereas a worm can spread without user intervention.
- Trojan: Malware that disguises itself as a regular program to trick users to install it on their systems. Once installed, it can perform malicious actions such as stealing sensitive data, uploading files to the attacker's server, or monitoring
webcams.
- Backdoor / Remote Access Trojan (RAT): This is a type of Trojan that enables the attacker to gain access to and execute commands on the compromised system.
- Adware: Malware that presents unwanted advertisements (ads) to the user. They usually get delivered via free downloads and can forcibly install software on your system.
- Botnet: This is a group of computers infected with the same malware (called bots), waiting to receive instructions from the command-and-control server controlled by the attacker. The attacker can then issue a command to these bots, which can perform malicious activities such as DDOS attacks or sending spam emails.
- Information stealer: Malware designed to steal sensitive data such as banking credentials or typed keystrokes from the infected system. Some examples of these malicious programs include key loggers, spyware, sniffers, and form grabbers.
Ransomware: Malware that holds the system for ransom by locking users out of their computer or by encrypting their files.
Rootkit: Malware that provides the attacker with privileged access to the infected system and conceals its presence or the presence of other software.
Downloader or dropper: Malware designed to download or install additional malware components.


## 2. Descripci칩n general de la arquitectura del laboratorio
![](capturas/structure.png)

La arquitectura usada consiste en una **m치quina f칤sica (llamada m치quina host) que ejecuta Ubuntu Linux con instancias de m치quina virtual Linux (Ubuntu Linux VM) y m치quina virtual Windows (Windows VM)**. Estas m치quinas virtuales se configurar치n para ser parte de la misma red y utilizar치n el modo de **configuraci칩n de red de Host-only** para que el malware no pueda comunicarse con Internet y el tr치fico de la red est칠 contenido en el entorno de laboratorio aislado.

La VM de Windows es donde se ejecutar치 el malware durante el an치lisis, y la VM de Linux usada para monitorear el tr치fico de red y ser치 configurada para simular servicios de Internet (DNS, HTTP, etc.), para proporcionar una respuesta adecuada cuando el malware solicite estos servicios. Por ejemplo, la m치quina virtual Linux se configurar치 de manera que cuando el malware solicite un servicio como DNS, la m치quina virtual Linux proporcione la respuesta DNS adecuada. 

En esta configuraci칩n, la m치quina virtual Linux estar치 preconfigurada en la direcci칩n IP 192.168.1.100 y la direcci칩n IP de la m치quina virtual Windows se configurar치 en 192.168.1.x (donde x es cualquier n칰mero de 1 a 254 excepto 100). La puerta de enlace predeterminada y el DNS de la VM de Windows se configurar치n en la direcci칩n IP de la VM de Linux (es decir, 192.168.1.100) para que todo el tr치fico de la red de Windows se enrute a trav칠s de la VM de Linux.

Tambi칠n es posible configurar un laboratorio compuesto por m칰ltiples VMs ejecutando diferentes versiones de Windows; esto nos permitir치 analizar la muestra de malware en varias versiones de sistemas operativos Windows.
![](capturas/structure-2.png)


## 3. Configuraci칩n de VM Linux
- Instalaci칩n de Ubuntu | Windows.
- Instalaci칩n de Virtual Guest Additions software.
- Configuraci칩n de Windows VM:
  - Deshabilitar Windows Update.
  - Deshabilitar Windows Defender 游먍  Services 游먍 Windows Defender 游먍 Boton derecho 游먍  Select poperties 游먍  Stop Service
  - Mostrar extensiones de ficheros 游먍 Opciones de carpeta 游먍 Ver 游먍  Mostrar extensiones para ficheros
  - Mostrar ficheros y carpetas ocultos.
  - Deshabilitar ASLR (Address Space Layout Randomization): ASLR (Address Space Layout Randomization) es una t칠cnica de seguridad utilizada para dificultar los ataques de desbordamiento de b칰fer (buffer overflow) y otras vulnerabilidades de corrupci칩n de memoria. La idea principal de ASLR es ubicar aleatoriamente en el espacio de direcciones de memoria las 치reas clave de un proceso, como el ejecutable base, la pila, el mont칩n y las librer칤as cargadas. Esto hace que las direcciones de memoria sean impredecibles para un atacante, dificultando la ejecuci칩n de c칩digo malicioso.
    游먍  Windows + R 游먍  regedit 游먍 Computer\HKEY_LOCAL_MACHINE\SISTEM\CurrentSet\Control\Session Manager\Memory Management 游먍  New Key 游먍 QWORD (32 bits) 游먍 poner como nombre: MoveImages
  - Deshabilitar Firewall 游먍 Windows Defender Firewall.
  - Crear un snapshot 游먍 HOST + T
- Instalaci칩n:
  ```
  sudo apt-get install python-pip
  pip install --upgrade pip
  sudo apt-get install python-magic
  sudo apt-get install upx
  sudo pip install pefile
  sudo apt-get install yara
  sudo pip install yara-python
  sudo apt-get install ssdeep
  sudo apt-get install build-essential libffi-dev python python-dev libfuzzy-dev
  sudo pip install ssdeep
  sudo apt-get install wireshark
  sudo apt-get install tshark
  ```
- INetSim (http://www.inetsim.org/index.html) is a powerful utility that allows simulating various Internet services (such as DNS, and HTTP):
  ```
  sudo su
  echo "deb http://www.inetsim.org/debian/ binary/" >  /etc/apt/sources.list.d/inetsim.list
  wget -O - http://www.inetsim.org/inetsim-archive-signing-key.asc | apt-key add -
  apt update
  apt-get install inetsim
  ```
- You can now isolate Ubuntu VM within your lab by configuring the virtual appliance to use Host-only network mode. On VMware, bring up the Network Adapter Settings and choose Host-only. File| Preferences | Network | Host-only networks | Add host-only network.
- IP address of 192.168.1.100 to the Ubuntu Linux VM.
- Configure INetSim so that it can listen to and simulate all the services on the configured IP address 192.168.1.100:
  ```
  sudo gedit /etc/inetsim/inetsim.conf
  # service_bind_address
  #
  # IP address to bind services to
  #
  # Syntax: service_bind_address <IP address>
  #
  # Default: 127.0.0.1
  #
  #service_bind_address 10.10.10.1
  service_bind_address 192.168.1.100
  #
  #dns_default_ip 10.10.10.1
  dns_default_ip 192.168.1.100
  ```
- Launch INetSim:
  ```
  sudo inetsim
  ```
- Take a snapshot: On Virtualbox, the same can be done by clicking on Machine | Take Snapshot. 游먍 Host + T

- Instalar Flare VM: Es una colecci칩n de scripts de instalaci칩n de software para sistemas Windows que permite configurar y mantener f치cilmente un entorno de ingenier칤a inversa y an치lisis de malware en una m치quina virtual.Las principales caracter칤sticas de FLARE VM son:
  - Proporciona un conjunto curado de herramientas expertas para ingenier칤a inversa, an치lisis de malware, monitoreo, depuraci칩n, desensamblado, descompilaci칩n y m치s, todas preinstaladas y configuradas. Algunas herramientas incluidas son IDA, Binary Ninja, Radare2, OllyDbg, x64dbg, Ghidra, entre otras. (https://github.com/dnSpy/dnSpy)
  - Utiliza Chocolatey (un administrador de paquetes para Windows) y Boxstarter para automatizar la instalaci칩n y configuraci칩n de las herramientas en un entorno Windows virtualizado.
  - Est치 dise침ado para instalarse 칰nicamente en una m치quina virtual Windows, no en un host f칤sico, para permitir un an치lisis de malware seguro y contenido.
  - Proporciona un proceso de instalaci칩n, actualizaci칩n y desinstalaci칩n simplificado a trav칠s de scripts de PowerShell.
  - Permite personalizar f치cilmente las herramientas a instalar a trav칠s de una interfaz gr치fica de usuario.
  - Es un proyecto de c칩digo abierto mantenido por el equipo FLARE de Mandiant/FireEye, con contribuciones de la comunidad.
  - Enlace: https://github.com/mandiant/flare-vm
  - Video con instruciones para instalar: https://www.youtube.com/watch?v=i8dCyy8WMKY
  - Desactivar: Windows Defender through Group Policy:
    - gpedit.msc
    - En el Editor de Directiva de Grupo, navegue a la siguiente ruta: Computer Configuration > Administrative Templates > Windows Components > Windows Defender Antivirus
    - Busque la configuraci칩n "Turn off Windows Defender Antivirus" (o "Desactivar Antivirus Windows Defender" en espa침ol).
    - Haga doble clic en ella para editarla.
    - Seleccione "Enabled" (Habilitado) y haga clic en "Apply" (Aplicar) y luego en "OK".
    - Cierre el Editor de Directiva de Grupo Local.
  - Computer Configuration > Administrative Templates > Windows Components > Microsoft Defender Antivirus > Real-time Protection > Enable Turn off real-time protection
  - Instalaci칩n: Desde la carpeta del master, ejecutar con PowerShell como administrador:
    - Set-ExecutionPolicy unrestricted
    - Si falla: Set-ExecutionPolicy -Scope      CurrentUser
      - unresticted
      - ./


## 4. Configuraci칩n de VM Windows
- Download Python from https://www.python.org/downloads/. Be sure to download Python 2.7.x (such as 2.7.13); most of the scripts used in this book are written to run on the Python 2.7 version and may not run correctly on Python 3.
- Configure your Windows VM to run in Host-only network configuration mode.
- Configure the IP address of the Windows VM to 192.168.1.x (choose any IP address except 192.168.1.100 because the Linux VM is set to use that IP) and set up your Default gateway and the DNS server to the IP address of Linux VM (that is, 192.168.1.100).
- Make sure they can communicate with each other. You can check for the connectivity by running the ping command launch the Local Group Policy Editor. In the left-hand pane of Local Group Policy Editor, navigate to Computer Configuration | Administrative Templates | Windows Components | Windows Defender. In the right-hand pane, doubleclick on the Turn off Windows Defender policy to edit it; then select Enabled and click on OK.


## 5. Malware Sources
- Hybrid Analysis: https://www.hybrid-analysis.com/
- KernelMode.info: http://www.kernelmode.info/forum/viewforum.php?f=16
- VirusBay: https://beta.virusbay.io/
- Contagio malware dump: http://contagiodump.blogspot.com/
- AVCaesar: https://avcaesar.malware.lu/
- Malwr: https://malwr.com/
- VirusShare: https://virusshare.com/
- theZoo: http://thezoo.morirt.com/

You can find links to various other malware sources in Lenny Zeltser's blog post https://zeltser.com/malware-sample-sources/.


# CHAPTER 2: An치lisis est치tico
El an치lisis **est치tico es la t칠cnica de analizar el archivo sospechoso sin ejecutarlo**. Es un m칠todo de an치lisis inicial que implica extraer informaci칩n 칰til del binario sospechoso para tomar una decisi칩n informada sobre **c칩mo clasificarlo o analizarlo** y d칩nde centrar sus esfuerzos de an치lisis posteriores.

**Aprenderemos:**
- Identificar la arquitectura de destino del malware.
- Tomar huellas dactilares del malware.
- Escanear el binario sospechoso con motores antivirus.
- Extraer cadenas, funciones y metadatos asociados con el archivo.
- Identificar las t칠cnicas de ofuscaci칩n utilizadas para frustrar el an치lisis.
- Clasificaci칩n y comparaci칩n de muestras de malware.

Estas t칠cnicas pueden revelar informaci칩n diferente sobre el archivo. No es necesario seguir todas estas t칠cnicas y no es necesario seguirlas en el orden indicando anteriormente. La elecci칩n de las t칠cnicas a utilizar depende de su objetivo y del contexto que rodea el archivo sospechoso.

## 1. Determinar el tipo de fichero
Determinar el tipo de archivo de un binario sospechoso nos ayudar치 a **identificar el sistema operativo objetivo del malware** (Windows, Linux, etc.) **y la arquitectura** (plataformas de 32 o 64 bits). Por ejemplo, si el binario sospechoso tiene un tipo de archivo ejecutable port치til (PE), que es el formato de archivo para archivos ejecutables de Windows (.exe, .dll, .sys, .drv, .com, .ocx, etc.), entonces podemos deducir que el archivo est치 dise침ado para apuntar al sistema operativo Windows.

En lugar de depender de la extensi칩n del archivo, se puede utilizar **la firma del archivo para determinar el tipo de archivo.**
**Una firma de archivo es una secuencia 칰nica de bytes que se escribe en el encabezado del archivo.** Diferentes archivos tienen diferentes firmas, que pueden usarse para identificar el tipo de archivo. **Los archivos ejecutables de Windows, tambi칠n llamados archivos PE** (como los archivos que terminan en **.exe, .dll, .com, .drv, .sys**, etc.), **tienen una firma de archivo de MZ o caracteres hexadecimales 4D 5A enlos primeros dos bytes del archivo.**
![](https://web-assets.esetstatic.com/wls/2023/07/2.HxD_.jpg)

### Identificando el tipo de fichero usando un m칠todo manual
El m칠todo manual para determinar el tipo de archivo es buscar la firma del archivo abri칠ndolo en un editor hexadecimal.

En sistemas Linux, para buscar la firma del archivo se puede utilizar el comando xxd, que genera un volcado hexadecimal del archivo:
```
xxd -g 1 log.exe | more
```

### Identificando el tipo de fichero usando herramientas
- En sistemas Linux, esto se puede lograr usando la utilidad file. En el siguiente ejemplo, el comando file se ejecut칩 en dos archivos diferentes.
  - En el primer archivo que no tiene ninguna extensi칩n, se detecta como un archivo ejecutable de 32 bits (PE32)
    ```
    $ file mini
    mini: PE32 executable (GUI) Intel 80386, for MS Windows
    ```
  - En el segundo archivo es un ejecutable de 64 bits (PE32+):
    ```
    $ file notepad.exe
    notepad.exe: PE32+ executable (GUI) x86-64, for MS Windows
    ```

- En Windows: CFF Explorer, part of Explorer Suite (http://www.ntcore.com/exsuite.php), can be used to determine the file type.


### Identificando el tipo de fichero usando Python
El m칩dulo python-magic puede ser usado para identificar el tipo de fichero de un archivo.
```
$ python
Python 2.7.12 (default, Nov 19 2016, 06:48:10)
>>> import magic
>>> m = magic.open(magic.MAGIC_NONE)
>>> m.load()
>>> ftype = m.file(r'log.exe')
>>> print ftype
PE32 executable (GUI) Intel 80386, for MS Windows
```


## 2. Fingerprinting the Malware
**Checksum:**
El checksum, tambi칠n conocido como suma de verificaci칩n, es un valor calculado a partir de un conjunto de datos con el objetivo de verificar su integridad. Es una forma de asegurarse de que los datos no han sido alterados, ya sea accidentalmente o de manera malintencionada, durante la transmisi칩n o el almacenamiento.

El proceso de checksum implica aplicar un algoritmo o funci칩n matem치tica a los datos originales para producir un valor hash o una cadena de caracteres. Este valor hash es una representaci칩n compacta de los datos originales. Cuando los datos se transmiten o se almacenan junto con su checksum, cualquier parte que reciba o acceda a esos datos puede calcular de nuevo el checksum y compararlo con el valor original. Si los valores coinciden, se puede asumir que los datos no han sido modificados. Si los valores no coinciden, indica que los datos pueden haber sido corrompidos o alterados

Los checksums son ampliamente utilizados en diversas aplicaciones, como la verificaci칩n de la integridad de archivos descargados de Internet, la detecci칩n de errores en la transmisi칩n de datos y la validaci칩n de la autenticidad de la informaci칩n. Por ejemplo, al descargar un archivo, a menudo se proporciona un checksum (como SHA256sum) que el usuario puede verificar para asegurarse de que el archivo no ha sido da침ado o modificado desde que fue publicado por el creador.

Los algoritmos de checksum pueden variar en complejidad, desde simples sumas de los valores de los bytes hasta funciones hash criptogr치ficas m치s sofisticadas como SHA-256. Aunque los checksums son 칰tiles para detectar cambios en los datos, no son infalibles y no pueden garantizar la seguridad contra ataques maliciosos sofisticados, como los ataques de colisi칩n, donde dos conjuntos de datos diferentes pueden producir el mismo checksum

**Hash Collision:**
Un hash collision, o colisi칩n de hash, ocurre cuando dos piezas distintas de datos producen el mismo valor de hash al ser procesadas por una funci칩n de hash. Esto significa que, a pesar de que los datos de entrada son diferentes, el resultado de la funci칩n de hash es id칠ntico para ambos. Las funciones de hash est치n dise침adas para tomar datos de entrada de cualquier tama침o y producir un resultado de longitud fija, conocido como valor de hash, que act칰a como una representaci칩n digital de los datos originales.

Las colisiones de hash son un fen칩meno inherente a las funciones de hash debido al principio del palomar, que establece que si se tienen m치s palomas que palomares y cada paloma debe ser alojada en un palomar, al menos un palomar contendr치 m치s de una paloma. De manera similar, dado que el n칰mero de posibles entradas para una funci칩n de hash es pr치cticamente infinito, pero el n칰mero de posibles resultados de hash es finito, eventualmente debe ocurrir que dos entradas diferentes produzcan el mismo hash.

Las colisiones de hash pueden tener implicaciones significativas en varios campos, especialmente en la criptograf칤a y la seguridad inform치tica. Por ejemplo, en la autenticaci칩n de datos o en la firma digital, una colisi칩n de hash podr칤a permitir a un atacante crear datos falsificados que produzcan el mismo valor de hash que los datos originales y leg칤timos, comprometiendo as칤 la integridad de los datos.

Para mitigar el riesgo de colisiones de hash, se utilizan algoritmos de hash criptogr치ficos dise침ados para ser resistentes a colisiones, lo que significa que es computacionalmente inviable encontrar dos entradas diferentes que produzcan el mismo valor de hash. Sin embargo, no existe un algoritmo de hash que pueda garantizar completamente la ausencia de colisiones debido a las limitaciones matem치ticas y computacionales

**Fingerprinting:**
Fingerprinting involves generating the cryptographic hash values for the suspect binary based on its file content. The cryptographic hashing algorithms such as MD5, SHA1 or SHA256 are considered the de facto standard for generating file hashes for the malware specimens.

El fingerprinting de malware es el proceso de recopilar informaci칩n y caracter칤sticas distintivas de un archivo malicioso, lo que permite a los analistas de seguridad y a las herramientas de protecci칩n identificar, clasificar y entender mejor el comportamiento del malware.

**Beneficios de tomar un fingerprint de un malware:**
- Identificaci칩n 칔nica: Al igual que las huellas dactilares humanas son 칰nicas para cada individuo, el fingerprinting de malware permite identificar de manera 칰nica una muestra de malware, lo que facilita su seguimiento y detecci칩n en diferentes sistemas
- Prevenci칩n de Fraudes y Autenticaci칩n: El fingerprinting puede detectar patrones inusuales que podr칤an indicar una actividad sospechosa, como intentos de fraude o accesos no autorizados, y es una herramienta valiosa para la autenticaci칩n de usuarios y dispositivos
-Investigaci칩n y An치lisis Forense: El fingerprinting es crucial para el an치lisis forense, ya que proporciona datos detallados sobre el malware que pueden ser utilizados para entender su origen, prop칩sito y c칩mo se propaga
- Desarrollo de Firmas de Antivirus: La informaci칩n recopilada a trav칠s del fingerprinting se utiliza para desarrollar firmas que los programas antivirus pueden usar para identificar y bloquear malware conocido.


### Generando Cryptographic Hash de un malware
Este proceso te permitir치 obtener un identificador 칰nico para el archivo malicioso basado en su contenido, lo cual es 칰til para su an치lisis, identificaci칩n y comparaci칩n con bases de datos de malware conocido.
- En Windows:
  ```
  certUtil -hashfile nombreArchivo SHA256
  certUtil -hashfile nombreArchivo MD5 | SHA256 | SHA512
  Get-FileHash -Algorithm Sha256 nombreArchivo
  Get-FileHash -Algorithm MD5 | SHA256 | SHA512 nombreArchivo
  ```
- En Linux:
  ```
  sha256sum nombre_del_archivo
  ```
- En python:
  ```
  python
  Python 2.7.12 (default, Nov 19 2016, 06:48:10)
  >>> import hashlib
  >>> content = open(r"log.exe","rb").read()
  >>> print hashlib.md5(content).hexdigest()
  6e4e030fbd2ee786e1b6b758d5897316
  >>> print hashlib.sha256(content).hexdigest()
  01636faaae739655bf88b39d21834b7dac923386d2b52efb4142cb278061f97f
  >>> print hashlib.sha1(content).hexdigest()
  625644bacf83a889038e4a283d29204edc0e9b65
  ```

## 3. Multiple Anti-Virus Scanning
Escanear el binario sospechoso con varios esc치neres antivirus ayuda a determinar si existen firmas de c칩digo malicioso para el archivo sospechoso. El nombre de la firma de un archivo en particular puede proporcionar informaci칩n adicional sobre el archivo y sus capacidades. Al visitar los sitios web de los respectivos proveedores de antivirus o buscar la firma en los motores de b칰squeda, puede obtener m치s detalles sobre el archivo sospechoso. Esta informaci칩n puede ayudarle en su investigaci칩n posterior y puede reducir el tiempo de an치lisis.

### Virus Total
VirusTotal es una herramienta en l칤nea gratuita que se utiliza para analizar archivos y URLs en busca de virus, gusanos, troyanos y otros tipos de malware. La plataforma utiliza m치s de 70 motores antivirus y anti-malware para escanear y proporcionar un informe detallado sobre cualquier amenaza detectada.

Para usar VirusTotal para escanear un malware, puedes seguir estos pasos:
- Subir el Archivo o URL Sospechosa: Accede a la p치gina web de VirusTotal y selecciona la opci칩n para subir el archivo que deseas analizar o ingresa la URL que quieres verificar
- An치lisis Autom치tico: Una vez que el archivo o URL ha sido subido, VirusTotal lo analizar치 autom치ticamente utilizando sus m칰ltiples motores antivirus y te proporcionar치 un informe con los resultados
- Interpretar los Resultados: El informe incluir치 una lista de todos los motores antivirus que analizaron el archivo y sus resultados. Si alguno de los motores detecta una amenaza, el informe indicar치 el nombre de la amenaza y proporcionar치 informaci칩n adicional sobre ella
- Evaluar la Confiabilidad: Es importante tener en cuenta que aunque VirusTotal es una herramienta valiosa, no es infalible y no garantiza una protecci칩n completa contra el malware. Por lo tanto, se recomienda utilizar una variedad de herramientas de seguridad y seguir las mejores pr치cticas de seguridad cibern칠tica
- Uso de la API P칰blica: Para usuarios avanzados o para integraciones autom치ticas, VirusTotal ofrece una API p칰blica que permite enviar muestras y recibir informes de an치lisis de manera program치tica
- Herramientas Adicionales: Adem치s de la p치gina web, existen herramientas como VirusTotal Uploader y aplicaciones para dispositivos m칩viles que facilitan el env칤o de archivos y URLs a VirusTotal para su an치lisis

## Querying Hash Values Using VirusTotal
Para consultar valores de hash utilizando VirusTotal, puedes seguir estos pasos:
- Obtener un Hash de Archivo: Primero, necesitas el hash del archivo que deseas consultar. Los hashes permitidos son MD5, SHA1 y SHA256
- Acceder a VirusTotal: Ve a la p치gina web de VirusTotal (https://www.virustotal.com/).
- Ingresar el Hash en la B칰squeda: Utiliza la barra de b칰squeda de VirusTotal para ingresar el hash del archivo. Aseg칰rate de que el hash corresponda a uno de los formatos permitidos (MD5, SHA1, SHA256).
- Revisar el Informe: Despu칠s de buscar el hash, VirusTotal te mostrar치 el 칰ltimo informe disponible para ese archivo. Si el archivo ha sido analizado previamente, podr치s ver los resultados de los diferentes motores antivirus y otra informaci칩n relevante
- Uso de la API de VirusTotal: Si prefieres automatizar el proceso o realizar consultas en masa, puedes utilizar la API p칰blica de VirusTotal. Necesitar치s una clave API que puedes obtener creando una cuenta en VirusTotal.
- Ejemplo de Uso de la API con cURL:
  ```
  curl --request POST \
  --url 'https://www.virustotal.com/vtapi/v2/file/report' \
  -d apikey=$your-api-key \
  -d 'resource=$your-file-hash'
  ```
  Reemplaza $your-api-key con tu clave API y $your-file-hash con el hash del archivo que deseas consultar.
  
- Ejemplo de Uso de la API con Python:
  ```
  python
  import requests
  
  url = 'https://www.virustotal.com/vtapi/v2/file/report'
  params = {'apikey': 'tu_clave_api', 'resource': 'hash_del_archivo'}
  response = requests.post(url, data=params)
  print(response.json())
  ```
  Reemplaza 'tu_clave_api' con tu clave API y 'hash_del_archivo' con el hash del archivo que deseas consultar.
  
Nota: La API p칰blica de VirusTotal tiene una limitaci칩n de cuatro consultas por minuto. Si necesitamos realizar un mayor volumen de consultas o acceder a informaci칩n m치s detallada, tendremos que considerar usar la API privada de VirusTotal o el servicio premium VirusTotal Intelligence.


- Otro script:
  ```
  import urllib
  import urllib2
  import json
  import sys

  hash_value = sys.argv[1]
  vt_url = "https://www.virustotal.com/vtapi/v2/file/report"
  api_key = "<update your api key here>"
  parameters = {'apikey': api_key, 'resource': hash_value}
  encoded_parameters = urllib.urlencode(parameters)
  request = urllib2.Request(vt_url, encoded_parameters)
  response = urllib2.urlopen(request)
  json_response = json.loads(response.read())
  if json_response['response_code']:
    detections = json_response['positives']
    total = json_response['total']
    scan_results = json_response['scans']
    print "Detections: %s/%s" % (detections, total)
    print "VirusTotal Results:"
    for av_name, av_data in scan_results.items():
      print "\t%s ==> %s" % (av_name, av_data['result'])
  else:
    print "No AV Detections For: %s" % hash_value
  ```
  Running the preceding script by giving it an MD5 hash of a binary shows the antivirus detections and the signature names for the binary.
  ```
  md5sum 5340.exe
  5340fcfb3d2fa263c280e9659d13ba93 5340.exe

  python vt_hash_query.py 5340fcfb3d2fa263c280e9659d13ba93
  Detections: 44/56
  VirusTotal Results:
     Bkav ==> None
     MicroWorld-eScan ==> Trojan.Generic.11318045
     nProtect ==> Trojan/W32.Agent.105472.SJ
     CMC ==> None
     CAT-QuickHeal ==> Trojan.Agen.r4
     ALYac ==> Trojan.Generic.11318045
     Malwarebytes ==> None
     Zillya ==> None
     SUPERAntiSpyware ==> None
     TheHacker ==> None
     K7GW ==> Trojan ( 001d37dc1 )
     K7AntiVirus ==> Trojan ( 001d37dc1 )
     NANO-Antivirus ==> Trojan.Win32.Agent.cxbxiy
     F-Prot ==> W32/Etumbot.K
     Symantec ==> Trojan.Zbot
     [.........Removed..............]

  ```
  
- Usando la herramienta PEstudio (https://www.winitor.com/) o la herramienta PPEE (https://www.mzrst.com/).
- Online scanners such as VirSCAN (http://www.virscan.org/), Jotti Malware Scan (https://virusscan.jotti.org/), and OPSWAT's Metadefender (https://www.metadefender.com/#!/scan-file) allow you to scan a suspect file with multiple anti-virus scanning engines, and some of them also allow you to do hash lookups.
- Consideracuiones a tener en cuenta cuando subimos un binario a un scanner online: Aunque los esc치neres antivirus y los servicios de escaneo en l칤nea son herramientas 칰tiles para identificar malware, existen limitaciones y riesgos asociados con su uso. Es crucial ser consciente de estos riesgos, especialmente en lo que respecta a la confidencialidad de la informaci칩n y la posibilidad de que los atacantes adapten sus m칠todos para evadir la detecci칩n.
  - Detecci칩n no garantizada: Los autores de malware pueden modificar su c칩digo y emplear t칠cnicas de ofuscaci칩n para evadir estas detecciones, lo que puede resultar en que algunos motores antivirus no logren identificar el archivo como malicioso. Esto se debe a que las t칠cnicas de ofuscaci칩n y metamorfismo pueden cambiar la apariencia del c칩digo malicioso sin alterar su funcionalidad, dificultando su detecci칩n basada en firmas.
  - Riesgos de compartir binarios: Al subir un archivo binario a un sitio p칰blico, existe el riesgo de que este archivo se comparta con terceros y proveedores. Si el archivo binario contiene informaci칩n sensible, personal o propiedad de una organizaci칩n, no es recomendable enviarlo a servicios p칰blicos de escaneo antivirus, especialmente si es parte de una investigaci칩n confidencial. Esto se debe a que el archivo podr칤a contener datos cr칤ticos que no deber칤an ser expuesto.
  - Uso de valores hash criptogr치ficos: Como alternativa a la presentaci칩n del archivo binario, la mayor칤a de los servicios de escaneo antivirus en l칤nea permiten buscar en su base de datos de archivos escaneados utilizando valores hash criptogr치ficos (MD5, SHA1 o SHA256). Esto significa que en lugar de subir el archivo completo, se puede buscar utilizando el hash criptogr치fico del archivo, lo que reduce el riesgo de exponer informaci칩n sensible.


  
## 4. Extracting Strings
La extracci칩n de cadenas de un fichero ejecutable es un proceso utilizado en el an치lisis de malware y en la ingenier칤a inversa de software para **identificar y extraer secuencias de caracteres legibles (cadenas) dentro de un archivo binario**. Este proceso es fundamental para entender el comportamiento potencial de un programa sin necesidad de ejecutarlo o analizar su c칩digo fuente, que puede no estar disponible. Las cadenas pueden incluir rutas de archivos, mensajes de error, URLs de servidores de comando y control (C&C), claves de cifrado, y otros indicadores de compromiso (IoCs) que son 칰tiles para el an치lisis de seguridad.

Las **cadenas son secuencias de caracteres imprimibles en ASCII y Unicode incrustadas en un archivo.**
La extracci칩n de cadenas puede dar pistas sobre la funcionalidad del programa y los indicadores asociados con un binario sospechoso. Por ejemplo, si un malware crea un archivo, el nombre del archivo se almacena como una cadena en el binario. Tambi칠n si un malware resuelve un nombre de dominio controlado por el atacante, entonces el nombre de dominio se almacena como una cadena. Las cadenas extra칤das del binario pueden contener **referencias a nombres de archivos, URL, nombres de dominio, direcciones IP, comandos de ataque, claves de registro, etc**. Aunque las cadenas no dan una idea clara del prop칩sito y la capacidad de un archivo, pueden dar una **pista sobre lo que el malware es capaz de hacer.**


### 4.1 Extraer Cadenas usando herramientas
**Herramientas para la extracci칩n de cadenas de archivos ejecutables:**
- Strings: Disponible en sistemas Unix y Windows, es una herramienta de l칤nea de comandos que busca secuencias de caracteres ASCII o Unicode que son al menos de una longitud m칤nima especificada (por defecto, 4 caracteres). El comando strings, por defecto, extrae las cadenas ASCII que tienen al menos cuatro caracteres de largo. Con la opci칩n -a es posible extraer cadenas de todo el archivo.
  ```
  strings -a log.exe
  ```
  Espec칤menes de malware tambi칠n utilizan cadenas Unicode (2 bytes por car치cter). Para obtener informaci칩n 칰til del binario, a veces necesitas extraer tanto cadenas ASCII como Unicode. Para extraer cadenas Unicode usando el comando strings, usamos la opci칩n -el.
  ```
  strings -a -el log.exe
  ```

- Binwalk: Aunque es m치s conocida por su capacidad para analizar y extraer firmware, tambi칠n puede ser utilizada para extraer cadenas.
- HEx Editors: Permiten visualizar y editar el contenido binario de un archivo, incluyendo la extracci칩n manual de cadenas.
- En Windows, pestudio (https://www.winitor.com) es una herramienta 칰til que muestra cadenas ASCII y Unicode. pestudio es una excelente herramienta de an치lisis de PE para realizar pruebas iniciales evaluaci칩n de malware de un binario sospechoso y est치 dise침ado para recuperar varios elementos 칰tiles.
- Tambi칠n en windows se puede usar el comando strings de sysinternals y PPEE (https://www.mzrst.com/).


**Proceso de Extracci칩n:** La herramienta seleccionada lee el archivo binario y busca secuencias de caracteres que coincidan con patrones de cadenas legibles. Estas cadenas se extraen y se presentan al analista para su revisi칩n.

**An치lisis de las Cadenas:** Una vez extra칤das, las cadenas pueden ser analizadas para buscar informaci칩n relevante que pueda indicar el prop칩sito del archivo ejecutable, incluyendo:
  - Direcciones IP y URLs que pueden se침alar a servidores de C&C.
  - Rutas de archivos espec칤ficos que el malware intenta modificar o leer.
  - Mensajes de error o logs que el malware genera.
  - Referencias a librer칤as espec칤ficas o llamadas al sistema que indican c칩mo interact칰a el malware con el sistema operativo.



### 4.2 Decoding Obfuscated Strings Using FLOSS
La mayor칤a de las veces, los autores de malware utilizan t칠cnicas simples de ofuscaci칩n de cadenas para evitar la detecci칩n. En tales casos, esas cadenas ofuscadas no aparecer치n en la utilidad de cadenas ni en otras herramientas de extracci칩n de cadenas. **FireEye Labs Ofuscated String Solver (FLOSS)** es una herramienta dise침ada para **identificar y extraer autom치ticamente cadenas ofuscadas de malware**. Puede ayudarle a determinar las cadenas que los autores de malware quieren ocultar de las herramientas de extracci칩n de cadenas.

FLOSS tambi칠n se puede utilizar como la utilidad de cadenas para **extraer cadenas legibles por humanos (ASCII y Unicode)**. Puede descargar FLOSS para Windows o Linux desde https://github.com/fireeye/flare-floss.
```
sudo apt install python3-venv python3-full
mkdir ~/miENV
python3.12 -m venv miENV


git clone https://github.com/mandiant/flare-floss.git
cd flare-floss
python setup.py install
```


Otra forma de instalar flare-floss en linux:
```
python3.11 -m venv venv
source venv/bin/activate
pip3.11 install flare-floss
floss program.exe > analisis-floss.txt
```



En el siguiente ejemplo, no s칩lo se han extraido las cadenas legibles por humanos, sino que tambi칠n decodific칩 las cadenas ofuscadas y extrajo las cadenas de la pila que la utilidad de cadenas y otras herramientas de extracci칩n de cadenas no detectaron. El siguiente resultado muestra una referencia a un ejecutable, un archivo de Excel y una clave de registro de ejecuci칩n:
```
$ chmod +x floss
$ ./floss 5340.exe
FLOSS static ASCII strings
!This program cannot be run in DOS mode.
Rich
.text
`.rdata
@.data
[..removed..]
FLOSS decoded 15 strings
kb71271.log
R6002
- floating point not loaded
\Microsoft
winlogdate.exe
~tasyd3.xls
[....REMOVED....]
FLOSS extracted 13 stack strings
BINARY
ka4a8213.log
afjlfjsskjfslkfjsdlkf
'Clt
~tasyd3.xls
"%s"="%s"
regedit /s %s
[HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Run]
[.....REMOVED......]
```

Si solo est치 interesado en las **cadenas decodificadas/apiladas y desea excluir las cadenas est치ticas (ASCII y Unicode)** de la salida FLOSS, proporcione el modificador --no-static-strings.

https://www.mandiant.com/resources/blog/automatically-extracting-obfuscated-strings


**An치lisis de los Resultados:** FLOSS mostrar치 las cadenas ofuscadas que ha logrado identificar y extraer. Estas cadenas pueden incluir direcciones IP, URLs, nombres de dominio, claves de cifrado, y otros datos que el malware utiliza en sus operaciones. Es importante analizar estas cadenas en el contexto del comportamiento general del malware para entender su prop칩sito y c칩mo interact칰a con los sistemas infectados.
- Cadenas ASCII Est치ticas: Estas son cadenas de texto que se pueden leer directamente en el archivo binario y no est치n ofuscadas. Por ejemplo, la cadena "!This program cannot be run in DOS mode." es t칤pica en los archivos ejecutables de Windows y no es indicativa de actividad maliciosa por s칤 misma.
- Cadenas Decodificadas: FLOSS ha decodificado 15 cadenas que estaban ofuscadas en el archivo. Estas pueden incluir nombres de archivos de registro como "kb71271.log", mensajes de error como "R6002 - floating point not loaded", o referencias a directorios del sistema como "\Microsoft". Estas cadenas pueden ser pistas sobre la funcionalidad del malware, como los archivos que intenta crear o modificar, o errores que maneja.
- Cadenas Extra칤das de la Pila (Stack Strings): Estas son cadenas que FLOSS ha identificado y extra칤do de la memoria de la pila durante la ejecuci칩n del malware. Por ejemplo, "ka4a8213.log" podr칤a ser otro archivo de registro, y "~tasyd3.xls" podr칤a ser un archivo que el malware busca o genera. La cadena "%s"="%s" sugiere una operaci칩n de formato o asignaci칩n, y "regedit /s %s" indica que el malware podr칤a estar intentando modificar el registro de Windows de forma silenciosa.
- Cadenas Relacionadas con la Persistencia: La referencia a "[HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Run]" es particularmente significativa, ya que esta ubicaci칩n del registro se utiliza com칰nmente para configurar programas que se ejecutan autom치ticamente al iniciar sesi칩n en Windows. Esto podr칤a indicar que el malware intenta establecer persistencia en el sistema infectado.

Al analizar estos resultados, es importante **considerar el contexto y la funcionalidad potencial que las cadenas podr칤an representar** dentro del malware. Por ejemplo:
- Cadenas de Archivos y Directorios: Pueden indicar los archivos y directorios con los que el malware interact칰a.
- Mensajes de Error: Pueden revelar las funciones del sistema que el malware intenta utilizar y c칩mo maneja las condiciones de error.
- Comandos del Sistema: Como "regedit /s %s", pueden sugerir intentos de modificar la configuraci칩n del sistema para lograr objetivos maliciosos.
- Referencias al Registro de Windows: Pueden indicar intentos de lograr la persistencia o modificar la configuraci칩n del sistema para beneficio del malware.



## 5. Determining File Obfuscation
Aunque la extracci칩n de cadenas es una t칠cnica excelente para obtener informaci칩n valiosa, a menudo los autores de malware ofuscan o blindan su binario de malware. La ofuscaci칩n es utilizada por los autores de malware para proteger el funcionamiento interno del malware de los investigadores de seguridad, analistas de malware e ingenieros inversos. Estas t칠cnicas de ofuscaci칩n dificultan la detecci칩n/analizaci칩n del binario; extraer las cadenas de tal binario resulta en muy pocas cadenas, y la mayor칤a de las cadenas est치n oscurecidas. Los autores de malware a menudo usan programas como Empaquetadores y Encriptadores para ofuscar su archivo con el fin de evadir la detecci칩n de productos de seguridad tales como antivirus y para impedir el an치lisis.

### 5.1 Packers and Cryptors
- Los ejecutables tienen lo que se llama un **punto de entrada (ENTRY POINT)**. Cuando se ejecuta, este punto de entrada es simplemente la ubicaci칩n de las primeras piezas de c칩digo que se van a ejecutar dentro del archivo, como se ilustra a continuaci칩n:
  
  ![](capturas/entry-point.png)

- Cuando un ejecutable est치 empaquetado, debe desempaquetarse antes de que se pueda ejecutar cualquier c칩digo. Debido a esto, los packers cambian el punto de entrada desde la ubicaci칩n original a lo que se llama el "Unpacking Stub".
  ![](capturas/unpacking-stub.png)

- El "Unpacking Stub" comenzar치 a desempaquetar el ejecutable a su estado original. Una vez que el programa est칠 completamente desempaquetado, el punto de entrada se reubicar치 de nuevo a su lugar normal para comenzar a ejecutar el c칩digo:
  ![](capturas/unpacking-stub-2.png)

- Solo en este punto un analista puede comenzar a entender lo que el ejecutable est치 haciendo, ya que ahora est치 en su forma verdadera y original.

- Un Empaquetador es un programa que toma el ejecutable como entrada y utiliza la compresi칩n para ofuscar el contenido del ejecutable. Este contenido ofuscado se almacena entonces dentro de la estructura de un nuevo archivo ejecutable; el resultado es un nuevo archivo ejecutable (programa empaquetado) con contenido ofuscado en el disco. Al ejecutar el programa empaquetado, ejecuta una rutina de descompresi칩n, que extrae el binario original en la memoria durante el tiempo de ejecuci칩n y desencadena la ejecuci칩n.

- Un Encriptador es similar a un Empaquetador, pero en lugar de usar compresi칩n, utiliza encriptaci칩n para ofuscar el contenido del ejecutable, y el contenido encriptado se almacena en el nuevo archivo ejecutable. Al ejecutar el programa encriptado, ejecuta una rutina de desencriptaci칩n para extraer el binario original en la memoria y luego desencadena la ejecuci칩n.

- Formas de saber que un ejecutable est치 empaquetado:
  - El ejecutable puede tener secciones con nombres de ciertos packers como UPX.
  - Uso de Herramientas de An치lisis de Malware: Herramientas como PEiD (Virustotal detecta malware), Exeinfo PE, RDG Packer Detector, y Die (Detect It Easy) son espec칤ficamente dise침adas para identificar empaquetadores, compiladores y protectores utilizados en archivos ejecutables. Estas herramientas analizan el archivo y, bas치ndose en una base de datos de firmas de empaquetadores conocidos, pueden indicar si el archivo ha sido empaquetado y, en muchos casos, identificar el empaquetador espec칤fico utilizado.
  - An치lisis de la Entrop칤a: Los archivos empaquetados suelen tener una alta entrop칤a, lo que indica una distribuci칩n aleatoria de los bytes debido a la compresi칩n o cifrado. Herramientas de an치lisis de malware y editores hexadecimales pueden calcular la entrop칤a de un archivo y, si es inusualmente alta, esto puede ser un indicador de empaquetamiento.  - Inspecci칩n de la Tabla de Importaciones: Los empaquetadores suelen modificar la tabla de importaciones de un archivo PE (Portable Executable). Al analizar la tabla de importaciones con herramientas como CFF Explorer o PEStudio, se puede observar si muestra un conjunto reducido o inusual de importaciones, lo que puede sugerir que el archivo ha sido empaquetado. 
  - B칰squeda de Cadenas y Secciones Inusuales: Algunos empaquetadores agregan secciones con nombres inusuales al archivo PE o dejan cadenas dentro del archivo que indican el uso de un empaquetador. La inspecci칩n manual con editores hexadecimales o el uso de herramientas de an치lisis que buscan estas caracter칤sticas pueden revelar indicios de empaquetamiento.
  - An치lisis Heur칤stico: Algunas soluciones de seguridad avanzadas utilizan an치lisis heur칤sticos para identificar comportamientos t칤picos de archivos empaquetados, como la ejecuci칩n de un stub de desempaquetamiento en tiempo de ejecuci칩n

Para demostrar el concepto de ofuscaci칩n de archivos, tomemos un ejemplo de una muestra de malware llamada Spybot (no empaquetada); la extracci칩n de cadenas de Spybot muestra referencias a nombres de ejecutables sospechosos y direcciones IP, como se muestra aqu칤:

```
$ strings -a spybot.exe
[....removed....]
EDU_Hack.exe
Sitebot.exe
Winamp_Installer.exe
PlanetSide.exe
DreamweaverMX_Crack.exe
FlashFXP_Crack.exe
Postal_2_Crack.exe
Red_Faction_2_No-CD_Crack.exe
Renegade_No-CD_Crack.exe
Generals_No-CD_Crack.exe
Norton_Anti-Virus_2002_Crack.exe
Porn.exe
AVP_Crack.exe
zoneallarm_pro_crack.exe
[...REMOVED...]
209.126.201.22
209.126.201.20
```

UPX, que se encuentra en https://upx.github.io/, es un empaquetador de ejecutables. UPX (Ultimate Packer for eXecutables) es una herramienta de c칩digo abierto y gratuita dise침ada para comprimir archivos ejecutables. Su objetivo principal es reducir el tama침o de los archivos ejecutables (binarios), lo que puede ser 칰til para ahorrar espacio en disco y reducir los tiempos de carga en sistemas con recursos limitados. Empaquetamos y volvemos a comprobar los strings, observando que ya no se muestra mucha informaci칩n:

```
$ upx -o spybot_packed.exe spybot.exe
Ultimate Packer for eXecutables
Copyright (C) 1996 - 2013
UPX 3.91 Markus Oberhumer, Laszlo Molnar & John Reiser Sep 30th 2013
File size Ratio Format Name
-------------------- ------ ----------- -----------
44576 -> 21536 48.31% win32/pe spybot_packed.exe
Packed 1 file.

$ strings -a spybot_packed.exe
!This program cannot be run in DOS mode.
UPX0
UPX1
.rsrc
3.91
UPX!
t ;t
/t:VU
]^M
9-lh
:A$m
hAgo .
C@@f.
Q*vPCi
%_I;9
PVh29A
[...REMOVED...]
```

UPX is a common packer, and many times you will come across malware samples packed with UPX. In most cases, it is possible to unpack the sample using the -d option. An example command is
```
upx -d -o spybot_unpacked.exe spybot_packed.exe.
```


### 5.2 Detecting File Obfuscation Using Exeinfo PE
La mayor칤a de los ejecutables leg칤timos no ofuscan su contenido, pero algunos ejecutables pueden hacerlo para evitar que otros examinen su c칩digo. Cuando te encuentres con una muestra que est치 empaquetada, hay una alta probabilidad de que sea maliciosa. Para detectar empaquetadores en Windows, puedes usar una herramienta gratuita como Exeinfo PE (http://exeinfo.atwebpages.com/).


Other CLI and GUI tools that can help you with packer detections include TrID (http://mark0.net/soft-trid-e.html), TRIDNet (http://mark0.net/soft-tridnet-e.html), Detect It Easy (http://ntinfo.biz/), RDG Packer Detector (http://www.rdgsoft.net/), packerid.py (https://github.com/sooshie/packerid), and PEiD (http://www.softpedia.com/get/Programming/Packers-Crypters-Protectors/PEiD-updated.shtml).


## 6. Inspecting PE Header Information
- Los ejecutables tienen lo que se llama un **punto de entrada (ENTRY POINT)**. Cuando se ejecuta, este punto de entrada es simplemente la ubicaci칩n de las primeras piezas de c칩digo que se van a ejecutar dentro del archivo, como se ilustra a continuaci칩n:
  
  ![](capturas/entry-point.png)

- Los ejecutables de Windows deben ajustarse al formato **PE/COFF (Portable Executable/Common Object File Format).** El formato de archivo PE es utilizado por los archivos ejecutables de Windows (tales como .exe, .dll, .sys, .ocx y .drv) y tales archivos generalmente se denominan archivos Portable Executable (PE). El archivo PE es una serie de estructuras y subcomponentes que contienen la informaci칩n requerida por el sistema operativo para cargarlo en la memoria.
- Cuando un ejecutable se compila, incluye un encabezado (encabezado PE), que describe su estructura. Cuando se ejecuta el binario, el cargador del sistema operativo lee la informaci칩n del encabezado PE y luego carga el contenido binario del archivo en la memoria. El encabezado PE contiene informaci칩n como d칩nde necesita ser cargado el ejecutable en la memoria, la direcci칩n donde comienza la ejecuci칩n, la lista de bibliotecas/funciones en las que se basa la aplicaci칩n, y los recursos utilizados por el binario. Examinar el encabezado PE proporciona una gran cantidad de informaci칩n sobre el binario y sus funcionalidades.
- Inspecting PE Header Information se refiere a examinar la informaci칩n contenida en el encabezado de un archivo ejecutable Portable Executable (PE) en sistemas Windows. El encabezado PE es una estructura de datos importante que contiene informaci칩n esencial sobre c칩mo el sistema operativo debe cargar y manejar el archivo ejecutable o la biblioteca de enlace din치mico (DLL).
- La **entrop칤a de un archivo** es una medida de la cantidad de aleatoriedad o incertidumbre que contiene. En el contexto de un Ejecutable Port치til (PE), una alta entrop칤a puede ser indicativa de que el archivo ha sido comprimido o cifrado, lo cual es una t칠cnica com칰nmente utilizada por el malware para ocultar su c칩digo y evitar la detecci칩n por parte de herramientas de seguridad. Por lo tanto, la entrop칤a es una caracter칤stica prominente que las herramientas de an치lisis de malware buscan al evaluar la sospechosidad de un archivo. Si un archivo PE tiene una entrop칤a inusualmente alta, podr칤a ser un indicador de que contiene c칩digo malicioso o que ha sido manipulado para esconder su verdadera naturaleza. La entrop칤a de un archivo es una clasificaci칩n que califica qu칠 tan aleatorios son los datos dentro de un archivo PE. Con una escala del 0 al 8, donde 0 significa menos "aleatoriedad" de los datos en el archivo, y un puntaje hacia 8 indica que estos datos son m치s "aleatorios".
- Los autores de malware utilizan t칠cnicas como la encriptaci칩n o el empaquetado para ofuscar su c칩digo e intentar eludir el antivirus. Debido a esto, estos archivos tendr치n una entrop칤a alta.
- Cuando **inspeccionas el encabezado PE, generalmente buscas detalles como:**
  - Tipo de Archivo: Determinar si el archivo es un ejecutable, una DLL, un controlador del sistema, entre otros.
  - Punto de Entrada: La ubicaci칩n en el c칩digo donde el sistema operativo comienza a ejecutar el programa.
  - Secciones del Archivo: Informaci칩n sobre las diferentes secciones del archivo, como c칩digo, datos y recursos.
  - Dependencias de la Biblioteca: Qu칠 otras bibliotecas (DLLs) necesita el ejecutable para funcionar.
  - Informaci칩n de la Plataforma: Para qu칠 arquitectura de hardware est치 dise침ado el archivo (por ejemplo, x86, x64).
  - Firmas Digitales: Para verificar la autenticidad y la integridad del archivo.

- **Resources for understanding the PE file structure:**
  - An In-Depth Look into the Win32 Portable Executable File Format - Part 1:
  http://www.delphibasics.info/home/delphibasicsarticles/anindepthlookintothewin32portableexecutablefileformat-part1
  - An In-Depth Look into the Win32 Portable Executable File Format - Part 2:
  http://www.delphibasics.info/home/delphibasicsarticles/anindepthlookintothewin32portableexecutablefileformat-part2
  - PE Headers and structures: http://www.openrce.org/reference_library/files/reference/PE%20Format.pdf
  - PE101 - A Windows Executable Walkthrough: https://github.com/corkami/pics/blob/master/binary/pe101/pe101.pdf

- **Tools that allow you to examine and modify the PE structure and its sub-components:**
  - CFF Explorer: http://www.ntcore.com/exsuite.php
  - PE Internals: http://www.andreybazhan.com/pe-internals.html
  - PPEE(puppy): https://www.mzrst.com/
  - PEBrowse Professional: http://www.smidgeonsoft.prohosting.com/pebrowsepro-file-viewer.html


- A tool such as **pestudio** (https://www.winitor.com) or **PPEE** (puppy: https://www.mzrst.com/) can assist you with exploring interesting artifacts from the PE file.

- **Comando pecheck:** El comando pecheck es una herramienta de an치lisis de archivos PE (Portable Executable) desarrollada por Didier Stevens. Cuando se ejecuta pecheck en un archivo PE, la herramienta examina el archivo y proporciona un informe que incluye informaci칩n sobre las siguientes estructuras y elementos:
  - DOS Header: La cabecera inicial que est치 presente para mantener la compatibilidad con aplicaciones DOS antiguas.
  - PE Header: La cabecera que sigue al DOS Header y contiene metadatos esenciales sobre el archivo ejecutable, como la arquitectura de la m치quina para la que est치 compilado (x86, x64, etc.) y los puntos de entrada del programa.
  - Optional Header: Una secci칩n del PE Header que proporciona informaci칩n adicional necesaria para la carga del ejecutable, como la direcci칩n base de la imagen, la alineaci칩n de las secciones y el punto de entrada del programa.
  - Section Headers: Las cabeceras de las secciones del archivo que describen c칩mo se organizan los datos y el c칩digo dentro del archivo PE.
  - Data Directories: Partes del Optional Header que contienen punteros a estructuras de datos importantes como la tabla de importaciones y exportaciones, recursos y m치s.

- **Utilidad pe-tree:** pe-tree es una herramienta de an치lisis de archivos Portable Executable (PE) dise침ada para proporcionar una vista estructurada y jer치rquica de los componentes internos de los archivos PE.
  - Vista Jer치rquica: pe-tree presenta la informaci칩n del archivo PE en una estructura de 치rbol, lo que permite a los usuarios expandir y colapsar secciones para explorar detalles espec칤ficos de manera eficiente. Esto incluye cabeceras, secciones, tablas de importaci칩n/exportaci칩n, recursos y m치s.
  - An치lisis de Secciones y Cabeceras: La herramienta analiza y muestra informaci칩n detallada sobre las cabeceras PE, incluyendo el DOS Header, PE Header, Optional Header, y Section Headers. Esto es crucial para entender la configuraci칩n y el comportamiento potencial del archivo.
  - Identificaci칩n de Anomal칤as: pe-tree puede ayudar a identificar caracter칤sticas inusuales o sospechosas en los archivos PE, como secciones ocultas, configuraciones an칩malas en las cabeceras, o firmas digitales inv치lidas.
  - Integraci칩n con Herramientas de An치lisis de Malware: pe-tree puede integrarse con otras herramientas y plataformas de an치lisis de malware para proporcionar una visi칩n m치s completa del archivo analizado. Esto puede incluir la extracci칩n y an치lisis de cadenas, as칤 como la identificaci칩n de patrones de c칩digo malicioso.


- **Analazing PE Header en windows con CFF Explorer:** https://ntcore.com/explorer-suite/


### 6.1 Inspecci칩n de Dependencias de Archivos e Importaciones
Generalmente, el malware interact칰a con archivos, registro, red, etc. Para realizar dichas interacciones, el malware depende frecuentemente de las funciones expuestas por el sistema operativo. Windows exporta la mayor칤a de sus funciones, llamadas Interfaces de Programaci칩n de Aplicaciones (API), requeridas para estas interacciones en archivos de Biblioteca de Enlace Din치mico (DLL). Los ejecutables importan y llaman a estas funciones t칤picamente de varias DLL que proporcionan diferentes funcionalidades. Las funciones que un ejecutable importa de otros archivos (principalmente DLL) se denominan funciones importadas (o importaciones).

Por ejemplo, si un ejecutable de malware quiere crear un archivo en el disco, en Windows, puede usar una API CreateFile(), que se exporta en kernel32.dll. Para llamar a la API, primero tiene que cargar kernel32.dll en su memoria y luego llamar a la funci칩n CreateFile().

Inspeccionar las DLL en las que conf칤a un malware y las funciones API que importa de las DLL puede dar una idea sobre la funcionalidad y capacidad del malware y qu칠 anticipar durante su ejecuci칩n. Las dependencias de archivos en ejecutables de Windows se almacenan en la tabla de importaciones de la estructura del archivo PE.


Sometimes you might want to use Python to enumerate DLL files and imported functions (probably to work with a large number of files); this can be done using Ero Carerra's pefile module (https://github.com/erocarrera/pefile). The installation of the pefile module on Ubuntu Linux VM was covered in Chapter 1, Introduction to Malware Analysis. If you are using any other operating system, then it can be installed using pip (pip install pefile). The following Python script demonstrates the use of the pefile module to enumerate the DLLs and the imported API functions:

```
import pefile
import sys
mal_file = sys.argv[1]
pe = pefile.PE(mal_file)
if hasattr(pe, 'DIRECTORY_ENTRY_IMPORT'):
    for entry in pe.DIRECTORY_ENTRY_IMPORT:
        print "%s" % entry.dll
    for imp in entry.imports:
        if imp.name != None:
            print "\t%s" % (imp.name)
        else:
            print "\tord(%s)" % (str(imp.ordinal))
            print "\n"
```

The following is the result of running the preceding script against the spybot_packed.exe sample; from the output, you can see the list of DLLs and imported functions:
```
$ python enum_imports.py spybot_packed.exe
KERNEL32.DLL
 LoadLibraryA
 GetProcAddress
 VirtualProtect
 VirtualAlloc
 VirtualFree
 ExitProcess
ADVAPI32.DLL
 RegCloseKey
CRTDLL.DLL
 atoi
[...REMOVED....]
```

### 6.2 Inspecting Exports
El ejecutable y la DLL pueden exportar funciones, que pueden ser utilizadas por otros programas. T칤picamente, una DLL exporta funciones (exportaciones) que son importadas por el ejecutable. Una DLL no puede funcionar por s칤 sola y depende de un proceso anfitri칩n para ejecutar su c칩digo. Un atacante a menudo crea una DLL que exporta funciones que contienen funcionalidad maliciosa. Para ejecutar las funciones maliciosas dentro de la DLL, de alguna manera se hace que sea cargada por un proceso que llama a estas funciones maliciosas. Las DLL tambi칠n pueden importar funciones de otras bibliotecas (DLL) para realizar operaciones del sistema.
Inspeccionar las funciones exportadas puede darte una idea r치pida de las capacidades de la DLL. En el siguiente ejemplo, al cargar una DLL asociada con malware llamado Ramnit en pestudio, se muestran sus funciones exportadas, dando una indicaci칩n de sus capacidades. Cuando un proceso carga esta DLL, en alg칰n momento, estas funciones ser치n llamadas para realizar actividades maliciosas:


In Python, the exported functions can be enumerated using the pefile module, as shown here:
```
$ python
Python 2.7.12 (default, Nov 19 2016, 06:48:10)
>>> import pefile
>>> pe = pefile.PE("rmn.dll")
>>> if hasattr(pe, 'DIRECTORY_ENTRY_EXPORT'):
... for exp in pe.DIRECTORY_ENTRY_EXPORT.symbols:
... print "%s" % exp.name
...
AddDriverPath
AddRegistryforME
CleanupDevice
CleanupDevice_EX
CreateBridgeRegistryfor2K
CreateFolder
CreateKey
CreateRegistry
DeleteDriverPath
DeleteOemFile
DeleteOemInfFile
DeleteRegistryforME
DuplicateFile
EditRegistry
EnumerateDevice
GetOS
[.....REMOVED....]
```

### 6.3 Examining PE Section Table And Sections
El contenido real del archivo PE est치 dividido en secciones. Estas secciones son inmediatamente seguidas por el encabezado PE. Estas secciones representan ya sea c칩digo o datos y tienen atributos en memoria como lectura/escritura. La secci칩n que representa c칩digo contiene instrucciones que ser치n ejecutadas por el procesador, mientras que la secci칩n que contiene datos puede representar diferentes tipos de datos, como datos de programa de lectura/escritura (variables globales), tablas de importaci칩n/exportaci칩n, recursos, etc. Cada secci칩n tiene un nombre distintivo que transmite el prop칩sito de la secci칩n.

**Secciones en un PE File:**
- .text || CODE: Contiene el c칩digo ejecutable. Tiene un atributo de lectura-ejecuci칩n.
- .data || DATA: Contiene datos y variables globales. Tiene un atributo de lectura-escritura.
- .rdata: Contiene datos de solo lectura. A veces tambi칠n contiene informaci칩n de importaci칩n y exportaci칩n.
- .idata: Si est치 presente, contiene la tabla de importaci칩n. Si no est치 presente, entonces la informaci칩n de importaci칩n se almacena en la secci칩n .rdata.
- .edata: Si est치 presente, contiene informaci칩n de exportaci칩n. Si no est치 presente, entonces la informaci칩n de exportaci칩n se encuentra en la secci칩n .rdata.
- .rsrc: Esta secci칩n contiene los recursos utilizados por el ejecutable, como 칤conos, di치logos, men칰s, cadenas, y as칤 sucesivamente.


Estos nombres de secci칩n son principalmente para humanos y no son utilizados por el sistema operativo, lo que significa que **es posible para un atacante o un software de ofuscaci칩n crear secciones con nombres diferentes.** Si nos encuentramos con nombres de secci칩n que no son comunes, entonces debemos tratarlos con sospecha, y se requiere un an치lisis adicional para confirmar su malicia. La informaci칩n sobre estas secciones (como el nombre de la secci칩n, d칩nde encontrar la secci칩n y sus caracter칤sticas) est치 presente en la tabla de secciones en el encabezado PE. Examinar una tabla de secciones proporcionar치 informaci칩n sobre la secci칩n y sus caracter칤sticas. Cuando cargamos un ejecutable en pestudio y hacemos clic en secciones, muestra la informaci칩n de la secci칩n extra칤da de la tabla de secciones y sus atributos (lectura/escritura, etc.). 

**Campo / Descripcion:**
- Names: Displays section names. In this case, the executable contains four sections (.text,.data, .rdata and .rsrc).
- Virtual-Size: Indicates the size of the section when loaded into memory.
- Virtual-Address: This is the relative virtual address (that is, offset from the base address of the executable) where the section can be found in memory.
- Raw-size: Indicates the size of the section on the disk.
- Raw-data: Indicates the offset in the file where the section can be found.
- Entry-point: This is the RVA (relative virtual address) where the code starts executing. In this case, the entry point is in the .text section, which is normal. 

![](capturas/pestudio.png)

**Discrepancias:**
- Los nombres de las secciones no contienen secciones comunes a침adidas por el compilador (como .text, .data, y as칤 sucesivamente) sino que contienen nombres de secci칩n UPX0 y UPX1.
- El punto de entrada est치 en la secci칩n UPX1, lo que indica que la ejecuci칩n comenzar치 en esta secci칩n (rutina de descompresi칩n).
- Normalmente, el tama침o en bruto (raw-size) y el tama침o virtual (virtual-size) deber칤an ser casi iguales, pero peque침as diferencias son normales debido al alineamiento de secciones. En este caso, el tama침o en bruto es 0, indicando que esta secci칩n no ocupar치 espacio en el disco, pero el tama침o virtual especifica que, en memoria, ocupa m치s espacio (alrededor de 127 kb). Esto es una fuerte indicaci칩n de un binario empaquetado. La raz칩n de esta discrepancia es que cuando se ejecuta un binario empaquetado, la rutina de descompresi칩n del empaquetador copiar치 datos o instrucciones descomprimidas en la memoria durante el tiempo de ejecuci칩n.


### Herramienta pescanner
pescanner, creado por Michael Ligh y Glenn P. Edwards, es una excelente herramienta para detectar archivos PE sospechosos basados en los atributos del archivo PE; utiliza heur칤sticas en lugar de firmas y puede ayudarte a identificar binarios empaquetados incluso si no hay firmas para ello. Se puede descargar una copia del script desde https://github.com/hiddenillusion/AnalyzePE/blob/master/pescanner.py.



### 6.4 Examinando el Compilation Timestamp
El encabezado PE contiene informaci칩n que especifica cu치ndo se compil칩 el binario; examinar este campo puede dar una idea de cu치ndo se cre칩 inicialmente el malware. Esta informaci칩n puede ser 칰til para construir una l칤nea de tiempo de la campa침a de ataque. Tambi칠n es posible que un atacante modifique la marca de tiempo para evitar que un analista conozca la marca de tiempo real. A veces, una marca de tiempo de compilaci칩n puede usarse para clasificar muestras sospechosas.




### 6.5 Examinando PE Resources
Los recursos requeridos por el archivo ejecutable, como iconos, men칰s, di치logos y cadenas, se almacenan en la secci칩n de recursos (.rsrc) de un archivo ejecutable. A menudo, los atacantes almacenan informaci칩n como binarios adicionales, documentos se침uelo y datos de configuraci칩n en la secci칩n de recursos, por lo que examinar los recursos puede revelar informaci칩n valiosa sobre un binario. La secci칩n de recursos tambi칠n contiene informaci칩n de versi칩n que puede revelar detalles sobre el origen, el nombre de la empresa, los detalles del autor del programa y la informaci칩n de copyright.

Resource Hacker (http://www.angusj.com/resourcehacker/) es una excelente herramienta para examinar, ver y extraer los recursos de un binario sospechoso.
Notice how the file extension is changed to .xls.exe 具

![](capturas/resourcehacker.png)

Loading a malicious binary in resource hacker shows three resources (Icon, Binary, and Icon Group). The malware specimen uses the icon of Microsoft Excel (to give the appearance of an excel sheet):

![](capturas/resourcehacker-2.png)

El ejecutable tambi칠n contiene datos binarios; uno de ellos tiene una firma de archivo de D0 CF 11 E0 A1 B1 1A E1. Esta secuencia de bytes representa la firma de archivo para un archivo de documento de Microsoft Office. Los atacantes, en este caso, almacenaron una hoja de c치lculo de Excel falsa en la secci칩n de recursos. Al ejecutarse, el malware se ejecuta en segundo plano, y esta hoja de c치lculo falsa se muestra al usuario como una distracci칩n:

![](capturas/resourcehacker-3.png)


## 7. Comparing And Classifying The Malware
Si bien el hash criptogr치fico (MD5/SHA1/SHA256) es una t칠cnica excelente para detectar muestras id칠nticas, no ayuda a identificar muestras similares. Con frecuencia, los autores de malware cambian aspectos m칤nimos del malware, lo que cambia completamente el valor del hash. Las siguientes secciones describen algunas de las t칠cnicas que pueden ayudar en comparar y clasificar el binario sospechoso:

### 7.1 Classifying Malware Using Fuzzy Hashing
La comparaci칩n de archivos mediante el hash difuso (fuzzy hashing) es un excelente m칠todo para buscar similitudes. Usaremos la herramienta ssdeep (http://ssdeep.sourceforge.net) para generar el hash difuso de una muestra. Esta herramienta tambi칠n ayuda a determinar el porcentaje de similitud entre las muestras. Esta t칠cnica es 칰til para comparar un binario sospechoso con las muestras en un repositorio para identificar las muestras que son similares; esto puede ayudar a identificar las muestras que pertenecen a la misma familia de malware o al mismo grupo de actores.

Usaremos ssdeep para calcular y comparar hashes difusos:
```
ssdeep veri.exe
ssdeep,1.1--blocksize:hash:hash,filename 49152:op398U/qCazcQ3iEZgcwwGF0iWC28pUtu6On2spPHlDB:op98USfcy8cwF2bC28pUtsRptDB,"/home/ubuntu/Desktop/veri.exe"
```


El hash difuso, tambi칠n conocido como fuzzy hashing, es una t칠cnica utilizada para **detectar archivos que son similares, pero no id칠nticos, entre s칤**. Esta t칠cnica contrasta con las funciones de hash criptogr치ficas tradicionales, que est치n dise침adas para producir hashes significativamente diferentes incluso para diferencias menores en los datos de entrada

#### ssdeep y el Hash Difuso
ssdeep es una herramienta que implementa el algoritmo de hashing difuso conocido como Context Triggered Piecewise Hashing (CTPH). Este m칠todo permite identificar archivos que tienen homolog칤as, es decir, secuencias de bytes id칠nticos en el mismo orden, aunque puedan existir diferencias en el contenido y la longitud de los bytes intermedios

#### Funcionamiento de ssdeep
ssdeep divide el archivo en m칰ltiples piezas y calcula hashes tradicionales para cada pieza. Luego, combina estos hashes en una sola cadena, lo que permite comparar archivos de manera m치s flexible que con los hashes criptogr치ficos. Por ejemplo, si se modifican, insertan o eliminan datos en un archivo, ssdeep a칰n puede encontrar un grado de similitud con el archivo original.

#### Aplicaciones de ssdeep
ssdeep es ampliamente utilizado en la detecci칩n de malware y en la identificaci칩n de archivos similares. Es particularmente 칰til en investigaciones forenses digitales, donde se requiere comparar archivos para identificar versiones modificadas de archivos conocidos. Por ejemplo, si se sospecha que un archivo es una variante de un malware conocido, ssdeep puede ayudar a confirmar o descartar esta sospecha al comparar los hashes difusos.

#### Instalaci칩n y Uso
ssdeep est치 disponible para su descarga e instalaci칩n en m칰ltiples sistemas operativos, incluyendo Windows, Ubuntu, Fedora, Debian, CentOS, Arch Linux y FreeBSD. Para sistemas que no proporcionan un paquete de ssdeep, se puede construir a partir del c칩digo fuente disponible en GitHub.

#### Comandos B치sicos de ssdeep
La herramienta ssdeep ofrece una variedad de opciones de l칤nea de comandos para calcular y comparar hashes difusos.
- -r: Esta opci칩n permite que ssdeep procese directorios de manera recursiva, es decir, analizar치 todos los archivos en el directorio actual y en todos sus subdirectorios.
- -m: se utiliza para comparar archivos contra un conjunto de hashes conocidos. Determina el porcentaje de similaridad.
- -a: Esta opci칩n indica a ssdeep que compare cada hash contra todos los dem치s, lo que es 칰til para identificar archivos similares dentro de un conjunto de datos.
- -p: Esta opci칩n hace que ssdeep imprima los porcentajes de coincidencia cuando compara hashes. Es 칰til para obtener una medida cuantitativa de cu치n similares son dos archivos basados en sus hashes difusos.
- -b: Esta opci칩n activa el modo de salida binaria. En este modo, ssdeep produce una salida en un formato que es m치s adecuado para el procesamiento por otras herramientas o scripts. Es importante notar que esta opci칩n puede no ser adecuada para la visualizaci칩n directa por humanos debido a su naturaleza binaria


### 7.2 Classifying Malware Using Import Hash
La t칠cnica de **Import Hash, o imphash**, es un m칠todo utilizado para clasificar y rastrear malware **bas치ndose en las importaciones de un archivo ejecutable PE (Portable Executable)**. Este m칠todo se centra en las funciones que el malware llama de otros archivos, generalmente DLLs (Dynamic Link Libraries) que proporcionan funcionalidad al sistema operativo Windows.

El imphash se calcula generando un valor hash a partir de los nombres de las bibliotecas/API y su orden espec칤fico dentro del ejecutable. Debido a la forma en que se genera la tabla de importaciones de un PE, el imphash resultante puede ser utilizado para identificar muestras de malware relacionadas. Si dos muestras tienen el mismo imphash, es probable que est칠n relacionadas y que hayan sido creadas o utilizadas por el mismo grupo de amenazas.

Mandiant, una compa침칤a especializada en seguridad inform치tica, utiliza el imphash para rastrear las actividades de grupos de amenazas espec칤ficos a lo largo del tiempo. Por ejemplo, si un grupo de amenazas favorece ciertos backdoors, Mandiant puede seguir la pista de estos backdoors a trav칠s de sus imphashes. Esto permite a los investigadores buscar nuevas muestras similares que el mismo grupo de amenazas podr칤a haber creado y utilizado.

**El imphash es considerado una forma poderosa de identificar malware relacionado porque el valor del hash tiende a ser relativamente 칰nico. Esto se debe a que el enlazador del compilador genera y construye la Tabla de Direcciones de Importaci칩n (IAT) basada en el orden espec칤fico de las llamadas a las API.**

La herramienta pefile, por ejemplo, se puede utilizar para calcular el imphash de un archivo PE. Mandiant ha contribuido con un parche que permite calcular el valor del imphash para un PE dado en pefile. El siguiente es un ejemplo de c칩digo que utiliza pefile para obtener el imphash de un archivo PE:
```
import pefile
import sys

pe = pefile.PE(sys.argv[1])
print("Import Hash: %s" % pe.get_imphash())
```

Este m칠todo de clasificaci칩n de malware es 칰til para los investigadores de seguridad y los analistas de malware, ya que les permite correlacionar muestras de malware y rastrear la evoluci칩n de las amenazas a lo largo del tiempo.


**Nota:** La herramienta pestudio calcula autom치ticamente el imphash.


### 7.3 Classifying Malware Using Section Hash
La clasificaci칩n de malware utilizando el hash de secci칩n, o Section Hash, es una t칠cnica de an치lisis est치tico que se centra en las secciones individuales de un archivo ejecutable PE (Portable Executable). Cada secci칩n de un archivo PE, como .text, .data, .rdata, etc., puede contener diferentes tipos de datos, como c칩digo ejecutable, recursos y datos de inicializaci칩n. Al calcular el hash de cada una de estas secciones, los analistas pueden obtener una firma que puede ser utilizada para identificar y clasificar muestras de malware.

El Section Hash es 칰til para identificar variantes de malware que comparten secciones de c칩digo comunes. Por ejemplo, si un atacante reutiliza un m칩dulo de c칩digo espec칤fico en diferentes variantes de malware, el hash de la secci칩n correspondiente ser치 el mismo en todas estas variantes. Esto permite a los investigadores agrupar muestras relacionadas y rastrear la evoluci칩n del malware a lo largo del tiempo.

El an치lisis de malware con Radare2, por ejemplo, puede incluir la obtenci칩n de hashes de secciones utilizando comandos espec칤ficos como "iS" seguido de los algoritmos de hash deseados (md5, sha1, sha256), para obtener informaci칩n sobre las secciones y sus respectivos hashes.

La clasificaci칩n basada en Section Hash puede ser complementada con otras t칠cnicas de an치lisis est치tico, como el an치lisis de strings, el an치lisis de importaciones y exportaciones, y el an치lisis de metadatos del archivo PE. Estas t칠cnicas proporcionan una visi칩n m치s completa del comportamiento potencial del malware y pueden ayudar a identificar caracter칤sticas 칰nicas de diferentes familias de malware.

Es importante destacar que, aunque el Section Hash es una herramienta valiosa en la clasificaci칩n de malware, no es infalible. Los atacantes pueden ofuscar o modificar las secciones de un archivo PE para evitar la detecci칩n, lo que puede hacer que el hash de secci칩n cambie y, por lo tanto, dificultar la clasificaci칩n basada en esta t칠cnica. Por esta raz칩n, el Section Hash se utiliza a menudo en combinaci칩n con otras t칠cnicas de an치lisis para mejorar la precisi칩n en la detecci칩n y clasificaci칩n del malware.

Formas de c치lculo de Section Hash:
- Con la herramienta pestudio.
- Con Python: Usando el m칩dulo pefile:
  ```
  >>> import pefile
  >>> pe = pefile.PE("5340.exe")
  >>> for section in pe.sections:
  ... print "%s\t%s" % (section.Name, section.get_hash_md5())
  ```

### 7.4 Classifying Malware Using YARA
La creaci칩n de reglas YARA es fundamental para su eficacia en la clasificaci칩n de malware. Una regla YARA t칤picamente consta de una secci칩n de metadatos, donde se pueden incluir detalles como el nombre de la regla, autor, versi칩n y cualquier otra informaci칩n relevante; una secci칩n de strings, donde se definen las cadenas de texto, binarias o expresiones regulares que se buscan; y una secci칩n de condiciones, que especifica c칩mo deben coincidir o relacionarse las strings definidas para que la regla se considere como coincidente.

YARA permite la identificaci칩n r치pida de malware conocido y la detecci칩n de variantes o familias de malware relacionadas mediante la b칰squeda de patrones espec칤ficos.

https://yara.readthedocs.io/en/v3.7.0/writingrules.html

#### Crear reglas YARA
Para crear reglas YARA, es necesario seguir una estructura espec칤fica que consta de tres partes principales: metadatos, strings y condiciones. A continuaci칩n, se detallan los pasos para escribir reglas YARA efectivas:
- Metadatos: Los metadatos son informaci칩n descriptiva sobre la regla que no afecta su funcionamiento. Incluyen detalles como el nombre de la regla, autor, versi칩n y cualquier otra informaci칩n relevante. Los metadatos son opcionales pero 칰tiles para la organizaci칩n y documentaci칩n.
- Strings: Las strings son los patrones de texto, binarios o expresiones regulares que se buscar치n en los archivos o procesos. Se definen utilizando el s칤mbolo $, seguido de un identificador. Las strings pueden ser literales, hexadecimales o basadas en expresiones regulares.
- Condiciones: Las condiciones son expresiones l칩gicas que determinan cu치ndo se considera que una regla coincide con un archivo o proceso. Las condiciones pueden ser simples, como la presencia de una string, o complejas, utilizando operadores l칩gicos y cuantificadores.

#### Ejemplo de una Regla YARA B치sica
```
yara
rule ExampleMalwareDetection
{
    meta:
        author = "Your Name"
        description = "Detects Example Malware"
        version = "1.0"

    strings:
        $a = "malicious string" nocase
        $b = { 6A 40 68 00 30 00 00 } // Hexadecimal pattern
        $c = /md5: [0-9A-F]{32}/ // Regular expression

    condition:
        $a and $b and $c
}
```

#### Pasos para Escribir Reglas YARA:
- Definir Metadatos: Comience con la secci칩n de metadatos para describir la regla. Aunque opcional, es una buena pr치ctica incluir metadatos para mantener las reglas organizadas.
- Identificar Strings: Determine las strings que son indicativas del malware o del contenido que desea detectar. Puede utilizar strings literales, patrones hexadecimales o expresiones regulares.
- Establecer Condiciones: Defina las condiciones bajo las cuales se considerar치 que la regla ha encontrado una coincidencia. Puede utilizar operadores l칩gicos como and, or, y not, as칤 como cuantificadores como all of them o any of them.
- Probar la Regla: Una vez que haya escrito la regla, pru칠bela con muestras conocidas para asegurarse de que detecta correctamente el malware sin generar falsos positivos.
- Refinar la Regla: Si la regla genera falsos positivos o no detecta todas las variantes del malware, ajuste las strings y las condiciones hasta que la regla sea efectiva y precisa.
- Documentar y Mantener: Documente la regla y mant칠ngala actualizada a medida que surjan nuevas variantes del malware o se descubran nuevos indicadores de compromiso.

Es importante tener en cuenta que escribir reglas YARA efectivas requiere un conocimiento profundo del malware que se est치 detectando y de los patrones que lo caracterizan. Adem치s, las reglas deben ser lo suficientemente espec칤ficas para evitar falsos positivos, pero tambi칠n lo suficientemente generales para detectar variantes del malware

https://www.youtube.com/watch?v=RGXQeco_1Zk&t=787s


# CHAPTER 3: DYNAMIC ANALYSIS
El an치lisis din치mico de malware es un proceso que implica la ejecuci칩n del malware en un entorno controlado y aislado, conocido como sandbox o m치quina virtual, para observar su comportamiento y funcionalidad en tiempo real. Este tipo de an치lisis permite a los investigadores y analistas de seguridad comprender c칩mo se comporta el malware una vez que se ejecuta en un sistema, identificando las acciones que realiza, como la modificaci칩n de archivos, la comunicaci칩n con servidores remotos, la inyecci칩n de c칩digo en otros procesos, entre otros comportamientos maliciosos.

Las ventajas del an치lisis din치mico incluyen la capacidad de obtener informaci칩n detallada sobre el comportamiento del malware, lo que permite documentar y entender mejor las amenazas para desarrollar medidas de protecci칩n m치s efectivas. Adem치s, este tipo de an치lisis puede revelar la presencia de t칠cnicas de evasi칩n, como la detecci칩n de entornos virtuales (antisandbox), que el malware puede utilizar para evitar su an치lisis en entornos controlados.

El an치lisis din치mico es complementario al an치lisis est치tico, que se enfoca en el examen del c칩digo fuente del malware sin ejecutarlo, proporcionando una visi칩n completa del funcionamiento y prop칩sito del software malicioso. Juntos, el an치lisis est치tico y din치mico ofrecen una metodolog칤a robusta para el estudio y la clasificaci칩n de malware, contribuyendo significativamente a la ciberseguridad y la defensa contra amenazas inform치ticas.

## 1. Lab Environment Overview
Tanto la m치quina virtual de Linux como la de Windows se configuraron para utilizar el modo de configuraci칩n de red de solo anfitri칩n. La m치quina virtual de Linux estaba preconfigurada con una direcci칩n IP de 192.168.1.100, y la direcci칩n IP de la m치quina virtual de Windows se estableci칩 en 192.168.1.50. La puerta de enlace predeterminada y el DNS de la m치quina virtual de Windows se establecieron en la direcci칩n IP de la m치quina virtual de Linux (192.168.1.100), de modo que todo el tr치fico de red de Windows se enrutara a trav칠s de la m치quina virtual de Linux. La m치quina virtual de Windows se utilizar치 para ejecutar la muestra de malware durante el an치lisis, y la m치quina virtual de Linux se utilizar치 para monitorear el tr치fico de red y se configurar치 para simular servicios de internet (como DNS, HTTP, y otros) para proporcionar la respuesta adecuada cuando el malware solicite estos servicios.

## 2. System And Network Monitoring
El objetivo de un an치lisi din치mico es recopilar datos en tiempo real relacionados con el comportamiento del malware y su impacto en el sistema. Diferentes tipos de monitoreo realizados durante el an치lisis din치mico:
- Monitoreo de procesos: Implica monitorear la actividad del proceso y examinar las propiedades del proceso resultante durante la ejecuci칩n del malware.
- Monitoreo del sistema de archivos: Incluye monitorear la actividad del sistema de archivos en tiempo real durante la ejecuci칩n del malware.
- Monitoreo del registro: Implica monitorear las claves del registro a las que se accede/modifica y los datos del registro que son le칤dos/escritos por el binario malicioso.
- Monitoreo de la red: Involucra monitorear el tr치fico en vivo hacia y desde el sistema durante la ejecuci칩n del malware.


## 3. Dynamic Analysis (Monitoring) Tools

### 3.1 Process Inspection with Process Hacker
Process Hacker (http://processhacker.sourceforge.net/) is an open source, multipurpose tool that helps in monitoring system resources. It is a great tool for examining the
processes running on the system and to inspect the process attributes. It can also be used to explore services, network connections, disk activity, and so on.

VirusTotal lo detecta como malware.

### 3.2 Determining System Interaction with Process Monitor
Process Monitor (https://technet.microsoft.com/en-us/sysinternals/processmonitor.aspx) is an advanced monitoring tool that shows the real-time interaction of the processes
with the filesystem, registry, and process/thread activity.

### 3.3 Logging System Activities Using Noriben
Even though Process Monitor is a great tool to monitor a malware's interaction with the system, it can be very noisy, and manual effort is required to filter the noise. Noriben
(https://github.com/Rurik/Noriben) is a Python script that works in conjunction with Process Monitor and helps in collecting, analyzing, and reporting runtime indicators of the
malware. The advantage of using Noriben is that it comes with pre-defined filters that assist in reducing noise and allow you to focus on the malware-related events.

### 3.4 Capturing Network Traffic With Wireshark
When the malware is executed, you will want to capture the network traffic generated as a result of running the malware; this will help you understand the communication channel
used by the malware and will also help in determining network-based indicators. 

### 3.5 Simulating Services with INetSim
INetSim is a free Linux-based software suite for simulating standard internet services (such as DNS, HTTP/HTTPS, and so on).

Another alternative to INetSim is FakeNet-NG (https://github.com/fireeye/flare-fakenet-ng), which allows you to intercept and redirect all or specific network traffic by simulating network services.


## 4. Dynamic Analysis Steps
Durante el an치lisis din치mico (an치lisis del comportamiento), seguriemos una secuencia de pasos para determinar la funcionalidad del malware. La siguiente lista describe los pasos involucrados en el an치lisis din치mico:
- Revertir a la instant치nea limpia: Esto incluye volver tus m치quinas virtuales a un estado limpio.
- Ejecutar las herramientas de monitoreo/an치lisis din치mico: En este paso, ejecutar치s las herramientas de monitoreo antes de ejecutar la muestra de malware. Para aprovechar al m치ximo las herramientas de monitoreo cubiertas en la secci칩n anterior, necesitas ejecutarlas con privilegios de administrador.
- Ejecutar la muestra de malware: En este paso, ejecutar치s la muestra de malware con privilegios de administrador.
- Detener las herramientas de monitoreo: Esto implica terminar las herramientas de monitoreo despu칠s de que el binario de malware se haya ejecutado durante un tiempo especificado.
- Analizar los resultados: Esto implica recopilar los datos/informes de las herramientas de monitoreo y analizarlos para determinar el comportamiento y la funcionalidad del malware.


## 5. Putting it All Together: Analyzing a Malware Executable
Realizaremos tanto an치lisis est치tico como din치mico para determinar las caracter칤sticas y el comportamiento de una muestra de malware.


## 6. Dynamic-Link Library (DLL) Analysis



# Examples
## Emotet
https://assets.tryhackme.com/additional/cmn-malware/int-mal-sample.pdf

