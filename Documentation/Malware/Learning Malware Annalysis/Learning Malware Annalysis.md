# CHAPTER 1
## 1. ¬øQu√© es el malware?
**El malware es un c√≥digo que realiza acciones maliciosas**; puede tomar la forma de un ejecutable, un script, un c√≥digo o cualquier otro software. Los atacantes utilizan malware para robar informaci√≥n confidencial, espiar el sistema infectado o tomar el control del sistema. Por lo general, accede al dispositivo sin nuestro consentimiento a trav√©s de varios canales de comunicaci√≥n, como correo electr√≥nico, web o unidades USB.


**Acciones maliciosas que realiza el malware:**
- Interrumpir el funcionamiento del ordenador.
- Robar informaci√≥n sensible, incluyendo datos personales, empresariales y financieros.
- Acceso no autorizado al sistema.
- Espiar.
- Enviar correos electr√≥nicos de spam.
- Participar en ataques de denegaci√≥n de servicio distribuido (DDoS).
- Bloquear los archivos del ordenador y exigir un rescate para liberarlos.

Malware es un t√©rmino amplio que se refiere a **diferentes tipos de programas maliciosos como troyanos, virus, gusanos y rootkits...**

### Tipos de malware m√°s comunes:
Algunos de ellos se categorizan seg√∫n su funcionalidad y vectores de ataque, como se describe a continuaci√≥n:
- **Virus:**  
Programa malicioso que se adjunta a un archivo leg√≠timo y se propaga cuando se ejecuta el archivo infectado. Causa variedad de da√±os, como la eliminaci√≥n de archivos, el robo de informaci√≥n o el bloqueo del sistema. Este Malware es capaz de copiarse a s√≠ mismo y propagarse a otros ordenadores. Un virus necesita intervenci√≥n del usuario, mientras que un gusano puede propagarse sin ella.

- **Gusano:**  
Son programas maliciosos que se propagan a trav√©s de redes y sistemas inform√°ticos. Los gusanos pueden causar una sobrecarga en la red y ralentizar el rendimiento del sistema.

- **Troyano:**  
Malware que se disfraza de programa leg√≠timo para enga√±ar al usuario y que lo instale. Una vez instalado, puede realizar acciones maliciosas como robar datos sensibles, subir archivos al servidor del atacante o espiar a trav√©s de la webcam.

- **Backdoor / Remote Access Trojan (RAT) | Puerta trasera / Troyano de acceso remoto (RAT):**  
Tipo de troyano que permite al atacante acceder y ejecutar comandos en el sistema comprometido.

- **Adware:**  
Malware que muestra anuncios no deseados al usuario. Suele distribuirse junto con descargas gratuitas e incluso puede instalar software de manera forzada.

- **Botnet:**  
Conjunto de ordenadores infectados con el mismo malware (llamado bots), que esperan instrucciones del servidor de comando y control controlado por el atacante. El atacante puede ordenar a estos bots que realicen actividades maliciosas como ataques DDoS o env√≠o masivo de spam.

- **Ladr√≥n de informaci√≥n (Information stealer):**  
Malware dise√±ado para robar datos sensibles como credenciales bancarias o pulsaciones del teclado. Algunos ejemplos son los keyloggers, spyware, sniffers y form grabbers.

- **Ransomware:**  
Malware que mantiene el sistema como reh√©n, bloqueando el acceso al ordenador o cifrando los archivos del usuario y exigiendo un rescate para recuperarlos.

- **Rootkit:**  
Malware que otorga al atacante acceso privilegiado al sistema infectado y oculta su presencia o la de otros programas maliciosos. Los rootkits pueden permitir a los atacantes controlar el sistema y recopilar informaci√≥n sin ser detectados.

- **Downloader o Dropper:**  
Malware dise√±ado para descargar o instalar componentes maliciosos adicionales en el sistema.


## 2. Descripci√≥n general de la arquitectura del laboratorio
![](capturas/structure.png)

La arquitectura usada consiste en una **m√°quina f√≠sica (llamada m√°quina host) que ejecuta Ubuntu Linux con instancias de m√°quina virtual Linux (Ubuntu Linux VM) y m√°quina virtual Windows (Windows VM)**. Estas m√°quinas virtuales se configurar√°n para ser parte de la misma red y utilizar√°n el modo de **configuraci√≥n de red de Host-only** para que el malware no pueda comunicarse con Internet y as√≠ el tr√°fico de la red estar√° contenido en el entorno de laboratorio aislado.

La VM de Windows es donde se ejecutar√° el malware durante el an√°lisis, y la VM de Linux se usar√° para monitorear el tr√°fico de red y ser√° configurada para simular servicios de Internet (DNS, HTTP, etc.), para proporcionar una respuesta adecuada cuando el malware solicite estos servicios. Por ejemplo, la m√°quina virtual Linux se configurar√° de manera que cuando el malware solicite un servicio como DNS, la m√°quina virtual Linux proporcione la respuesta DNS adecuada. 

En esta configuraci√≥n, la m√°quina virtual Linux estar√° preconfigurada en la direcci√≥n IP 192.168.1.100 y la direcci√≥n IP de la m√°quina virtual Windows se configurar√° en 192.168.1.x (donde x es cualquier n√∫mero de 1 a 254 excepto 100). La puerta de enlace predeterminada y el DNS de la VM de Windows se configurar√°n en la direcci√≥n IP de la VM de Linux (es decir, 192.168.1.100) para que todo el tr√°fico de la red de Windows se enrute a trav√©s de la VM de Linux.

Tambi√©n es posible configurar un laboratorio compuesto por m√∫ltiples VMs ejecutando diferentes versiones de Windows; esto nos permitir√° analizar la muestra de malware en varias versiones de sistemas operativos Windows.
![](capturas/structure-2.png)


## 3. Configuraci√≥n de las VMs
- Instalaci√≥n de MV Ubuntu & MV Windows.
- Instalaci√≥n de Virtual Guest Additions software en ambas VMs.
  
### 3.1 Configuraci√≥n de Windows VM:
- Deshabilitamos Windows Update.
- Deshabilitamos Windows Defender ü†Æ  Services ü†Æ Windows Defender ü†Æ Boton derecho ü†Æ  Select properties ü†Æ  Stop Service
- Mostrar extensiones de ficheros ü†Æ Opciones de carpeta ü†Æ Ver ü†Æ  Mostrar extensiones para ficheros
- Mostrar ficheros y carpetas ocultos.
- Deshabilitamos ASLR (Address Space Layout Randomization): ASLR (Address Space Layout Randomization) es una t√©cnica de seguridad utilizada para dificultar los ataques de desbordamiento de b√∫fer (buffer overflow) y otras vulnerabilidades de corrupci√≥n de memoria. La idea principal de ASLR es ubicar aleatoriamente en el espacio de direcciones de memoria las √°reas clave de un proceso, como el ejecutable base, la pila, el mont√≥n y las librer√≠as cargadas. Esto hace que las direcciones de memoria sean impredecibles para un atacante, dificultando la ejecuci√≥n de c√≥digo malicioso.
    ü†Æ  Windows + R ü†Æ  regedit ü†Æ Computer\HKEY_LOCAL_MACHINE\SISTEM\CurrentSet\Control\Session Manager\Memory Management ü†Æ  New Key ü†Æ QWORD (32 bits) ü†Æ poner como nombre: MoveImages
- Deshabilitamos Firewall ü†Æ Windows Defender Firewall.
- Creamos un snapshot ü†Æ HOST + T

- Instalamos Flare VM: Es una colecci√≥n de scripts de instalaci√≥n de software para sistemas Windows que permite configurar y mantener f√°cilmente un entorno de ingenier√≠a inversa y an√°lisis de malware en una m√°quina virtual.Las principales caracter√≠sticas de FLARE VM son:
  - Proporciona un conjunto de herramientas expertas para ingenier√≠a inversa, an√°lisis de malware, monitoreo, depuraci√≥n, desensamblado, descompilaci√≥n y m√°s, todas preinstaladas y configuradas. Algunas herramientas incluidas son IDA, Binary Ninja, Radare2, OllyDbg, x64dbg, Ghidra, entre otras. (https://github.com/dnSpy/dnSpy)
  - Utiliza Chocolatey (un administrador de paquetes para Windows) y Boxstarter para automatizar la instalaci√≥n y configuraci√≥n de las herramientas en un entorno Windows virtualizado.
  - Est√° dise√±ado para instalarse √∫nicamente en una m√°quina virtual Windows, no en un host f√≠sico, para permitir un an√°lisis de malware seguro y contenido.
  - Proporciona un proceso de instalaci√≥n, actualizaci√≥n y desinstalaci√≥n simplificado a trav√©s de scripts de PowerShell.
  - Permite personalizar f√°cilmente las herramientas a instalar a trav√©s de una interfaz gr√°fica de usuario.
  - Es un proyecto de c√≥digo abierto mantenido por el equipo FLARE de Mandiant/FireEye, con contribuciones de la comunidad.
  - Enlace: https://github.com/mandiant/flare-vm
  - Video con instruciones para instalar: https://www.youtube.com/watch?v=i8dCyy8WMKY
  - Desactivamos: Windows Defender through Group Policy:
    - gpedit.msc
    - En el Editor de Directiva de Grupo, navegue a la siguiente ruta: Computer Configuration > Administrative Templates > Windows Components > Windows Defender Antivirus
    - Busque la configuraci√≥n "Turn off Windows Defender Antivirus" (o "Desactivar Antivirus Windows Defender" en espa√±ol).
    - Haga doble clic en ella para editarla.
    - Seleccione "Enabled" (Habilitado) y haga clic en "Apply" (Aplicar) y luego en "OK".
    - Cierre el Editor de Directiva de Grupo Local.
  - Computer Configuration > Administrative Templates > Windows Components > Microsoft Defender Antivirus > Real-time Protection > Enable Turn off real-time protection
  - Instalaci√≥n: Desde la carpeta del master, ejecutar con PowerShell como administrador:
    - Set-ExecutionPolicy unrestricted
    - Si falla: Set-ExecutionPolicy -Scope      CurrentUser
      - unresticted
      - ./

- Descargamos Python desde https://www.python.org/downloads/. Aseg√∫rate de descargar la versi√≥n Python 2.7.x (por ejemplo, 2.7.13); la mayor√≠a de los scripts usados en este libro est√°n escritos para ejecutarse con la versi√≥n Python 2.7 y puede que no funcionen correctamente en Python 3.

- Configuramos la m√°quina virtual de Windows para que funcione en modo de red solo-anfitri√≥n (Host-only).

- Configuramos la direcci√≥n IP de la m√°quina virtual de Windows como 192.168.1.x (elegimos cualquier direcci√≥n IP excepto 192.168.1.100, ya que esa la usar√° la m√°quina virtual con Linux) y establecemos la puerta de enlace predeterminada y el servidor DNS a la direcci√≥n IP de la m√°quina virtual con Linux (es decir, 192.168.1.100).

- Nos aseguramos de que ambas m√°quinas puedan comunicarse entre s√≠. Comprobamos la conectividad ejecutando el comando ping.

- Para desactivar Windows Defender:
  - Abrimos el Editor de directivas de grupo local.
  - En el panel izquierdo, navegamos hasta: Configuraci√≥n del equipo | Plantillas administrativas | Componentes de Windows | Windows Defender.
  - En el panel derecho, hacemos doble clic en la directiva Desactivar Windows Defender para editarla.
  - Seleccionamos Habilitada y haz clic en Aceptar.
 

### 3.2 Configuraci√≥n de Linux VM:
- Instalaci√≥n:
  ```
  sudo apt-get install python-pip
  pip install --upgrade pip
  sudo apt-get install python-magic
  sudo apt-get install upx
  sudo pip install pefile
  sudo apt-get install yara
  sudo pip install yara-python
  sudo apt-get install ssdeep
  sudo apt-get install build-essential libffi-dev python python-dev libfuzzy-dev
  sudo pip install ssdeep
  sudo apt-get install wireshark
  sudo apt-get install tshark
  ```
- INetSim (http://www.inetsim.org/index.html) es una herramienta potente que permite simular varios servicios de Internet (como DNS y HTTP).Emula servicios t√≠picos de Internet dentro de una red controlada o aislada (como una sandbox). Esto permite ver c√≥mo se comporta un malware cuando intenta comunicarse con servidores externos, sin que el malware realmente acceda a Internet:
  ```
  sudo su
  echo "deb http://www.inetsim.org/debian/ binary/" >  /etc/apt/sources.list.d/inetsim.list
  wget -O - http://www.inetsim.org/inetsim-archive-signing-key.asc | apt-key add -
  apt update
  apt-get install inetsim
  ```
  
- Ahora podemos aislar la m√°quina virtual de Ubuntu dentro del laboratorio configurando el modo de red "Solo-anfitri√≥n" (Host-only) en el dispositivo virtual. Es importante aislar la m√°quina virtual del acceso a Internet real, para evitar que el malware cause da√±os o se comunique con atacantes reales. El modo de red Host-only en VMware:
    - Crea una red cerrada entre tu m√°quina real (host) y la m√°quina virtual (VM).
    - No permite acceso a Internet ni a otras redes, solo comunicaci√≥n directa entre host y VM.
    - Es ideal para entornos de prueba o an√°lisis seguro.
  
- IP address of 192.168.1.100 to the Ubuntu Linux VM.
  
- Configurar INetSim para que pueda escuchar y simular todos los servicios en la ip 192.168.1.100:
  ```
  sudo gedit /etc/inetsim/inetsim.conf
  # service_bind_address
  #
  # IP address to bind services to
  #
  # Syntax: service_bind_address <IP address>
  #
  # Default: 127.0.0.1
  #
  #service_bind_address 10.10.10.1
  service_bind_address 192.168.1.100
  #
  #dns_default_ip 10.10.10.1
  dns_default_ip 192.168.1.100
  ```
- Arrancar INetSim:
  ```
  sudo inetsim
  ```
- Hacemos una snapshot | instant√°nea: En VirtualBox, se puede hacer haciendo clic en M√°quina | Tomar instant√°nea. ü†Æ Host + T


## 4. Otra posible configuraci√≥n para las MV

### 4.1 Configuraci√≥n Virtual Box

- Instalamos una MV Windows10 Pro y una MV Remnux.
- Instalamos Virtual guest addition.
- Cambiamos a una configuraci√≥n de red tipo 10.0.0.0/24 para evitar posibles saltos a redes usuales como 192.168.X.X. Actualmente en Virtual box s√≥lo se pueden crear redes del rango 192.168.57.... Para crear una red del rango 10.0.0.0/24, tenemos que habilitarlo en el fichero de configuraci√≥n de redes:
```
sudo nano /etc/vbox/networks.conf

A√±adimos:
* 10.0.0.0/24
```

- Creamos en l√≠nea de comandos una red hostonly:
```
VBoxManage hostonly cretate
```
El comando anterior, genera una nueva red y nos indica su nombre, por ejemplo vboxnet1.

- Especificamos el rango de la red:
```
VBoxManage hostonly ipconfig vboxnet1 --ip 10.0.0.1 --netmask 255.255.255.0
```

- Cerramos y abrimos VirtualBox para que actualice este cambio.

- En virtualbox, Vamos a la configuraci√≥n de redes: Red vboxnet1 --> Configuraci√≥n de la red:
```
Direccion IPv4: 10.0.0.1
m√°scara de red: 255.255.255.0
```
- Vamos a la configuraci√≥n de redes: Red vboxnet1 --> Servidor DHCP:
```
Direcci√≥n del Servidor: 10.0.0.2
M√°scara de red: 255.255.255.0
Limite inferior: 10.0.0.3
L√≠mite superior: 10.0.0.254
```
- Verificamos que la VM WIN y la WM Linux tiene s√≥lo un adaptador de red activo: Red vboxnet1


### 4.2 M√°quina virtual Remnux

```
ip: 10.0.0.3/24
Configuraci√≥n inetsim:
nano /etc/inetsim/inetsim.conf
service_bind_addres  0.0.0.0
dns_default_ip       10.0.0.3

Ejecutar inetsim.
```

### 4.3 M√°quina Virtual WIN:
```
ip: 10.0.0.4/24
Download Windows Terminal:
Download the VCLibs package. In a PowerShell window, run: wget https://aka.ms/Microsoft.VCLibs.x64.14.00.Desktop.appx -usebasicparsing -o VCLibs.appx
Download the Windows Terminal MSIX bundle from the provided link: wget https://github.com/microsoft/terminal/releases/download/v1.15.3465.0/Microsoft.WindowsTerminal_Win10_1.15.3465.0_8wekyb3d8bbwe.msixbundle -UseBasicParsing -o winterminal.msixbundle
In a PowerShell admin window, add the VCLibs package: Add-AppxPackage [C:\path\to\downloaded\VCLibs.appx]
In a PowerShell admin window, run: Add-AppxPackage [C:\path\to\downloaded\winterminal.msixbundle]

(Optional) Pin Windows Terminal to the task bar

Disable proxy auto detect setting:
In the Windows search bar, search ‚Äúproxy settings‚Äù,
Switch "Automatically detect settings" button off

Disable Tamper Protection
Search "Defender", open Defender settings and set all Defender Settings to off

Disable AV/Defender in GPO
Si tenemos Windows10 Home y gpedit.msc no est√° instalado:
- cmd ejecutar como administrador
- FOR %F IN ("%SystemRoot%\servicing\Packages\Microsoft-Windows-GroupPolicy-ClientTools-Package~*.mum") DO ( DISM /Online /NoRestart /Add-Package:"%F" )
- FOR %F IN ("%SystemRoot%\servicing\Packages\Microsoft-Windows-GroupPolicy-ClientExtensions-Package~*.mum") DO ( DISM /Online /NoRestart /Add-Package:"%F" )
- Windows+r --> gpedit.msc

In Windows search bar, search "group policy"
In GPO, navigate to ‚Üí Administrative Templates ‚Üí Windows Components ‚Üí Microsoft Defender Antivirus ‚Üí Enable ‚ÄúTurn off Microsoft Defender Antivirus‚Äù
Disable Windows Firewall
GPO ‚Üí Administrative Templates ‚Üí Network ‚Üí Network Connections ‚Üí Windows Defender Firewall ‚Üí Domain Profile ‚Üí Disable ‚ÄúProtect All Network Connections‚Äù
Do the same but for the Standard profile



TAKE A SNAPSHOT!

Download and install FLARE-VM:
In PowerShell Admin prompt, run: (New-Object net.webclient).DownloadFile('https://raw.githubusercontent.com/mandiant/flare-vm/main/install.ps1',"$([Environment]::GetFolderPath("Desktop"))\install.ps1")
Change directories to the Desktop

Run: Unblock-File .\install.ps1
Run: Set-ExecutionPolicy Unrestricted
Accept the prompt to set the ExecPol to unrestricted if one appears
Run: .\install.ps1 -customConfig https://raw.githubusercontent.com/HuskyHacks/PMAT-labs/main/config.xml
Follow the rest of the prompts and continue with the installation.

Configuraci√≥n del adaptador de ip IPV/4:
Usar la siguiente direcci√≥n del servidor de DNS: 10.0.0.3


When the installation is done, TAKE ANOTHER SNAPSHOT!
```

Comprobar que todas las m√°quinas se ven con pings.
comprobar que la MV Win, si accede a una web o recurso, recibe respuesta de inetsim.


![Inetsim-setup](capturas/Inetsim-setup.png)


### Interacciones seg√∫n los modos de red
C√≥mo interact√∫an las MVs con el Host f√≠sco que las contiene:
![networking-modes](capturas/networking-modes.png)

**El modo de red Host-Only en entornos virtualizados permite la comunicaci√≥n √∫nicamente entre las m√°quinas virtuales y el host f√≠sico, sin acceso a internet ni a otras m√°quinas de la LAN. Sin embargo, Host-Only permite la comunicaci√≥n entre la VM infectada y el host**. Es por ello que este modo no es totalmente seguro para an√°lisis de malware si el host contiene datos valiosos o est√° desprotegido.

Aunque **con Host-Only se evita que el malware salga a internet o ataque otros dispositivos de la red corporativa**, la posibilidad de comunicaci√≥n directa con el host representa un riesgo: si el malware logra aprovechar vulnerabilidades presentes en el sistema de virtualizaci√≥n o en el propio host, podr√≠a salir del entorno controlado y comprometer el host f√≠sico. Hist√≥ricamente han existido exploits (vulnerabilidades de escape de VM) que permiten a malware salir de la m√°quina virtual y ejecutar c√≥digo en el host, aunque estos no son triviales ni comunes en entornos bien actualizados.

Por tanto, Host-Only **aporta un nivel de aislamiento, pero no garantiza seguridad absoluta**. En buenas pr√°cticas de an√°lisis de malware, se recomienda adem√°s:
- Usar instant√°neas para restaurar el estado limpio de la VM r√°pidamente.
- Mantener el host lo m√°s aislado posible y sin informaci√≥n sensible.
- Aplicar actualizaciones de seguridad tanto al host como al software de virtualizaci√≥n.
- Considerar el uso de entornos totalmente desconectados (‚Äúair-gapped‚Äù) para an√°lisis de malware de riesgo elevado.
- Cifrar discos duros para que no tengan acceso entre ellos para aislar plenamente el disco que tenga las funciones de lab.


https://academy.tcm-sec.com/courses/1547503/lectures/42863183

## 6. Malware Sources
- Hybrid Analysis: https://www.hybrid-analysis.com/
- KernelMode.info: http://www.kernelmode.info/forum/viewforum.php?f=16
- VirusBay: https://beta.virusbay.io/
- Contagio malware dump: http://contagiodump.blogspot.com/
- AVCaesar: https://avcaesar.malware.lu/
- Malwr: https://malwr.com/
- VirusShare: https://virusshare.com/
- theZoo: http://thezoo.morirt.com/
- Elastic Malware Benchmark: https://github.com/elastic/ember
- Tekdefense: https://www.tekdefense.com/downloads/malware-samples/
- Syrianmalware: https://syrianmalware.com/
- VX underground: https://vx-underground.org/
- MalwareBazar: https://bazaar.abuse.ch/
- Zeltser: https://zeltser.com/malware-sample-sources/

-------------------------------------------------  
-------------------------------------------------  
# CHAPTER 2: An√°lisis est√°tico
El an√°lisis **est√°tico es la t√©cnica de analizar el archivo sospechoso sin ejecutarlo**. Es un m√©todo de an√°lisis inicial que implica extraer informaci√≥n √∫til del binario sospechoso para tomar una decisi√≥n informada sobre **c√≥mo clasificarlo o analizarlo** y d√≥nde centrar nuestros esfuerzos.

**Aprenderemos:**
1. Identificar la arquitectura de destino del malware.  
2. Tomar huellas dactilares del malware.  
3. Escanear el binario sospechoso con motores antivirus.  
4. Extraer cadenas, funciones y metadatos asociados con el archivo.
5. Funciones/APIs utilizadas.
6. Tama√±o del archivo y Estructura PE.
7. Identificar las t√©cnicas de ofuscaci√≥n utilizadas para frustrar el an√°lisis.  
8. Clasificaci√≥n y comparaci√≥n de muestras de malware.

Estas t√©cnicas pueden revelar informaci√≥n diferente sobre el archivo. No es necesario seguir todas estas t√©cnicas y no es necesario seguirlas en el orden indicado anteriormente. La elecci√≥n de las t√©cnicas a utilizar depende de su objetivo y del contexto que rodea el archivo sospechoso.

## 1. Identificar la arquitectura de destino del malware: Determinar el tipo de fichero
Determinar el tipo de archivo de un binario sospechoso nos ayudar√° a **identificar el sistema operativo objetivo del malware** (Windows, Linux, etc.) **y la arquitectura** (plataformas de 32 o 64 bits). Por ejemplo, si el binario sospechoso tiene un **tipo de archivo Ejecutable Port√°til (PE)**, que es el formato de archivo para archivos ejecutables de Windows (.exe, .dll, .sys, .drv, .com, .ocx, etc.), entonces podemos deducir que el archivo est√° dise√±ado para apuntar al sistema operativo Windows.

### C√≥mo se determina el tipo de fichero.
**1.1. Por la extensi√≥n:** .exe, .dll, .sys, .drv, .com, .ocx, etc.  Hay que tener cuidado con la extensi√≥n ya que se puede cambiar la extensi√≥n para ocultar el malware.

**1.2. Por la firma del archivo:** Se busca la firma del archivo abri√©ndolo en un editor hexadecimal. **Una firma de archivo es una secuencia √∫nica de bytes que se escribe en el encabezado del archivo.** Diferentes archivos tienen diferentes firmas, que pueden usarse para identificar el tipo de archivo. **Los archivos ejecutables de Windows, tambi√©n llamados archivos PE**, **tienen una firma de archivo de MZ o caracteres hexadecimales 4D 5A enlos primeros dos bytes del archivo.**

![](https://web-assets.esetstatic.com/wls/2023/07/2.HxD_.jpg)

En sistemas Linux, para buscar la firma del archivo se puede utilizar el comando ```xxd```, que genera un volcado hexadecimal del archivo:
```
xxd -g 1 log.exe | more
```

Vemos el detalle de la salida del comando xxd usando contra una muestra de malware. Lo que aparece como "MZP" se traduce en ASCII como:
- 4D = M
- 5A = Z
- 50 = P
![](https://github.com/soniasalido/cybersecurity/blob/main/Documentation/Malware/Learning%20Malware%20Annalysis/capturas/xxd.png)

**"MZ"** es la firma m√°gica de los archivos ejecutables en DOS/Windows (archivos .exe). Llamada as√≠ por Mark Zbikowski, ingeniero de Microsoft. Indica que **el archivo es un ejecutable PE (Portable Executable)** o que al menos comienza con una cabecera compatible con DOS.

La ‚ÄúP‚Äù no forma parte de la firma est√°ndar. Es simplemente el siguiente byte despu√©s del ‚ÄúMZ‚Äù, y su valor depende del contenido binario del archivo.



**1.3. Identificando el tipo de fichero usando herramientas:**
- En sistemas Linux, esto se puede lograr usando la utilidad ```file```.
  - Ejemplo 1: En el primer archivo que no tiene ninguna extensi√≥n, se detecta como un archivo ejecutable de 32 bits (PE32)
    ```
    $ file mini
    mini: PE32 executable (GUI) Intel 80386, for MS Windows
    ```
  - Ejemplo2: En el segundo archivo es un ejecutable de 64 bits (PE32+):
    ```
    $ file notepad.exe
    notepad.exe: PE32+ executable (GUI) x86-64, for MS Windows
    ```

- En Windows: Podemos usar **CFF Explorer**, que es parte de Explorer Suite (http://www.ntcore.com/exsuite.php).


**1.4. Identificando el tipo de fichero usando Python**
El m√≥dulo ```python-magic``` puede ser usado para identificar el tipo de fichero de un archivo.
```
$ python
Python 2.7.12 (default, Nov 19 2016, 06:48:10)
>>> import magic
>>> m = magic.open(magic.MAGIC_NONE)
>>> m.load()
>>> ftype = m.file(r'log.exe')
>>> print ftype
PE32 executable (GUI) Intel 80386, for MS Windows
```

**1.5 Herramienta PEV:**
La herramienta PEV (Portable Executable).

-------------------------------------------------
## 2. Tomar huellas dactilares del malware: Fingerprinting the Malware

### 2.1 ¬øQu√© es "Fingerprinting the Malware"?
Fingerprinting significa **identificar de forma √∫nica una pieza de malware** usando ciertas caracter√≠sticas t√©cnicas que la distinguen de otras.

Es como sacarle la huella digital para poder:
- Detectarlo en otros sistemas.
- Compararlo con otras variantes.
- Crear reglas para antivirus o sistemas de detecci√≥n.

**Fingerprinting:** El fingerprinting de malware es el proceso de recopilar informaci√≥n y caracter√≠sticas distintivas de un archivo malicioso, lo que permite a los analistas de seguridad y a las herramientas de protecci√≥n identificar, clasificar y entender mejor el comportamiento del malware.

### Beneficios de tomar un fingerprint de un malware:
- **Identificaci√≥n √önica:** Al igual que las huellas dactilares humanas son √∫nicas para cada individuo, el fingerprinting de malware permite identificar de manera √∫nica una muestra de malware, lo que facilita su seguimiento y detecci√≥n en diferentes sistemas
- **Prevenci√≥n de Fraudes y Autenticaci√≥n:** El fingerprinting puede detectar patrones inusuales que podr√≠an indicar una actividad sospechosa, como intentos de fraude o accesos no autorizados, y es una herramienta valiosa para la autenticaci√≥n de usuarios y dispositivos
- **Investigaci√≥n y An√°lisis Forense:** El fingerprinting es crucial para el an√°lisis forense, ya que proporciona datos detallados sobre el malware que pueden ser utilizados para entender su origen, prop√≥sito y c√≥mo se propaga.
- **Desarrollo de Firmas de Antivirus:** La informaci√≥n recopilada a trav√©s del fingerprinting se utiliza para desarrollar firmas que los programas antivirus pueden usar para identificar y bloquear malware conocido.


### 2.2 Huellas comunes que se analizan. Formas de Identificar de forma √∫nica una pieza de malware
| Tipo de fingerprint	| ¬øQu√© es? |
| -- | -- |
| **Hash (MD5, SHA-1, SHA-256)** | 	Identificadores √∫nicos del archivo binario. Un simple cambio en el c√≥digo genera un hash distinto. | 
| **Strings**	|  Cadenas de texto presentes en el malware (nombres de funciones, URLs, rutas, mensajes, etc.). | 
| **API calls** | 	Funciones del sistema operativo que el malware utiliza (ej: ```CreateRemoteThread, WriteProcessMemory```). | 
| **Comportamientos** | 	Acciones como persistencia, inyecci√≥n de procesos, cifrado de archivos, comunicaci√≥n con C2 (```comando y control```). | 
| **Ruta o nombre del archivo** | 	Algunos malware usan nombres o rutas repetidas. | 
| **Certificados digitales falsos** | 	A veces el malware usa firmas digitales maliciosas o robadas. | 
| **Firmas de red**	|  Patrones en el tr√°fico que genera (como DNS malicioso, peticiones HTTP an√≥malas...). | 


### 2.2.1. Hash del archivo:
- Checksum.
- Hash criptogr√°fico.

‚úÖ El checksum es una forma de fingerprint, pero muy b√°sica.  
‚ö†Ô∏è En an√°lisis serio de malware, siempre se usa hash criptogr√°fico (como SHA-256).  
‚úÖ El checksum puede ser √∫til como verificaci√≥n r√°pida, pero no para identificar malware de forma segura.

El checksum, tambi√©n conocido como **suma de verificaci√≥n**, es un **valor calculado a partir de un conjunto de datos con el objetivo de verificar su integridad**. Es una forma de asegurarse de que los datos no han sido alterados, ya sea accidentalmente o de manera malintencionada, durante la transmisi√≥n o el almacenamiento.

El proceso de checksum implica **aplicar un algoritmo o funci√≥n matem√°tica a los datos originales para producir un valor hash o una cadena de caracteres**. Este valor hash es una representaci√≥n compacta de los datos originales. Cuando los datos se transmiten o se almacenan junto con su checksum, cualquier parte que reciba o acceda a esos datos puede calcular de nuevo el checksum y compararlo con el valor original. Si los valores coinciden, se puede asumir que los datos no han sido modificados. Si los valores no coinciden, indica que los datos pueden haber sido corrompidos o alterados

**Usos de checksums:**  
- Verificaci√≥n de la integridad de archivos descargados de Internet.
- Detecci√≥n de errores en la transmisi√≥n de datos.
- Validaci√≥n de la autenticidad de la informaci√≥n. Por ejemplo, al descargar un archivo, a menudo se proporciona un checksum (como SHA256sum) que el usuario puede verificar para asegurarse de que el archivo no ha sido da√±ado o modificado desde que fue publicado por el creador.

**Algoritmos de checksum:**  
- **Algoritmos simples como CRC32 o Adler-32**. No est√°n dise√±ados para seguridad: son f√°cil de falsificar.
- **Hash criptogr√°fico como MD5, SHA-1, SHA-256** que son un tipo de checksum mucho m√°s seguros y √∫nicos.


**¬øSon infalibles los checksums?**  
Aunque los checksums son √∫tiles para detectar cambios en los datos, no son infalibles y **no pueden garantizar la seguridad contra ataques maliciosos sofisticados, como los ataques de colisi√≥n,** donde dos conjuntos de datos diferentes pueden producir el mismo checksum


**Hash Collision:**  
Un hash collision, o colisi√≥n de hash, ocurre cuando dos piezas distintas de datos producen el mismo valor de hash al ser procesadas por una funci√≥n de hash. Esto significa que, a pesar de que los datos de entrada son diferentes, el resultado de la funci√≥n de hash es id√©ntico para ambos. Las funciones de hash est√°n dise√±adas para tomar datos de entrada de cualquier tama√±o y producir un resultado de longitud fija, conocido como **valor de hash, que act√∫a como una representaci√≥n digital de los datos originales.**

Las colisiones de hash son un fen√≥meno inherente a las funciones de hash debido al **principio del palomar**, que establece que si se tienen m√°s palomas que palomares y cada paloma debe ser alojada en un palomar, al menos un palomar contendr√° m√°s de una paloma. De manera similar, dado que el n√∫mero de posibles entradas para una funci√≥n de hash es pr√°cticamente infinito, pero el n√∫mero de posibles resultados de hash es finito, eventualmente debe ocurrir que dos entradas diferentes produzcan el mismo hash.

Las colisiones de hash pueden tener implicaciones significativas en varios campos, especialmente en la criptograf√≠a y la seguridad inform√°tica. Por ejemplo, en la autenticaci√≥n de datos o en la firma digital, **una colisi√≥n de hash podr√≠a permitir a un atacante crear datos falsificados que produzcan el mismo valor de hash que los datos originales y leg√≠timos, comprometiendo as√≠ la integridad de los datos.**

Para mitigar el riesgo de colisiones de hash, se utilizan algoritmos de hash criptogr√°ficos dise√±ados para ser resistentes a colisiones, lo que significa que es computacionalmente inviable encontrar dos entradas diferentes que produzcan el mismo valor de hash. Sin embargo, **no existe un algoritmo de hash que pueda garantizar completamente la ausencia de colisiones debido a las limitaciones matem√°ticas y computacionales.**


**¬øSe usa el checksum para fingerprinting?**
‚úÖ S√≠, pero con matices:
| Uso	| Checksum simple (CRC, etc.)	| Hash criptogr√°fico (MD5, SHA-256)|
| -- | --| -- |
| Detecci√≥n de integridad | 	‚úÖ | 	‚úÖ |
| Identificaci√≥n de malware | 	‚ùå (no fiable) | 	‚úÖ (muy com√∫n) |
| Comparaci√≥n de archivos | 	‚ùå (colisiones posibles) | 	‚úÖ |
| Seguridad o forense | 	‚ùå | 	‚úÖ |



**Generando Cryptographic Hash de un malware:**  
Este proceso nos permite obtener un identificador √∫nico para el archivo malicioso basado en su contenido, lo cual es √∫til para su an√°lisis, identificaci√≥n y comparaci√≥n con bases de datos de malware conocido.
- En Windows:
  ```
  certUtil -hashfile nombreArchivo SHA256
  certUtil -hashfile nombreArchivo MD5 | SHA256 | SHA512
  Get-FileHash -Algorithm Sha256 nombreArchivo
  Get-FileHash -Algorithm MD5 | SHA256 | SHA512 nombreArchivo
  ```
- En Linux:
  ```
  sha256sum nombre_del_archivo
  ```
- En python:
  ```
  python
  Python 2.7.12 (default, Nov 19 2016, 06:48:10)
  >>> import hashlib
  >>> content = open(r"log.exe","rb").read()
  >>> print hashlib.md5(content).hexdigest()
  6e4e030fbd2ee786e1b6b758d5897316
  >>> print hashlib.sha256(content).hexdigest()
  01636faaae739655bf88b39d21834b7dac923386d2b52efb4142cb278061f97f
  >>> print hashlib.sha1(content).hexdigest()
  625644bacf83a889038e4a283d29204edc0e9b65
  ```


## 3. Firmas de antivirus (AV signatures)
Bases de datos como VirusTotal o Hybrid Analysis asocian la muestra a una familia de malware espec√≠fica.
- Ej: "Trojan:Win32/Emotet.CA"
- Estas firmas son una forma de fingerprint si son suficientemente espec√≠ficas.


### Virus Total
VirusTotal es una herramienta en l√≠nea gratuita que se utiliza para analizar archivos y URLs en busca de virus, gusanos, troyanos y otros tipos de malware. La plataforma utiliza m√°s de 70 motores antivirus y anti-malware para escanear y proporcionar un informe detallado sobre cualquier amenaza detectada.

Pasos para usar VirusTotal para escanear un malware:
- Subir el Archivo o URL Sospechosa: Accede a la p√°gina web de VirusTotal y selecciona la opci√≥n para subir el archivo que deseas analizar o ingresa la URL que quieres verificar
- An√°lisis Autom√°tico: Una vez que el archivo o URL ha sido subido, VirusTotal lo analizar√° autom√°ticamente utilizando sus m√∫ltiples motores antivirus y nos proporcionar√° un informe con los resultados
- Interpretar los Resultados: El informe incluir√° una lista de todos los motores antivirus que analizaron el archivo y sus resultados. Si alguno de los motores detecta una amenaza, el informe indicar√° el nombre de la amenaza y proporcionar√° informaci√≥n adicional sobre ella
- Evaluar la Confiabilidad: Es importante tener en cuenta que aunque VirusTotal es una herramienta valiosa, no es infalible y no garantiza una protecci√≥n completa contra el malware. Por lo tanto, se recomienda utilizar una variedad de herramientas de seguridad y seguir las mejores pr√°cticas de seguridad cibern√©tica
- Uso de la API P√∫blica: Para usuarios avanzados o para integraciones autom√°ticas, VirusTotal ofrece una API p√∫blica que permite enviar muestras y recibir informes de an√°lisis de manera program√°tica
- Herramientas Adicionales: Adem√°s de la p√°gina web, existen herramientas como VirusTotal Uploader y aplicaciones para dispositivos m√≥viles que facilitan el env√≠o de archivos y URLs a VirusTotal para su an√°lisis

### Querying Hash Values Using VirusTotal
Pasos para consultar valores de hash utilizando VirusTotal:
- Obtener un Hash de Archivo: Primero, necesitamoss el hash del archivo que deseamos consultar. Los hashes permitidos son MD5, SHA1 y SHA256
- Acceder a VirusTotal: Vamos a la p√°gina web de VirusTotal (https://www.virustotal.com/).
- Ingresar el Hash en la B√∫squeda: Utilizamos la barra de b√∫squeda de VirusTotal para ingresar el hash del archivo.
- Revisar el Informe: Despu√©s de buscar el hash, VirusTotal nos mostrar√° el √∫ltimo informe disponible para ese archivo. Si el archivo ha sido analizado previamente, podremos ver los resultados de los diferentes motores antivirus y otra informaci√≥n relevante

###  Uso de la API de VirusTotal: 
Si preferimos automatizar el proceso o realizar consultas en masa, podemos utilizar la API p√∫blica de VirusTotal. Necesitaremos una clave API que podemos obtener creando una cuenta en VirusTotal.
- Ejemplo de Uso de la API con cURL:
```
curl --request POST \
--url 'https://www.virustotal.com/vtapi/v2/file/report' \
-d apikey=$your-api-key \
-d 'resource=$your-file-hash'
```
Reemplazamos $your-api-key con nuestra clave API y $your-file-hash con el hash del archivo que deseamos consultar.


###  Ejemplo de Uso de la API con Python:
```
python
import requests
  
url = 'https://www.virustotal.com/vtapi/v2/file/report'
params = {'apikey': 'tu_clave_api', 'resource': 'hash_del_archivo'}
response = requests.post(url, data=params)
print(response.json())
```
Reemplazamos 'tu_clave_api' con tu clave API y 'hash_del_archivo' con el hash del archivo que deseamos consultar.
  
Nota: La API p√∫blica de VirusTotal tiene una limitaci√≥n de cuatro consultas por minuto. Si necesitamos realizar un mayor volumen de consultas o acceder a informaci√≥n m√°s detallada, tendremos que considerar usar la API privada de VirusTotal o el servicio premium VirusTotal Intelligence.


Otro script:
  ```
  import urllib
  import urllib2
  import json
  import sys

  hash_value = sys.argv[1]
  vt_url = "https://www.virustotal.com/vtapi/v2/file/report"
  api_key = "<update your api key here>"
  parameters = {'apikey': api_key, 'resource': hash_value}
  encoded_parameters = urllib.urlencode(parameters)
  request = urllib2.Request(vt_url, encoded_parameters)
  response = urllib2.urlopen(request)
  json_response = json.loads(response.read())
  if json_response['response_code']:
    detections = json_response['positives']
    total = json_response['total']
    scan_results = json_response['scans']
    print "Detections: %s/%s" % (detections, total)
    print "VirusTotal Results:"
    for av_name, av_data in scan_results.items():
      print "\t%s ==> %s" % (av_name, av_data['result'])
  else:
    print "No AV Detections For: %s" % hash_value
  ```


Running the preceding script by giving it an MD5 hash of a binary shows the antivirus detections and the signature names for the binary.
  ```
  md5sum 5340.exe
  5340fcfb3d2fa263c280e9659d13ba93 5340.exe

  python vt_hash_query.py 5340fcfb3d2fa263c280e9659d13ba93
  Detections: 44/56
  VirusTotal Results:
     Bkav ==> None
     MicroWorld-eScan ==> Trojan.Generic.11318045
     nProtect ==> Trojan/W32.Agent.105472.SJ
     CMC ==> None
     CAT-QuickHeal ==> Trojan.Agen.r4
     ALYac ==> Trojan.Generic.11318045
     Malwarebytes ==> None
     Zillya ==> None
     SUPERAntiSpyware ==> None
     TheHacker ==> None
     K7GW ==> Trojan ( 001d37dc1 )
     K7AntiVirus ==> Trojan ( 001d37dc1 )
     NANO-Antivirus ==> Trojan.Win32.Agent.cxbxiy
     F-Prot ==> W32/Etumbot.K
     Symantec ==> Trojan.Zbot
     [.........Removed..............]

  ```
### Otras herramientas:
- Usando la herramienta PEstudio (https://www.winitor.com/) o la herramienta PPEE (https://www.mzrst.com/).
- Online scanners such as VirSCAN (http://www.virscan.org/), Jotti Malware Scan (https://virusscan.jotti.org/), and OPSWAT's Metadefender (https://www.metadefender.com/#!/scan-file) allow you to scan a suspect file with multiple anti-virus scanning engines, and some of them also allow you to do hash lookups.

### Consideraciones a tener en cuenta cuando subimos un binario a un scanner online:
-  Aunque los esc√°neres antivirus y los servicios de escaneo en l√≠nea son herramientas √∫tiles para identificar malware, existen limitaciones y riesgos asociados con su uso. Es crucial ser consciente de estos riesgos, especialmente en lo que respecta a la confidencialidad de la informaci√≥n y la posibilidad de que los atacantes adapten sus m√©todos para evadir la detecci√≥n.
  - Detecci√≥n no garantizada: Los autores de malware pueden modificar su c√≥digo y emplear t√©cnicas de ofuscaci√≥n para evadir estas detecciones, lo que puede resultar en que algunos motores antivirus no logren identificar el archivo como malicioso. Esto se debe a que las t√©cnicas de ofuscaci√≥n y metamorfismo pueden cambiar la apariencia del c√≥digo malicioso sin alterar su funcionalidad, dificultando su detecci√≥n basada en firmas.
  - Riesgos de compartir binarios: Al subir un archivo binario a un sitio p√∫blico, existe el riesgo de que este archivo se comparta con terceros y proveedores. Si el archivo binario contiene informaci√≥n sensible, personal o propiedad de una organizaci√≥n, no es recomendable enviarlo a servicios p√∫blicos de escaneo antivirus, especialmente si es parte de una investigaci√≥n confidencial. Esto se debe a que el archivo podr√≠a contener datos cr√≠ticos que no deber√≠an ser expuesto.
  - Uso de valores hash criptogr√°ficos: Como alternativa a la presentaci√≥n del archivo binario, la mayor√≠a de los servicios de escaneo antivirus en l√≠nea permiten buscar en su base de datos de archivos escaneados utilizando valores hash criptogr√°ficos (MD5, SHA1 o SHA256). Esto significa que en lugar de subir el archivo completo, se puede buscar utilizando el hash criptogr√°fico del archivo, lo que reduce el riesgo de exponer informaci√≥n sensible.


## 4. Extraer Cadenas de texto (Strings)
Extraer strings legibles del ejecutable puede revelar:
- URLs de comando y control (C2).
- Mensajes de error.
- Frases tipo "your files have been encrypted".
- Nombres de funciones o variables.
- Direcciones IP y URLs que pueden se√±alar a servidores de C&C.
- Rutas de archivos espec√≠ficos que el malware intenta modificar o leer.
- Logs que el malware genera.
- Referencias a librer√≠as espec√≠ficas o llamadas al sistema que indican c√≥mo interact√∫a el malware con el sistema operativo.


La extracci√≥n de cadenas de un fichero ejecutable es un proceso utilizado en el an√°lisis de malware y en la ingenier√≠a inversa de software para **identificar y extraer secuencias de caracteres legibles (cadenas) dentro de un archivo binario**. Este proceso es fundamental para entender el comportamiento potencial de un programa sin necesidad de ejecutarlo o analizar su c√≥digo fuente, que puede no estar disponible. Las cadenas pueden incluir rutas de archivos, mensajes de error, URLs de servidores de comando y control (C&C), claves de cifrado, y otros indicadores de compromiso (IoCs) que son √∫tiles para el an√°lisis de seguridad.

Las **cadenas son secuencias de caracteres imprimibles en ASCII y Unicode incrustadas en un archivo.**
La extracci√≥n de cadenas puede dar pistas sobre la funcionalidad del programa y los indicadores asociados con un binario sospechoso. Por ejemplo, si un malware crea un archivo, el nombre del archivo se almacena como una cadena en el binario. Tambi√©n si un malware resuelve un nombre de dominio controlado por el atacante, entonces el nombre de dominio se almacena como una cadena. Las cadenas extra√≠das del binario pueden contener **referencias a nombres de archivos, URL, nombres de dominio, direcciones IP, comandos de ataque, claves de registro, etc**. Aunque las cadenas no dan una idea clara del prop√≥sito y la capacidad de un archivo, pueden dar una **pista sobre lo que el malware es capaz de hacer.**


### 4.1 Extraer Cadenas usando herramientas
**Herramientas para la extracci√≥n de cadenas de archivos ejecutables:**
- **Strings:** Disponible en sistemas Unix y Windows, es una herramienta de l√≠nea de comandos que busca secuencias de caracteres ASCII o Unicode que son al menos de una longitud m√≠nima especificada (por defecto, 4 caracteres). El comando strings, por defecto, extrae las cadenas ASCII que tienen al menos cuatro caracteres de largo. Con la opci√≥n -a es posible extraer cadenas de todo el archivo.
  ```
  strings -a log.exe
  ```
  Espec√≠menes de malware tambi√©n utilizan **cadenas Unicode (2 bytes por car√°cter)**. Para obtener informaci√≥n √∫til del binario, a veces necesitas extraer tanto cadenas ASCII como Unicode. Para extraer cadenas Unicode usando el comando strings, usamos la opci√≥n -el.
  ```
  strings -a -el log.exe
  ```

  **Filtrar la salida** del comando strings para buscar cosas determinadas:
  ```
  strings -a -el log.exe | grep ".exe"
  strings -a -el log.exe | grep ".dll"
  ```
  

- **Binwalk:** Aunque es m√°s conocida por su capacidad para analizar y extraer firmware, tambi√©n puede ser utilizada para extraer cadenas.
- **HEx Editors:** Permiten visualizar y editar el contenido binario de un archivo, incluyendo la extracci√≥n manual de cadenas.
- En Windows, **pestudio** (https://www.winitor.com) es una herramienta √∫til que muestra cadenas ASCII y Unicode.
- Tambi√©n en windows se puede usar el **comando strings de sysinternals** y PPEE (https://www.mzrst.com/).
- BinText.
- Ghidra.


**Proceso de Extracci√≥n:** La herramienta seleccionada lee el archivo binario y busca secuencias de caracteres que coincidan con patrones de cadenas legibles. Estas cadenas se extraen y se presentan al analista para su revisi√≥n.



### 4.2 Decoding Obfuscated Strings Using FLOSS
La mayor√≠a de las veces, los autores de malware utilizan t√©cnicas simples de ofuscaci√≥n de cadenas para evitar la detecci√≥n. En tales casos, esas cadenas ofuscadas no aparecer√°n en la utilidad de cadenas ni en otras herramientas de extracci√≥n de cadenas. **FireEye Labs Ofuscated String Solver (FLOSS)** es una herramienta dise√±ada para **identificar y extraer autom√°ticamente cadenas ofuscadas de malware**. Puede ayudarle a determinar las cadenas que los autores de malware quieren ocultar de las herramientas de extracci√≥n de cadenas.

FLOSS tambi√©n se puede utilizar como la utilidad de cadenas para **extraer cadenas legibles por humanos (ASCII y Unicode)**. Para descargar FLOSS para Windows o Linux: https://github.com/fireeye/flare-floss.
```
sudo apt install python3-venv python3-full
mkdir ~/miENV
python3.12 -m venv miENV


git clone https://github.com/mandiant/flare-floss.git
cd flare-floss
python setup.py install
```


Otra forma de instalar flare-floss en linux:
```
python3.11 -m venv venv
source venv/bin/activate
pip3.11 install flare-floss
floss program.exe > analisis-floss.txt
```



En el siguiente ejemplo, no s√≥lo se han extraido las cadenas legibles por humanos, sino que tambi√©n decodific√≥ las cadenas ofuscadas y extrajo las cadenas de la pila que la utilidad de cadenas y otras herramientas de extracci√≥n de cadenas no detectaron. El siguiente resultado muestra una referencia a un ejecutable, un archivo de Excel y una clave de registro de ejecuci√≥n:
```
$ chmod +x floss
$ ./floss 5340.exe
FLOSS static ASCII strings
!This program cannot be run in DOS mode.
Rich
.text
`.rdata
@.data
[..removed..]
FLOSS decoded 15 strings
kb71271.log
R6002
- floating point not loaded
\Microsoft
winlogdate.exe
~tasyd3.xls
[....REMOVED....]
FLOSS extracted 13 stack strings
BINARY
ka4a8213.log
afjlfjsskjfslkfjsdlkf
'Clt
~tasyd3.xls
"%s"="%s"
regedit /s %s
[HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Run]
[.....REMOVED......]
```

Si s√≥lo estmos interesados en las **cadenas decodificadas/apiladas y deseamos excluir las cadenas est√°ticas (ASCII y Unicode)** de la salida FLOSS, proporcionamos el modificador ```--no-static-strings```.

https://www.mandiant.com/resources/blog/automatically-extracting-obfuscated-strings


**An√°lisis de los Resultados:** FLOSS mostrar√° las cadenas ofuscadas que ha logrado identificar y extraer. Estas cadenas pueden incluir direcciones IP, URLs, nombres de dominio, claves de cifrado, y otros datos que el malware utiliza en sus operaciones. Es importante analizar estas cadenas en el contexto del comportamiento general del malware para entender su prop√≥sito y c√≥mo interact√∫a con los sistemas infectados.
- Cadenas ASCII Est√°ticas: Estas son cadenas de texto que se pueden leer directamente en el archivo binario y no est√°n ofuscadas. Por ejemplo, la cadena "!This program cannot be run in DOS mode." es t√≠pica en los archivos ejecutables de Windows y no es indicativa de actividad maliciosa por s√≠ misma.
- Cadenas Decodificadas: Estas cadenas pueden incluir nombres de archivos de registro como "kb71271.log", mensajes de error como "R6002 - floating point not loaded", o referencias a directorios del sistema como "\Microsoft". Estas cadenas pueden ser pistas sobre la funcionalidad del malware, como los archivos que intenta crear o modificar, o errores que maneja.
- Cadenas Extra√≠das de la Pila (Stack Strings): Estas son cadenas que FLOSS ha identificado y extra√≠do de la memoria de la pila durante la ejecuci√≥n del malware. Por ejemplo, "ka4a8213.log" podr√≠a ser otro archivo de registro, y "~tasyd3.xls" podr√≠a ser un archivo que el malware busca o genera. La **cadena "%s"="%s" sugiere una operaci√≥n de formato o asignaci√≥n**, y "regedit /s %s" indica que el malware podr√≠a estar intentando modificar el registro de Windows de forma silenciosa.
- Cadenas Relacionadas con la Persistencia: La referencia a **"[HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Run]"** es particularmente significativa, ya que esta ubicaci√≥n del registro se utiliza com√∫nmente para configurar programas que se ejecutan autom√°ticamente al iniciar sesi√≥n en Windows. Esto podr√≠a indicar que el malware intenta establecer persistencia en el sistema infectado.

Al analizar estos resultados, es importante **considerar el contexto y la funcionalidad potencial que las cadenas podr√≠an representar** dentro del malware. Por ejemplo:
- Cadenas de Archivos y Directorios: Pueden indicar los archivos y directorios con los que el malware interact√∫a.
- Mensajes de Error: Pueden revelar las funciones del sistema que el malware intenta utilizar y c√≥mo maneja las condiciones de error.
- Comandos del Sistema: Como "regedit /s %s", pueden sugerir intentos de modificar la configuraci√≥n del sistema para lograr objetivos maliciosos.
- Referencias al Registro de Windows: Pueden indicar intentos de lograr la persistencia o modificar la configuraci√≥n del sistema para beneficio del malware.





## 5. Funciones/APIs utilizadas

**Las Windows API (Application Programming Interface de Windows)** son un conjunto de funciones y servicios que proporciona el sistema operativo Windows para que los programas (como aplicaciones o malware) puedan interactuar con el sistema.

Una Windows API es una puerta de acceso al sistema operativo que permite a los programas:
- Crear y manejar ventanas.
- Leer y escribir archivos.
- Conectarse a internet.
- Ejecutar procesos.
- Usar memoria.
- Interactuar con dispositivos, etc.


**La llamada a funciones del sistema operativo puede ser muy reveladora.**
- API sospechosas: ```CreateRemoteThread, VirtualAllocEx, RegSetValueEx```, etc.
- Algunas familias de malware tienen un patr√≥n de llamadas √∫nico.


**üìå Ejemplos comunes de Windows API (muy usadas en malware):**

| Funci√≥n API |	Lo que hace |	DLL asociada |
| -- | -- | -- |
| CreateFileA |	Abre o crea un archivo |	KERNEL32.dll |
| WriteFile |	Escribe datos en un archivo o socket |	KERNEL32.dll |
| CreateProcessA |	Crea un nuevo proceso |	KERNEL32.dll |
| VirtualAlloc |	Reserva memoria en un proceso |	KERNEL32.dll |
| LoadLibraryA |	Carga una DLL en tiempo de ejecuci√≥n |	KERNEL32.dll |
| GetProcAddress |	Obtiene la direcci√≥n de una funci√≥n de una DLL |	KERNEL32.dll |
| InternetOpenA |	Abre una sesi√≥n de internet |	WININET.dll |
| InternetConnectA |	Se conecta a un servidor |	WININET.dll |
| Send / Recv |	Env√≠a/recibe datos por red |	WS2_32.dll |
| RegOpenKeyEx |	Abrir una clave del registro  |	Registry Persistence |
| RegCreateKeyEx |	Crear una clave del registro  |	Registry Persistence |
| RegSetValueEx |	Escribir un valor en una clave |	Registry Persistence |
| RegCloseKey |	Cerrar la clave del registro |	Registry Persistence |
| RegDeleteKey / RegDeleteValue |	Eliminar claves o valores |	Registry Persistence |



### 5.1 Tabla de Direcciones de Importaci√≥n (IAT)
![IAT](capturas/iat.png)

**La Tabla de Direcciones de Importaci√≥n (IAT, por sus siglas en ingl√©s: Import Address Table)** es una estructura presente en los archivos ejecutables del formato PE (Portable Executable) en Windows, utilizada tanto por programas leg√≠timos como por malware. Su funci√≥n principal es almacenar las direcciones virtuales de las funciones importadas de otras bibliotecas (DLLs), que el programa necesitar√° usar durante su ejecuci√≥n.

El sistema operativo utiliza la **IAT para resolver en tiempo de carga d√≥nde est√° cada funci√≥n importada**, permitiendo as√≠ que el binario llame a funciones externas como API de Windows o funciones de otras DLLs.

Los analistas de malware suelen **revisar la IAT para identificar qu√© funciones y bibliotecas utiliza el malware**, lo que ayuda a determinar su comportamiento o capacidades (por ejemplo, si realiza conexiones de red, manipulaci√≥n de archivos, acceso al registro, etc.).

Es com√∫n que **t√©cnicas de evasi√≥n o persistencia de malware manipulen la IAT**, bien para ocultar llamadas a funciones, redirigirlas o enganchar (‚Äú```hookear```‚Äù) funciones y modificar el comportamiento del programa (por ejemplo, interceptar informaci√≥n antes de pasarla al sistema operativo).



### 5.2 Inspecci√≥n de Dependencias de Archivos e Importaciones:
Cuando analizamos qu√© funciones importa un ejecutable desde DLLs del sistema operativo, estamos viendo su huella funcional. Eso ayuda a:
- Detectar comportamientos: ¬øquiere conectarse a red? ¬øleer el registro? ¬øcrear procesos?.
- Asociar el malware a una familia conocida (muchos malware reusan los mismos patrones de importaci√≥n).
- Crear reglas YARA o modelos de detecci√≥n basados en esas dependencias.

**¬øQu√© tipo de importaciones se suelen revisar?**
| DLL com√∫n	| Funciones clave (APIs) |	¬øQu√© indica? |
| -- | -- | -- |
| kernel32.dll	| 	CreateFile, ReadFile, WriteFile		| Acceso a archivos |
| kernel32.dll	| 	VirtualAllocEx		| Reserva memoria en otro proceso |
| kernel32.dll	| 	VirtualAlloc		| Reserva memoria en el propio proceso |
| kernel32.dll	| 	WriteProcessMemory		| Escribe en otro proceso |
| kernel32.dll	| 	CreateRemoteThread		| Ejecuta c√≥digo en otro proceso |
| kernel32.dll	| 	VirtualProtect		| Cambia permisos de p√°ginas de memoria |
| advapi32.dll	| 	RegOpenKey, RegSetValue, OpenService	| 	Registro de Windows, servicios |
| user32.dll	| 	MessageBox, GetAsyncKeyState	| 	Interacci√≥n con el usuario, keylogging |
| wininet.dll / ws2_32.dll	| 	InternetOpen, connect, send	| 	Conexi√≥n a red o C2 |
| ntdll.dll	| 	Funciones de bajo nivel	| 	Indicador de t√©cnicas evasivas |


**Herramientas para inspecci√≥n de importaciones:**
- PEStudio (Windows)
- CFF Explorer (Windows)
- Ghidra / IDA Pro (pesta√±a de imports) (Windows & Linux)
- Dependency Walker (Windows)
- ```objdump o pefile.py``` (en Linux o scripts)


**¬øC√≥mo encaja la inspecci√≥n de dependencias de archivos e importaciones en el fingerprinting?**  
Las combinaciones de funciones importadas y DLLs usadas crean un patr√≥n √∫nico o muy caracter√≠stico del malware. Por Ejemplo: Si un binario importa ```WriteProcessMemory, CreateRemoteThread, y VirtualAllocEx```, hay una alta probabilidad de que est√© haciendo ```process injection```, una t√©cnica com√∫n en muchos troyanos y rootkits.

Generalmente, el malware interact√∫a con archivos, registros, la red, etc. Para realizar dichas interacciones, el malware depende frecuentemente de las funciones expuestas por el sistema operativo. Windows exporta la mayor√≠a de sus funciones, llamadas **Interfaces de Programaci√≥n de Aplicaciones (API)**, requeridas para estas interacciones en **archivos de Biblioteca de Enlace Din√°mico (DLL)**. Los ejecutables importan y llaman a estas funciones t√≠picamente de varias DLL que proporcionan diferentes funcionalidades. Las funciones que un ejecutable importa de otros archivos (principalmente DLL) se denominan **funciones importadas (o importaciones | imports)**.

**Por ejemplo:** Si un ejecutable de malware quiere crear un archivo en el disco, en Windows, puede usar una ```API CreateFile()```, que se exporta en kernel32.dll. Para llamar a la API, primero tiene que cargar ```kernel32.dll``` en su memoria y luego llamar a la funci√≥n ```CreateFile()```.

Si inspeccionamos las DLL en las que conf√≠a un malware y las funciones API que importa de las DLL, podremos tener una idea sobre la funcionalidad y capacidad del malware y nos podremos anticipar durante su ejecuci√≥n. **Las dependencias de archivos en ejecutables de Windows se almacenan en la tabla de importaciones de la estructura del archivo PE (IAT).**


**Uso Python para enumerar archivos DLL y funciones importadas:** Esto puede hacerse utilizando el m√≥dulo pefile de Ero Carrera (https://github.com/erocarrera/pefile).

```
pip install pefile
```

El siguiente script en Python demuestra c√≥mo usar el m√≥dulo pefile para enumerar las DLLs y las funciones API importadas:
```
import pefile
import sys
mal_file = sys.argv[1]
pe = pefile.PE(mal_file)
if hasattr(pe, 'DIRECTORY_ENTRY_IMPORT'):
    for entry in pe.DIRECTORY_ENTRY_IMPORT:
        print "%s" % entry.dll
    for imp in entry.imports:
        if imp.name != None:
            print "\t%s" % (imp.name)
        else:
            print "\tord(%s)" % (str(imp.ordinal))
            print "\n"
```

A continuaci√≥n se muestra el resultado de ejecutar el script anterior sobre la muestra spybot_packed.exe; en la salida, puedes ver la lista de DLLs y funciones importadas:
```
$ python enum_imports.py spybot_packed.exe
KERNEL32.DLL
 LoadLibraryA
 GetProcAddress
 VirtualProtect
 VirtualAlloc
 VirtualFree
 ExitProcess
ADVAPI32.DLL
 RegCloseKey
CRTDLL.DLL
 atoi
[...REMOVED....]
```

### 5.3 Inspeccionando Exports:
**El an√°lisis de exports mira qu√© funciones expone el propio archivo malicioso (generalmente una DLL) para que otro proceso las use.** Ver qu√© funciones exporta un archivo nos puede revelar:
- Qu√© hace el malware (sin ni siquiera ejecutarlo).
- Si se trata de una DLL maliciosa disfrazada (por ejemplo, una DLL side-loaded).
- Patr√≥n de nombres caracter√≠stico de una familia de malware.

**Casos t√≠picos de uso:**
- Ver nombres de funciones exportadas: pueden estar relacionados con manipulaci√≥n del registro, controladores, persistencia, etc.
- Detectar t√©cnicas como DLL Injection o DLL Hijacking.
- Saber si es una DLL leg√≠tima modificada o una creada desde cero.

**Herramientas √∫tiles para analizar las exportaciones:**
- PEStudio ‚Üí pesta√±a de "Exports".
- Ghidra / IDA Pro ‚Üí pesta√±a "Exports".
- CFF Explorer.
- Python + pefile ‚Üí como el ejemplo que diste

El ejecutable y la DLL pueden exportar funciones, que pueden ser utilizadas por otros programas. T√≠picamente, una DLL exporta funciones (exportaciones) que son importadas por el ejecutable. Una DLL no puede funcionar por s√≠ sola y depende de un proceso anfitri√≥n para ejecutar su c√≥digo. Un atacante a menudo crea una DLL que exporta funciones que contienen funcionalidad maliciosa. Para ejecutar las funciones maliciosas dentro de la DLL, de alguna manera se hace que sea cargada por un proceso que llama a estas funciones maliciosas. Las DLL tambi√©n pueden importar funciones de otras bibliotecas (DLL) para realizar operaciones del sistema.

En Python, las funciones exportadas pueden ser enumeradas utilizando el m√≥dulo pefile, como se muestra aqu√≠:
```
$ python
Python 2.7.12 (default, Nov 19 2016, 06:48:10)
>>> import pefile
>>> pe = pefile.PE("rmn.dll")
>>> if hasattr(pe, 'DIRECTORY_ENTRY_EXPORT'):
... for exp in pe.DIRECTORY_ENTRY_EXPORT.symbols:
... print "%s" % exp.name
...
AddDriverPath
AddRegistryforME
CleanupDevice
CleanupDevice_EX
CreateBridgeRegistryfor2K
CreateFolder
CreateKey
CreateRegistry
DeleteDriverPath
DeleteOemFile
DeleteOemInfFile
DeleteRegistryforME
DuplicateFile
EditRegistry
EnumerateDevice
GetOS
[.....REMOVED....]
```

Esto enumerar√≠a todas las funciones exportadas por la DLL, que nos dar√≠a pistas claras de DLLs que interact√∫an con el registro y realizan tareas potencialmente maliciosas:
- CreateRegistry.
- EditRegistry.
- CleanupDevice.

### 5.4 Cat√°logo en l√≠nea de API de Windows:
Cat√°logo en l√≠nea de API de Windows com√∫nmente utilizadas en malware: https://malapi.io/
![](capturas/malapi.png)

Este es un recurso incre√≠ble que ayuda a discernir qu√© API vale la pena analizar al realizar an√°lisis de IAT.

## 6. Tama√±o del archivo y estructura PE
Algunos malware tienen tama√±os caracter√≠sticos o estructuras inusuales:
- ‚úÖ Tama√±o total del binario
  - Algunos malware tienen tama√±os muy caracter√≠sticos (demasiado peque√±os, muy grandes, etc.).
  - Puede indicar uso de packers (empaquetadores).
- ‚úÖ N√∫mero de secciones en el PE.
  - Nombres inusuales: .asdf, .textbss, etc.
  - Secciones adicionales: UPX, code, stub, etc.
  - N√∫mero de secciones (demasiadas o muy pocas).
- ‚úÖ Cabecera PE (PE Header Information)
  - Timestamps.
  - Direcci√≥n de entrada (Entry Point).
  - Tabla de importaci√≥n (IAT).
  - Versiones del compilador.
  - Firmas digitales.
  - Subsistema (GUI o consola).
  - Tama√±o de cada secci√≥n.
  - Entrop√≠a (medida de aleatoriedad)

### 6.1 Inspecting PE Header Information

#### ¬øQu√© significa "PE"?
PE significa Portable Executable (Ejecutable Port√°til), un formato de archivo usado por Windows para sus programas ejecutables, bibliotecas (DLL), controladores, etc.


#### ¬øQu√© es la cabecera PE?
El encabezado PE (PE Header) contiene informaci√≥n cr√≠tica que el sistema operativo necesita para cargar y ejecutar el archivo correctamente. El formato PE (Portable Executable) es la estructura de los ejecutables en Windows (.exe, .dll, etc.). La cabecera PE contiene metadatos clave que pueden ayudarnos a identificar caracter√≠sticas √∫nicas del malware.

**¬øQu√© elementos del PE Header se usan como "huella digital"?**
| Campo de la cabecera PE |	¬øPor qu√© es √∫til en fingerprinting? |
| -- | -- |
| Tipo de archivo (EXE, DLL, SYS‚Ä¶) | Identificar la arquitectura de destino del malware |
| Timestamp de compilaci√≥n  |		Puede identificar la fecha falsa usada por ciertas familias |
| N√∫mero y nombres de secciones |		.text (c√≥digo), .data, .rsrc (recursos), .rdata, pero algunos malware usan .asdf, .xyz, etc. |
| Entrypoint (direcci√≥n de entrada) | D√≥nde empieza a ejecutarse el c√≥digo.	Puede indicar empaquetadores o payloads ocultos |
| Import Address Table (IAT) |		Lista de funciones del sistema o DLLs que el ejecutable usar√° |
| Export Table |		Lista de funciones del sistema o DLLs que el ejecutable ofrece a otros |
| Versi√≥n del compilador |		Ayuda a saber con qu√© herramienta fue creado |
| Firmas digitales / certificados |	Algunos malware usan firmas falsas o robadas |
|  Direcciones y tama√±os en memoria y en disco | xx |



- Los ejecutables tienen lo que se llama un **punto de entrada (ENTRY POINT)**. Cuando se ejecuta, este punto de entrada es simplemente la ubicaci√≥n de las primeras piezas de c√≥digo que se van a ejecutar dentro del archivo, como se ilustra a continuaci√≥n:
  
  ![](capturas/entry-point.png)

- Los ejecutables de Windows deben ajustarse al formato **PE/COFF (Portable Executable/Common Object File Format).** El formato de archivo PE es utilizado por los archivos ejecutables de Windows (tales como .exe, .dll, .sys, .ocx y .drv) y tales archivos generalmente se denominan **archivos Portable Executable (PE)**. El archivo PE es una serie de estructuras y subcomponentes que **contienen la informaci√≥n requerida por el sistema operativo para cargarlo en la memoria.**
  
- **Cuando un ejecutable se compila, incluye un encabezado (encabezado PE), que describe su estructura.** Cuando se ejecuta el binario, el cargador del sistema operativo lee la informaci√≥n del encabezado PE y luego carga el contenido binario del archivo en la memoria. El encabezado PE contiene informaci√≥n como d√≥nde necesita ser cargado el ejecutable en la memoria, la direcci√≥n donde comienza la ejecuci√≥n, la lista de bibliotecas/funciones en las que se basa la aplicaci√≥n, y los recursos utilizados por el binario. Examinar el encabezado PE proporciona una gran cantidad de informaci√≥n sobre el binario y sus funcionalidades.

- **Inspecting PE Header Information se refiere a examinar la informaci√≥n contenida en el encabezado** de un archivo ejecutable Portable Executable (PE) en sistemas Windows. El encabezado PE es una estructura de datos importante que contiene informaci√≥n esencial sobre c√≥mo el sistema operativo debe cargar y manejar el archivo ejecutable o la biblioteca de enlace din√°mico (DLL).

- La **entrop√≠a de un archivo** es una medida de la cantidad de aleatoriedad o incertidumbre que contiene. En el contexto de un Ejecutable Port√°til (PE), una **alta entrop√≠a puede ser indicativa de que el archivo ha sido comprimido o cifrado**, lo cual es una t√©cnica com√∫nmente utilizada por el malware para ocultar su c√≥digo y evitar la detecci√≥n por parte de herramientas de seguridad. Por lo tanto, la entrop√≠a es una caracter√≠stica prominente que las herramientas de an√°lisis de malware buscan al evaluar la sospechosidad de un archivo. Si un archivo PE tiene una entrop√≠a inusualmente alta, podr√≠a ser un indicador de que contiene c√≥digo malicioso o que ha sido manipulado para esconder su verdadera naturaleza. La entrop√≠a de un archivo es una clasificaci√≥n que califica qu√© tan aleatorios son los datos dentro de un archivo PE. Con una escala del 0 al 8, donde 0 significa menos "aleatoriedad" de los datos en el archivo, y un puntaje hacia 8 indica que estos datos son m√°s "aleatorios".

- Los autores de malware utilizan t√©cnicas como la **encriptaci√≥n o el empaquetado para ofuscar su c√≥digo e intentar eludir el antivirus**. Debido a esto, estos archivos tendr√°n una entrop√≠a alta.

- Cuando **inspeccionamos el encabezado PE, generalmente buscamos detalles como:**
  - Tipo de Archivo: Determinar si el archivo es un ejecutable, una DLL, un controlador del sistema, entre otros.
  - Punto de Entrada: La ubicaci√≥n en el c√≥digo donde el sistema operativo comienza a ejecutar el programa.
  - Secciones del Archivo: Informaci√≥n sobre las diferentes secciones del archivo, como c√≥digo, datos y recursos.
  - Dependencias de la Biblioteca: Qu√© otras bibliotecas (DLLs) necesita el ejecutable para funcionar.
  - Informaci√≥n de la Plataforma: Para qu√© arquitectura de hardware est√° dise√±ado el archivo (por ejemplo, x86, x64).
  - Firmas Digitales: Para verificar la autenticidad y la integridad del archivo.

- **Resources for understanding the PE file structure:**
  - An In-Depth Look into the Win32 Portable Executable File Format - Part 1:
  http://www.delphibasics.info/home/delphibasicsarticles/anindepthlookintothewin32portableexecutablefileformat-part1
  - An In-Depth Look into the Win32 Portable Executable File Format - Part 2:
  http://www.delphibasics.info/home/delphibasicsarticles/anindepthlookintothewin32portableexecutablefileformat-part2
  - PE Headers and structures: http://www.openrce.org/reference_library/files/reference/PE%20Format.pdf
  - PE101 - A Windows Executable Walkthrough: https://github.com/corkami/pics/blob/master/binary/pe101/pe101.pdf


#### Herramientas para an√°lisis de archivos PE:
- **Comando pecheck:** El comando pecheck es una herramienta de an√°lisis de archivos PE (Portable Executable) desarrollada por Didier Stevens. Cuando se ejecuta pecheck en un archivo PE, la herramienta examina el archivo y proporciona un informe que incluye informaci√≥n sobre las siguientes estructuras y elementos:
  - DOS Header: La cabecera inicial que est√° presente para mantener la compatibilidad con aplicaciones DOS antiguas.
  - PE Header: La cabecera que sigue al DOS Header y contiene metadatos esenciales sobre el archivo ejecutable, como la arquitectura de la m√°quina para la que est√° compilado (x86, x64, etc.) y los puntos de entrada del programa.
  - Optional Header: Una secci√≥n del PE Header que proporciona informaci√≥n adicional necesaria para la carga del ejecutable, como la direcci√≥n base de la imagen, la alineaci√≥n de las secciones y el punto de entrada del programa.
  - Section Headers: Las cabeceras de las secciones del archivo que describen c√≥mo se organizan los datos y el c√≥digo dentro del archivo PE.
  - Data Directories: Partes del Optional Header que contienen punteros a estructuras de datos importantes como la tabla de importaciones y exportaciones, recursos y m√°s.

- **Utilidad pe-tree:** pe-tree es una herramienta de an√°lisis de archivos Portable Executable (PE) dise√±ada para proporcionar una vista estructurada y jer√°rquica de los componentes internos de los archivos PE.
  - Vista Jer√°rquica: pe-tree presenta la informaci√≥n del archivo PE en una estructura de √°rbol, lo que permite a los usuarios expandir y colapsar secciones para explorar detalles espec√≠ficos de manera eficiente. Esto incluye cabeceras, secciones, tablas de importaci√≥n/exportaci√≥n, recursos y m√°s.
  - An√°lisis de Secciones y Cabeceras: La herramienta analiza y muestra informaci√≥n detallada sobre las cabeceras PE, incluyendo el DOS Header, PE Header, Optional Header, y Section Headers. Esto es crucial para entender la configuraci√≥n y el comportamiento potencial del archivo.
  - Identificaci√≥n de Anomal√≠as: pe-tree puede ayudar a identificar caracter√≠sticas inusuales o sospechosas en los archivos PE, como secciones ocultas, configuraciones an√≥malas en las cabeceras, o firmas digitales inv√°lidas.
  - Integraci√≥n con Herramientas de An√°lisis de Malware: pe-tree puede integrarse con otras herramientas y plataformas de an√°lisis de malware para proporcionar una visi√≥n m√°s completa del archivo analizado. Esto puede incluir la extracci√≥n y an√°lisis de cadenas, as√≠ como la identificaci√≥n de patrones de c√≥digo malicioso.


- **Analazing PE Header en windows con CFF Explorer:** https://ntcore.com/explorer-suite/



### 6.2 Examining PE Section Table And Sections
El contenido real del archivo PE est√° dividido en secciones. Estas secciones son inmediatamente seguidas por el encabezado PE. Estas secciones representan ya sea c√≥digo o datos y tienen atributos en memoria como lectura/escritura. La secci√≥n que representa c√≥digo contiene instrucciones que ser√°n ejecutadas por el procesador, mientras que la secci√≥n que contiene datos puede representar diferentes tipos de datos, como datos de programa de lectura/escritura (variables globales), tablas de importaci√≥n/exportaci√≥n, recursos, etc. Cada secci√≥n tiene un nombre distintivo que transmite el prop√≥sito de la secci√≥n.

**Secciones en un PE File:**
- .text || CODE: Contiene el c√≥digo ejecutable. Tiene un atributo de lectura-ejecuci√≥n.
- .data || DATA: Contiene datos y variables globales. Tiene un atributo de lectura-escritura.
- .rdata: Contiene datos de solo lectura. A veces tambi√©n contiene informaci√≥n de importaci√≥n y exportaci√≥n.
- .idata: Si est√° presente, contiene la tabla de importaci√≥n. Si no est√° presente, entonces la informaci√≥n de importaci√≥n se almacena en la secci√≥n .rdata.
- .edata: Si est√° presente, contiene informaci√≥n de exportaci√≥n. Si no est√° presente, entonces la informaci√≥n de exportaci√≥n se encuentra en la secci√≥n .rdata.
- .rsrc: Esta secci√≥n contiene los recursos utilizados por el ejecutable, como √≠conos, di√°logos, men√∫s, cadenas, y as√≠ sucesivamente.


**üì¶ Secciones comunes y su significado**
| Secci√≥n |	Funci√≥n principal |	Riesgo si mal usada |
| -- | -- | -- |
| .text | 	C√≥digo ejecutable (instrucciones del programa) | 	‚úÖ Normal, pero puede ocultar shellcode |
| .data | 	Variables globales (lectura/escritura) | 	‚ö†Ô∏è Riesgo si contiene c√≥digo o C2 info |
| .rdata | 	Datos de solo lectura (a veces import/export info) | 	‚ö†Ô∏è Puede esconder strings maliciosas |
| .idata | 	Tabla de importaci√≥n | 	‚úÖ √ötil para fingerprinting API usage |
| .edata | 	Tabla de exportaci√≥n | 	‚úÖ Relevante si es una DLL |
| .rsrc | 	Recursos (√≠conos, di√°logos, cadenas, etc.) | 	‚ö†Ô∏è Puede contener payloads cifrados |
| .reloc | 	Informaci√≥n de reubicaci√≥n de direcciones | 	Rara vez usada por malware |
| .UPX | 	Secci√≥n t√≠pica de ejecutables empaquetados | 	üö® Puede ocultar comportamiento real |


Estos nombres de secci√≥n son principalmente para humanos y no son utilizados por el sistema operativo, lo que significa que **es posible para un atacante o un software de ofuscaci√≥n crear secciones con nombres diferentes.** Si nos encontramos con nombres de secci√≥n que no son comunes, entonces debemos tratarlos con sospecha, y se requiere un an√°lisis adicional para confirmar su malicia. La informaci√≥n sobre estas secciones (como el nombre de la secci√≥n, d√≥nde encontrar la secci√≥n y sus caracter√≠sticas) est√° presente en la tabla de secciones en el encabezado PE. Examinar una tabla de secciones proporcionar√° informaci√≥n sobre la secci√≥n y sus caracter√≠sticas. Cuando cargamos un ejecutable en pestudio y hacemos clic en secciones, muestra la informaci√≥n de la secci√≥n extra√≠da de la tabla de secciones y sus atributos (lectura/escritura, etc.). 

**Campo / Descripcion:**
- Names (Nombres): Muestra los nombres de las secciones. En este caso, el ejecutable contiene cuatro secciones: .text, .data, .rdata y .rsrc.
- Virtual-Size (Tama√±o virtual): Indica el tama√±o de la secci√≥n cuando se carga en memoria.
- Virtual-Address (Direcci√≥n virtual): Es la direcci√≥n virtual relativa (es decir, el desplazamiento desde la direcci√≥n base del ejecutable) donde se puede encontrar la secci√≥n en memoria.
- Raw-size (Tama√±o en disco): Indica el tama√±o de la secci√≥n tal como est√° almacenada en el disco.
- Raw-data (Datos en disco): Indica el desplazamiento en el archivo donde se puede encontrar la secci√≥n.
- Entry-point (Punto de entrada): Es la RVA (direcci√≥n virtual relativa) donde comienza la ejecuci√≥n del c√≥digo. En este caso, el punto de entrada est√° en la secci√≥n .text, lo cual es lo normal.

![](capturas/pestudio.png)

**Discrepancias:**
- Los nombres de las secciones no contienen secciones comunes a√±adidas por el compilador (como .text, .data, y as√≠ sucesivamente) sino que contienen nombres de secci√≥n UPX0 y UPX1.
- El punto de entrada est√° en la secci√≥n UPX1, lo que indica que la ejecuci√≥n comenzar√° en esta secci√≥n (rutina de descompresi√≥n).
- Normalmente, el tama√±o en bruto (raw-size) y el tama√±o virtual (virtual-size) deber√≠an ser casi iguales, pero peque√±as diferencias son normales debido al alineamiento de secciones. En este caso, el tama√±o en bruto es 0, indicando que esta secci√≥n no ocupar√° espacio en el disco, pero el tama√±o virtual especifica que, en memoria, ocupa m√°s espacio (alrededor de 127 kb). Esto es una fuerte indicaci√≥n de un binario empaquetado. La raz√≥n de esta discrepancia es que cuando se ejecuta un binario empaquetado, la rutina de descompresi√≥n del empaquetador copiar√° datos o instrucciones descomprimidas en la memoria durante el tiempo de ejecuci√≥n.



### 6.2 Herramientas para inspeccionar cabeceras PE:
- CFF Explorer: http://www.ntcore.com/exsuite.php
- PE Internals: http://www.andreybazhan.com/pe-internals.html
-  PPEE(puppy): https://www.mzrst.com/
- PEBrowse Professional: http://www.smidgeonsoft.prohosting.com/pebrowsepro-file-viewer.html
- A tool such as **pestudio** (https://www.winitor.com) or **PPEE** (puppy: https://www.mzrst.com/) can assist you with exploring interesting artifacts from the PE file.
- PEStudio ‚Üí s√∫per visual, destaca elementos sospechosos.
- peview.exe
- Detect It Easy (DIE) ‚Üí detecta si est√° empaquetado.
- CFF Explorer ‚Üí an√°lisis avanzado de PE.
-```objdump / readpe / pefile.py``` ‚Üí para l√≠nea de comandos o scripts.
- pesec.
  
- peframe: La herramienta peframe es un analizador est√°tico de archivos ejecutables PE (Portable Executable, t√≠picos de Windows) usado en an√°lisis de malware. Descargar peframe: https://github.com/guelfoweb/peframe
  ```
  python3 -m venv peenv
  # 2. Activa el entorno
  source peenv/bin/activate

  python3 -m pip install --upgrade installer

  git clone https://github.com/guelfoweb/peframe.git
  cd peframe
  
  pip install build

  python3 -m build

  # Esto crear√° un archivo .whl dentro del directorio dist/, algo como:
  # dist/peframe-6.0-py3-none-any.whl

  #  Instala el .whl con installer
  python3 -m installer dist/peframe-*.whl
  
  # 4. Ejecuta peframe
  peframe archivo.exe

  ```
- Detect it Easy: Die: https://horsicq.github.io/
  
- Ghidra.
  
- radare2:
  ```
  sudo apt install radare2
  r2 -A archivo.exe
  aaa              # Carga toda la informaci√≥n del binario
  iI               # Info del formato PE (arch, machine, tama√±o)
  iD               # Directivas del PE como imports/exports
  iS               # Muestra todas las secciones (.text, .data, etc.)
  iS~text          # Filtra por secci√≥n de c√≥digo
  iH               # Cabecera del binario
  ii               # Imports
  iij              # Muestra imports pero en formato JSON (√∫til para scripts)
  ii~VirtualAlloc  # Busca funciones espec√≠ficas, por ejemplo VirtualAlloc
  ii~kernel32      # Ver funciones importadas de kernel32.dll
  ii~WriteProcessMemory
  ii~CreateRemoteThread
  ii~LoadLibrary
  ii~GetProcAddress
  ii~WinExec
  iE               # Exported symbols (s√≠mbolos exportados).
  ie               #  muestra entrypoints del binario
  ae               # Entrypoint analizado
  iz               # Strings encontradas (utf-8, ascii)
  iz~=[A-Za-z0-9]{6,} # Para buscar cadenas raras que podr√≠an estar cifradas
  iz~xor           # Busca strings y llamadas relacionadas con cifrado
  iz~decrypt       # Busca strings y llamadas relacionadas con cifrado
  iz~key           # Busca strings y llamadas relacionadas con cifrado
  ii~RtlDecompress # Busca strings y llamadas relacionadas con cifrado
  afl              # Lista de funciones encontradas
  afl~main         # Busca funciones que contengan "main"
  af               # Define funci√≥n en direcci√≥n actual
  / WinExec        # Buscador de patrones
  pdf              # Print disassembly function
  iz               # Strings del binario
  iz~http          # Filtrar strings que contengan "http"
  axt              # Referencias a una direcci√≥n
  axtj             # Referencias (en JSON)
  axg              # Grafo de referencias cruzadas
  dcu              # Desensamblar hasta llamada (debug)
  / http           # Buscar la palabra "http"
  / bin.sh         # Buscar posibles llamadas a shells
  /c 90            # Buscar NOPs (hexadecimal)
  q                # Salir
  ```


**üõ†Ô∏è Herramientas para inspecci√≥n de secciones PE**
- EStudio ‚Üí muestra secciones con permisos, entrop√≠a, tama√±o, etc.
- Detect It Easy (DIE) ‚Üí identifica empaquetadores y secciones.
- Ghidra / IDA Pro ‚Üí muestra secciones y te permite analizarlas.
- CFF Explorer ‚Üí an√°lisis visual del PE Header + secciones.


#### Herramienta pescanner
pescanner, creado por Michael Ligh y Glenn P. Edwards, es una excelente herramienta para detectar archivos PE sospechosos basados en los atributos del archivo PE; utiliza heur√≠sticas en lugar de firmas y puede ayudarte a identificar binarios empaquetados incluso si no hay firmas para ello. Se puede descargar una copia del script desde https://github.com/hiddenillusion/AnalyzePE/blob/master/pescanner.py.


#### Herramienta pesec
Esta herramienta es utilizada para analizar archivos binarios de Windows (PE - Portable Executable) con el objetivo de revisar ciertas protecciones de seguridad que pueda tener el ejecutable, como por ejemplo:  
![Foto de perfil](capturas/pesec.jpg)
- ASLR (Address Space Layout Randomization): no  
Significa que el binario no soporta aleatorizaci√≥n del espacio de direcciones, lo cual lo hace m√°s vulnerable a exploits de memoria.

- DEP/NX (Data Execution Prevention / No-eXecute): no  
No tiene protecci√≥n para prevenir la ejecuci√≥n de c√≥digo en regiones no ejecutables de la memoria. Esto facilita ataques como el buffer overflow.

- SEH (Structured Exception Handling): yes  
Indica que el ejecutable usa SEH, un mecanismo para manejar excepciones estructuradas. No es una mitigaci√≥n por s√≠ sola, pero es un dato t√©cnico √∫til.

- CFG (Control Flow Guard): no  
No incluye esta mitigaci√≥n contra el secuestro del flujo de control, usada para prevenir exploits tipo ROP.

- Stack cookies (EXPERIMENTAL): yes  
Usa canarios de pila (stack cookies), una protecci√≥n para detectar desbordamientos de buffer.

Este binario es poco seguro: carece de ASLR, DEP/NX y CFG, lo que lo deja expuesto a ataques de explotaci√≥n de memoria. Aunque tiene stack cookies y usa SEH, eso no es suficiente para considerarlo bien protegido.


### 6.3 Examinando el Compilation Timestamp ‚¨ÖÔ∏è‚¨ÖÔ∏è‚¨ÖÔ∏è 
El encabezado PE contiene informaci√≥n que especifica cu√°ndo se compil√≥ el binario; examinar este campo puede dar una idea de cu√°ndo se cre√≥ inicialmente el malware. Esta informaci√≥n puede ser √∫til para construir una l√≠nea de tiempo de la campa√±a de ataque. Tambi√©n es posible que un atacante modifique la marca de tiempo para evitar que un analista conozca la marca de tiempo real. A veces, una marca de tiempo de compilaci√≥n puede usarse para clasificar muestras sospechosas.

El Compilation Timestamp es un valor que se encuentra en la cabecera PE del archivo (IMAGE_FILE_HEADER.TimeDateStamp). Est√° en formato UNIX timestamp (n√∫mero de segundos desde 1970).

‚úÖ Nos permite:
- Construir l√≠neas de tiempo de campa√±as de malware.
- Agrupar muestras por periodos o builds (compilaciones).
- Detectar malware falsamente fechado (si se repite un timestamp en muchas muestras).
- Correlacionar con eventos (por ejemplo: ataques de cierta fecha).
- Identificar muestras que usan timestamps falsos cl√°sicos (como el famoso 0x2A425E19 que corresponde a 2001 pero se ha usado en muchas muestras modificadas).



### 6.4 Examinando PE Resources ‚¨ÖÔ∏è‚¨ÖÔ∏è‚¨ÖÔ∏è 
Los recursos requeridos por el archivo ejecutable, como iconos, men√∫s, di√°logos y cadenas, se almacenan en la secci√≥n de recursos (.rsrc) de un archivo ejecutable. A menudo, los atacantes almacenan informaci√≥n como binarios adicionales, documentos se√±uelo y datos de configuraci√≥n en la secci√≥n de recursos, por lo que examinar los recursos puede revelar informaci√≥n valiosa sobre un binario. La secci√≥n de recursos tambi√©n contiene informaci√≥n de versi√≥n que puede revelar detalles sobre el origen, el nombre de la empresa, los detalles del autor del programa y la informaci√≥n de copyright.


#### Ejemplo de malware que tiene una dll incrustada en la secci√≥n .rsrc
https://github.com/soniasalido/cybersecurity/blob/main/LABS/Investigating%20Malware/github_RPISEC/Labs/Lab_03/Lab-3.1/decompilado/0-Lab3.1.malware/RC_DATA-IDR_DLL1.md

![malware-section-RPISEC-Lab-3.1](https://raw.githubusercontent.com/soniasalido/cybersecurity/refs/heads/main/LABS/Investigating%20Malware/github_RPISEC/Labs/Lab_03/Lab-3.1/analisis-estatico/capturas/pestudio-sections.png)
![malware-section2-RPISEC-Lab-3.1](https://raw.githubusercontent.com/soniasalido/cybersecurity/refs/heads/main/LABS/Investigating%20Malware/github_RPISEC/Labs/Lab_03/Lab-3.1/analisis-estatico/capturas/pestudio-sections-2.png)
![malware-resource-RPISEC-Lab-3.1](https://raw.githubusercontent.com/soniasalido/cybersecurity/refs/heads/main/LABS/Investigating%20Malware/github_RPISEC/Labs/Lab_03/Lab-3.1/analisis-estatico/capturas/pestudio-resources.png)


## 7. Identificar las t√©cnicas de ofuscaci√≥n utilizadas para frustrar el an√°lisis: Determining File Obfuscation
Aunque la extracci√≥n de cadenas es una t√©cnica excelente para obtener informaci√≥n valiosa, a menudo los autores de malware ofuscan o blindan su binario de malware. La ofuscaci√≥n es utilizada por los autores de malware para proteger el funcionamiento interno del malware de los investigadores de seguridad, analistas de malware e ingenieros inversos. Estas t√©cnicas de ofuscaci√≥n dificultan la detecci√≥n/analizaci√≥n del binario; extraer las cadenas de tal binario resulta en muy pocas cadenas, y la mayor√≠a de las cadenas est√°n oscurecidas. Los autores de malware a menudo usan programas como Empaquetadores y Encriptadores para ofuscar su archivo con el fin de evadir la detecci√≥n de productos de seguridad tales como antivirus y para impedir el an√°lisis.

### 7.1 Identificaci√≥n del packer que se us√≥ para empaquetar malware
Usamos la herramienta pepack que detecta si un binario est√° empaquetado usando una base de datos de firmas (como [db_packers.txt](https://github.com/soniasalido/cybersecurity/blob/main/Documentation/Malware/Learning%20Malware%20Annalysis/db_packer.txt)). El fichero db_packers.txt es un archivo de texto que tiene firmas o patrones que identifican los empaquetadores m√°s comunes:
```
UPX
ASPack
FSG
MEW
NSPack
...
```
Si ejecutamos el comando:
```
pepack fichero.bin -d db_packers.txt
```
- Analiza el binario fichero.bin
- Compara con la base de datos de packers
- Si est√° empaquetado, intenta desempaquetarlo
- Usualmente crea un nuevo archivo desempaquetado (a veces en el mismo directorio)

### 7.1 Packers and Cryptors
- Los ejecutables tienen lo que se llama un **punto de entrada (ENTRY POINT)**. Cuando se ejecuta, este punto de entrada es simplemente la ubicaci√≥n de las primeras piezas de c√≥digo que se van a ejecutar dentro del archivo, como se ilustra a continuaci√≥n:
  
  ![](capturas/entry-point.png)

- Cuando un ejecutable est√° empaquetado, debe desempaquetarse antes de que se pueda ejecutar cualquier c√≥digo. Debido a esto, los packers cambian el punto de entrada desde la ubicaci√≥n original a lo que se llama el "Unpacking Stub".
  ![](capturas/unpacking-stub.png)

- El "Unpacking Stub" comenzar√° a desempaquetar el ejecutable a su estado original. Una vez que el programa est√© completamente desempaquetado, el punto de entrada se reubicar√° de nuevo a su lugar normal para comenzar a ejecutar el c√≥digo:
  ![](capturas/unpacking-stub-2.png)

- Solo en este punto un analista puede comenzar a entender lo que el ejecutable est√° haciendo, ya que ahora est√° en su forma verdadera y original.

- Un Empaquetador es un programa que toma el ejecutable como entrada y utiliza la compresi√≥n para ofuscar el contenido del ejecutable. Este contenido ofuscado se almacena entonces dentro de la estructura de un nuevo archivo ejecutable; el resultado es un nuevo archivo ejecutable (programa empaquetado) con contenido ofuscado en el disco. Al ejecutar el programa empaquetado, ejecuta una rutina de descompresi√≥n, que extrae el binario original en la memoria durante el tiempo de ejecuci√≥n y desencadena la ejecuci√≥n.

- Un Encriptador es similar a un Empaquetador, pero en lugar de usar compresi√≥n, utiliza encriptaci√≥n para ofuscar el contenido del ejecutable, y el contenido encriptado se almacena en el nuevo archivo ejecutable. Al ejecutar el programa encriptado, ejecuta una rutina de desencriptaci√≥n para extraer el binario original en la memoria y luego desencadena la ejecuci√≥n.

- Formas de saber que un ejecutable est√° empaquetado:
  - El ejecutable puede tener secciones con nombres de ciertos packers como UPX.
  - Uso de Herramientas de An√°lisis de Malware: Herramientas como PEiD (Virustotal detecta malware), Exeinfo PE, RDG Packer Detector, y Die (Detect It Easy) son espec√≠ficamente dise√±adas para identificar empaquetadores, compiladores y protectores utilizados en archivos ejecutables. Estas herramientas analizan el archivo y, bas√°ndose en una base de datos de firmas de empaquetadores conocidos, estableciendo si el archivo ha sido empaquetado y, en muchos casos, identificar el empaquetador espec√≠fico utilizado.
  - An√°lisis de la Entrop√≠a: Los archivos empaquetados suelen tener una alta entrop√≠a, lo que indica una distribuci√≥n aleatoria de los bytes debido a la compresi√≥n o cifrado. Herramientas de an√°lisis de malware y editores hexadecimales pueden calcular la entrop√≠a de un archivo y, si es inusualmente alta, esto puede ser un indicador de empaquetamiento.
  - Inspecci√≥n de la Tabla de Importaciones: Los empaquetadores suelen modificar la tabla de importaciones de un archivo PE (Portable Executable). Al analizar la tabla de importaciones con herramientas como CFF Explorer o PEStudio, se puede observar si muestra un conjunto reducido o inusual de importaciones, lo que puede sugerir que el archivo ha sido empaquetado. 
  - B√∫squeda de Cadenas y Secciones Inusuales: Algunos empaquetadores agregan secciones con nombres inusuales al archivo PE o dejan cadenas dentro del archivo que indican el uso de un empaquetador. La inspecci√≥n manual con editores hexadecimales o el uso de herramientas de an√°lisis que buscan estas caracter√≠sticas pueden revelar indicios de empaquetamiento.
  - An√°lisis Heur√≠stico: Algunas soluciones de seguridad avanzadas utilizan an√°lisis heur√≠sticos para identificar comportamientos t√≠picos de archivos empaquetados, como la ejecuci√≥n de un stub de desempaquetamiento en tiempo de ejecuci√≥n

Para demostrar el concepto de ofuscaci√≥n de archivos, tomemos un ejemplo de una muestra de malware llamada Spybot (no empaquetada); la extracci√≥n de cadenas de Spybot muestra referencias a nombres de ejecutables sospechosos y direcciones IP, como se muestra aqu√≠:

```
$ strings -a spybot.exe
[....removed....]
EDU_Hack.exe
Sitebot.exe
Winamp_Installer.exe
PlanetSide.exe
DreamweaverMX_Crack.exe
FlashFXP_Crack.exe
Postal_2_Crack.exe
Red_Faction_2_No-CD_Crack.exe
Renegade_No-CD_Crack.exe
Generals_No-CD_Crack.exe
Norton_Anti-Virus_2002_Crack.exe
Porn.exe
AVP_Crack.exe
zoneallarm_pro_crack.exe
[...REMOVED...]
209.126.201.22
209.126.201.20
```

UPX, que se encuentra en https://upx.github.io/, es un empaquetador de ejecutables. UPX (Ultimate Packer for eXecutables) es una herramienta de c√≥digo abierto y gratuita dise√±ada para comprimir archivos ejecutables. Su objetivo principal es reducir el tama√±o de los archivos ejecutables (binarios), lo que puede ser √∫til para ahorrar espacio en disco y reducir los tiempos de carga en sistemas con recursos limitados. Empaquetamos y volvemos a comprobar los strings, observando que ya no se muestra mucha informaci√≥n:

```
$ upx -o spybot_packed.exe spybot.exe
Ultimate Packer for eXecutables
Copyright (C) 1996 - 2013
UPX 3.91 Markus Oberhumer, Laszlo Molnar & John Reiser Sep 30th 2013
File size Ratio Format Name
-------------------- ------ ----------- -----------
44576 -> 21536 48.31% win32/pe spybot_packed.exe
Packed 1 file.

$ strings -a spybot_packed.exe
!This program cannot be run in DOS mode.
UPX0
UPX1
.rsrc
3.91
UPX!
t ;t
/t:VU
]^M
9-lh
:A$m
hAgo .
C@@f.
Q*vPCi
%_I;9
PVh29A
[...REMOVED...]
```

UPX is a common packer, and many times you will come across malware samples packed with UPX. In most cases, it is possible to unpack the sample using the -d option. An example command is
```
upx -d -o spybot_unpacked.exe spybot_packed.exe.
```


### 7.2 Detecting File Obfuscation Using Exeinfo PE
La mayor√≠a de los ejecutables leg√≠timos no ofuscan su contenido, pero algunos ejecutables pueden hacerlo para evitar que otros examinen su c√≥digo. Cuando nos encontremos con una muestra que est√° empaquetada, hay una alta probabilidad de que sea maliciosa. Para detectar empaquetadores en Windows, podmeos usar una herramienta gratuita como **Exeinfo PE (http://exeinfo.atwebpages.com/).**


Other CLI and GUI tools that can help you with packer detections include TrID (http://mark0.net/soft-trid-e.html), TRIDNet (http://mark0.net/soft-tridnet-e.html), Detect It Easy (http://ntinfo.biz/), RDG Packer Detector (http://www.rdgsoft.net/), packerid.py (https://github.com/sooshie/packerid), and PEiD (http://www.softpedia.com/get/Programming/Packers-Crypters-Protectors/PEiD-updated.shtml).

### 7.3 Stub
**Un stub es un componente esencial en los programas conocidos como ```crypters```** que se encarga de descifrar el malware cifrado y ejecutarlo directamente en la memoria del sistema, evitando as√≠ ser detectado al no escribir el malware en disco.

**Un stub es una porci√≥n de c√≥digo peque√±o cuya funci√≥n principal es desempaquetar, desencriptar o preparar el c√≥digo malicioso real para su ejecuci√≥n.** Es com√∫n en malware que utiliza t√©cnicas de packing o crypting para evadir la detecci√≥n.

**Un stub es el c√≥digo de arranque o loader que se ejecuta primero cuando el malware inicia.** Su misi√≥n es restaurar o cargar el payload original del malware (que puede estar comprimido, cifrado o camuflado) en memoria y luego transferirle el control.

El stub act√∫a como intermediario que prepara el entorno para que el c√≥digo malicioso real (payload) se ejecute, muchas veces sin dejar rastros visibles en el sistema de archivos. 
![Flujo Stub](capturas/flujo-stub.png)

**¬øD√≥nde se encuentra el stub?**
- En malware empaquetado: El stub est√° al principio del archivo ejecutable, seguido por el cuerpo del malware en forma cifrada o comprimida.
- En droppers y downloaders: El stub puede encargarse de desencriptar o descargar el payload desde Internet y ejecutarlo.

**Ejemplo t√≠pico:**
- El atacante cifra el malware original.
- Adjunta un stub al inicio.
- El stub se ejecuta, descifra el malware en memoria y lo lanza.
- El c√≥digo malicioso comienza su actividad real.

![Flujo Stub Completo](capturas/stub-flujo-completo.png)

üß© 1. UPX (Ultimate Packer for eXecutables): UPX es una herramienta de compresi√≥n que empaqueta un ejecutable, comprimiendo su contenido y a√±adi√©ndole un stub que lo desempaqueta en tiempo de ejecuci√≥n.

üóÇÔ∏è 2. Archivo empaquetado: malz.exe. Despu√©s de pasar por UPX, se genera un nuevo archivo empaquetado: malz.exe contiene el stub al inicio, seguido del c√≥digo comprimido del ejecutable original.

üì¶ 3. Estructura interna del ejecutable UPX: Estructura interna de malz.exe:
- Parte superior header PE.
- La parte media es el stub UPX (el loader).
- La parte inferior es el el ejecutable original.


üîì 4. Empaquetado
- Parte superior: El header PE.
- Parte media: el stub.
- Parte final: EL payload empaquetado del ejecutable original.


üé¨ 5. Desempaquetado en tiempo de ejecuci√≥n del malware empaquetado.

![Flujo Stub Completo](capturas/stub-flujo-completo-3.jpg)

![UPX](capturas/upx.png)

![UPX](capturas/upx2.png)


**An√°lisis: Virtual Size vs Size of Raw Data**
| Campo | Valor hexadecimal | 	Valor decimal |
| -- | -- | -- |
| Virtual Size | 	0000C000 | 	49.152 bytes |
| Size of Raw Data | 	00000000 | 	0 bytes |

La Size of Raw Data es 0, mientras que el Virtual Size es grande (49.152 bytes). Esto es altamente inusual y sospechoso, y tiene implicaciones claras en el contexto de malware empaquetado:
- Size of Raw Data = 0 significa que esta secci√≥n no tiene contenido en el disco, es decir, no hay datos reales escritos en el archivo en esa secci√≥n.
- Virtual Size = 0xC000 (49.152 bytes) indica que en memoria s√≠ se reserva espacio para esta secci√≥n.

‚û°Ô∏è Es decir, esta secci√≥n (Raw Data) no existe f√≠sicamente en el archivo, pero el cargador del PE la reserva y la inicializa en memoria. No existe todav√≠a. Raw Data necesita ser inicializada despu√©s de que el binario se descomprima desde su estado empaquetado.

Esto es t√≠pico en binarios empaquetados con UPX:
- UPX0 suele ser una secci√≥n vac√≠a en disco pero marcada como ejecutable en memoria.
- Cuando se ejecuta el binario, el stub de UPX desempaqueta el payload y lo escribe en esta secci√≥n (UPX0), que solo existe en memoria, no en disco.


-------------------------------------------------
## 8. Clasificaci√≥n y comparaci√≥n de muestras de malware: Comparing And Classifying The Malware
Si bien el hash criptogr√°fico (MD5/SHA1/SHA256) es una t√©cnica excelente para detectar muestras id√©nticas, no ayuda a identificar muestras similares. Con frecuencia, los autores de malware cambian aspectos m√≠nimos del malware, lo que cambia completamente el valor del hash. Las siguientes secciones describen algunas de las t√©cnicas que pueden ayudar en comparar y clasificar el binario sospechoso:

### 8.1 Classifying Malware Using Fuzzy Hashing
La comparaci√≥n de archivos mediante el hash difuso (fuzzy hashing) es un excelente m√©todo para buscar similitudes. Usaremos la herramienta ssdeep (http://ssdeep.sourceforge.net) para generar el hash difuso de una muestra. Esta herramienta tambi√©n ayuda a determinar el porcentaje de similitud entre las muestras. Esta t√©cnica es √∫til para comparar un binario sospechoso con las muestras en un repositorio para identificar las muestras que son similares; esto puede ayudar a identificar las muestras que pertenecen a la misma familia de malware o al mismo grupo de actores.

Usaremos ssdeep para calcular y comparar hashes difusos:
```
ssdeep veri.exe
ssdeep,1.1--blocksize:hash:hash,filename 49152:op398U/qCazcQ3iEZgcwwGF0iWC28pUtu6On2spPHlDB:op98USfcy8cwF2bC28pUtsRptDB,"/home/ubuntu/Desktop/veri.exe"
```


El hash difuso, tambi√©n conocido como fuzzy hashing, es una t√©cnica utilizada para **detectar archivos que son similares, pero no id√©nticos, entre s√≠**. Esta t√©cnica contrasta con las funciones de hash criptogr√°ficas tradicionales, que est√°n dise√±adas para producir hashes significativamente diferentes incluso para diferencias menores en los datos de entrada

#### ssdeep y el Hash Difuso
ssdeep es una herramienta que implementa el algoritmo de hashing difuso conocido como Context Triggered Piecewise Hashing (CTPH). Este m√©todo permite identificar archivos que tienen homolog√≠as, es decir, secuencias de bytes id√©nticos en el mismo orden, aunque puedan existir diferencias en el contenido y la longitud de los bytes intermedios

#### Funcionamiento de ssdeep
ssdeep divide el archivo en m√∫ltiples piezas y calcula hashes tradicionales para cada pieza. Luego, combina estos hashes en una sola cadena, lo que permite comparar archivos de manera m√°s flexible que con los hashes criptogr√°ficos. Por ejemplo, si se modifican, insertan o eliminan datos en un archivo, ssdeep a√∫n puede encontrar un grado de similitud con el archivo original.

#### Aplicaciones de ssdeep
ssdeep es ampliamente utilizado en la detecci√≥n de malware y en la identificaci√≥n de archivos similares. Es particularmente √∫til en investigaciones forenses digitales, donde se requiere comparar archivos para identificar versiones modificadas de archivos conocidos. Por ejemplo, si se sospecha que un archivo es una variante de un malware conocido, ssdeep puede ayudar a confirmar o descartar esta sospecha al comparar los hashes difusos.

#### Instalaci√≥n y Uso
ssdeep est√° disponible para su descarga e instalaci√≥n en m√∫ltiples sistemas operativos, incluyendo Windows, Ubuntu, Fedora, Debian, CentOS, Arch Linux y FreeBSD. Para sistemas que no proporcionan un paquete de ssdeep, se puede construir a partir del c√≥digo fuente disponible en GitHub.

#### Comandos B√°sicos de ssdeep
La herramienta ssdeep ofrece una variedad de opciones de l√≠nea de comandos para calcular y comparar hashes difusos.
- -r: Esta opci√≥n permite que ssdeep procese directorios de manera recursiva, es decir, analizar√° todos los archivos en el directorio actual y en todos sus subdirectorios.
- -m: se utiliza para comparar archivos contra un conjunto de hashes conocidos. Determina el porcentaje de similaridad.
- -a: Esta opci√≥n indica a ssdeep que compare cada hash contra todos los dem√°s, lo que es √∫til para identificar archivos similares dentro de un conjunto de datos.
- -p: Esta opci√≥n hace que ssdeep imprima los porcentajes de coincidencia cuando compara hashes. Es √∫til para obtener una medida cuantitativa de cu√°n similares son dos archivos basados en sus hashes difusos.
- -b: Esta opci√≥n activa el modo de salida binaria. En este modo, ssdeep produce una salida en un formato que es m√°s adecuado para el procesamiento por otras herramientas o scripts. Es importante notar que esta opci√≥n puede no ser adecuada para la visualizaci√≥n directa por humanos debido a su naturaleza binaria


### 8.2 Classifying Malware Using Import Hash
La t√©cnica de **Import Hash, o imphash**, es un m√©todo utilizado para clasificar y rastrear malware **bas√°ndose en las importaciones de un archivo ejecutable PE (Portable Executable)**. Este m√©todo se centra en las funciones que el malware llama de otros archivos, generalmente DLLs (Dynamic Link Libraries) que proporcionan funcionalidad al sistema operativo Windows.

El imphash se calcula generando un valor hash a partir de los nombres de las bibliotecas/API y su orden espec√≠fico dentro del ejecutable. Debido a la forma en que se genera la tabla de importaciones de un PE, el imphash resultante puede ser utilizado para identificar muestras de malware relacionadas. Si dos muestras tienen el mismo imphash, es probable que est√©n relacionadas y que hayan sido creadas o utilizadas por el mismo grupo de amenazas.

Mandiant, una compa√±√≠a especializada en seguridad inform√°tica, utiliza el imphash para rastrear las actividades de grupos de amenazas espec√≠ficos a lo largo del tiempo. Por ejemplo, si un grupo de amenazas favorece ciertos backdoors, Mandiant puede seguir la pista de estos backdoors a trav√©s de sus imphashes. Esto permite a los investigadores buscar nuevas muestras similares que el mismo grupo de amenazas podr√≠a haber creado y utilizado.

**El imphash es considerado una forma poderosa de identificar malware relacionado porque el valor del hash tiende a ser relativamente √∫nico. Esto se debe a que el enlazador del compilador genera y construye la Tabla de Direcciones de Importaci√≥n (IAT) basada en el orden espec√≠fico de las llamadas a las API.**

**La IAT (Import Address Table) o Tabla de Direcciones de Importaci√≥n** es una estructura cr√≠tica que te dice qu√© funciones externas (de DLLs) usa un programa y d√≥nde est√°n ubicadas en memoria cuando se ejecuta.

**La IAT es una tabla de punteros a funciones importadas desde bibliotecas externas** (por ejemplo, KERNEL32.dll, USER32.dll, etc.). Se encuentra dentro del archivo PE (como un .exe o .dll) y permite que el sistema operativo resuelva las llamadas a funciones durante la carga del programa.

**La IAT sirve para:**
- Saber qu√© funciones del sistema utiliza el malware, lo que puede revelar su comportamiento (ej: red, archivos, procesos).
- Detectar t√©cnicas de evasi√≥n, como:
  - Importaciones din√°micas (cuando el malware oculta las llamadas a APIs carg√°ndolas en tiempo de ejecuci√≥n con ```LoadLibrary + GetProcAddress```).
  - IAT hooking, cuando el malware modifica la tabla IAT para interceptar o redirigir funciones.


La herramienta pefile, por ejemplo, se puede utilizar para calcular el imphash de un archivo PE. Mandiant ha contribuido con un parche que permite calcular el valor del imphash para un PE dado en pefile. El siguiente es un ejemplo de c√≥digo que utiliza pefile para obtener el imphash de un archivo PE:
```
import pefile
import sys

pe = pefile.PE(sys.argv[1])
print("Import Hash: %s" % pe.get_imphash())
```

Este m√©todo de clasificaci√≥n de malware es √∫til para los investigadores de seguridad y los analistas de malware, ya que les permite correlacionar muestras de malware y rastrear la evoluci√≥n de las amenazas a lo largo del tiempo.


**Nota:** La herramienta pestudio calcula autom√°ticamente el imphash.


### 8.3 Classifying Malware Using Section Hash
La clasificaci√≥n de malware utilizando el hash de secci√≥n, o Section Hash, es una t√©cnica de an√°lisis est√°tico que se centra en las secciones individuales de un archivo ejecutable PE (Portable Executable). Cada secci√≥n de un archivo PE, como .text, .data, .rdata, etc., puede contener diferentes tipos de datos, como c√≥digo ejecutable, recursos y datos de inicializaci√≥n. Al calcular el hash de cada una de estas secciones, los analistas pueden obtener una firma que puede ser utilizada para identificar y clasificar muestras de malware.

El Section Hash es √∫til para identificar variantes de malware que comparten secciones de c√≥digo comunes. Por ejemplo, si un atacante reutiliza un m√≥dulo de c√≥digo espec√≠fico en diferentes variantes de malware, el hash de la secci√≥n correspondiente ser√° el mismo en todas estas variantes. Esto permite a los investigadores agrupar muestras relacionadas y rastrear la evoluci√≥n del malware a lo largo del tiempo.

El an√°lisis de malware con Radare2, por ejemplo, puede incluir la obtenci√≥n de hashes de secciones utilizando comandos espec√≠ficos como "iS" seguido de los algoritmos de hash deseados (md5, sha1, sha256), para obtener informaci√≥n sobre las secciones y sus respectivos hashes.

La clasificaci√≥n basada en Section Hash puede ser complementada con otras t√©cnicas de an√°lisis est√°tico, como el an√°lisis de strings, el an√°lisis de importaciones y exportaciones, y el an√°lisis de metadatos del archivo PE. Estas t√©cnicas proporcionan una visi√≥n m√°s completa del comportamiento potencial del malware y pueden ayudar a identificar caracter√≠sticas √∫nicas de diferentes familias de malware.

Es importante destacar que, aunque el Section Hash es una herramienta valiosa en la clasificaci√≥n de malware, no es infalible. Los atacantes pueden ofuscar o modificar las secciones de un archivo PE para evitar la detecci√≥n, lo que puede hacer que el hash de secci√≥n cambie y, por lo tanto, dificultar la clasificaci√≥n basada en esta t√©cnica. Por esta raz√≥n, el Section Hash se utiliza a menudo en combinaci√≥n con otras t√©cnicas de an√°lisis para mejorar la precisi√≥n en la detecci√≥n y clasificaci√≥n del malware.

Formas de c√°lculo de Section Hash:
- Con la herramienta pestudio.
- Con Python: Usando el m√≥dulo pefile:
  ```
  >>> import pefile
  >>> pe = pefile.PE("5340.exe")
  >>> for section in pe.sections:
  ... print "%s\t%s" % (section.Name, section.get_hash_md5())
  ```

### 8.4 Classifying Malware Using YARA
La creaci√≥n de reglas YARA es fundamental para su eficacia en la clasificaci√≥n de malware. Una regla YARA t√≠picamente consta de una secci√≥n de metadatos, donde se pueden incluir detalles como el nombre de la regla, autor, versi√≥n y cualquier otra informaci√≥n relevante; una secci√≥n de strings, donde se definen las cadenas de texto, binarias o expresiones regulares que se buscan; y una secci√≥n de condiciones, que especifica c√≥mo deben coincidir o relacionarse las strings definidas para que la regla se considere como coincidente.

YARA permite la identificaci√≥n r√°pida de malware conocido y la detecci√≥n de variantes o familias de malware relacionadas mediante la b√∫squeda de patrones espec√≠ficos.

https://yara.readthedocs.io/en/v3.7.0/writingrules.html

#### Crear reglas YARA
Para crear reglas YARA, es necesario seguir una estructura espec√≠fica que consta de tres partes principales: metadatos, strings y condiciones. A continuaci√≥n, se detallan los pasos para escribir reglas YARA efectivas:
- Metadatos: Los metadatos son informaci√≥n descriptiva sobre la regla que no afecta su funcionamiento. Incluyen detalles como el nombre de la regla, autor, versi√≥n y cualquier otra informaci√≥n relevante. Los metadatos son opcionales pero √∫tiles para la organizaci√≥n y documentaci√≥n.
- Strings: Las strings son los patrones de texto, binarios o expresiones regulares que se buscar√°n en los archivos o procesos. Se definen utilizando el s√≠mbolo $, seguido de un identificador. Las strings pueden ser literales, hexadecimales o basadas en expresiones regulares.
- Condiciones: Las condiciones son expresiones l√≥gicas que determinan cu√°ndo se considera que una regla coincide con un archivo o proceso. Las condiciones pueden ser simples, como la presencia de una string, o complejas, utilizando operadores l√≥gicos y cuantificadores.

#### Ejemplo de una Regla YARA B√°sica
```
yara
rule ExampleMalwareDetection
{
    meta:
        author = "Your Name"
        description = "Detects Example Malware"
        version = "1.0"

    strings:
        $a = "malicious string" nocase
        $b = { 6A 40 68 00 30 00 00 } // Hexadecimal pattern
        $c = /md5: [0-9A-F]{32}/ // Regular expression

    condition:
        $a and $b and $c
}
```

#### Pasos para Escribir Reglas YARA:
- Definir Metadatos: Comience con la secci√≥n de metadatos para describir la regla. Aunque opcional, es una buena pr√°ctica incluir metadatos para mantener las reglas organizadas.
- Identificar Strings: Determine las strings que son indicativas del malware o del contenido que desea detectar. Puede utilizar strings literales, patrones hexadecimales o expresiones regulares.
- Establecer Condiciones: Defina las condiciones bajo las cuales se considerar√° que la regla ha encontrado una coincidencia. Puede utilizar operadores l√≥gicos como and, or, y not, as√≠ como cuantificadores como all of them o any of them.
- Probar la Regla: Una vez que haya escrito la regla, pru√©bela con muestras conocidas para asegurarse de que detecta correctamente el malware sin generar falsos positivos.
- Refinar la Regla: Si la regla genera falsos positivos o no detecta todas las variantes del malware, ajuste las strings y las condiciones hasta que la regla sea efectiva y precisa.
- Documentar y Mantener: Documente la regla y mant√©ngala actualizada a medida que surjan nuevas variantes del malware o se descubran nuevos indicadores de compromiso.

Es importante tener en cuenta que escribir reglas YARA efectivas requiere un conocimiento profundo del malware que se est√° detectando y de los patrones que lo caracterizan. Adem√°s, las reglas deben ser lo suficientemente espec√≠ficas para evitar falsos positivos, pero tambi√©n lo suficientemente generales para detectar variantes del malware

https://www.youtube.com/watch?v=RGXQeco_1Zk&t=787s

-----------------------------------------------
-----------------------------------------------
# CHAPTER 3: DYNAMIC ANALYSIS
El an√°lisis din√°mico de malware es un proceso que implica la ejecuci√≥n del malware en un entorno controlado y aislado, conocido como sandbox o m√°quina virtual, para observar su comportamiento y funcionalidad en tiempo real. Este tipo de an√°lisis permite a los investigadores y analistas de seguridad comprender c√≥mo se comporta el malware una vez que se ejecuta en un sistema, identificando las acciones que realiza, como la modificaci√≥n de archivos, la comunicaci√≥n con servidores remotos, la inyecci√≥n de c√≥digo en otros procesos, entre otros comportamientos maliciosos.

Las ventajas del an√°lisis din√°mico incluyen la capacidad de obtener informaci√≥n detallada sobre el comportamiento del malware, lo que permite documentar y entender mejor las amenazas para desarrollar medidas de protecci√≥n m√°s efectivas. Adem√°s, este tipo de an√°lisis puede revelar la presencia de t√©cnicas de evasi√≥n, como la detecci√≥n de entornos virtuales (antisandbox), que el malware puede utilizar para evitar su an√°lisis en entornos controlados.

El an√°lisis din√°mico es complementario al an√°lisis est√°tico, que se enfoca en el examen del c√≥digo fuente del malware sin ejecutarlo, proporcionando una visi√≥n completa del funcionamiento y prop√≥sito del software malicioso. Juntos, el an√°lisis est√°tico y din√°mico ofrecen una metodolog√≠a robusta para el estudio y la clasificaci√≥n de malware, contribuyendo significativamente a la ciberseguridad y la defensa contra amenazas inform√°ticas.

## 1. Lab Environment Overview
Tanto la m√°quina virtual de Linux como la de Windows se configuraron para utilizar el modo de configuraci√≥n de red de solo anfitri√≥n. La m√°quina virtual de Linux estaba preconfigurada con una direcci√≥n IP de 192.168.1.100, y la direcci√≥n IP de la m√°quina virtual de Windows se estableci√≥ en 192.168.1.50. La puerta de enlace predeterminada y el DNS de la m√°quina virtual de Windows se establecieron en la direcci√≥n IP de la m√°quina virtual de Linux (192.168.1.100), de modo que todo el tr√°fico de red de Windows se enrutara a trav√©s de la m√°quina virtual de Linux. La m√°quina virtual de Windows se utilizar√° para ejecutar la muestra de malware durante el an√°lisis, y la m√°quina virtual de Linux se utilizar√° para monitorear el tr√°fico de red y se configurar√° para simular servicios de internet (como DNS, HTTP, y otros) para proporcionar la respuesta adecuada cuando el malware solicite estos servicios.

## 2. System And Network Monitoring
El objetivo de un an√°lisi din√°mico es recopilar datos en tiempo real relacionados con el comportamiento del malware y su impacto en el sistema. Diferentes tipos de monitoreo realizados durante el an√°lisis din√°mico:
- Monitoreo de procesos: Implica monitorear la actividad del proceso y examinar las propiedades del proceso resultante durante la ejecuci√≥n del malware.
- Monitoreo del sistema de archivos: Incluye monitorear la actividad del sistema de archivos en tiempo real durante la ejecuci√≥n del malware.
- Monitoreo del registro: Implica monitorear las claves del registro a las que se accede/modifica y los datos del registro que son le√≠dos/escritos por el binario malicioso.
- Monitoreo de la red: Involucra monitorear el tr√°fico en vivo hacia y desde el sistema durante la ejecuci√≥n del malware.


## 3. Dynamic Analysis (Monitoring) Tools

### 3.1 Process Inspection with Process Hacker
Process Hacker (http://processhacker.sourceforge.net/) is an open source, multipurpose tool that helps in monitoring system resources. It is a great tool for examining the
processes running on the system and to inspect the process attributes. It can also be used to explore services, network connections, disk activity, and so on.

VirusTotal lo detecta como malware.

### 3.2 Determining System Interaction with Process Monitor
Process Monitor (https://technet.microsoft.com/en-us/sysinternals/processmonitor.aspx) is an advanced monitoring tool that shows the real-time interaction of the processes
with the filesystem, registry, and process/thread activity.

### 3.3 Logging System Activities Using Noriben
Even though Process Monitor is a great tool to monitor a malware's interaction with the system, it can be very noisy, and manual effort is required to filter the noise. Noriben
(https://github.com/Rurik/Noriben) is a Python script that works in conjunction with Process Monitor and helps in collecting, analyzing, and reporting runtime indicators of the
malware. The advantage of using Noriben is that it comes with pre-defined filters that assist in reducing noise and allow you to focus on the malware-related events.

### 3.4 Capturing Network Traffic With Wireshark
When the malware is executed, you will want to capture the network traffic generated as a result of running the malware; this will help you understand the communication channel
used by the malware and will also help in determining network-based indicators. 

### 3.5 Simulating Services with INetSim
INetSim is a free Linux-based software suite for simulating standard internet services (such as DNS, HTTP/HTTPS, and so on).

Another alternative to INetSim is FakeNet-NG (https://github.com/fireeye/flare-fakenet-ng), which allows you to intercept and redirect all or specific network traffic by simulating network services.


## 4. Dynamic Analysis Steps
Durante el an√°lisis din√°mico (an√°lisis del comportamiento), seguriemos una secuencia de pasos para determinar la funcionalidad del malware. La siguiente lista describe los pasos involucrados en el an√°lisis din√°mico:
- Revertir a la instant√°nea limpia: Esto incluye volver tus m√°quinas virtuales a un estado limpio.
- Ejecutar las herramientas de monitoreo/an√°lisis din√°mico: En este paso, ejecutar√°s las herramientas de monitoreo antes de ejecutar la muestra de malware. Para aprovechar al m√°ximo las herramientas de monitoreo cubiertas en la secci√≥n anterior, necesitas ejecutarlas con privilegios de administrador.
- Ejecutar la muestra de malware: En este paso, ejecutar√°s la muestra de malware con privilegios de administrador.
- Detener las herramientas de monitoreo: Esto implica terminar las herramientas de monitoreo despu√©s de que el binario de malware se haya ejecutado durante un tiempo especificado.
- Analizar los resultados: Esto implica recopilar los datos/informes de las herramientas de monitoreo y analizarlos para determinar el comportamiento y la funcionalidad del malware.


## 5. Putting it All Together: Analyzing a Malware Executable
Realizaremos tanto an√°lisis est√°tico como din√°mico para determinar las caracter√≠sticas y el comportamiento de una muestra de malware.


## 6. Dynamic-Link Library (DLL) Analysis



# Examples
## Emotet
https://assets.tryhackme.com/additional/cmn-malware/int-mal-sample.pdf

---------------------------------------------
---------------------------------------------
## Usar PEStudio (Interfaz gr√°fica)
- Descarga PEStudio (gratis):üîó https://www.winitor.com/
- Abre el archivo sospechoso (.exe, .dll) desde PEStudio.
- Ve a la pesta√±a: Sections.
- Observa los siguientes campos:
  - Nombre de la secci√≥n: .text, .data, .rsrc, etc.
  - Entropy: si es muy alta (> 7.0), puede indicar cifrado u ofuscaci√≥n.
  - RVA / Offset / Tama√±o virtual: diferencias notables pueden ser sospechosas.

Permissions: busca secciones con Executable + Writable, lo cual no es normal y puede indicar shellcode.

üìå PEStudio tambi√©n marcar√° en rojo o naranja las secciones que considera sospechosas autom√°ticamente.


## Script en Python con pefile
Este script analiza las secciones y te muestra:
- Nombres
- Tama√±os
- Entrop√≠a
- Permisos
```
pip install pefile
import pefile
import math

def get_entropy(data):
    if not data:
        return 0.0
    entropy = 0
    for x in range(256):
        p_x = float(data.count(bytes([x]))) / len(data)
        if p_x > 0:
            entropy -= p_x * math.log2(p_x)
    return entropy

pe = pefile.PE("malware.exe")

print("Nombre | Tama√±o | Entrop√≠a | Permisos")
print("-" * 50)

for section in pe.sections:
    name = section.Name.strip().decode('utf-8', errors='replace')
    size = section.SizeOfRawData
    entropy = get_entropy(section.get_data())
    perms = section.Characteristics

    exec_flag = bool(perms & 0x20000000)
    write_flag = bool(perms & 0x80000000)
    read_flag = bool(perms & 0x40000000)

    flags = []
    if read_flag: flags.append("R")
    if write_flag: flags.append("W")
    if exec_flag: flags.append("X")

    print(f"{name:7} | {size:6} | {entropy:.2f}    | {' '.join(flags)}")

    # Posible anomal√≠a
    if entropy > 7.0:
        print(f"‚ö†Ô∏è  Alta entrop√≠a en {name}")
    if exec_flag and write_flag:
        print(f"üö®  Secci√≥n ejecutable y escribible: {name}")

```

Resultado t√≠pico:
```
Nombre | Tama√±o | Entrop√≠a | Permisos
-----------------------------------------
.text   | 20480  | 6.35    | R X
.data   | 8192   | 5.22    | R W
.rsrc   | 10240  | 7.85    | R
‚ö†Ô∏è  Alta entrop√≠a en .rsrc
```

## Script en Python para analizar secciones PE
```
import pefile
import math
import pandas as pd

def get_entropy(data):
    if not data:
        return 0.0
    entropy = 0
    for x in range(256):
        p_x = float(data.count(bytes([x]))) / len(data)
        if p_x > 0:
            entropy -= p_x * math.log2(p_x)
    return entropy

# Ruta del archivo PE a analizar
file_path = "malware.exe"  # Cambia esto por el nombre de tu archivo

pe = pefile.PE(file_path)
section_data = []

for section in pe.sections:
    name = section.Name.strip().decode('utf-8', errors='replace')
    size = section.SizeOfRawData
    entropy = get_entropy(section.get_data())
    perms = section.Characteristics

    exec_flag = bool(perms & 0x20000000)
    write_flag = bool(perms & 0x80000000)
    read_flag = bool(perms & 0x40000000)

    flags = []
    if read_flag: flags.append("R")
    if write_flag: flags.append("W")
    if exec_flag: flags.append("X")

    section_data.append({
        "Secci√≥n": name,
        "Tama√±o (bytes)": size,
        "Entrop√≠a": round(entropy, 2),
        "Permisos": " ".join(flags),
        "Alta entrop√≠a": entropy > 7.0,
        "RWX (riesgo)": exec_flag and write_flag
    })

# Exportar a CSV
df = pd.DataFrame(section_data)
df.to_csv("resultado_secciones.csv", index=False)

print("‚úÖ An√°lisis completado. Revisa 'resultado_secciones.csv'")
```

üß∞Requisitos. Es necesario tener estos m√≥dulos instalados:
```
pip install pefile pandas
```

Este script analizar√° las secciones, calcular√° entrop√≠a y marcar√° secciones sospechosas (como aquellas con permisos de ejecuci√≥n y escritura o entrop√≠a alta), y nos exportar√° todo a un archivo resultado_secciones.csv que podr√°s abrir en Excel o cualquier visor de hojas de c√°lculo.



----------------------------------------------
----------------------------------------------
## Enlaces de inter√©s

https://tutorials.ophion.feralhosting.com/Tutorials/Malware%20Analysis/UD-Reverse-Engineering-And-Malware-Analysis-Fundamentals/

https://elhacker.info/manuales/An%c3%a1lisis%20de%20malware/

https://elhacker.info/manuales/An%C3%A1lisis%20de%20malware/Learning%20Malware%20Analysis_%20Explore%20the%20concepts,%20tools,%20and%20techniques%20to%20analyze%20and%20investigate%20Windows%20malware%20(%20PDFDrive.com%20).pdf

https://www.wolf.university/masteringmalwareanalysis/ebook/masteringmalwareanalysis.pdf

https://www.wolf.university/cybersecuritythreatsmalwaretrendsandstrategies/ebook/cybersecuritythreatsmalwaretrendsandstrategies.pdf

https://elhacker.info/manuales/An%c3%a1lisis%20de%20malware/Practical_Malware_Analysis.pdf


https://elhacker.info/manuales/An%c3%a1lisis%20de%20malware/Windows%20Malware%20Analysis%20Essentials_%20Master%20the%20fundamentals%20of%20malware%20analysis%20for%20the%20Windows%20platform%20and%20enhance%20your%20anti-malware%20skill%20set%20(%20PDFDrive.com%20).pdf

https://www.wolf.university/ghidrasoftwarereverseengineeringforbeginners/ebook/ghidrasoftwarereverseengineeringforbeginners.pdf

https://elhacker.info/manuales/An%c3%a1lisis%20de%20malware/intro-reverseeng.pdf


https://github.com/Neo23x0/signature-base/tree/master/yara


https://github.com/baynam1995/MalwareAnalysiBook/blob/master/Learning.Malware.Analysis.Techniques.Investigate.pdf

https://elhacker.info/manuales/Virus/Rootkits%20and%20Bootkits_%20Reversing%20Modern%20Malware%20and%20Next%20Generation%20Threats%20Early%20Access.pdf


https://ftp.idu.ac.id/wp-content/uploads/ebook/tdg/MILITARY%20REFERENCE%20AND%20REVERSE%20ENGINEERING/Mastering%20Reverse%20Engineering%20Re-engineer%20your%20ethical%20hacking%20skills%20by%20Reginald%20Wong%20(z-lib.org).pdf

https://ccdcoe.org/uploads/2020/07/Malware_Reverse_Engineering_Handbook.pdf

https://github.com/Dump-GUY/Malware-analysis-and-Reverse-engineering

https://github.com/gabimarti/ingenieria_inversa_a_partir_del_codigo_fuente/tree/master


Binary Ninja is an interactive decompiler, disassembler, debugger, and binary analysis platform built by reverse engineers, for reverse engineers: https://binary.ninja/


https://rada.re/n/
