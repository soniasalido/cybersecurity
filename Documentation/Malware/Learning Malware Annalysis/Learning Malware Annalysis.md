# CHAPTER 1
## 1. ¬øQu√© es el malware?
El malware es un c√≥digo que realiza acciones maliciosas; puede tomar la forma de un ejecutable, un script, un c√≥digo o cualquier otro software. Los atacantes utilizan malware para robar informaci√≥n confidencial, espiar el sistema infectado o tomar el control del sistema. Por lo general, accede al dispositivo sin nuestro consentimiento a trav√©s de varios canales de comunicaci√≥n, como correo electr√≥nico, web o unidades USB.


**Acciones maliciosas que realiza el malware:**
- Interrumpir el funcionamiento del ordenador.
- Robar informaci√≥n sensible, incluyendo datos personales, empresariales y financieros.
- Acceso no autorizado al sistema.
- Espiar.
- Enviar correos electr√≥nicos de spam.
- Participar en ataques de denegaci√≥n de servicio distribuido (DDoS).
- Bloquear los archivos del ordenador y exigir un rescate para liberarlos.

Malware es un t√©rmino amplio que se refiere a diferentes tipos de programas maliciosos como troyanos, virus, gusanos y rootkits. Al realizar un an√°lisis de malware, encontrar√°s con frecuencia diversos tipos de programas maliciosos. Algunos de ellos se categorizan seg√∫n su funcionalidad y vectores de ataque, como se describe a continuaci√≥n.

### Tipos de malware m√°s comunes:
- **Virus:**  
Programa malicioso que se adjunta a un archivo leg√≠timo y se propaga cuando se ejecuta el archivo infectado. Causa variedad de da√±os, como el eliminaci√≥n de archivos, el robo de informaci√≥n o el bloqueo del sistema. Este Malware es capaz de copiarse a s√≠ mismo y propagarse a otros ordenadores. Un virus necesita intervenci√≥n del usuario, mientras que un gusano puede propagarse sin ella.

- **Gusano:**  
Son programas maliciosos que se propagan a trav√©s de redes y sistemas inform√°ticos. Los gusanos pueden causar una sobrecarga en la red y ralentizar el rendimiento del sistema.

- **Troyano:**  
Malware que se disfraza de programa leg√≠timo para enga√±ar al usuario y que lo instale. Una vez instalado, puede realizar acciones maliciosas como robar datos sensibles, subir archivos al servidor del atacante o espiar a trav√©s de la webcam.

- **Backdoor / Remote Access Trojan (RAT) | Puerta trasera / Troyano de acceso remoto (RAT):**  
Tipo de troyano que permite al atacante acceder y ejecutar comandos en el sistema comprometido.

- **Adware:**  
Malware que muestra anuncios no deseados al usuario. Suele distribuirse junto con descargas gratuitas e incluso puede instalar software de manera forzada.

- **Botnet:**  
Conjunto de ordenadores infectados con el mismo malware (llamado bots), que esperan instrucciones del servidor de comando y control controlado por el atacante. El atacante puede ordenar a estos bots que realicen actividades maliciosas como ataques DDoS o env√≠o masivo de spam.

- **Ladr√≥n de informaci√≥n (Information stealer):**  
Malware dise√±ado para robar datos sensibles como credenciales bancarias o pulsaciones del teclado. Algunos ejemplos son los keyloggers, spyware, sniffers y form grabbers.

- **Ransomware:**  
Malware que mantiene el sistema como reh√©n, bloqueando el acceso al ordenador o cifrando los archivos del usuario y exigiendo un rescate para recuperarlos.

- **Rootkit:**  
Malware que otorga al atacante acceso privilegiado al sistema infectado y oculta su presencia o la de otros programas maliciosos. Los rootkits pueden permitir a los atacantes controlar el sistema y recopilar informaci√≥n sin ser detectados.

- **Downloader o Dropper:**  
Malware dise√±ado para descargar o instalar componentes maliciosos adicionales en el sistema.


## 2. Descripci√≥n general de la arquitectura del laboratorio
![](capturas/structure.png)

La arquitectura usada consiste en una **m√°quina f√≠sica (llamada m√°quina host) que ejecuta Ubuntu Linux con instancias de m√°quina virtual Linux (Ubuntu Linux VM) y m√°quina virtual Windows (Windows VM)**. Estas m√°quinas virtuales se configurar√°n para ser parte de la misma red y utilizar√°n el modo de **configuraci√≥n de red de Host-only** para que el malware no pueda comunicarse con Internet y as√≠ el tr√°fico de la red estar√° contenido en el entorno de laboratorio aislado.

La VM de Windows es donde se ejecutar√° el malware durante el an√°lisis, y la VM de Linux se usar√° para monitorear el tr√°fico de red y ser√° configurada para simular servicios de Internet (DNS, HTTP, etc.), para proporcionar una respuesta adecuada cuando el malware solicite estos servicios. Por ejemplo, la m√°quina virtual Linux se configurar√° de manera que cuando el malware solicite un servicio como DNS, la m√°quina virtual Linux proporcione la respuesta DNS adecuada. 

En esta configuraci√≥n, la m√°quina virtual Linux estar√° preconfigurada en la direcci√≥n IP 192.168.1.100 y la direcci√≥n IP de la m√°quina virtual Windows se configurar√° en 192.168.1.x (donde x es cualquier n√∫mero de 1 a 254 excepto 100). La puerta de enlace predeterminada y el DNS de la VM de Windows se configurar√°n en la direcci√≥n IP de la VM de Linux (es decir, 192.168.1.100) para que todo el tr√°fico de la red de Windows se enrute a trav√©s de la VM de Linux.

Tambi√©n es posible configurar un laboratorio compuesto por m√∫ltiples VMs ejecutando diferentes versiones de Windows; esto nos permitir√° analizar la muestra de malware en varias versiones de sistemas operativos Windows.
![](capturas/structure-2.png)


## 3. Configuraci√≥n de VM Linux
- Instalaci√≥n de Ubuntu | Windows.
- Instalaci√≥n de Virtual Guest Additions software.
- Configuraci√≥n de Windows VM:
  - Deshabilitar Windows Update.
  - Deshabilitar Windows Defender ü†Æ  Services ü†Æ Windows Defender ü†Æ Boton derecho ü†Æ  Select poperties ü†Æ  Stop Service
  - Mostrar extensiones de ficheros ü†Æ Opciones de carpeta ü†Æ Ver ü†Æ  Mostrar extensiones para ficheros
  - Mostrar ficheros y carpetas ocultos.
  - Deshabilitar ASLR (Address Space Layout Randomization): ASLR (Address Space Layout Randomization) es una t√©cnica de seguridad utilizada para dificultar los ataques de desbordamiento de b√∫fer (buffer overflow) y otras vulnerabilidades de corrupci√≥n de memoria. La idea principal de ASLR es ubicar aleatoriamente en el espacio de direcciones de memoria las √°reas clave de un proceso, como el ejecutable base, la pila, el mont√≥n y las librer√≠as cargadas. Esto hace que las direcciones de memoria sean impredecibles para un atacante, dificultando la ejecuci√≥n de c√≥digo malicioso.
    ü†Æ  Windows + R ü†Æ  regedit ü†Æ Computer\HKEY_LOCAL_MACHINE\SISTEM\CurrentSet\Control\Session Manager\Memory Management ü†Æ  New Key ü†Æ QWORD (32 bits) ü†Æ poner como nombre: MoveImages
  - Deshabilitar Firewall ü†Æ Windows Defender Firewall.
  - Crear un snapshot ü†Æ HOST + T
- Instalaci√≥n:
  ```
  sudo apt-get install python-pip
  pip install --upgrade pip
  sudo apt-get install python-magic
  sudo apt-get install upx
  sudo pip install pefile
  sudo apt-get install yara
  sudo pip install yara-python
  sudo apt-get install ssdeep
  sudo apt-get install build-essential libffi-dev python python-dev libfuzzy-dev
  sudo pip install ssdeep
  sudo apt-get install wireshark
  sudo apt-get install tshark
  ```
- INetSim (http://www.inetsim.org/index.html) is a powerful utility that allows simulating various Internet services (such as DNS, and HTTP):
  ```
  sudo su
  echo "deb http://www.inetsim.org/debian/ binary/" >  /etc/apt/sources.list.d/inetsim.list
  wget -O - http://www.inetsim.org/inetsim-archive-signing-key.asc | apt-key add -
  apt update
  apt-get install inetsim
  ```
- You can now isolate Ubuntu VM within your lab by configuring the virtual appliance to use Host-only network mode. On VMware, bring up the Network Adapter Settings and choose Host-only. File| Preferences | Network | Host-only networks | Add host-only network.
- IP address of 192.168.1.100 to the Ubuntu Linux VM.
- Configure INetSim so that it can listen to and simulate all the services on the configured IP address 192.168.1.100:
  ```
  sudo gedit /etc/inetsim/inetsim.conf
  # service_bind_address
  #
  # IP address to bind services to
  #
  # Syntax: service_bind_address <IP address>
  #
  # Default: 127.0.0.1
  #
  #service_bind_address 10.10.10.1
  service_bind_address 192.168.1.100
  #
  #dns_default_ip 10.10.10.1
  dns_default_ip 192.168.1.100
  ```
- Launch INetSim:
  ```
  sudo inetsim
  ```
- Take a snapshot: On Virtualbox, the same can be done by clicking on Machine | Take Snapshot. ü†Æ Host + T

- Instalar Flare VM: Es una colecci√≥n de scripts de instalaci√≥n de software para sistemas Windows que permite configurar y mantener f√°cilmente un entorno de ingenier√≠a inversa y an√°lisis de malware en una m√°quina virtual.Las principales caracter√≠sticas de FLARE VM son:
  - Proporciona un conjunto curado de herramientas expertas para ingenier√≠a inversa, an√°lisis de malware, monitoreo, depuraci√≥n, desensamblado, descompilaci√≥n y m√°s, todas preinstaladas y configuradas. Algunas herramientas incluidas son IDA, Binary Ninja, Radare2, OllyDbg, x64dbg, Ghidra, entre otras. (https://github.com/dnSpy/dnSpy)
  - Utiliza Chocolatey (un administrador de paquetes para Windows) y Boxstarter para automatizar la instalaci√≥n y configuraci√≥n de las herramientas en un entorno Windows virtualizado.
  - Est√° dise√±ado para instalarse √∫nicamente en una m√°quina virtual Windows, no en un host f√≠sico, para permitir un an√°lisis de malware seguro y contenido.
  - Proporciona un proceso de instalaci√≥n, actualizaci√≥n y desinstalaci√≥n simplificado a trav√©s de scripts de PowerShell.
  - Permite personalizar f√°cilmente las herramientas a instalar a trav√©s de una interfaz gr√°fica de usuario.
  - Es un proyecto de c√≥digo abierto mantenido por el equipo FLARE de Mandiant/FireEye, con contribuciones de la comunidad.
  - Enlace: https://github.com/mandiant/flare-vm
  - Video con instruciones para instalar: https://www.youtube.com/watch?v=i8dCyy8WMKY
  - Desactivar: Windows Defender through Group Policy:
    - gpedit.msc
    - En el Editor de Directiva de Grupo, navegue a la siguiente ruta: Computer Configuration > Administrative Templates > Windows Components > Windows Defender Antivirus
    - Busque la configuraci√≥n "Turn off Windows Defender Antivirus" (o "Desactivar Antivirus Windows Defender" en espa√±ol).
    - Haga doble clic en ella para editarla.
    - Seleccione "Enabled" (Habilitado) y haga clic en "Apply" (Aplicar) y luego en "OK".
    - Cierre el Editor de Directiva de Grupo Local.
  - Computer Configuration > Administrative Templates > Windows Components > Microsoft Defender Antivirus > Real-time Protection > Enable Turn off real-time protection
  - Instalaci√≥n: Desde la carpeta del master, ejecutar con PowerShell como administrador:
    - Set-ExecutionPolicy unrestricted
    - Si falla: Set-ExecutionPolicy -Scope      CurrentUser
      - unresticted
      - ./


## 4. Configuraci√≥n de VM Windows
- Download Python from https://www.python.org/downloads/. Be sure to download Python 2.7.x (such as 2.7.13); most of the scripts used in this book are written to run on the Python 2.7 version and may not run correctly on Python 3.
- Configure your Windows VM to run in Host-only network configuration mode.
- Configure the IP address of the Windows VM to 192.168.1.x (choose any IP address except 192.168.1.100 because the Linux VM is set to use that IP) and set up your Default gateway and the DNS server to the IP address of Linux VM (that is, 192.168.1.100).
- Make sure they can communicate with each other. You can check for the connectivity by running the ping command launch the Local Group Policy Editor. In the left-hand pane of Local Group Policy Editor, navigate to Computer Configuration | Administrative Templates | Windows Components | Windows Defender. In the right-hand pane, doubleclick on the Turn off Windows Defender policy to edit it; then select Enabled and click on OK.


## 5. Malware Sources
- Hybrid Analysis: https://www.hybrid-analysis.com/
- KernelMode.info: http://www.kernelmode.info/forum/viewforum.php?f=16
- VirusBay: https://beta.virusbay.io/
- Contagio malware dump: http://contagiodump.blogspot.com/
- AVCaesar: https://avcaesar.malware.lu/
- Malwr: https://malwr.com/
- VirusShare: https://virusshare.com/
- theZoo: http://thezoo.morirt.com/

You can find links to various other malware sources in Lenny Zeltser's blog post https://zeltser.com/malware-sample-sources/.

-------------------------------------------------  
-------------------------------------------------  
# CHAPTER 2: An√°lisis est√°tico
El an√°lisis **est√°tico es la t√©cnica de analizar el archivo sospechoso sin ejecutarlo**. Es un m√©todo de an√°lisis inicial que implica extraer informaci√≥n √∫til del binario sospechoso para tomar una decisi√≥n informada sobre **c√≥mo clasificarlo o analizarlo** y d√≥nde centrar sus esfuerzos de an√°lisis posteriores.

**Aprenderemos:**
1. Identificar la arquitectura de destino del malware.  
2. Tomar huellas dactilares del malware.  
3. Escanear el binario sospechoso con motores antivirus.  
4. Extraer cadenas, funciones y metadatos asociados con el archivo.  
5. Identificar las t√©cnicas de ofuscaci√≥n utilizadas para frustrar el an√°lisis.  
6. Clasificaci√≥n y comparaci√≥n de muestras de malware.

Estas t√©cnicas pueden revelar informaci√≥n diferente sobre el archivo. No es necesario seguir todas estas t√©cnicas y no es necesario seguirlas en el orden indicando anteriormente. La elecci√≥n de las t√©cnicas a utilizar depende de su objetivo y del contexto que rodea el archivo sospechoso.

## 1. Identificar la arquitectura de destino del malware: Determinar el tipo de fichero
Determinar el tipo de archivo de un binario sospechoso nos ayudar√° a **identificar el sistema operativo objetivo del malware** (Windows, Linux, etc.) **y la arquitectura** (plataformas de 32 o 64 bits). Por ejemplo, si el binario sospechoso tiene un **tipo de archivo Ejecutable Port√°til (PE)**, que es el formato de archivo para archivos ejecutables de Windows (.exe, .dll, .sys, .drv, .com, .ocx, etc.), entonces podemos deducir que el archivo est√° dise√±ado para apuntar al sistema operativo Windows.

### C√≥mo se determina el tipo de fichero.
**1.1. Por la extensi√≥n:** .exe, .dll, .sys, .drv, .com, .ocx, etc.  

**1.2. Por la firma del archivo:** Se busca la firma del archivo abri√©ndolo en un editor hexadecimal. **Una firma de archivo es una secuencia √∫nica de bytes que se escribe en el encabezado del archivo.** Diferentes archivos tienen diferentes firmas, que pueden usarse para identificar el tipo de archivo. **Los archivos ejecutables de Windows, tambi√©n llamados archivos PE**, **tienen una firma de archivo de MZ o caracteres hexadecimales 4D 5A enlos primeros dos bytes del archivo.**

![](https://web-assets.esetstatic.com/wls/2023/07/2.HxD_.jpg)

En sistemas Linux, para buscar la firma del archivo se puede utilizar el comando ```xxd```, que genera un volcado hexadecimal del archivo:
```
xxd -g 1 log.exe | more
```

**1.3. Identificando el tipo de fichero usando herramientas:**
- En sistemas Linux, esto se puede lograr usando la utilidad ```file```. En el siguiente ejemplo, el comando file se ejecut√≥ en dos archivos diferentes.
  - En el primer archivo que no tiene ninguna extensi√≥n, se detecta como un archivo ejecutable de 32 bits (PE32)
    ```
    $ file mini
    mini: PE32 executable (GUI) Intel 80386, for MS Windows
    ```
  - En el segundo archivo es un ejecutable de 64 bits (PE32+):
    ```
    $ file notepad.exe
    notepad.exe: PE32+ executable (GUI) x86-64, for MS Windows
    ```

- En Windows: Podemos usar CFF Explorer, que es parte de Explorer Suite (http://www.ntcore.com/exsuite.php).


**1.4. Identificando el tipo de fichero usando Python**
El m√≥dulo ```python-magic``` puede ser usado para identificar el tipo de fichero de un archivo.
```
$ python
Python 2.7.12 (default, Nov 19 2016, 06:48:10)
>>> import magic
>>> m = magic.open(magic.MAGIC_NONE)
>>> m.load()
>>> ftype = m.file(r'log.exe')
>>> print ftype
PE32 executable (GUI) Intel 80386, for MS Windows
```

-------------------------------------------------
## 2. Tomar huellas dactilares del malware: Fingerprinting the Malware

### ¬øQu√© es "Fingerprinting the Malware"?
Fingerprinting significa **identificar de forma √∫nica una pieza de malware** usando ciertas caracter√≠sticas t√©cnicas que la distinguen de otras.

Es como sacarle la huella digital digital para poder:
- Detectarlo en otros sistemas.
- Compararlo con otras variantes.
- Crear reglas para antivirus o sistemas de detecci√≥n.

**Fingerprinting:**  
El fingerprinting de malware es el proceso de recopilar informaci√≥n y caracter√≠sticas distintivas de un archivo malicioso, lo que permite a los analistas de seguridad y a las herramientas de protecci√≥n identificar, clasificar y entender mejor el comportamiento del malware.

### Beneficios de tomar un fingerprint de un malware:
- **Identificaci√≥n √önica:** Al igual que las huellas dactilares humanas son √∫nicas para cada individuo, el fingerprinting de malware permite identificar de manera √∫nica una muestra de malware, lo que facilita su seguimiento y detecci√≥n en diferentes sistemas
- **Prevenci√≥n de Fraudes y Autenticaci√≥n:** El fingerprinting puede detectar patrones inusuales que podr√≠an indicar una actividad sospechosa, como intentos de fraude o accesos no autorizados, y es una herramienta valiosa para la autenticaci√≥n de usuarios y dispositivos
- **Investigaci√≥n y An√°lisis Forense:** El fingerprinting es crucial para el an√°lisis forense, ya que proporciona datos detallados sobre el malware que pueden ser utilizados para entender su origen, prop√≥sito y c√≥mo se propaga
- **Desarrollo de Firmas de Antivirus:** La informaci√≥n recopilada a trav√©s del fingerprinting se utiliza para desarrollar firmas que los programas antivirus pueden usar para identificar y bloquear malware conocido.


### Huellas comunes que se analizan
| Tipo de fingerprint	| ¬øQu√© es? |
| -- | -- |
| **Hash (MD5, SHA-1, SHA-256)** | 	Identificadores √∫nicos del archivo binario. Un simple cambio en el c√≥digo genera un hash distinto. | 
| **Strings**	|  Cadenas de texto presentes en el malware (nombres de funciones, URLs, rutas, mensajes, etc.). | 
| **API calls** | 	Funciones del sistema operativo que el malware utiliza (ej: ```CreateRemoteThread, WriteProcessMemory```). | 
| **Comportamientos** | 	Acciones como persistencia, inyecci√≥n de procesos, cifrado de archivos, comunicaci√≥n con C2 (```comando y control```). | 
| **Ruta o nombre del archivo** | 	Algunos malware usan nombres o rutas repetidas. | 
| **Certificados digitales falsos** | 	A veces el malware usa firmas digitales maliciosas o robadas. | 
| **Firmas de red**	|  Patrones en el tr√°fico que genera (como DNS malicioso, peticiones HTTP an√≥malas...). | 


### Formas de Identificar de forma √∫nica una pieza de malware
#### 2.1. Hash del archivo:
- Checksum.
- Hash criptogr√°fico.

‚úÖ El checksum es una forma de fingerprint, pero muy b√°sica.  
‚ö†Ô∏è En an√°lisis serio de malware, siempre se usa hash criptogr√°fico (como SHA-256).  
‚úÖ El checksum puede ser √∫til como verificaci√≥n r√°pida, pero no para identificar malware de forma segura.

El checksum, tambi√©n conocido como **suma de verificaci√≥n**, es un **valor calculado a partir de un conjunto de datos con el objetivo de verificar su integridad**. Es una forma de asegurarse de que los datos no han sido alterados, ya sea accidentalmente o de manera malintencionada, durante la transmisi√≥n o el almacenamiento.

El proceso de checksum implica **aplicar un algoritmo o funci√≥n matem√°tica a los datos originales para producir un valor hash o una cadena de caracteres**. Este valor hash es una representaci√≥n compacta de los datos originales. Cuando los datos se transmiten o se almacenan junto con su checksum, cualquier parte que reciba o acceda a esos datos puede calcular de nuevo el checksum y compararlo con el valor original. Si los valores coinciden, se puede asumir que los datos no han sido modificados. Si los valores no coinciden, indica que los datos pueden haber sido corrompidos o alterados

**Usos de checksums:**  
- Verificaci√≥n de la integridad de archivos descargados de Internet.
- Detecci√≥n de errores en la transmisi√≥n de datos.
- Validaci√≥n de la autenticidad de la informaci√≥n. Por ejemplo, al descargar un archivo, a menudo se proporciona un checksum (como SHA256sum) que el usuario puede verificar para asegurarse de que el archivo no ha sido da√±ado o modificado desde que fue publicado por el creador.

**Algoritmos de checksum:**  
- **Algoritnos simples como CRC32 o Adler-32**. No est√°n dise√±ados para seguridad: son f√°cil de falsificar.
- **Hash criptogr√°fico como MD5, SHA-1, SHA-256** que son un tipo de checksum mucho m√°s seguro y √∫nico.


**¬øSon infalibles los checksums?**  
Aunque los checksums son √∫tiles para detectar cambios en los datos, no son infalibles y **no pueden garantizar la seguridad contra ataques maliciosos sofisticados, como los ataques de colisi√≥n,** donde dos conjuntos de datos diferentes pueden producir el mismo checksum


**Hash Collision:**  
Un hash collision, o colisi√≥n de hash, ocurre cuando dos piezas distintas de datos producen el mismo valor de hash al ser procesadas por una funci√≥n de hash. Esto significa que, a pesar de que los datos de entrada son diferentes, el resultado de la funci√≥n de hash es id√©ntico para ambos. Las funciones de hash est√°n dise√±adas para tomar datos de entrada de cualquier tama√±o y producir un resultado de longitud fija, conocido como **valor de hash, que act√∫a como una representaci√≥n digital de los datos originales.**

Las colisiones de hash son un fen√≥meno inherente a las funciones de hash debido al **principio del palomar**, que establece que si se tienen m√°s palomas que palomares y cada paloma debe ser alojada en un palomar, al menos un palomar contendr√° m√°s de una paloma. De manera similar, dado que el n√∫mero de posibles entradas para una funci√≥n de hash es pr√°cticamente infinito, pero el n√∫mero de posibles resultados de hash es finito, eventualmente debe ocurrir que dos entradas diferentes produzcan el mismo hash.

Las colisiones de hash pueden tener implicaciones significativas en varios campos, especialmente en la criptograf√≠a y la seguridad inform√°tica. Por ejemplo, en la autenticaci√≥n de datos o en la firma digital, **una colisi√≥n de hash podr√≠a permitir a un atacante crear datos falsificados que produzcan el mismo valor de hash que los datos originales y leg√≠timos, comprometiendo as√≠ la integridad de los datos.**

Para mitigar el riesgo de colisiones de hash, se utilizan algoritmos de hash criptogr√°ficos dise√±ados para ser resistentes a colisiones, lo que significa que es computacionalmente inviable encontrar dos entradas diferentes que produzcan el mismo valor de hash. Sin embargo, **no existe un algoritmo de hash que pueda garantizar completamente la ausencia de colisiones debido a las limitaciones matem√°ticas y computacionales.**


**¬øSe usa el checksum para fingerprinting?**
‚úÖ S√≠, pero con matices:
| Uso	| Checksum simple (CRC, etc.)	| Hash criptogr√°fico (MD5, SHA-256)|
| -- | --| -- |
| Detecci√≥n de integridad | 	‚úÖ | 	‚úÖ |
| Identificaci√≥n de malware | 	‚ùå (no fiable) | 	‚úÖ (muy com√∫n) |
| Comparaci√≥n de archivos | 	‚ùå (colisiones posibles) | 	‚úÖ |
| Seguridad o forense | 	‚ùå | 	‚úÖ |



**Generando Cryptographic Hash de un malware:**  
Este proceso te permitir√° obtener un identificador √∫nico para el archivo malicioso basado en su contenido, lo cual es √∫til para su an√°lisis, identificaci√≥n y comparaci√≥n con bases de datos de malware conocido.
- En Windows:
  ```
  certUtil -hashfile nombreArchivo SHA256
  certUtil -hashfile nombreArchivo MD5 | SHA256 | SHA512
  Get-FileHash -Algorithm Sha256 nombreArchivo
  Get-FileHash -Algorithm MD5 | SHA256 | SHA512 nombreArchivo
  ```
- En Linux:
  ```
  sha256sum nombre_del_archivo
  ```
- En python:
  ```
  python
  Python 2.7.12 (default, Nov 19 2016, 06:48:10)
  >>> import hashlib
  >>> content = open(r"log.exe","rb").read()
  >>> print hashlib.md5(content).hexdigest()
  6e4e030fbd2ee786e1b6b758d5897316
  >>> print hashlib.sha256(content).hexdigest()
  01636faaae739655bf88b39d21834b7dac923386d2b52efb4142cb278061f97f
  >>> print hashlib.sha1(content).hexdigest()
  625644bacf83a889038e4a283d29204edc0e9b65
  ```

#### 2.2. Extraer Cadenas de texto (Strings)
Extraer strings legibles del ejecutable puede revelar:
- URLs de comando y control (C2).
- Mensajes de error.
- Frases tipo "your files have been encrypted".
- Nombres de funciones o variables.

üìå Herramientas: strings, BinText, Ghidra, PEStudio.


#### 2.3. Firmas de antivirus (AV signatures)
Bases de datos como VirusTotal o Hybrid Analysis asocian la muestra a una familia de malware espec√≠fica.
- Ej: "Trojan:Win32/Emotet.CA"
- Estas firmas son una forma de fingerprint si son suficientemente espec√≠ficas.


#### 2.4. Funciones/APIs utilizadas
La llamada a funciones del sistema operativo puede ser muy reveladora.
- API sospechosas: CreateRemoteThread, VirtualAllocEx, RegSetValueEx, etc.
- Algunas familias de malware tienen un patr√≥n de llamadas √∫nico.

üìå Herramientas: PEStudio, Ghidra, IDA, CAPA


##### ‚¨ÖÔ∏è‚¨ÖÔ∏è‚¨ÖÔ∏èInspecci√≥n de Dependencias de Archivos e Importaciones: ‚¨ÖÔ∏è‚¨ÖÔ∏è‚¨ÖÔ∏è
Cuando analizamos qu√© funciones importa un ejecutable desde DLLs del sistema operativo, estamos viendo su huella funcional. Eso ayuda a:
- Detectar comportamientos: ¬øquiere conectarse a red? ¬øleer el registro? ¬øcrear procesos?.
- Asociar el malware a una familia conocida (muchos malware reusan los mismos patrones de importaci√≥n).
- Crear reglas YARA o modelos de detecci√≥n basados en esas dependencias.

**¬øQu√© tipo de importaciones se suelen revisar?**
| DLL com√∫n	| Funciones clave (APIs) |	¬øQu√© indica? |
| -- | -- | -- |
| kernel32.dll	| 	CreateFile, ReadFile, WriteFile		| Acceso a archivos |
| advapi32.dll	| 	RegOpenKey, RegSetValue, OpenService	| 	Registro de Windows, servicios |
| user32.dll	| 	MessageBox, GetAsyncKeyState	| 	Interacci√≥n con el usuario, keylogging |
| wininet.dll / ws2_32.dll	| 	InternetOpen, connect, send	| 	Conexi√≥n a red o C2 |
| ntdll.dll	| 	Funciones de bajo nivel	| 	Indicador de t√©cnicas evasivas |


**Herramientas para inspecci√≥n de importaciones:**
- PEStudio
- CFF Explorer
- Ghidra / IDA Pro (pesta√±a de imports)
- Dependency Walker
- ```objdump o pefile.py``` (en Linux o scripts)


**¬øC√≥mo encaja la inspecci√≥n de dependencias de srchivos e importaciones en el fingerprinting?**  
Las combinaciones de funciones importadas y DLLs usadas crean un patr√≥n √∫nico o muy caracter√≠stico del malware. Por Ejemplo: Si un binario importa ```WriteProcessMemory, CreateRemoteThread, y VirtualAllocEx```, hay una alta probabilidad de que est√© haciendo ```process injection```, una t√©cnica com√∫n en muchos troyanos y rootkits.

Generalmente, el malware interact√∫a con archivos, registro, red, etc. Para realizar dichas interacciones, el malware depende frecuentemente de las funciones expuestas por el sistema operativo. Windows exporta la mayor√≠a de sus funciones, llamadas **Interfaces de Programaci√≥n de Aplicaciones (API)**, requeridas para estas interacciones en archivos de Biblioteca de Enlace Din√°mico (DLL). Los ejecutables importan y llaman a estas funciones t√≠picamente de varias DLL que proporcionan diferentes funcionalidades. Las funciones que un ejecutable importa de otros archivos (principalmente DLL) se denominan funciones importadas (o importaciones).

Por ejemplo, si un ejecutable de malware quiere crear un archivo en el disco, en Windows, puede usar una API CreateFile(), que se exporta en kernel32.dll. Para llamar a la API, primero tiene que cargar kernel32.dll en su memoria y luego llamar a la funci√≥n CreateFile().

Inspeccionar las DLL en las que conf√≠a un malware y las funciones API que importa de las DLL puede dar una idea sobre la funcionalidad y capacidad del malware y qu√© anticipar durante su ejecuci√≥n. Las dependencias de archivos en ejecutables de Windows se almacenan en la tabla de importaciones de la estructura del archivo PE.


Sometimes you might want to use Python to enumerate DLL files and imported functions (probably to work with a large number of files); this can be done using Ero Carerra's pefile module (https://github.com/erocarrera/pefile). The installation of the pefile module on Ubuntu Linux VM was covered in Chapter 1, Introduction to Malware Analysis. If you are using any other operating system, then it can be installed using pip (pip install pefile). The following Python script demonstrates the use of the pefile module to enumerate the DLLs and the imported API functions:

```
import pefile
import sys
mal_file = sys.argv[1]
pe = pefile.PE(mal_file)
if hasattr(pe, 'DIRECTORY_ENTRY_IMPORT'):
    for entry in pe.DIRECTORY_ENTRY_IMPORT:
        print "%s" % entry.dll
    for imp in entry.imports:
        if imp.name != None:
            print "\t%s" % (imp.name)
        else:
            print "\tord(%s)" % (str(imp.ordinal))
            print "\n"
```

The following is the result of running the preceding script against the spybot_packed.exe sample; from the output, you can see the list of DLLs and imported functions:
```
$ python enum_imports.py spybot_packed.exe
KERNEL32.DLL
 LoadLibraryA
 GetProcAddress
 VirtualProtect
 VirtualAlloc
 VirtualFree
 ExitProcess
ADVAPI32.DLL
 RegCloseKey
CRTDLL.DLL
 atoi
[...REMOVED....]
```

##### ‚¨ÖÔ∏è‚¨ÖÔ∏è‚¨ÖÔ∏èInspecting Exports:‚¨ÖÔ∏è‚¨ÖÔ∏è‚¨ÖÔ∏è
El an√°lisis de exports mira qu√© funciones expone el propio archivo malicioso (generalmente una DLL) para que otro proceso las use. Ver qu√© funciones exporta un archivo nos puede revelar:
- Qu√© hace el malware (sin ni siquiera ejecutarlo).
- Si se trata de una DLL maliciosa disfrazada (por ejemplo, una DLL side-loaded).
- Patr√≥n de nombres caracter√≠stico de una familia de malware.

**Casos t√≠picos de uso:**
- Ver nombres de funciones exportadas: pueden estar relacionados con manipulaci√≥n del registro, controladores, persistencia, etc.
- Detectar t√©cnicas como DLL Injection o DLL Hijacking.
- Saber si es una DLL leg√≠tima modificada o una creada desde cero.

**Herramientas √∫tiles para analizar las exportaciones:**
- PEStudio ‚Üí pesta√±a de "Exports".
- Ghidra / IDA Pro ‚Üí pesta√±a "Exports".
- CFF Explorer.
- Python + pefile ‚Üí como el ejemplo que diste

El ejecutable y la DLL pueden exportar funciones, que pueden ser utilizadas por otros programas. T√≠picamente, una DLL exporta funciones (exportaciones) que son importadas por el ejecutable. Una DLL no puede funcionar por s√≠ sola y depende de un proceso anfitri√≥n para ejecutar su c√≥digo. Un atacante a menudo crea una DLL que exporta funciones que contienen funcionalidad maliciosa. Para ejecutar las funciones maliciosas dentro de la DLL, de alguna manera se hace que sea cargada por un proceso que llama a estas funciones maliciosas. Las DLL tambi√©n pueden importar funciones de otras bibliotecas (DLL) para realizar operaciones del sistema.
Inspeccionar las funciones exportadas puede darte una idea r√°pida de las capacidades de la DLL. En el siguiente ejemplo, al cargar una DLL asociada con malware llamado Ramnit en pestudio, se muestran sus funciones exportadas, dando una indicaci√≥n de sus capacidades. Cuando un proceso carga esta DLL, en alg√∫n momento, estas funciones ser√°n llamadas para realizar actividades maliciosas:


In Python, the exported functions can be enumerated using the pefile module, as shown here:
```
$ python
Python 2.7.12 (default, Nov 19 2016, 06:48:10)
>>> import pefile
>>> pe = pefile.PE("rmn.dll")
>>> if hasattr(pe, 'DIRECTORY_ENTRY_EXPORT'):
... for exp in pe.DIRECTORY_ENTRY_EXPORT.symbols:
... print "%s" % exp.name
...
AddDriverPath
AddRegistryforME
CleanupDevice
CleanupDevice_EX
CreateBridgeRegistryfor2K
CreateFolder
CreateKey
CreateRegistry
DeleteDriverPath
DeleteOemFile
DeleteOemInfFile
DeleteRegistryforME
DuplicateFile
EditRegistry
EnumerateDevice
GetOS
[.....REMOVED....]
```
Esto enumerar√≠a todas las funciones exportadas por la DLL, que nos dar√≠a pistas claras de DLLs que interact√∫an con el registro y realizan tareas potencialmente maliciosas:
- CreateRegistry.
- EditRegistry.
- CleanupDevice.


#### 2.5. Comportamiento din√°mico
Observar qu√© hace al ejecutarse en un entorno controlado:
- Modificar el registro.
- Crear servicios.
- Se conecta a Internet.
- Instalar persistencia.
- Cifrar archivos

üìå Herramientas: Cuckoo Sandbox, ProcMon, Wireshark


#### 2.6. Tama√±o del archivo y estructura PE
Algunos malware tienen tama√±os caracter√≠sticos o estructuras inusuales:
- Tama√±o total del binario
  - Algunos malware tienen tama√±os muy caracter√≠sticos (demasiado peque√±os, muy grandes, etc.).
  - Puede indicar uso de packers (empaquetadores).
- N√∫mero de secciones en el PE.
  - Nombres inusuales: .asdf, .textbss, etc.
  - Secciones adicionales: UPX, code, stub, etc.
  - N√∫mero de secciones (demasiadas o muy pocas).
- ‚úÖ Cabecera PE (PE Header Information)
  - Timestamps.
  - Direcci√≥n de entrada (Entry Point).
  - Tabla de importaci√≥n (IAT).
  - Versiones del compilador.
  - Firmas digitales.
  - Subsistema (GUI o consola).
  - Tama√±o de cada secci√≥n.
  - Entrop√≠a (medida de aleatoriedad)

##### ‚¨ÖÔ∏è‚¨ÖÔ∏è‚¨ÖÔ∏èInspecting PE Header Information‚¨ÖÔ∏è‚¨ÖÔ∏è‚¨ÖÔ∏è

**¬øQu√© es la cabecera PE?**  
El formato PE (Portable Executable) es la estructura de los ejecutables en Windows (.exe, .dll, etc.). La cabecera PE contiene metadatos clave que pueden ayudarte a identificar caracter√≠sticas √∫nicas del malware.

**¬øQu√© elementos del PE Header se usan como "huella digital"?**
| Campo de la cabecera PE |	¬øPor qu√© es √∫til en fingerprinting? |
| -- | -- |
| Timestamp de compilaci√≥n  |		Puede identificar la fecha falsa usada por ciertas familias |
| N√∫mero y nombres de secciones |		.text, .data, .rdata, pero algunos malware usan .asdf, .xyz, etc. |
| Entrypoint (direcci√≥n de entrada |	)	Puede indicar empaquetadores o payloads ocultos |
| Import Table (IAT) |		Lista de funciones del sistema que el ejecutable usar√° |
| Versi√≥n del compilador |		Ayuda a saber con qu√© herramienta fue creado |
| Firmas digitales / certificados |	Algunos malware usan firmas falsas o robadas |


**Herramientas para inspeccionar cabeceras PE:**
- PEStudio ‚Üí s√∫per visual, destaca elementos sospechosos.
- Detect It Easy (DIE) ‚Üí detecta si est√° empaquetado.
- CFF Explorer ‚Üí an√°lisis avanzado de PE.
-```objdump / readpe / pefile.py``` ‚Üí para l√≠nea de comandos o scripts.



- Los ejecutables tienen lo que se llama un **punto de entrada (ENTRY POINT)**. Cuando se ejecuta, este punto de entrada es simplemente la ubicaci√≥n de las primeras piezas de c√≥digo que se van a ejecutar dentro del archivo, como se ilustra a continuaci√≥n:
  
  ![](capturas/entry-point.png)

- Los ejecutables de Windows deben ajustarse al formato **PE/COFF (Portable Executable/Common Object File Format).** El formato de archivo PE es utilizado por los archivos ejecutables de Windows (tales como .exe, .dll, .sys, .ocx y .drv) y tales archivos generalmente se denominan archivos Portable Executable (PE). El archivo PE es una serie de estructuras y subcomponentes que contienen la informaci√≥n requerida por el sistema operativo para cargarlo en la memoria.
- Cuando un ejecutable se compila, incluye un encabezado (encabezado PE), que describe su estructura. Cuando se ejecuta el binario, el cargador del sistema operativo lee la informaci√≥n del encabezado PE y luego carga el contenido binario del archivo en la memoria. El encabezado PE contiene informaci√≥n como d√≥nde necesita ser cargado el ejecutable en la memoria, la direcci√≥n donde comienza la ejecuci√≥n, la lista de bibliotecas/funciones en las que se basa la aplicaci√≥n, y los recursos utilizados por el binario. Examinar el encabezado PE proporciona una gran cantidad de informaci√≥n sobre el binario y sus funcionalidades.
- Inspecting PE Header Information se refiere a examinar la informaci√≥n contenida en el encabezado de un archivo ejecutable Portable Executable (PE) en sistemas Windows. El encabezado PE es una estructura de datos importante que contiene informaci√≥n esencial sobre c√≥mo el sistema operativo debe cargar y manejar el archivo ejecutable o la biblioteca de enlace din√°mico (DLL).
- La **entrop√≠a de un archivo** es una medida de la cantidad de aleatoriedad o incertidumbre que contiene. En el contexto de un Ejecutable Port√°til (PE), una alta entrop√≠a puede ser indicativa de que el archivo ha sido comprimido o cifrado, lo cual es una t√©cnica com√∫nmente utilizada por el malware para ocultar su c√≥digo y evitar la detecci√≥n por parte de herramientas de seguridad. Por lo tanto, la entrop√≠a es una caracter√≠stica prominente que las herramientas de an√°lisis de malware buscan al evaluar la sospechosidad de un archivo. Si un archivo PE tiene una entrop√≠a inusualmente alta, podr√≠a ser un indicador de que contiene c√≥digo malicioso o que ha sido manipulado para esconder su verdadera naturaleza. La entrop√≠a de un archivo es una clasificaci√≥n que califica qu√© tan aleatorios son los datos dentro de un archivo PE. Con una escala del 0 al 8, donde 0 significa menos "aleatoriedad" de los datos en el archivo, y un puntaje hacia 8 indica que estos datos son m√°s "aleatorios".
- Los autores de malware utilizan t√©cnicas como la encriptaci√≥n o el empaquetado para ofuscar su c√≥digo e intentar eludir el antivirus. Debido a esto, estos archivos tendr√°n una entrop√≠a alta.
- Cuando **inspeccionas el encabezado PE, generalmente buscas detalles como:**
  - Tipo de Archivo: Determinar si el archivo es un ejecutable, una DLL, un controlador del sistema, entre otros.
  - Punto de Entrada: La ubicaci√≥n en el c√≥digo donde el sistema operativo comienza a ejecutar el programa.
  - Secciones del Archivo: Informaci√≥n sobre las diferentes secciones del archivo, como c√≥digo, datos y recursos.
  - Dependencias de la Biblioteca: Qu√© otras bibliotecas (DLLs) necesita el ejecutable para funcionar.
  - Informaci√≥n de la Plataforma: Para qu√© arquitectura de hardware est√° dise√±ado el archivo (por ejemplo, x86, x64).
  - Firmas Digitales: Para verificar la autenticidad y la integridad del archivo.

- **Resources for understanding the PE file structure:**
  - An In-Depth Look into the Win32 Portable Executable File Format - Part 1:
  http://www.delphibasics.info/home/delphibasicsarticles/anindepthlookintothewin32portableexecutablefileformat-part1
  - An In-Depth Look into the Win32 Portable Executable File Format - Part 2:
  http://www.delphibasics.info/home/delphibasicsarticles/anindepthlookintothewin32portableexecutablefileformat-part2
  - PE Headers and structures: http://www.openrce.org/reference_library/files/reference/PE%20Format.pdf
  - PE101 - A Windows Executable Walkthrough: https://github.com/corkami/pics/blob/master/binary/pe101/pe101.pdf

- **Tools that allow you to examine and modify the PE structure and its sub-components:**
  - CFF Explorer: http://www.ntcore.com/exsuite.php
  - PE Internals: http://www.andreybazhan.com/pe-internals.html
  - PPEE(puppy): https://www.mzrst.com/
  - PEBrowse Professional: http://www.smidgeonsoft.prohosting.com/pebrowsepro-file-viewer.html


- A tool such as **pestudio** (https://www.winitor.com) or **PPEE** (puppy: https://www.mzrst.com/) can assist you with exploring interesting artifacts from the PE file.

- **Comando pecheck:** El comando pecheck es una herramienta de an√°lisis de archivos PE (Portable Executable) desarrollada por Didier Stevens. Cuando se ejecuta pecheck en un archivo PE, la herramienta examina el archivo y proporciona un informe que incluye informaci√≥n sobre las siguientes estructuras y elementos:
  - DOS Header: La cabecera inicial que est√° presente para mantener la compatibilidad con aplicaciones DOS antiguas.
  - PE Header: La cabecera que sigue al DOS Header y contiene metadatos esenciales sobre el archivo ejecutable, como la arquitectura de la m√°quina para la que est√° compilado (x86, x64, etc.) y los puntos de entrada del programa.
  - Optional Header: Una secci√≥n del PE Header que proporciona informaci√≥n adicional necesaria para la carga del ejecutable, como la direcci√≥n base de la imagen, la alineaci√≥n de las secciones y el punto de entrada del programa.
  - Section Headers: Las cabeceras de las secciones del archivo que describen c√≥mo se organizan los datos y el c√≥digo dentro del archivo PE.
  - Data Directories: Partes del Optional Header que contienen punteros a estructuras de datos importantes como la tabla de importaciones y exportaciones, recursos y m√°s.

- **Utilidad pe-tree:** pe-tree es una herramienta de an√°lisis de archivos Portable Executable (PE) dise√±ada para proporcionar una vista estructurada y jer√°rquica de los componentes internos de los archivos PE.
  - Vista Jer√°rquica: pe-tree presenta la informaci√≥n del archivo PE en una estructura de √°rbol, lo que permite a los usuarios expandir y colapsar secciones para explorar detalles espec√≠ficos de manera eficiente. Esto incluye cabeceras, secciones, tablas de importaci√≥n/exportaci√≥n, recursos y m√°s.
  - An√°lisis de Secciones y Cabeceras: La herramienta analiza y muestra informaci√≥n detallada sobre las cabeceras PE, incluyendo el DOS Header, PE Header, Optional Header, y Section Headers. Esto es crucial para entender la configuraci√≥n y el comportamiento potencial del archivo.
  - Identificaci√≥n de Anomal√≠as: pe-tree puede ayudar a identificar caracter√≠sticas inusuales o sospechosas en los archivos PE, como secciones ocultas, configuraciones an√≥malas en las cabeceras, o firmas digitales inv√°lidas.
  - Integraci√≥n con Herramientas de An√°lisis de Malware: pe-tree puede integrarse con otras herramientas y plataformas de an√°lisis de malware para proporcionar una visi√≥n m√°s completa del archivo analizado. Esto puede incluir la extracci√≥n y an√°lisis de cadenas, as√≠ como la identificaci√≥n de patrones de c√≥digo malicioso.


- **Analazing PE Header en windows con CFF Explorer:** https://ntcore.com/explorer-suite/



##### ‚¨ÖÔ∏è‚¨ÖÔ∏è‚¨ÖÔ∏è Examining PE Section Table And Sections  ‚¨ÖÔ∏è‚¨ÖÔ∏è‚¨ÖÔ∏è
El contenido real del archivo PE est√° dividido en secciones. Estas secciones son inmediatamente seguidas por el encabezado PE. Estas secciones representan ya sea c√≥digo o datos y tienen atributos en memoria como lectura/escritura. La secci√≥n que representa c√≥digo contiene instrucciones que ser√°n ejecutadas por el procesador, mientras que la secci√≥n que contiene datos puede representar diferentes tipos de datos, como datos de programa de lectura/escritura (variables globales), tablas de importaci√≥n/exportaci√≥n, recursos, etc. Cada secci√≥n tiene un nombre distintivo que transmite el prop√≥sito de la secci√≥n.

**Secciones en un PE File:**
- .text || CODE: Contiene el c√≥digo ejecutable. Tiene un atributo de lectura-ejecuci√≥n.
- .data || DATA: Contiene datos y variables globales. Tiene un atributo de lectura-escritura.
- .rdata: Contiene datos de solo lectura. A veces tambi√©n contiene informaci√≥n de importaci√≥n y exportaci√≥n.
- .idata: Si est√° presente, contiene la tabla de importaci√≥n. Si no est√° presente, entonces la informaci√≥n de importaci√≥n se almacena en la secci√≥n .rdata.
- .edata: Si est√° presente, contiene informaci√≥n de exportaci√≥n. Si no est√° presente, entonces la informaci√≥n de exportaci√≥n se encuentra en la secci√≥n .rdata.
- .rsrc: Esta secci√≥n contiene los recursos utilizados por el ejecutable, como √≠conos, di√°logos, men√∫s, cadenas, y as√≠ sucesivamente.


**üì¶ Secciones comunes y su significado**
| Secci√≥n |	Funci√≥n principal |	Riesgo si mal usada |
| -- | -- | -- |
| .text | 	C√≥digo ejecutable (instrucciones del programa) | 	‚úÖ Normal, pero puede ocultar shellcode |
| .data | 	Variables globales (lectura/escritura) | 	‚ö†Ô∏è Riesgo si contiene c√≥digo o C2 info |
| .rdata | 	Datos de solo lectura (a veces import/export info) | 	‚ö†Ô∏è Puede esconder strings maliciosas |
| .idata | 	Tabla de importaci√≥n | 	‚úÖ √ötil para fingerprinting API usage |
| .edata | 	Tabla de exportaci√≥n | 	‚úÖ Relevante si es una DLL |
| .rsrc | 	Recursos (√≠conos, di√°logos, cadenas, etc.) | 	‚ö†Ô∏è Puede contener payloads cifrados |
| .reloc | 	Informaci√≥n de reubicaci√≥n de direcciones | 	Rara vez usada por malware |
| .UPX | 	Secci√≥n t√≠pica de ejecutables empaquetados | 	üö® Puede ocultar comportamiento real |


Estos nombres de secci√≥n son principalmente para humanos y no son utilizados por el sistema operativo, lo que significa que **es posible para un atacante o un software de ofuscaci√≥n crear secciones con nombres diferentes.** Si nos encuentramos con nombres de secci√≥n que no son comunes, entonces debemos tratarlos con sospecha, y se requiere un an√°lisis adicional para confirmar su malicia. La informaci√≥n sobre estas secciones (como el nombre de la secci√≥n, d√≥nde encontrar la secci√≥n y sus caracter√≠sticas) est√° presente en la tabla de secciones en el encabezado PE. Examinar una tabla de secciones proporcionar√° informaci√≥n sobre la secci√≥n y sus caracter√≠sticas. Cuando cargamos un ejecutable en pestudio y hacemos clic en secciones, muestra la informaci√≥n de la secci√≥n extra√≠da de la tabla de secciones y sus atributos (lectura/escritura, etc.). 

**Campo / Descripcion:**
- Names: Displays section names. In this case, the executable contains four sections (.text,.data, .rdata and .rsrc).
- Virtual-Size: Indicates the size of the section when loaded into memory.
- Virtual-Address: This is the relative virtual address (that is, offset from the base address of the executable) where the section can be found in memory.
- Raw-size: Indicates the size of the section on the disk.
- Raw-data: Indicates the offset in the file where the section can be found.
- Entry-point: This is the RVA (relative virtual address) where the code starts executing. In this case, the entry point is in the .text section, which is normal. 

![](capturas/pestudio.png)

**Discrepancias:**
- Los nombres de las secciones no contienen secciones comunes a√±adidas por el compilador (como .text, .data, y as√≠ sucesivamente) sino que contienen nombres de secci√≥n UPX0 y UPX1.
- El punto de entrada est√° en la secci√≥n UPX1, lo que indica que la ejecuci√≥n comenzar√° en esta secci√≥n (rutina de descompresi√≥n).
- Normalmente, el tama√±o en bruto (raw-size) y el tama√±o virtual (virtual-size) deber√≠an ser casi iguales, pero peque√±as diferencias son normales debido al alineamiento de secciones. En este caso, el tama√±o en bruto es 0, indicando que esta secci√≥n no ocupar√° espacio en el disco, pero el tama√±o virtual especifica que, en memoria, ocupa m√°s espacio (alrededor de 127 kb). Esto es una fuerte indicaci√≥n de un binario empaquetado. La raz√≥n de esta discrepancia es que cuando se ejecuta un binario empaquetado, la rutina de descompresi√≥n del empaquetador copiar√° datos o instrucciones descomprimidas en la memoria durante el tiempo de ejecuci√≥n.


**üõ†Ô∏è Herramientas para inspecci√≥n de secciones PE**
- EStudio ‚Üí muestra secciones con permisos, entrop√≠a, tama√±o, etc.
- Detect It Easy (DIE) ‚Üí identifica empaquetadores y secciones.
- Ghidra / IDA Pro ‚Üí muestra secciones y te permite analizarlas.
- CFF Explorer ‚Üí an√°lisis visual del PE Header + secciones.


### Herramienta pescanner
pescanner, creado por Michael Ligh y Glenn P. Edwards, es una excelente herramienta para detectar archivos PE sospechosos basados en los atributos del archivo PE; utiliza heur√≠sticas en lugar de firmas y puede ayudarte a identificar binarios empaquetados incluso si no hay firmas para ello. Se puede descargar una copia del script desde https://github.com/hiddenillusion/AnalyzePE/blob/master/pescanner.py.



##### ‚¨ÖÔ∏è‚¨ÖÔ∏è‚¨ÖÔ∏è Examinando el Compilation Timestamp ‚¨ÖÔ∏è‚¨ÖÔ∏è‚¨ÖÔ∏è 
El encabezado PE contiene informaci√≥n que especifica cu√°ndo se compil√≥ el binario; examinar este campo puede dar una idea de cu√°ndo se cre√≥ inicialmente el malware. Esta informaci√≥n puede ser √∫til para construir una l√≠nea de tiempo de la campa√±a de ataque. Tambi√©n es posible que un atacante modifique la marca de tiempo para evitar que un analista conozca la marca de tiempo real. A veces, una marca de tiempo de compilaci√≥n puede usarse para clasificar muestras sospechosas.

El Compilation Timestamp es un valor que se encuentra en la cabecera PE del archivo (IMAGE_FILE_HEADER.TimeDateStamp). Est√° en formato UNIX timestamp (n√∫mero de segundos desde 1970).

‚úÖ Nos permite:
- Construir l√≠neas de tiempo de campa√±as de malware.
- Agrupar muestras por periodos o builds (compilaciones).
- Detectar malware falsamente fechado (si se repite un timestamp en muchas muestras).
- Correlacionar con eventos (por ejemplo: ataques de cierta fecha).
- Identificar muestras que usan timestamps falsos cl√°sicos (como el famoso 0x2A425E19 que corresponde a 2001 pero se ha usado en muchas muestras modificadas).



##### ‚¨ÖÔ∏è‚¨ÖÔ∏è‚¨ÖÔ∏è Examinando PE Resources ‚¨ÖÔ∏è‚¨ÖÔ∏è‚¨ÖÔ∏è 
Los recursos requeridos por el archivo ejecutable, como iconos, men√∫s, di√°logos y cadenas, se almacenan en la secci√≥n de recursos (.rsrc) de un archivo ejecutable. A menudo, los atacantes almacenan informaci√≥n como binarios adicionales, documentos se√±uelo y datos de configuraci√≥n en la secci√≥n de recursos, por lo que examinar los recursos puede revelar informaci√≥n valiosa sobre un binario. La secci√≥n de recursos tambi√©n contiene informaci√≥n de versi√≥n que puede revelar detalles sobre el origen, el nombre de la empresa, los detalles del autor del programa y la informaci√≥n de copyright.

Resource Hacker (http://www.angusj.com/resourcehacker/) es una excelente herramienta para examinar, ver y extraer los recursos de un binario sospechoso.
Notice how the file extension is changed to .xls.exe ‚ü∂

![](capturas/resourcehacker.png)

Loading a malicious binary in resource hacker shows three resources (Icon, Binary, and Icon Group). The malware specimen uses the icon of Microsoft Excel (to give the appearance of an excel sheet):

![](capturas/resourcehacker-2.png)

El ejecutable tambi√©n contiene datos binarios; uno de ellos tiene una firma de archivo de D0 CF 11 E0 A1 B1 1A E1. Esta secuencia de bytes representa la firma de archivo para un archivo de documento de Microsoft Office. Los atacantes, en este caso, almacenaron una hoja de c√°lculo de Excel falsa en la secci√≥n de recursos. Al ejecutarse, el malware se ejecuta en segundo plano, y esta hoja de c√°lculo falsa se muestra al usuario como una distracci√≥n:

![](capturas/resourcehacker-3.png)



#### 2.7. YARA rules (firmas personalizadas)
Reglas personalizadas que combinan varios indicadores (strings, APIs, offsets‚Ä¶).
- Muy √∫tiles para detectar familias completas de malware o variantes similares.

```
rule Petya_MBR
{
  strings:
    $a = "Your files are encrypted"
    $b = { E8 ?? ?? ?? ?? 83 C4 04 }
  condition:
    $a and $b
}
```

#### 2.8. Nombre del archivo / ubicaci√≥n t√≠pica
- Algunos malware siempre se copia como svchost.exe en %AppData%
- No es √∫nico, pero puede ayudar al fingerprinting de campa√±as espec√≠ficas.


#### 2.9. Metadatos del binario
- Timestamp de compilaci√≥n.
- Nombre del compilador.
- Certificado digital (si lo hay).

üìå Herramientas: PEStudio, ExifTool, SigCheck


#### 2.10. Tr√°fico de red (Network signature)
- Hostnames o IPs de C2.
- Peticiones HTTP espec√≠ficas.
- DNS maliciosos

üìå Herramientas: Wireshark, Suricata, Zeek


-------------------------------------------------
## 3. Escanear el binario sospechoso con motores antivirus: Multiple Anti-Virus Scanning
Escanear el binario sospechoso con varios esc√°neres antivirus ayuda a determinar si existen firmas de c√≥digo malicioso para el archivo sospechoso. El nombre de la firma de un archivo en particular puede proporcionar informaci√≥n adicional sobre el archivo y sus capacidades. Al visitar los sitios web de los respectivos proveedores de antivirus o buscar la firma en los motores de b√∫squeda, puede obtener m√°s detalles sobre el archivo sospechoso. Esta informaci√≥n puede ayudarle en su investigaci√≥n posterior y puede reducir el tiempo de an√°lisis.

### Virus Total
VirusTotal es una herramienta en l√≠nea gratuita que se utiliza para analizar archivos y URLs en busca de virus, gusanos, troyanos y otros tipos de malware. La plataforma utiliza m√°s de 70 motores antivirus y anti-malware para escanear y proporcionar un informe detallado sobre cualquier amenaza detectada.

Para usar VirusTotal para escanear un malware, puedes seguir estos pasos:
- Subir el Archivo o URL Sospechosa: Accede a la p√°gina web de VirusTotal y selecciona la opci√≥n para subir el archivo que deseas analizar o ingresa la URL que quieres verificar
- An√°lisis Autom√°tico: Una vez que el archivo o URL ha sido subido, VirusTotal lo analizar√° autom√°ticamente utilizando sus m√∫ltiples motores antivirus y te proporcionar√° un informe con los resultados
- Interpretar los Resultados: El informe incluir√° una lista de todos los motores antivirus que analizaron el archivo y sus resultados. Si alguno de los motores detecta una amenaza, el informe indicar√° el nombre de la amenaza y proporcionar√° informaci√≥n adicional sobre ella
- Evaluar la Confiabilidad: Es importante tener en cuenta que aunque VirusTotal es una herramienta valiosa, no es infalible y no garantiza una protecci√≥n completa contra el malware. Por lo tanto, se recomienda utilizar una variedad de herramientas de seguridad y seguir las mejores pr√°cticas de seguridad cibern√©tica
- Uso de la API P√∫blica: Para usuarios avanzados o para integraciones autom√°ticas, VirusTotal ofrece una API p√∫blica que permite enviar muestras y recibir informes de an√°lisis de manera program√°tica
- Herramientas Adicionales: Adem√°s de la p√°gina web, existen herramientas como VirusTotal Uploader y aplicaciones para dispositivos m√≥viles que facilitan el env√≠o de archivos y URLs a VirusTotal para su an√°lisis

## Querying Hash Values Using VirusTotal
Para consultar valores de hash utilizando VirusTotal, puedes seguir estos pasos:
- Obtener un Hash de Archivo: Primero, necesitas el hash del archivo que deseas consultar. Los hashes permitidos son MD5, SHA1 y SHA256
- Acceder a VirusTotal: Ve a la p√°gina web de VirusTotal (https://www.virustotal.com/).
- Ingresar el Hash en la B√∫squeda: Utiliza la barra de b√∫squeda de VirusTotal para ingresar el hash del archivo. Aseg√∫rate de que el hash corresponda a uno de los formatos permitidos (MD5, SHA1, SHA256).
- Revisar el Informe: Despu√©s de buscar el hash, VirusTotal te mostrar√° el √∫ltimo informe disponible para ese archivo. Si el archivo ha sido analizado previamente, podr√°s ver los resultados de los diferentes motores antivirus y otra informaci√≥n relevante
- Uso de la API de VirusTotal: Si prefieres automatizar el proceso o realizar consultas en masa, puedes utilizar la API p√∫blica de VirusTotal. Necesitar√°s una clave API que puedes obtener creando una cuenta en VirusTotal.
- Ejemplo de Uso de la API con cURL:
  ```
  curl --request POST \
  --url 'https://www.virustotal.com/vtapi/v2/file/report' \
  -d apikey=$your-api-key \
  -d 'resource=$your-file-hash'
  ```
  Reemplaza $your-api-key con tu clave API y $your-file-hash con el hash del archivo que deseas consultar.
  
- Ejemplo de Uso de la API con Python:
  ```
  python
  import requests
  
  url = 'https://www.virustotal.com/vtapi/v2/file/report'
  params = {'apikey': 'tu_clave_api', 'resource': 'hash_del_archivo'}
  response = requests.post(url, data=params)
  print(response.json())
  ```
  Reemplaza 'tu_clave_api' con tu clave API y 'hash_del_archivo' con el hash del archivo que deseas consultar.
  
Nota: La API p√∫blica de VirusTotal tiene una limitaci√≥n de cuatro consultas por minuto. Si necesitamos realizar un mayor volumen de consultas o acceder a informaci√≥n m√°s detallada, tendremos que considerar usar la API privada de VirusTotal o el servicio premium VirusTotal Intelligence.


- Otro script:
  ```
  import urllib
  import urllib2
  import json
  import sys

  hash_value = sys.argv[1]
  vt_url = "https://www.virustotal.com/vtapi/v2/file/report"
  api_key = "<update your api key here>"
  parameters = {'apikey': api_key, 'resource': hash_value}
  encoded_parameters = urllib.urlencode(parameters)
  request = urllib2.Request(vt_url, encoded_parameters)
  response = urllib2.urlopen(request)
  json_response = json.loads(response.read())
  if json_response['response_code']:
    detections = json_response['positives']
    total = json_response['total']
    scan_results = json_response['scans']
    print "Detections: %s/%s" % (detections, total)
    print "VirusTotal Results:"
    for av_name, av_data in scan_results.items():
      print "\t%s ==> %s" % (av_name, av_data['result'])
  else:
    print "No AV Detections For: %s" % hash_value
  ```
  Running the preceding script by giving it an MD5 hash of a binary shows the antivirus detections and the signature names for the binary.
  ```
  md5sum 5340.exe
  5340fcfb3d2fa263c280e9659d13ba93 5340.exe

  python vt_hash_query.py 5340fcfb3d2fa263c280e9659d13ba93
  Detections: 44/56
  VirusTotal Results:
     Bkav ==> None
     MicroWorld-eScan ==> Trojan.Generic.11318045
     nProtect ==> Trojan/W32.Agent.105472.SJ
     CMC ==> None
     CAT-QuickHeal ==> Trojan.Agen.r4
     ALYac ==> Trojan.Generic.11318045
     Malwarebytes ==> None
     Zillya ==> None
     SUPERAntiSpyware ==> None
     TheHacker ==> None
     K7GW ==> Trojan ( 001d37dc1 )
     K7AntiVirus ==> Trojan ( 001d37dc1 )
     NANO-Antivirus ==> Trojan.Win32.Agent.cxbxiy
     F-Prot ==> W32/Etumbot.K
     Symantec ==> Trojan.Zbot
     [.........Removed..............]

  ```
  
- Usando la herramienta PEstudio (https://www.winitor.com/) o la herramienta PPEE (https://www.mzrst.com/).
- Online scanners such as VirSCAN (http://www.virscan.org/), Jotti Malware Scan (https://virusscan.jotti.org/), and OPSWAT's Metadefender (https://www.metadefender.com/#!/scan-file) allow you to scan a suspect file with multiple anti-virus scanning engines, and some of them also allow you to do hash lookups.
- Consideracuiones a tener en cuenta cuando subimos un binario a un scanner online: Aunque los esc√°neres antivirus y los servicios de escaneo en l√≠nea son herramientas √∫tiles para identificar malware, existen limitaciones y riesgos asociados con su uso. Es crucial ser consciente de estos riesgos, especialmente en lo que respecta a la confidencialidad de la informaci√≥n y la posibilidad de que los atacantes adapten sus m√©todos para evadir la detecci√≥n.
  - Detecci√≥n no garantizada: Los autores de malware pueden modificar su c√≥digo y emplear t√©cnicas de ofuscaci√≥n para evadir estas detecciones, lo que puede resultar en que algunos motores antivirus no logren identificar el archivo como malicioso. Esto se debe a que las t√©cnicas de ofuscaci√≥n y metamorfismo pueden cambiar la apariencia del c√≥digo malicioso sin alterar su funcionalidad, dificultando su detecci√≥n basada en firmas.
  - Riesgos de compartir binarios: Al subir un archivo binario a un sitio p√∫blico, existe el riesgo de que este archivo se comparta con terceros y proveedores. Si el archivo binario contiene informaci√≥n sensible, personal o propiedad de una organizaci√≥n, no es recomendable enviarlo a servicios p√∫blicos de escaneo antivirus, especialmente si es parte de una investigaci√≥n confidencial. Esto se debe a que el archivo podr√≠a contener datos cr√≠ticos que no deber√≠an ser expuesto.
  - Uso de valores hash criptogr√°ficos: Como alternativa a la presentaci√≥n del archivo binario, la mayor√≠a de los servicios de escaneo antivirus en l√≠nea permiten buscar en su base de datos de archivos escaneados utilizando valores hash criptogr√°ficos (MD5, SHA1 o SHA256). Esto significa que en lugar de subir el archivo completo, se puede buscar utilizando el hash criptogr√°fico del archivo, lo que reduce el riesgo de exponer informaci√≥n sensible.


-------------------------------------------------
## 4. Extraer cadenas, funciones y metadatos asociados con el archivo: Extracting Strings
La extracci√≥n de cadenas de un fichero ejecutable es un proceso utilizado en el an√°lisis de malware y en la ingenier√≠a inversa de software para **identificar y extraer secuencias de caracteres legibles (cadenas) dentro de un archivo binario**. Este proceso es fundamental para entender el comportamiento potencial de un programa sin necesidad de ejecutarlo o analizar su c√≥digo fuente, que puede no estar disponible. Las cadenas pueden incluir rutas de archivos, mensajes de error, URLs de servidores de comando y control (C&C), claves de cifrado, y otros indicadores de compromiso (IoCs) que son √∫tiles para el an√°lisis de seguridad.

Las **cadenas son secuencias de caracteres imprimibles en ASCII y Unicode incrustadas en un archivo.**
La extracci√≥n de cadenas puede dar pistas sobre la funcionalidad del programa y los indicadores asociados con un binario sospechoso. Por ejemplo, si un malware crea un archivo, el nombre del archivo se almacena como una cadena en el binario. Tambi√©n si un malware resuelve un nombre de dominio controlado por el atacante, entonces el nombre de dominio se almacena como una cadena. Las cadenas extra√≠das del binario pueden contener **referencias a nombres de archivos, URL, nombres de dominio, direcciones IP, comandos de ataque, claves de registro, etc**. Aunque las cadenas no dan una idea clara del prop√≥sito y la capacidad de un archivo, pueden dar una **pista sobre lo que el malware es capaz de hacer.**


### 4.1 Extraer Cadenas usando herramientas
**Herramientas para la extracci√≥n de cadenas de archivos ejecutables:**
- Strings: Disponible en sistemas Unix y Windows, es una herramienta de l√≠nea de comandos que busca secuencias de caracteres ASCII o Unicode que son al menos de una longitud m√≠nima especificada (por defecto, 4 caracteres). El comando strings, por defecto, extrae las cadenas ASCII que tienen al menos cuatro caracteres de largo. Con la opci√≥n -a es posible extraer cadenas de todo el archivo.
  ```
  strings -a log.exe
  ```
  Espec√≠menes de malware tambi√©n utilizan cadenas Unicode (2 bytes por car√°cter). Para obtener informaci√≥n √∫til del binario, a veces necesitas extraer tanto cadenas ASCII como Unicode. Para extraer cadenas Unicode usando el comando strings, usamos la opci√≥n -el.
  ```
  strings -a -el log.exe
  ```

- Binwalk: Aunque es m√°s conocida por su capacidad para analizar y extraer firmware, tambi√©n puede ser utilizada para extraer cadenas.
- HEx Editors: Permiten visualizar y editar el contenido binario de un archivo, incluyendo la extracci√≥n manual de cadenas.
- En Windows, pestudio (https://www.winitor.com) es una herramienta √∫til que muestra cadenas ASCII y Unicode. pestudio es una excelente herramienta de an√°lisis de PE para realizar pruebas iniciales evaluaci√≥n de malware de un binario sospechoso y est√° dise√±ado para recuperar varios elementos √∫tiles.
- Tambi√©n en windows se puede usar el comando strings de sysinternals y PPEE (https://www.mzrst.com/).


**Proceso de Extracci√≥n:** La herramienta seleccionada lee el archivo binario y busca secuencias de caracteres que coincidan con patrones de cadenas legibles. Estas cadenas se extraen y se presentan al analista para su revisi√≥n.

**An√°lisis de las Cadenas:** Una vez extra√≠das, las cadenas pueden ser analizadas para buscar informaci√≥n relevante que pueda indicar el prop√≥sito del archivo ejecutable, incluyendo:
  - Direcciones IP y URLs que pueden se√±alar a servidores de C&C.
  - Rutas de archivos espec√≠ficos que el malware intenta modificar o leer.
  - Mensajes de error o logs que el malware genera.
  - Referencias a librer√≠as espec√≠ficas o llamadas al sistema que indican c√≥mo interact√∫a el malware con el sistema operativo.



### 4.2 Decoding Obfuscated Strings Using FLOSS
La mayor√≠a de las veces, los autores de malware utilizan t√©cnicas simples de ofuscaci√≥n de cadenas para evitar la detecci√≥n. En tales casos, esas cadenas ofuscadas no aparecer√°n en la utilidad de cadenas ni en otras herramientas de extracci√≥n de cadenas. **FireEye Labs Ofuscated String Solver (FLOSS)** es una herramienta dise√±ada para **identificar y extraer autom√°ticamente cadenas ofuscadas de malware**. Puede ayudarle a determinar las cadenas que los autores de malware quieren ocultar de las herramientas de extracci√≥n de cadenas.

FLOSS tambi√©n se puede utilizar como la utilidad de cadenas para **extraer cadenas legibles por humanos (ASCII y Unicode)**. Puede descargar FLOSS para Windows o Linux desde https://github.com/fireeye/flare-floss.
```
sudo apt install python3-venv python3-full
mkdir ~/miENV
python3.12 -m venv miENV


git clone https://github.com/mandiant/flare-floss.git
cd flare-floss
python setup.py install
```


Otra forma de instalar flare-floss en linux:
```
python3.11 -m venv venv
source venv/bin/activate
pip3.11 install flare-floss
floss program.exe > analisis-floss.txt
```



En el siguiente ejemplo, no s√≥lo se han extraido las cadenas legibles por humanos, sino que tambi√©n decodific√≥ las cadenas ofuscadas y extrajo las cadenas de la pila que la utilidad de cadenas y otras herramientas de extracci√≥n de cadenas no detectaron. El siguiente resultado muestra una referencia a un ejecutable, un archivo de Excel y una clave de registro de ejecuci√≥n:
```
$ chmod +x floss
$ ./floss 5340.exe
FLOSS static ASCII strings
!This program cannot be run in DOS mode.
Rich
.text
`.rdata
@.data
[..removed..]
FLOSS decoded 15 strings
kb71271.log
R6002
- floating point not loaded
\Microsoft
winlogdate.exe
~tasyd3.xls
[....REMOVED....]
FLOSS extracted 13 stack strings
BINARY
ka4a8213.log
afjlfjsskjfslkfjsdlkf
'Clt
~tasyd3.xls
"%s"="%s"
regedit /s %s
[HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Run]
[.....REMOVED......]
```

Si solo est√° interesado en las **cadenas decodificadas/apiladas y desea excluir las cadenas est√°ticas (ASCII y Unicode)** de la salida FLOSS, proporcione el modificador --no-static-strings.

https://www.mandiant.com/resources/blog/automatically-extracting-obfuscated-strings


**An√°lisis de los Resultados:** FLOSS mostrar√° las cadenas ofuscadas que ha logrado identificar y extraer. Estas cadenas pueden incluir direcciones IP, URLs, nombres de dominio, claves de cifrado, y otros datos que el malware utiliza en sus operaciones. Es importante analizar estas cadenas en el contexto del comportamiento general del malware para entender su prop√≥sito y c√≥mo interact√∫a con los sistemas infectados.
- Cadenas ASCII Est√°ticas: Estas son cadenas de texto que se pueden leer directamente en el archivo binario y no est√°n ofuscadas. Por ejemplo, la cadena "!This program cannot be run in DOS mode." es t√≠pica en los archivos ejecutables de Windows y no es indicativa de actividad maliciosa por s√≠ misma.
- Cadenas Decodificadas: FLOSS ha decodificado 15 cadenas que estaban ofuscadas en el archivo. Estas pueden incluir nombres de archivos de registro como "kb71271.log", mensajes de error como "R6002 - floating point not loaded", o referencias a directorios del sistema como "\Microsoft". Estas cadenas pueden ser pistas sobre la funcionalidad del malware, como los archivos que intenta crear o modificar, o errores que maneja.
- Cadenas Extra√≠das de la Pila (Stack Strings): Estas son cadenas que FLOSS ha identificado y extra√≠do de la memoria de la pila durante la ejecuci√≥n del malware. Por ejemplo, "ka4a8213.log" podr√≠a ser otro archivo de registro, y "~tasyd3.xls" podr√≠a ser un archivo que el malware busca o genera. La cadena "%s"="%s" sugiere una operaci√≥n de formato o asignaci√≥n, y "regedit /s %s" indica que el malware podr√≠a estar intentando modificar el registro de Windows de forma silenciosa.
- Cadenas Relacionadas con la Persistencia: La referencia a "[HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Run]" es particularmente significativa, ya que esta ubicaci√≥n del registro se utiliza com√∫nmente para configurar programas que se ejecutan autom√°ticamente al iniciar sesi√≥n en Windows. Esto podr√≠a indicar que el malware intenta establecer persistencia en el sistema infectado.

Al analizar estos resultados, es importante **considerar el contexto y la funcionalidad potencial que las cadenas podr√≠an representar** dentro del malware. Por ejemplo:
- Cadenas de Archivos y Directorios: Pueden indicar los archivos y directorios con los que el malware interact√∫a.
- Mensajes de Error: Pueden revelar las funciones del sistema que el malware intenta utilizar y c√≥mo maneja las condiciones de error.
- Comandos del Sistema: Como "regedit /s %s", pueden sugerir intentos de modificar la configuraci√≥n del sistema para lograr objetivos maliciosos.
- Referencias al Registro de Windows: Pueden indicar intentos de lograr la persistencia o modificar la configuraci√≥n del sistema para beneficio del malware.


-------------------------------------------------
## 5. Identificar las t√©cnicas de ofuscaci√≥n utilizadas para frustrar el an√°lisis: Determining File Obfuscation
Aunque la extracci√≥n de cadenas es una t√©cnica excelente para obtener informaci√≥n valiosa, a menudo los autores de malware ofuscan o blindan su binario de malware. La ofuscaci√≥n es utilizada por los autores de malware para proteger el funcionamiento interno del malware de los investigadores de seguridad, analistas de malware e ingenieros inversos. Estas t√©cnicas de ofuscaci√≥n dificultan la detecci√≥n/analizaci√≥n del binario; extraer las cadenas de tal binario resulta en muy pocas cadenas, y la mayor√≠a de las cadenas est√°n oscurecidas. Los autores de malware a menudo usan programas como Empaquetadores y Encriptadores para ofuscar su archivo con el fin de evadir la detecci√≥n de productos de seguridad tales como antivirus y para impedir el an√°lisis.

### 5.1 Packers and Cryptors
- Los ejecutables tienen lo que se llama un **punto de entrada (ENTRY POINT)**. Cuando se ejecuta, este punto de entrada es simplemente la ubicaci√≥n de las primeras piezas de c√≥digo que se van a ejecutar dentro del archivo, como se ilustra a continuaci√≥n:
  
  ![](capturas/entry-point.png)

- Cuando un ejecutable est√° empaquetado, debe desempaquetarse antes de que se pueda ejecutar cualquier c√≥digo. Debido a esto, los packers cambian el punto de entrada desde la ubicaci√≥n original a lo que se llama el "Unpacking Stub".
  ![](capturas/unpacking-stub.png)

- El "Unpacking Stub" comenzar√° a desempaquetar el ejecutable a su estado original. Una vez que el programa est√© completamente desempaquetado, el punto de entrada se reubicar√° de nuevo a su lugar normal para comenzar a ejecutar el c√≥digo:
  ![](capturas/unpacking-stub-2.png)

- Solo en este punto un analista puede comenzar a entender lo que el ejecutable est√° haciendo, ya que ahora est√° en su forma verdadera y original.

- Un Empaquetador es un programa que toma el ejecutable como entrada y utiliza la compresi√≥n para ofuscar el contenido del ejecutable. Este contenido ofuscado se almacena entonces dentro de la estructura de un nuevo archivo ejecutable; el resultado es un nuevo archivo ejecutable (programa empaquetado) con contenido ofuscado en el disco. Al ejecutar el programa empaquetado, ejecuta una rutina de descompresi√≥n, que extrae el binario original en la memoria durante el tiempo de ejecuci√≥n y desencadena la ejecuci√≥n.

- Un Encriptador es similar a un Empaquetador, pero en lugar de usar compresi√≥n, utiliza encriptaci√≥n para ofuscar el contenido del ejecutable, y el contenido encriptado se almacena en el nuevo archivo ejecutable. Al ejecutar el programa encriptado, ejecuta una rutina de desencriptaci√≥n para extraer el binario original en la memoria y luego desencadena la ejecuci√≥n.

- Formas de saber que un ejecutable est√° empaquetado:
  - El ejecutable puede tener secciones con nombres de ciertos packers como UPX.
  - Uso de Herramientas de An√°lisis de Malware: Herramientas como PEiD (Virustotal detecta malware), Exeinfo PE, RDG Packer Detector, y Die (Detect It Easy) son espec√≠ficamente dise√±adas para identificar empaquetadores, compiladores y protectores utilizados en archivos ejecutables. Estas herramientas analizan el archivo y, bas√°ndose en una base de datos de firmas de empaquetadores conocidos, pueden indicar si el archivo ha sido empaquetado y, en muchos casos, identificar el empaquetador espec√≠fico utilizado.
  - An√°lisis de la Entrop√≠a: Los archivos empaquetados suelen tener una alta entrop√≠a, lo que indica una distribuci√≥n aleatoria de los bytes debido a la compresi√≥n o cifrado. Herramientas de an√°lisis de malware y editores hexadecimales pueden calcular la entrop√≠a de un archivo y, si es inusualmente alta, esto puede ser un indicador de empaquetamiento.  - Inspecci√≥n de la Tabla de Importaciones: Los empaquetadores suelen modificar la tabla de importaciones de un archivo PE (Portable Executable). Al analizar la tabla de importaciones con herramientas como CFF Explorer o PEStudio, se puede observar si muestra un conjunto reducido o inusual de importaciones, lo que puede sugerir que el archivo ha sido empaquetado. 
  - B√∫squeda de Cadenas y Secciones Inusuales: Algunos empaquetadores agregan secciones con nombres inusuales al archivo PE o dejan cadenas dentro del archivo que indican el uso de un empaquetador. La inspecci√≥n manual con editores hexadecimales o el uso de herramientas de an√°lisis que buscan estas caracter√≠sticas pueden revelar indicios de empaquetamiento.
  - An√°lisis Heur√≠stico: Algunas soluciones de seguridad avanzadas utilizan an√°lisis heur√≠sticos para identificar comportamientos t√≠picos de archivos empaquetados, como la ejecuci√≥n de un stub de desempaquetamiento en tiempo de ejecuci√≥n

Para demostrar el concepto de ofuscaci√≥n de archivos, tomemos un ejemplo de una muestra de malware llamada Spybot (no empaquetada); la extracci√≥n de cadenas de Spybot muestra referencias a nombres de ejecutables sospechosos y direcciones IP, como se muestra aqu√≠:

```
$ strings -a spybot.exe
[....removed....]
EDU_Hack.exe
Sitebot.exe
Winamp_Installer.exe
PlanetSide.exe
DreamweaverMX_Crack.exe
FlashFXP_Crack.exe
Postal_2_Crack.exe
Red_Faction_2_No-CD_Crack.exe
Renegade_No-CD_Crack.exe
Generals_No-CD_Crack.exe
Norton_Anti-Virus_2002_Crack.exe
Porn.exe
AVP_Crack.exe
zoneallarm_pro_crack.exe
[...REMOVED...]
209.126.201.22
209.126.201.20
```

UPX, que se encuentra en https://upx.github.io/, es un empaquetador de ejecutables. UPX (Ultimate Packer for eXecutables) es una herramienta de c√≥digo abierto y gratuita dise√±ada para comprimir archivos ejecutables. Su objetivo principal es reducir el tama√±o de los archivos ejecutables (binarios), lo que puede ser √∫til para ahorrar espacio en disco y reducir los tiempos de carga en sistemas con recursos limitados. Empaquetamos y volvemos a comprobar los strings, observando que ya no se muestra mucha informaci√≥n:

```
$ upx -o spybot_packed.exe spybot.exe
Ultimate Packer for eXecutables
Copyright (C) 1996 - 2013
UPX 3.91 Markus Oberhumer, Laszlo Molnar & John Reiser Sep 30th 2013
File size Ratio Format Name
-------------------- ------ ----------- -----------
44576 -> 21536 48.31% win32/pe spybot_packed.exe
Packed 1 file.

$ strings -a spybot_packed.exe
!This program cannot be run in DOS mode.
UPX0
UPX1
.rsrc
3.91
UPX!
t ;t
/t:VU
]^M
9-lh
:A$m
hAgo .
C@@f.
Q*vPCi
%_I;9
PVh29A
[...REMOVED...]
```

UPX is a common packer, and many times you will come across malware samples packed with UPX. In most cases, it is possible to unpack the sample using the -d option. An example command is
```
upx -d -o spybot_unpacked.exe spybot_packed.exe.
```


### 5.2 Detecting File Obfuscation Using Exeinfo PE
La mayor√≠a de los ejecutables leg√≠timos no ofuscan su contenido, pero algunos ejecutables pueden hacerlo para evitar que otros examinen su c√≥digo. Cuando te encuentres con una muestra que est√° empaquetada, hay una alta probabilidad de que sea maliciosa. Para detectar empaquetadores en Windows, puedes usar una herramienta gratuita como Exeinfo PE (http://exeinfo.atwebpages.com/).


Other CLI and GUI tools that can help you with packer detections include TrID (http://mark0.net/soft-trid-e.html), TRIDNet (http://mark0.net/soft-tridnet-e.html), Detect It Easy (http://ntinfo.biz/), RDG Packer Detector (http://www.rdgsoft.net/), packerid.py (https://github.com/sooshie/packerid), and PEiD (http://www.softpedia.com/get/Programming/Packers-Crypters-Protectors/PEiD-updated.shtml).


-------------------------------------------------
## 6. Clasificaci√≥n y comparaci√≥n de muestras de malware: Comparing And Classifying The Malware
Si bien el hash criptogr√°fico (MD5/SHA1/SHA256) es una t√©cnica excelente para detectar muestras id√©nticas, no ayuda a identificar muestras similares. Con frecuencia, los autores de malware cambian aspectos m√≠nimos del malware, lo que cambia completamente el valor del hash. Las siguientes secciones describen algunas de las t√©cnicas que pueden ayudar en comparar y clasificar el binario sospechoso:

### 6.1 Classifying Malware Using Fuzzy Hashing
La comparaci√≥n de archivos mediante el hash difuso (fuzzy hashing) es un excelente m√©todo para buscar similitudes. Usaremos la herramienta ssdeep (http://ssdeep.sourceforge.net) para generar el hash difuso de una muestra. Esta herramienta tambi√©n ayuda a determinar el porcentaje de similitud entre las muestras. Esta t√©cnica es √∫til para comparar un binario sospechoso con las muestras en un repositorio para identificar las muestras que son similares; esto puede ayudar a identificar las muestras que pertenecen a la misma familia de malware o al mismo grupo de actores.

Usaremos ssdeep para calcular y comparar hashes difusos:
```
ssdeep veri.exe
ssdeep,1.1--blocksize:hash:hash,filename 49152:op398U/qCazcQ3iEZgcwwGF0iWC28pUtu6On2spPHlDB:op98USfcy8cwF2bC28pUtsRptDB,"/home/ubuntu/Desktop/veri.exe"
```


El hash difuso, tambi√©n conocido como fuzzy hashing, es una t√©cnica utilizada para **detectar archivos que son similares, pero no id√©nticos, entre s√≠**. Esta t√©cnica contrasta con las funciones de hash criptogr√°ficas tradicionales, que est√°n dise√±adas para producir hashes significativamente diferentes incluso para diferencias menores en los datos de entrada

#### ssdeep y el Hash Difuso
ssdeep es una herramienta que implementa el algoritmo de hashing difuso conocido como Context Triggered Piecewise Hashing (CTPH). Este m√©todo permite identificar archivos que tienen homolog√≠as, es decir, secuencias de bytes id√©nticos en el mismo orden, aunque puedan existir diferencias en el contenido y la longitud de los bytes intermedios

#### Funcionamiento de ssdeep
ssdeep divide el archivo en m√∫ltiples piezas y calcula hashes tradicionales para cada pieza. Luego, combina estos hashes en una sola cadena, lo que permite comparar archivos de manera m√°s flexible que con los hashes criptogr√°ficos. Por ejemplo, si se modifican, insertan o eliminan datos en un archivo, ssdeep a√∫n puede encontrar un grado de similitud con el archivo original.

#### Aplicaciones de ssdeep
ssdeep es ampliamente utilizado en la detecci√≥n de malware y en la identificaci√≥n de archivos similares. Es particularmente √∫til en investigaciones forenses digitales, donde se requiere comparar archivos para identificar versiones modificadas de archivos conocidos. Por ejemplo, si se sospecha que un archivo es una variante de un malware conocido, ssdeep puede ayudar a confirmar o descartar esta sospecha al comparar los hashes difusos.

#### Instalaci√≥n y Uso
ssdeep est√° disponible para su descarga e instalaci√≥n en m√∫ltiples sistemas operativos, incluyendo Windows, Ubuntu, Fedora, Debian, CentOS, Arch Linux y FreeBSD. Para sistemas que no proporcionan un paquete de ssdeep, se puede construir a partir del c√≥digo fuente disponible en GitHub.

#### Comandos B√°sicos de ssdeep
La herramienta ssdeep ofrece una variedad de opciones de l√≠nea de comandos para calcular y comparar hashes difusos.
- -r: Esta opci√≥n permite que ssdeep procese directorios de manera recursiva, es decir, analizar√° todos los archivos en el directorio actual y en todos sus subdirectorios.
- -m: se utiliza para comparar archivos contra un conjunto de hashes conocidos. Determina el porcentaje de similaridad.
- -a: Esta opci√≥n indica a ssdeep que compare cada hash contra todos los dem√°s, lo que es √∫til para identificar archivos similares dentro de un conjunto de datos.
- -p: Esta opci√≥n hace que ssdeep imprima los porcentajes de coincidencia cuando compara hashes. Es √∫til para obtener una medida cuantitativa de cu√°n similares son dos archivos basados en sus hashes difusos.
- -b: Esta opci√≥n activa el modo de salida binaria. En este modo, ssdeep produce una salida en un formato que es m√°s adecuado para el procesamiento por otras herramientas o scripts. Es importante notar que esta opci√≥n puede no ser adecuada para la visualizaci√≥n directa por humanos debido a su naturaleza binaria


### 6.2 Classifying Malware Using Import Hash
La t√©cnica de **Import Hash, o imphash**, es un m√©todo utilizado para clasificar y rastrear malware **bas√°ndose en las importaciones de un archivo ejecutable PE (Portable Executable)**. Este m√©todo se centra en las funciones que el malware llama de otros archivos, generalmente DLLs (Dynamic Link Libraries) que proporcionan funcionalidad al sistema operativo Windows.

El imphash se calcula generando un valor hash a partir de los nombres de las bibliotecas/API y su orden espec√≠fico dentro del ejecutable. Debido a la forma en que se genera la tabla de importaciones de un PE, el imphash resultante puede ser utilizado para identificar muestras de malware relacionadas. Si dos muestras tienen el mismo imphash, es probable que est√©n relacionadas y que hayan sido creadas o utilizadas por el mismo grupo de amenazas.

Mandiant, una compa√±√≠a especializada en seguridad inform√°tica, utiliza el imphash para rastrear las actividades de grupos de amenazas espec√≠ficos a lo largo del tiempo. Por ejemplo, si un grupo de amenazas favorece ciertos backdoors, Mandiant puede seguir la pista de estos backdoors a trav√©s de sus imphashes. Esto permite a los investigadores buscar nuevas muestras similares que el mismo grupo de amenazas podr√≠a haber creado y utilizado.

**El imphash es considerado una forma poderosa de identificar malware relacionado porque el valor del hash tiende a ser relativamente √∫nico. Esto se debe a que el enlazador del compilador genera y construye la Tabla de Direcciones de Importaci√≥n (IAT) basada en el orden espec√≠fico de las llamadas a las API.**

La herramienta pefile, por ejemplo, se puede utilizar para calcular el imphash de un archivo PE. Mandiant ha contribuido con un parche que permite calcular el valor del imphash para un PE dado en pefile. El siguiente es un ejemplo de c√≥digo que utiliza pefile para obtener el imphash de un archivo PE:
```
import pefile
import sys

pe = pefile.PE(sys.argv[1])
print("Import Hash: %s" % pe.get_imphash())
```

Este m√©todo de clasificaci√≥n de malware es √∫til para los investigadores de seguridad y los analistas de malware, ya que les permite correlacionar muestras de malware y rastrear la evoluci√≥n de las amenazas a lo largo del tiempo.


**Nota:** La herramienta pestudio calcula autom√°ticamente el imphash.


### 6.3 Classifying Malware Using Section Hash
La clasificaci√≥n de malware utilizando el hash de secci√≥n, o Section Hash, es una t√©cnica de an√°lisis est√°tico que se centra en las secciones individuales de un archivo ejecutable PE (Portable Executable). Cada secci√≥n de un archivo PE, como .text, .data, .rdata, etc., puede contener diferentes tipos de datos, como c√≥digo ejecutable, recursos y datos de inicializaci√≥n. Al calcular el hash de cada una de estas secciones, los analistas pueden obtener una firma que puede ser utilizada para identificar y clasificar muestras de malware.

El Section Hash es √∫til para identificar variantes de malware que comparten secciones de c√≥digo comunes. Por ejemplo, si un atacante reutiliza un m√≥dulo de c√≥digo espec√≠fico en diferentes variantes de malware, el hash de la secci√≥n correspondiente ser√° el mismo en todas estas variantes. Esto permite a los investigadores agrupar muestras relacionadas y rastrear la evoluci√≥n del malware a lo largo del tiempo.

El an√°lisis de malware con Radare2, por ejemplo, puede incluir la obtenci√≥n de hashes de secciones utilizando comandos espec√≠ficos como "iS" seguido de los algoritmos de hash deseados (md5, sha1, sha256), para obtener informaci√≥n sobre las secciones y sus respectivos hashes.

La clasificaci√≥n basada en Section Hash puede ser complementada con otras t√©cnicas de an√°lisis est√°tico, como el an√°lisis de strings, el an√°lisis de importaciones y exportaciones, y el an√°lisis de metadatos del archivo PE. Estas t√©cnicas proporcionan una visi√≥n m√°s completa del comportamiento potencial del malware y pueden ayudar a identificar caracter√≠sticas √∫nicas de diferentes familias de malware.

Es importante destacar que, aunque el Section Hash es una herramienta valiosa en la clasificaci√≥n de malware, no es infalible. Los atacantes pueden ofuscar o modificar las secciones de un archivo PE para evitar la detecci√≥n, lo que puede hacer que el hash de secci√≥n cambie y, por lo tanto, dificultar la clasificaci√≥n basada en esta t√©cnica. Por esta raz√≥n, el Section Hash se utiliza a menudo en combinaci√≥n con otras t√©cnicas de an√°lisis para mejorar la precisi√≥n en la detecci√≥n y clasificaci√≥n del malware.

Formas de c√°lculo de Section Hash:
- Con la herramienta pestudio.
- Con Python: Usando el m√≥dulo pefile:
  ```
  >>> import pefile
  >>> pe = pefile.PE("5340.exe")
  >>> for section in pe.sections:
  ... print "%s\t%s" % (section.Name, section.get_hash_md5())
  ```

### 6.4 Classifying Malware Using YARA
La creaci√≥n de reglas YARA es fundamental para su eficacia en la clasificaci√≥n de malware. Una regla YARA t√≠picamente consta de una secci√≥n de metadatos, donde se pueden incluir detalles como el nombre de la regla, autor, versi√≥n y cualquier otra informaci√≥n relevante; una secci√≥n de strings, donde se definen las cadenas de texto, binarias o expresiones regulares que se buscan; y una secci√≥n de condiciones, que especifica c√≥mo deben coincidir o relacionarse las strings definidas para que la regla se considere como coincidente.

YARA permite la identificaci√≥n r√°pida de malware conocido y la detecci√≥n de variantes o familias de malware relacionadas mediante la b√∫squeda de patrones espec√≠ficos.

https://yara.readthedocs.io/en/v3.7.0/writingrules.html

#### Crear reglas YARA
Para crear reglas YARA, es necesario seguir una estructura espec√≠fica que consta de tres partes principales: metadatos, strings y condiciones. A continuaci√≥n, se detallan los pasos para escribir reglas YARA efectivas:
- Metadatos: Los metadatos son informaci√≥n descriptiva sobre la regla que no afecta su funcionamiento. Incluyen detalles como el nombre de la regla, autor, versi√≥n y cualquier otra informaci√≥n relevante. Los metadatos son opcionales pero √∫tiles para la organizaci√≥n y documentaci√≥n.
- Strings: Las strings son los patrones de texto, binarios o expresiones regulares que se buscar√°n en los archivos o procesos. Se definen utilizando el s√≠mbolo $, seguido de un identificador. Las strings pueden ser literales, hexadecimales o basadas en expresiones regulares.
- Condiciones: Las condiciones son expresiones l√≥gicas que determinan cu√°ndo se considera que una regla coincide con un archivo o proceso. Las condiciones pueden ser simples, como la presencia de una string, o complejas, utilizando operadores l√≥gicos y cuantificadores.

#### Ejemplo de una Regla YARA B√°sica
```
yara
rule ExampleMalwareDetection
{
    meta:
        author = "Your Name"
        description = "Detects Example Malware"
        version = "1.0"

    strings:
        $a = "malicious string" nocase
        $b = { 6A 40 68 00 30 00 00 } // Hexadecimal pattern
        $c = /md5: [0-9A-F]{32}/ // Regular expression

    condition:
        $a and $b and $c
}
```

#### Pasos para Escribir Reglas YARA:
- Definir Metadatos: Comience con la secci√≥n de metadatos para describir la regla. Aunque opcional, es una buena pr√°ctica incluir metadatos para mantener las reglas organizadas.
- Identificar Strings: Determine las strings que son indicativas del malware o del contenido que desea detectar. Puede utilizar strings literales, patrones hexadecimales o expresiones regulares.
- Establecer Condiciones: Defina las condiciones bajo las cuales se considerar√° que la regla ha encontrado una coincidencia. Puede utilizar operadores l√≥gicos como and, or, y not, as√≠ como cuantificadores como all of them o any of them.
- Probar la Regla: Una vez que haya escrito la regla, pru√©bela con muestras conocidas para asegurarse de que detecta correctamente el malware sin generar falsos positivos.
- Refinar la Regla: Si la regla genera falsos positivos o no detecta todas las variantes del malware, ajuste las strings y las condiciones hasta que la regla sea efectiva y precisa.
- Documentar y Mantener: Documente la regla y mant√©ngala actualizada a medida que surjan nuevas variantes del malware o se descubran nuevos indicadores de compromiso.

Es importante tener en cuenta que escribir reglas YARA efectivas requiere un conocimiento profundo del malware que se est√° detectando y de los patrones que lo caracterizan. Adem√°s, las reglas deben ser lo suficientemente espec√≠ficas para evitar falsos positivos, pero tambi√©n lo suficientemente generales para detectar variantes del malware

https://www.youtube.com/watch?v=RGXQeco_1Zk&t=787s

-----------------------------------------------
-----------------------------------------------
# CHAPTER 3: DYNAMIC ANALYSIS
El an√°lisis din√°mico de malware es un proceso que implica la ejecuci√≥n del malware en un entorno controlado y aislado, conocido como sandbox o m√°quina virtual, para observar su comportamiento y funcionalidad en tiempo real. Este tipo de an√°lisis permite a los investigadores y analistas de seguridad comprender c√≥mo se comporta el malware una vez que se ejecuta en un sistema, identificando las acciones que realiza, como la modificaci√≥n de archivos, la comunicaci√≥n con servidores remotos, la inyecci√≥n de c√≥digo en otros procesos, entre otros comportamientos maliciosos.

Las ventajas del an√°lisis din√°mico incluyen la capacidad de obtener informaci√≥n detallada sobre el comportamiento del malware, lo que permite documentar y entender mejor las amenazas para desarrollar medidas de protecci√≥n m√°s efectivas. Adem√°s, este tipo de an√°lisis puede revelar la presencia de t√©cnicas de evasi√≥n, como la detecci√≥n de entornos virtuales (antisandbox), que el malware puede utilizar para evitar su an√°lisis en entornos controlados.

El an√°lisis din√°mico es complementario al an√°lisis est√°tico, que se enfoca en el examen del c√≥digo fuente del malware sin ejecutarlo, proporcionando una visi√≥n completa del funcionamiento y prop√≥sito del software malicioso. Juntos, el an√°lisis est√°tico y din√°mico ofrecen una metodolog√≠a robusta para el estudio y la clasificaci√≥n de malware, contribuyendo significativamente a la ciberseguridad y la defensa contra amenazas inform√°ticas.

## 1. Lab Environment Overview
Tanto la m√°quina virtual de Linux como la de Windows se configuraron para utilizar el modo de configuraci√≥n de red de solo anfitri√≥n. La m√°quina virtual de Linux estaba preconfigurada con una direcci√≥n IP de 192.168.1.100, y la direcci√≥n IP de la m√°quina virtual de Windows se estableci√≥ en 192.168.1.50. La puerta de enlace predeterminada y el DNS de la m√°quina virtual de Windows se establecieron en la direcci√≥n IP de la m√°quina virtual de Linux (192.168.1.100), de modo que todo el tr√°fico de red de Windows se enrutara a trav√©s de la m√°quina virtual de Linux. La m√°quina virtual de Windows se utilizar√° para ejecutar la muestra de malware durante el an√°lisis, y la m√°quina virtual de Linux se utilizar√° para monitorear el tr√°fico de red y se configurar√° para simular servicios de internet (como DNS, HTTP, y otros) para proporcionar la respuesta adecuada cuando el malware solicite estos servicios.

## 2. System And Network Monitoring
El objetivo de un an√°lisi din√°mico es recopilar datos en tiempo real relacionados con el comportamiento del malware y su impacto en el sistema. Diferentes tipos de monitoreo realizados durante el an√°lisis din√°mico:
- Monitoreo de procesos: Implica monitorear la actividad del proceso y examinar las propiedades del proceso resultante durante la ejecuci√≥n del malware.
- Monitoreo del sistema de archivos: Incluye monitorear la actividad del sistema de archivos en tiempo real durante la ejecuci√≥n del malware.
- Monitoreo del registro: Implica monitorear las claves del registro a las que se accede/modifica y los datos del registro que son le√≠dos/escritos por el binario malicioso.
- Monitoreo de la red: Involucra monitorear el tr√°fico en vivo hacia y desde el sistema durante la ejecuci√≥n del malware.


## 3. Dynamic Analysis (Monitoring) Tools

### 3.1 Process Inspection with Process Hacker
Process Hacker (http://processhacker.sourceforge.net/) is an open source, multipurpose tool that helps in monitoring system resources. It is a great tool for examining the
processes running on the system and to inspect the process attributes. It can also be used to explore services, network connections, disk activity, and so on.

VirusTotal lo detecta como malware.

### 3.2 Determining System Interaction with Process Monitor
Process Monitor (https://technet.microsoft.com/en-us/sysinternals/processmonitor.aspx) is an advanced monitoring tool that shows the real-time interaction of the processes
with the filesystem, registry, and process/thread activity.

### 3.3 Logging System Activities Using Noriben
Even though Process Monitor is a great tool to monitor a malware's interaction with the system, it can be very noisy, and manual effort is required to filter the noise. Noriben
(https://github.com/Rurik/Noriben) is a Python script that works in conjunction with Process Monitor and helps in collecting, analyzing, and reporting runtime indicators of the
malware. The advantage of using Noriben is that it comes with pre-defined filters that assist in reducing noise and allow you to focus on the malware-related events.

### 3.4 Capturing Network Traffic With Wireshark
When the malware is executed, you will want to capture the network traffic generated as a result of running the malware; this will help you understand the communication channel
used by the malware and will also help in determining network-based indicators. 

### 3.5 Simulating Services with INetSim
INetSim is a free Linux-based software suite for simulating standard internet services (such as DNS, HTTP/HTTPS, and so on).

Another alternative to INetSim is FakeNet-NG (https://github.com/fireeye/flare-fakenet-ng), which allows you to intercept and redirect all or specific network traffic by simulating network services.


## 4. Dynamic Analysis Steps
Durante el an√°lisis din√°mico (an√°lisis del comportamiento), seguriemos una secuencia de pasos para determinar la funcionalidad del malware. La siguiente lista describe los pasos involucrados en el an√°lisis din√°mico:
- Revertir a la instant√°nea limpia: Esto incluye volver tus m√°quinas virtuales a un estado limpio.
- Ejecutar las herramientas de monitoreo/an√°lisis din√°mico: En este paso, ejecutar√°s las herramientas de monitoreo antes de ejecutar la muestra de malware. Para aprovechar al m√°ximo las herramientas de monitoreo cubiertas en la secci√≥n anterior, necesitas ejecutarlas con privilegios de administrador.
- Ejecutar la muestra de malware: En este paso, ejecutar√°s la muestra de malware con privilegios de administrador.
- Detener las herramientas de monitoreo: Esto implica terminar las herramientas de monitoreo despu√©s de que el binario de malware se haya ejecutado durante un tiempo especificado.
- Analizar los resultados: Esto implica recopilar los datos/informes de las herramientas de monitoreo y analizarlos para determinar el comportamiento y la funcionalidad del malware.


## 5. Putting it All Together: Analyzing a Malware Executable
Realizaremos tanto an√°lisis est√°tico como din√°mico para determinar las caracter√≠sticas y el comportamiento de una muestra de malware.


## 6. Dynamic-Link Library (DLL) Analysis



# Examples
## Emotet
https://assets.tryhackme.com/additional/cmn-malware/int-mal-sample.pdf

---------------------------------------------
---------------------------------------------
## Usar PEStudio (Interfaz gr√°fica)
- Descarga PEStudio (gratis):üîó https://www.winitor.com/
- Abre el archivo sospechoso (.exe, .dll) desde PEStudio.
- Ve a la pesta√±a: Sections.
- Observa los siguientes campos:
  - Nombre de la secci√≥n: .text, .data, .rsrc, etc.
  - Entropy: si es muy alta (> 7.0), puede indicar cifrado u ofuscaci√≥n.
  - RVA / Offset / Tama√±o virtual: diferencias notables pueden ser sospechosas.

Permissions: busca secciones con Executable + Writable, lo cual no es normal y puede indicar shellcode.

üìå PEStudio tambi√©n marcar√° en rojo o naranja las secciones que considera sospechosas autom√°ticamente.


## Script en Python con pefile
Este script analiza las secciones y te muestra:
- Nombres
- Tama√±os
- Entrop√≠a
- Permisos
```
pip install pefile
import pefile
import math

def get_entropy(data):
    if not data:
        return 0.0
    entropy = 0
    for x in range(256):
        p_x = float(data.count(bytes([x]))) / len(data)
        if p_x > 0:
            entropy -= p_x * math.log2(p_x)
    return entropy

pe = pefile.PE("malware.exe")

print("Nombre | Tama√±o | Entrop√≠a | Permisos")
print("-" * 50)

for section in pe.sections:
    name = section.Name.strip().decode('utf-8', errors='replace')
    size = section.SizeOfRawData
    entropy = get_entropy(section.get_data())
    perms = section.Characteristics

    exec_flag = bool(perms & 0x20000000)
    write_flag = bool(perms & 0x80000000)
    read_flag = bool(perms & 0x40000000)

    flags = []
    if read_flag: flags.append("R")
    if write_flag: flags.append("W")
    if exec_flag: flags.append("X")

    print(f"{name:7} | {size:6} | {entropy:.2f}    | {' '.join(flags)}")

    # Posible anomal√≠a
    if entropy > 7.0:
        print(f"‚ö†Ô∏è  Alta entrop√≠a en {name}")
    if exec_flag and write_flag:
        print(f"üö®  Secci√≥n ejecutable y escribible: {name}")

```

Resultado t√≠pico:
```
Nombre | Tama√±o | Entrop√≠a | Permisos
-----------------------------------------
.text   | 20480  | 6.35    | R X
.data   | 8192   | 5.22    | R W
.rsrc   | 10240  | 7.85    | R
‚ö†Ô∏è  Alta entrop√≠a en .rsrc
```

## Script en Python para analizar secciones PE
```
import pefile
import math
import pandas as pd

def get_entropy(data):
    if not data:
        return 0.0
    entropy = 0
    for x in range(256):
        p_x = float(data.count(bytes([x]))) / len(data)
        if p_x > 0:
            entropy -= p_x * math.log2(p_x)
    return entropy

# Ruta del archivo PE a analizar
file_path = "malware.exe"  # Cambia esto por el nombre de tu archivo

pe = pefile.PE(file_path)
section_data = []

for section in pe.sections:
    name = section.Name.strip().decode('utf-8', errors='replace')
    size = section.SizeOfRawData
    entropy = get_entropy(section.get_data())
    perms = section.Characteristics

    exec_flag = bool(perms & 0x20000000)
    write_flag = bool(perms & 0x80000000)
    read_flag = bool(perms & 0x40000000)

    flags = []
    if read_flag: flags.append("R")
    if write_flag: flags.append("W")
    if exec_flag: flags.append("X")

    section_data.append({
        "Secci√≥n": name,
        "Tama√±o (bytes)": size,
        "Entrop√≠a": round(entropy, 2),
        "Permisos": " ".join(flags),
        "Alta entrop√≠a": entropy > 7.0,
        "RWX (riesgo)": exec_flag and write_flag
    })

# Exportar a CSV
df = pd.DataFrame(section_data)
df.to_csv("resultado_secciones.csv", index=False)

print("‚úÖ An√°lisis completado. Revisa 'resultado_secciones.csv'")
```

üß∞Requisitos. Es necesario tener estos m√≥dulos instalados:
```
pip install pefile pandas
```

Este script analizar√° las secciones, calcular√° entrop√≠a y marcar√° secciones sospechosas (como aquellas con permisos de ejecuci√≥n y escritura o entrop√≠a alta), y nos exportar√° todo a un archivo resultado_secciones.csv que podr√°s abrir en Excel o cualquier visor de hojas de c√°lculo.



----------------------------------------------
----------------------------------------------
## Enlaces de inter√©s

https://tutorials.ophion.feralhosting.com/Tutorials/Malware%20Analysis/UD-Reverse-Engineering-And-Malware-Analysis-Fundamentals/

https://elhacker.info/manuales/An%c3%a1lisis%20de%20malware/

https://elhacker.info/manuales/An%C3%A1lisis%20de%20malware/Learning%20Malware%20Analysis_%20Explore%20the%20concepts,%20tools,%20and%20techniques%20to%20analyze%20and%20investigate%20Windows%20malware%20(%20PDFDrive.com%20).pdf

https://www.wolf.university/masteringmalwareanalysis/ebook/masteringmalwareanalysis.pdf

https://www.wolf.university/cybersecuritythreatsmalwaretrendsandstrategies/ebook/cybersecuritythreatsmalwaretrendsandstrategies.pdf

https://elhacker.info/manuales/An%c3%a1lisis%20de%20malware/Practical_Malware_Analysis.pdf


https://elhacker.info/manuales/An%c3%a1lisis%20de%20malware/Windows%20Malware%20Analysis%20Essentials_%20Master%20the%20fundamentals%20of%20malware%20analysis%20for%20the%20Windows%20platform%20and%20enhance%20your%20anti-malware%20skill%20set%20(%20PDFDrive.com%20).pdf

https://www.wolf.university/ghidrasoftwarereverseengineeringforbeginners/ebook/ghidrasoftwarereverseengineeringforbeginners.pdf

https://elhacker.info/manuales/An%c3%a1lisis%20de%20malware/intro-reverseeng.pdf


https://github.com/Neo23x0/signature-base/tree/master/yara


https://github.com/baynam1995/MalwareAnalysiBook/blob/master/Learning.Malware.Analysis.Techniques.Investigate.pdf

https://elhacker.info/manuales/Virus/Rootkits%20and%20Bootkits_%20Reversing%20Modern%20Malware%20and%20Next%20Generation%20Threats%20Early%20Access.pdf


https://ftp.idu.ac.id/wp-content/uploads/ebook/tdg/MILITARY%20REFERENCE%20AND%20REVERSE%20ENGINEERING/Mastering%20Reverse%20Engineering%20Re-engineer%20your%20ethical%20hacking%20skills%20by%20Reginald%20Wong%20(z-lib.org).pdf

https://ccdcoe.org/uploads/2020/07/Malware_Reverse_Engineering_Handbook.pdf

https://github.com/Dump-GUY/Malware-analysis-and-Reverse-engineering

https://github.com/gabimarti/ingenieria_inversa_a_partir_del_codigo_fuente/tree/master


Binary Ninja is an interactive decompiler, disassembler, debugger, and binary analysis platform built by reverse engineers, for reverse engineers: https://binary.ninja/


https://rada.re/n/
