
# Ejercicio 1


## PISTAS
- El ensamblador es x86 32 bits.
- Comenzar desensamblando el código (ajustad la sintáxis de x86 a vuestro gusto: Intel o AT&T).
- Comenzad por ‘main’, es el punto de entrada de todos los programas, es fácil localizarlo.
- ¿Qué va haciendo ‘main’? ¿Se están cumpliendo todas las condiciones que inspecciona el programa?
- Además de ‘main’ el programa contiene otra función, el resto son llamadas a funciones externas.
- Podéis usad todas las herramientas que queráis, pero de nuevo, se resuelve con un buen desensamblador y estudiando el código parte a parte. Es decir, analizando.


## Tarea 1 
Descubrid a través de la lectura del código de la función ‘main’ desensamblada como ejecutar el programa.

Es decir, NO ES NECESARIO MANIPULAR EL PROGRAMA. Simplemente entendiendo como funciona ‘main’ es posible adivinar como evadir las protecciones y ejecutar el programa.

Se pide:
- Detallad y explicad mostrando el código ensamblador cuales son las condiciones para que el programa se ejecute.
- Demostrad (mediante capturas de pantalla) la ejecución del programa.

### ¿Qué va haciendo ‘main’?

### ¿Se están cumpliendo todas las condiciones que inspecciona el programa?

En ese main solo hay 4 condiciones importantes, en este orden, y si alguna falla se hace exit(-1) inmediatamente. Así que si llegamos a ejecutar la instrucción `puts(rot13(argv[2]))`, es que todas se han cumplido.
Las condiciones son:
- Número de argumentos: `argc` debe ser igual a 3:
  ```
  0001131b 89 ce           MOV   ESI,ECX          ; ESI = puntero a argc/argv
  0001131d 83 3e 03        CMP   dword ptr [ESI],0x3
  00011320 74 0a           JZ    LAB_0001132c     ; si argc == 3 -> OK
  00011322 83 ec 0c        SUB   ESP,0xc
  00011325 6a ff           PUSH  -0x1
  00011327 e8 54 fd ff ff  CALL  exit             ; si no, exit(-1)
  ```
  Es decir, para que se ejecute el programa, tenemos que pasar 3 argumentos: `argv[0] = programa`, `argv[1]` y `argv[2])`.

- Primer argumento numérico = 1729: `argv[1]` convertido a entero debe ser 1729:
  ```
  LAB_0001132c:
  0001132c 8b 46 04        MOV  EAX,dword ptr [ESI + 4]  ; EAX = *(ESI+4) = argv
  0001132f 83 c0 04        ADD  EAX,0x4                  ; EAX = &argv[1]
  00011332 8b 00           MOV  EAX,dword ptr [EAX]      ; EAX = argv[1]
  00011334 83 ec 0c        SUB  ESP,0xc
  00011337 50              PUSH EAX                      ; push argv[1]
  00011338 e8 73 fd ff ff  CALL atoi                     ; atoi(argv[1])
  0001133d 83 c4 10        ADD  ESP,0x10
  00011340 ba c1 06 00 00  MOV  EDX,0x6c1                ; 0x6c1 = 1729
  00011345 39 d0           CMP  EAX,EDX                  ; atoi(argv[1]) ?= 1729
  00011347 74 0a           JZ   LAB_00011353             ; si es igual -> OK
  00011349 83 ec 0c        SUB  ESP,0xc
  0001134c 6a ff           PUSH -0x1
  0001134e e8 2d fd ff ff  CALL exit                     ; si no, exit(-1)
  ```

- Debe existir una variable de entorno concreta:
  ```
  LAB_00011353:
  00011353 83 ec 0c        SUB  ESP,0xc
  00011356 8d 83 2b e0 ff ff  LEA EAX,[EBX + 0xffffe02b] ; EAX = &DAT_0001202b
                                                         ; (nombre de la variable de entorno, empieza por 'K')
  0001135c 50              PUSH EAX                      ; push nombre
  0001135d e8 ee fc ff ff  CALL getenv                  ; getenv(nombre)
  00011362 83 c4 10        ADD  ESP,0x10
  00011365 89 45 e4        MOV  [EBP + local_24],EAX    ; guardar retorno de getenv
  00011368 83 7d e4 00     CMP  dword ptr [EBP + local_24],0x0
  0001136c 75 0a           JNZ  LAB_00011378            ; si != NULL -> OK
  0001136e 83 ec 0c        SUB  ESP,0xc
  00011371 6a ff           PUSH -0x1
  00011373 e8 08 fd ff ff  CALL exit                    ; si NULL, exit(-1)
  ```
  
  Cadena en DAT_0001202b:
  ```
  DAT_0001202b
  0001202b 4b  K
  0001202c 45  E
  0001202d 59  Y
  0001202e 00  \0
  ```
  La cadena en DAT_0001202b es: "KEY".

  La llamada de main:
  ```
  00011356 8d 83 2b e0 ff ff  LEA EAX,[EBX + 0xffffe02b] ; → "KEY"
  0001135c 50                 PUSH EAX
  0001135d e8 ee fc ff ff     CALL getenv                 ; getenv("KEY")
  ```
  Lo que hace exactamente es: `char *env = getenv("KEY");`. Debe existir una variable de entorno KEY definida y correcta. Con un valor determinado que se explica justo en el siguiente punto:


- Esa variable de entorno debe valer exactamente `HOLAKASE`:
  ```
  LAB_00011378:
  00011378 8b 83 38 00 00 00  MOV EAX,dword ptr [EBX + 0x38] ; EAX = envkey = 0x12008
                                ; en 0x12008 está la cadena "HOLAKASE"
  0001137e 83 ec 08           SUB ESP,0x8
  00011381 ff 75 e4           PUSH dword ptr [EBP + local_24] ; push env
  00011384 50                 PUSH EAX                        ; push "HOLAKASE"
  00011385 e8 a6 fc ff ff     CALL strcmp                     ; strcmp("HOLAKASE", env)
  0001138a 83 c4 10           ADD  ESP,0x10
  0001138d 85 c0              TEST EAX,EAX
  0001138f 74 0a              JZ   LAB_0001139b               ; si devuelve 0 -> OK
  00011391 83 ec 0c           SUB  ESP,0xc
  00011394 6a ff              PUSH -0x1
  00011396 e8 e5 fc ff ff     CALL exit                       ; si != 0, exit(-1)
  ```

**<mark>Si todo lo anterior pasa: `rot13(argv[2])` y lo imprime:</mark>**
```
LAB_0001139b:
0001139b 8b 46 04        MOV  EAX,dword ptr [ESI + 4]  ; EAX = argv
0001139e 83 c0 08        ADD  EAX,0x8                  ; &argv[2]
000113a1 8b 00           MOV  EAX,dword ptr [EAX]      ; EAX = argv[2]
000113a3 83 ec 0c        SUB  ESP,0xc
000113a6 50              PUSH EAX                      ; push argv[2]
000113a7 e8 61 fe ff ff  CALL rot13                   ; rot13(argv[2])
000113ac 83 c4 10        ADD  ESP,0x10
000113af 83 ec 0c        SUB  ESP,0xc
000113b2 50              PUSH EAX                      ; resultado de rot13
000113b3 e8 b8 fc ff ff  CALL puts                    ; puts(rot13(argv[2]))
```


**Resumen en C:**
```c
int main(int argc, char **argv) {
    if (argc != 3)
        exit(-1);

    if (atoi(argv[1]) != 1729)
        exit(-1);

    char *env = getenv(NOMBRE_ENV);   // NOMBRE_ENV = cadena en DAT_0001202b = KEY
    if (env == NULL)
        exit(-1);

    if (strcmp("HOLAKASE", env) != 0)
        exit(-1);

    char *out = rot13(argv[2]);
    puts(out);

    return 0;
}

```

## Cómo ejecutar el programa (evadir las “protecciones”)
Para que el programa se ejecute, es decir, llegar a `rot13 + puts`:  
**1. Creamos una variable de entorno llamada Key y su valor = HOLAKASE:**
```
$ export KEY=HOLAKASE
```
donde:
- KEY es la variable de entorno que exige el programa.

**2. Ejecutamos el programa con 2 argumentos:**
```
$ ./programa 1729 HOLA
UBYN
```
donde:
- 1729 cumple la comparación con 0x6c1.
- HOLA es argv[2], al que se aplica ROT13 →
- UBYN, que es lo que se imprime.


## Tarea 2
Detallad que hace el programa realmente.
Se pide:
- El programa, además de “main”, solo tiene una única función. Encontradla y explicad que hace y como lo hace esta función mostrando el código ensamblador correspondiente.



# Ejercicio 2
Para este ejercicio emplearemos el código fuente del ransomware Babuk, el cual NO DEBEIS COMPILAR NI MUCHO MENOS EJECUTAR.

Babuk es un ransomware que tuvo un significativo auge a comienzos de 2021 y cuyo código fue liberado de forma súbita por sus creadores. Este malware es multiplataforma, existiendo versiones para Linux, Windows, routers y varios dispositivos IoT. Su código está escrito en los lenguajes Go y C.

El código fuente está disponible en el siguiente repositorio: https://github.com/Hildaboo/BabukRansomwareSourceCode

## Tarea 1
Una de las características del malware es que ejecuta una rutina o función que detiene ciertos procesos del sistema para evitar su detección por parte de estos. En otras ocaciones suele detectar la presencia de herramientas de análisis y detiene su propia ejecución o la camufla para evitar ser
analizada.

Esta tarea consiste en la localización de la función (ojo, no donde esta es llamada) que detiene los procesos en la versión para sistemas Windows del malware Babuk.

Es decir:
- Localizad el código de la función (de nuevo, NO DONDE ES LLAMADA).
- Realizad un análisis de código de la función.
- Enumerar los procesos que tiene en cuenta esta función para que sean detenenidos.

Documentad profusamente el proceso que habéis realizado (capturas de pantalla, evidencias). Cuanto más detallada (en calidad) esté hecho el análisis mayor será la puntuación.

## Tarea 2
Aquí (https://github.com/Hildaboo/BabukRansomwareSourceCode/blob/main/nas/enc/main.go#L810), se encuentra la función “main” del código del cifrador escrito en Go de la versión para dispositivos NAS de Babuk.

Esa función representa el punto de entrada del ejecutable. Dicho ejecutable es el que utilizan los cibercriminales para cifrar un sistema. Es decir, explotan un sistema, filtran el ejecutable y este se encarga de ir cifrando todos los archivos de la víctima en ese sistema.

Comentad el funcionamiento de la función referenciada con todo el detalle posible. Si no entendéis algunas partes saltadlas y proseguid o al menos comentad lo que creeis que es.

Código: https://github.com/Hildaboo/BabukRansomwareSourceCode/blob/main/nas/enc/main.go#L810
