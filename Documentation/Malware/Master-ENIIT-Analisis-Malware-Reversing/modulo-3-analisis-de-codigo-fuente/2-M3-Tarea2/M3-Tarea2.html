<!DOCTYPE html>
<html>
<head>
<title>M3-Tarea2.md</title>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">

<style>
/* https://github.com/microsoft/vscode/blob/master/extensions/markdown-language-features/media/markdown.css */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

body {
	font-family: var(--vscode-markdown-font-family, -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif);
	font-size: var(--vscode-markdown-font-size, 14px);
	padding: 0 26px;
	line-height: var(--vscode-markdown-line-height, 22px);
	word-wrap: break-word;
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}

body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-light.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-dark.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

.vscode-high-contrast.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

img {
	max-width: 100%;
	max-height: 100%;
}

a {
	text-decoration: none;
}

a:hover {
	text-decoration: underline;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom-width: 1px;
	border-bottom-style: solid;
}

h1, h2, h3 {
	font-weight: normal;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left-width: 5px;
	border-left-style: solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-size: 1em;
	line-height: 1.357em;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 16px;
	border-radius: 3px;
	overflow: auto;
}

pre code {
	color: var(--vscode-editor-foreground);
	tab-size: 4;
}

/** Theming */

.vscode-light pre {
	background-color: rgba(220, 220, 220, 0.4);
}

.vscode-dark pre {
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre {
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}

</style>

<style>
/* Tomorrow Theme */
/* http://jmblog.github.com/color-themes-for-google-code-highlightjs */
/* Original theme - https://github.com/chriskempson/tomorrow-theme */

/* Tomorrow Comment */
.hljs-comment,
.hljs-quote {
	color: #8e908c;
}

/* Tomorrow Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-deletion {
	color: #c82829;
}

/* Tomorrow Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-meta,
.hljs-link {
	color: #f5871f;
}

/* Tomorrow Yellow */
.hljs-attribute {
	color: #eab700;
}

/* Tomorrow Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
	color: #718c00;
}

/* Tomorrow Blue */
.hljs-title,
.hljs-section {
	color: #4271ae;
}

/* Tomorrow Purple */
.hljs-keyword,
.hljs-selector-tag {
	color: #8959a8;
}

.hljs {
	display: block;
	overflow-x: auto;
	color: #4d4d4c;
	padding: 0.5em;
}

.hljs-emphasis {
	font-style: italic;
}

.hljs-strong {
	font-weight: bold;
}
</style>

<style>
/*
 * Markdown PDF CSS
 */

 body {
	font-family: -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif, "Meiryo";
	padding: 0 12px;
}

pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	border-radius: 3px;
	overflow-x: auto;
	white-space: pre-wrap;
	overflow-wrap: break-word;
}

pre:not(.hljs) {
	padding: 23px;
	line-height: 19px;
}

blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.emoji {
	height: 1.4em;
}

code {
	font-size: 14px;
	line-height: 19px;
}

/* for inline code */
:not(pre):not(.hljs) > code {
	color: #C9AE75; /* Change the old color so it seems less like an error */
	font-size: inherit;
}

/* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
.page {
	page-break-after: always;
}

</style>

<script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script>
</head>
<body>
  <script>
    mermaid.initialize({
      startOnLoad: true,
      theme: document.body.classList.contains('vscode-dark') || document.body.classList.contains('vscode-high-contrast')
          ? 'dark'
          : 'default'
    });
  </script>
<p><img src="capturas/portada-tarea2-modulo3.png" alt="Portada"></p>
<div style="page-break-before: always;"></div>
<ul>
<li><a href="#ejercicio-1"><strong>Ejercicio 1</strong></a>
<ul>
<li><a href="#pistas"><strong>Pistas</strong></a></li>
<li><a href="#tarea-1-ejercicio-1"><strong>Tarea 1. Ejercicio 1</strong></a>
<ul>
<li><a href="#el-documento-del-ejercicio"><strong>El documento del ejercicio</strong></a></li>
<li><a href="#ajuste-de-la-sint%C3%A1xis-de-x86-intel-o-att"><strong>Ajuste de la sintáxis de x86: Intel o AT&amp;T</strong></a></li>
<li><a href="#lo-que-va-haciendo-la-funci%C3%B3n-main"><strong>Lo que va haciendo la función main</strong></a>
<ul>
<li><a href="#1-variables"><strong>1. Variables:</strong></a></li>
<li><a href="#3-c%C3%B3mo-accede-el-programa-a-sus-datos-globales"><strong>3. Cómo accede el programa a sus datos globales</strong></a></li>
<li><a href="#4-primera-protecci%C3%B3n-el-n%C3%BAmero-de-argumentos"><strong>4. Primera Protección: El número de argumentos</strong></a></li>
<li><a href="#5-segunda-protecci%C3%B3n-el-primer-argumento-del-usuario-debe-ser-1729"><strong>5. Segunda Protección: El primer argumento del usuario debe ser 1729</strong></a></li>
<li><a href="#6-tercera-protecci%C3%B3n-la-variable-de-entorno"><strong>6. Tercera Protección: La variable de entorno</strong></a></li>
<li><a href="#7-cuarta-protecci%C3%B3n-holakase"><strong>7. Cuarta Protección: HOLAKASE</strong></a></li>
<li><a href="#8-finalizaci%C3%B3n-del-programa"><strong>8. Finalización del Programa</strong></a></li>
<li><a href="#9-ep%C3%ADlogo-de-la-funci%C3%B3n-y-restauraci%C3%B3n-de-la-pila-original"><strong>9. Epílogo de la función y restauración de la pila original</strong></a></li>
<li><a href="#resumen-de-la-funci%C3%B3n-main-escrita-en-c"><strong>Resumen de la función main escrita en C</strong></a></li>
</ul>
</li>
<li><a href="#c%C3%B3mo-ejecutar-el-programa"><strong>Cómo ejecutar el programa</strong></a>
<ul>
<li><a href="#la-variable-de-entorno"><strong>La variable de entorno</strong></a></li>
<li><a href="#ejecuci%C3%B3n-del-programa-con-sus-argumentos"><strong>Ejecución del programa con sus argumentos</strong></a></li>
<li><a href="#ejecutando-el-programa-con-gdb"><strong>Ejecutando el programa con gdb</strong></a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#tarea-2-ejercicio-1"><strong>Tarea 2. Ejercicio 1</strong></a>
<ul>
<li><a href="#identificar-las-funciones-de-usuario"><strong>Identificar las Funciones de Usuario</strong></a></li>
<li><a href="#las-2-funciones-de-usuario"><strong>Las 2 Funciones de usuario</strong></a>
<ul>
<li><a href="#1-writetofile"><strong>1. writetofile</strong></a></li>
<li><a href="#2-rot13"><strong>2. rot13</strong></a>
<ul>
<li><a href="#encabezado-de-funci%C3%B3n-rot13"><strong>Encabezado de función rot13</strong></a></li>
<li><a href="#pr%C3%B3logo-de-la-funcion-rot13"><strong>Prólogo de la funcion rot13</strong></a></li>
<li><a href="#c%C3%B3mo-accede-el-programa-a-sus-datos-globales"><strong>Cómo accede el programa a sus datos globales</strong></a></li>
<li><a href="#comprobaci%C3%B3n-inicial-y-una-salida-temprana-de-la-funci%C3%B3n"><strong>Comprobación inicial y una salida temprana de la función</strong></a></li>
<li><a href="#preparaci%C3%B3n-de-llamada-a-strlen-e-invocaci%C3%B3n-para-obtener-la-longitud-del-texto-de-entrada"><strong>Preparación de llamada a strlen e invocación para obtener la longitud del texto de entrada</strong></a></li>
<li><a href="#gesti%C3%B3n-de-la-pila-tras-strlen-y-luego-reserva-memoria-din%C3%A1mica-con-malloc-usando-esa-longitud"><strong>Gestión de la pila tras <code>strlen</code> y luego reserva memoria dinámica con <code>malloc</code> usando esa longitud</strong></a></li>
<li><a href="#gesti%C3%B3n-del-resultado-de-malloc-comprobaci%C3%B3n-de-errores-y-si-todo-va-bien-copia-la-cadena-original-al-nuevo-buffer"><strong>Gestión del resultado de malloc. Comprobación de errores y, si todo va bien, copia la cadena original al nuevo buffer</strong></a></li>
<li><a href="#preparaci%C3%B3n-simple-de-variables-y-salto-al-inicio-de-un-bucle"><strong>Preparación simple de variables y salto al inicio de un bucle</strong></a></li>
<li><a href="#bucle-sobre-la-cadena"><strong>Bucle sobre la cadena</strong></a></li>
<li><a href="#la-l%C3%B3gica-del-algoritmo-rot13"><strong>La lógica del Algoritmo ROT13</strong></a></li>
<li><a href="#operaci%C3%B3n-de-la-resta-necesaria-para-el-cifrado--descifrado"><strong>Operación de la resta necesaria para el cifrado / descifrado</strong></a></li>
<li><a href="#lee-un-car%C3%A1cter"><strong>Lee un carácter</strong></a></li>
<li><a href="#avance-y-condici%C3%B3n-del-bucle-que-recorre-la-cadena-car%C3%A1cter-a-car%C3%A1cter"><strong>Avance y condición del bucle que recorre la cadena carácter a carácter</strong></a></li>
<li><a href="#ep%C3%ADlogo-de-la-funci%C3%B3n-rot13"><strong>Epílogo de la función rot13</strong></a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#nota-curiosa-aplicamos-reglas-capa-al-ejercicio"><strong>Nota curiosa: Aplicamos Reglas Capa al ejercicio</strong></a></li>
</ul>
</li>
<li><a href="#ejercicio-2"><strong>Ejercicio 2</strong></a>
<ul>
<li><a href="#tarea-1-ejercicio-2"><strong>Tarea 1. Ejercicio 2</strong></a>
<ul>
<li><a href="#crear-una-bd-simb%C3%B3lica-con-global"><strong>Crear una BD simbólica con Global</strong></a></li>
<li><a href="#mostrar-un-recuento-de-entradas-en-la-base-de-datos-de-global"><strong>Mostrar un recuento de entradas en la base de datos de Global</strong></a></li>
<li><a href="#localizar-el-c%C3%B3digo-de-la-funci%C3%B3n"><strong>Localizar el código de la función</strong></a></li>
<li><a href="#ver-todas-las-referencias-a-la-funci%C3%B3n-stop-processes"><strong>Ver todas las referencias a la función stop processes</strong></a></li>
<li><a href="#an%C3%A1lisis-de-la-funci%C3%B3n"><strong>Análisis de la función</strong></a></li>
<li><a href="#apis-de-windows-que-usa-esta-funci%C3%B3n"><strong>APIs de Windows que usa esta función</strong></a></li>
<li><a href="#l%C3%B3gica-de-esta-funci%C3%B3n"><strong>Lógica de esta función</strong></a></li>
<li><a href="#enumeraci%C3%B3n-de-los-procesos-que-tiene-en-cuenta-esta-funci%C3%B3n"><strong>Enumeración de los procesos que tiene en cuenta esta función</strong></a></li>
</ul>
</li>
<li><a href="#tarea-2-ejercicio-2"><strong>Tarea 2. Ejercicio 2</strong></a>
<ul>
<li><a href="#entendiendo-qu%C3%A9-pide-el-ejercicio"><strong>Entendiendo qué pide el ejercicio</strong></a></li>
<li><a href="#entendiendo-que-es-goroutine"><strong>Entendiendo que es Goroutine</strong></a></li>
<li><a href="#variables-y-estado-inicial-para-la-nota"><strong>Variables y estado inicial para la nota</strong></a></li>
<li><a href="#configuraci%C3%B3n-y-estado-inicial"><strong>Configuración y estado inicial</strong></a></li>
<li><a href="#los-argumentos-flagsargs"><strong>Los Argumentos (Flags/Args)</strong></a></li>
<li><a href="#prepara-sincronizaci%C3%B3n-de-goroutines"><strong>Prepara sincronización de goroutines</strong></a></li>
<li><a href="#exclusi%C3%B3n-de-ciertos-directorios-y-la-nota"><strong>Exclusión de ciertos directorios y la Nota</strong></a></li>
<li><a href="#cierre-del-recorrido-y-sincronizaci%C3%B3n-final"><strong>Cierre del recorrido y sincronización final</strong></a></li>
<li><a href="#resumen-del-modelo-de-concurrencia"><strong>Resumen del Modelo de Concurrencia</strong></a></li>
<li><a href="#resumen-de-la-l%C3%B3gica-de-exclusi%C3%B3n"><strong>Resumen de la Lógica de Exclusión</strong></a></li>
<li><a href="#resumen-de-las-acciones-del-sistema"><strong>Resumen de las Acciones del Sistema</strong></a></li>
<li><a href="#resumen-de-la-inicializaci%C3%B3n-criptogr%C3%A1fica"><strong>Resumen de la Inicialización Criptográfica</strong></a></li>
<li><a href="#resumen-de-la-l%C3%B3gica-de-cifrado"><strong>Resumen de la Lógica de Cifrado</strong></a></li>
<li><a href="#resumen-sobre-la-nota-de-rescate"><strong>Resumen sobre La Nota de Rescate</strong></a></li>
<li><a href="#resumen-sobre-cu%C3%A1ndo-termina-condiciones-de-salida"><strong>Resumen sobre cuándo termina. Condiciones de salida</strong></a></li>
</ul>
</li>
</ul>
</li>
</ul>
<div style="page-break-before: always;"></div>
<h1 id="ejercicio-1"><strong>Ejercicio 1</strong></h1>
<h2 id="pistas"><strong>Pistas</strong></h2>
<h2 id="tarea-1-ejercicio-1"><strong>Tarea 1. Ejercicio 1</strong></h2>
<p>Descubrid a través de la lectura del código de la función ‘main’ desensamblada como ejecutar el programa.</p>
<p>Es decir, NO ES NECESARIO MANIPULAR EL PROGRAMA. Simplemente entendiendo como funciona ‘main’ es posible adivinar como evadir las protecciones y ejecutar el programa.</p>
<p>Se pide:</p>
<ul>
<li>Detallad y explicad mostrando el código ensamblador cuales son las condiciones para que el programa se ejecute.</li>
<li>Demostrad (mediante capturas de pantalla) la ejecución del programa.</li>
</ul>
<p><img src="capturas/superando-4-protecciones.png" alt="superando-4-protecciones"></p>
<h3 id="el-documento-del-ejercicio"><strong>El documento del ejercicio</strong></h3>
<p><a href="ejercicio1/Ejercicio-1.zip">Ejercicio</a></p>
<ul>
<li>Contraseña para descomprimir: infected</li>
</ul>
<h3 id="ajuste-de-la-sint%C3%A1xis-de-x86-intel-o-att"><strong>Ajuste de la sintáxis de x86: Intel o AT&amp;T</strong></h3>
<p>Para el análisis hea utilizado Ghidra como desensamblador, con sintaxis estilo Intel. A continuación se muestran los fragmentos de código ensamblador relevantes.</p>
<h3 id="lo-que-va-haciendo-la-funci%C3%B3n-main"><strong>Lo que va haciendo la función main</strong></h3>
<p><a href="https://github.com/soniasalido/cybersecurity/blob/main/Documentation/Malware/Master-ENIIT-Analisis-Malware-Reversing/modulo-3-analisis-de-codigo-fuente/2-M3-Tarea2/ejercicio1/funcion-main.md">La función main</a></p>
<h4 id="1-variables"><strong>1. Variables:</strong></h4>
<pre class="hljs"><code><div>undefined main()
undefined         &lt;UNASSIGNED&gt;   &lt;RETURN&gt;
undefined4        Stack[0x0]:4   local_res0                              XREF[2]:     00011304(R), 
                                                                                      000113c7(*)  
undefined         Stack[-0x14]:1 local_14                                XREF[1]:     000113c0(*)  
undefined4        Stack[-0x24]:4 local_24                                XREF[3]:     00011365(W), 
                                                                                      00011368(R), 
                                                                                      00011381(R)
</div></code></pre>
<p>donde:</p>
<ul>
<li><code>main</code> devuelve (<code>return</code> ) un tipo <code>undefined</code>.</li>
<li>Hay tres variables en la pila:
<ul>
<li><code>local_res0</code>:
<ul>
<li><code>Stack[0x0]:4</code> → está a desplazamiento <code>+0x0</code> respecto a <code>EBP</code>.</li>
<li>Tamaño: 4 bytes.</li>
<li>Sirve para guardar la dirección de retorno original / ajuste de pila.</li>
<li>Se usa en las instrucciones en <code>0x00011304</code> (en modo lectura) y <code>0x000113c7</code> (en la salida de la función).</li>
</ul>
</li>
<li><code>local_14</code>:
<ul>
<li><code>Stack[-0x14]:1</code> → está a desplazamiento <code>-0x14</code> desde <code>EBP</code>, ocupa 1 byte.</li>
<li>Es una variable local de relleno, usada en la epílogo para restaurar la pila.</li>
<li>Ghidra la llama <code>local_14</code> sólo por el offset, que es 14.</li>
</ul>
</li>
<li><code>local_24</code>:
<ul>
<li><code>Stack[-0x24]:4</code> → desplazamiento <code>-0x24</code>, 4 bytes.</li>
<li>Ghidra la llama <code>local_24</code> sólo por el offset.</li>
<li>Es una variable local real: ahí se guarda el puntero devuelto por <code>getenv(&quot;KEY&quot;)</code>.</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<p><strong>2. El prólogo de la función main:</strong><br>
Continuamos analizando las siguientes insctrucciones de la función main, que son el prólogo de main ➡ preparan la pila, alinean <code>ESP</code> a 16 bytes y configuran los registros de base para código posición - independiente (PIC):</p>
<pre class="hljs"><code><div>  000112fd 8d 4c 24 04     LEA        ECX=&gt;Stack[0x4],[ESP + 0x4]
  00011301 83 e4 f0        AND        ESP,0xfffffff0
  00011304 ff 71 fc        PUSH       dword ptr [ECX + local_res0]
  00011307 55              PUSH       EBP
  00011308 89 e5           MOV        EBP,ESP
  0001130a 56              PUSH       ESI
  0001130b 53              PUSH       EBX
  0001130c 51              PUSH       ECX
  0001130d 83 ec 1c        SUB        ESP,0x1c
</div></code></pre>
<p>donde:</p>
<ul>
<li>Al entrar en la función, la pila está así:
<ul>
<li><code>[ESP + 0]</code> ➡ dirección de retorno <code>a _start</code>.</li>
<li><code>[ESP + 4]</code> ➡ <code>argc</code>.</li>
<li><code>[ESP + 8]</code> ➡ <code>argv</code>.</li>
<li><code>[ESP + 12]</code> ➡ <code>envp</code>.</li>
</ul>
</li>
<li>Guarda un puntero a los argumentos originales ➡ <code>LEA ECX,[ESP + 0x4]</code> ➡ <code>ECX = ESP + 4</code> ➡ <code>ECX</code> pasa a apuntar a <code>argc</code>.
<ul>
<li><code>[ECX + 0]</code> ➡ <code>argc</code>.</li>
<li><code>[ECX + 4]</code> ➡ <code>argv</code>.</li>
<li><code>[ECX + 8]</code> ➡ <code>envp</code>.</li>
<li><code>[ECX - 4]</code> ➡ antigua dirección de retorno.</li>
</ul>
</li>
<li><code>AND ESP,0xfffffff0</code> ➡ Se alinea la pila a 16 bytes.</li>
<li><code>PUSH dword ptr [ECX - 0x4]</code> ➡ Se restaura la dirección de retorno sobre la pila alineada.
<ul>
<li><code>[ECX - 4]</code> es lo que estaba en <code>[ESP_original + 0]</code>, es decir, la dirección de retorno original.</li>
<li>Se hace <code>PUSH</code> de ese valor.</li>
</ul>
</li>
<li>Se crea el marco de pila clásico de una función: Desde la instrucción con offset <code>00011307</code> al <code>001130d</code>.
<ul>
<li><code>PUSH EBP / MOV EBP,ESP</code>.</li>
<li>Se crea el marco estándar de función:
<ul>
<li>Se guarda el antiguo <code>EBP</code>.</li>
<li><code>EBP</code> pasa a apuntar al nuevo frame.</li>
</ul>
</li>
<li><code>PUSH ESI</code> y <code>PUSH EBX</code> ➡ Se guardan registros <code>callee-saved</code> que la función debe restaurar antes de salir.</li>
<li><code>PUSH ECX</code> ➡ Se guarda en la pila el puntero a los argumentos originales (<code>argc</code> / <code>argv</code> / <code>envp</code>).</li>
<li><code>SUB ESP,0x1c</code> ➡ Se reserva <code>0x1c</code> bytes en la pila para variables locales (<code>local_14</code>, <code>local_24</code>, ...)</li>
<li><code>SUB ESP,0x1c</code> ➡ Se reserva 0x1c bytes en la pila para variables locales (<code>local_14</code>, <code>local_24</code>, ...)</li>
</ul>
</li>
</ul>
<hr>
<h4 id="3-c%C3%B3mo-accede-el-programa-a-sus-datos-globales"><strong>3. Cómo accede el programa a sus datos globales</strong></h4>
<pre class="hljs"><code><div>  00011310 e8 fb fd    CALL   __x86.get_pc_thunk.bx   undefined __x86.get_pc_thunk.bx()
  00011315 81 c3 eb    ADD    EBX,0x2ceb
</div></code></pre>
<p>donde</p>
<ul>
<li><code>CALL __x86.get_pc_thunk.bx</code> ➡  Se inicializa <code>EBX</code> para código posición-independiente (PIC). Lo que hace es copiar la dirección de retorno en <code>EBX</code>. Es decir, al volver de la llamada, <code>EBX</code> contiene la dirección de la siguiente instrucción.</li>
<li><code>ADD EBX,0x2CEB</code> ➡ Suma un desplazamiento constante a ese valor:
<ul>
<li><code>EBX</code> = (dirección actual de código) + <code>0x2CEB</code></li>
</ul>
</li>
</ul>
<p>Esto lo hace porque el ejecutable está compilado como código posición-independiente (PIC). Estas <code>__x86.get_pc_thunk.*</code> son funciones helper que GCC sólo genera cuando compila en modo <code>-fPIC/-fPIE</code> (código posición-independiente) en x86 de 32 bits. Estas funciones lo que hacen es:</p>
<ul>
<li>Leer la dirección de retorno desde la pila.</li>
<li>Copiarla a un registro (<code>EBX</code>, <code>EDX</code>, <code>EAX</code>, según la variante).</li>
<li>Volver.</li>
</ul>
<p>Como el ejecutable está compilado como código posición-independiente (PIC), significa que:</p>
<ul>
<li>No puede usar direcciones absolutas “hardcodeadas” a datos globales.</li>
<li>En su lugar, obtiene la dirección actual de código (con <code>get_pc_thunk</code>) y le suma un offset fijo para llegar a la base de su tabla de datos.</li>
<li>A partir de ahí, accede a cadenas y variables globales como <code>DAT_0001202b (&quot;KEY&quot;)</code> o <code>envkey (&quot;HOLAKASE&quot;)</code> usando desplazamientos respecto a <code>EBX</code>.</li>
</ul>
<hr>
<h4 id="4-primera-protecci%C3%B3n-el-n%C3%BAmero-de-argumentos"><strong>4. Primera Protección: El número de argumentos</strong></h4>
<p>Recordamos que anteriormente:</p>
<ul>
<li><code>[ECX + 0]</code> ➡ <code>argc</code>.</li>
<li><code>[ECX + 4]</code> ➡ <code>argv</code>.</li>
<li><code>[ECX + 8]</code> ➡ <code>envp</code>.</li>
</ul>
<pre class="hljs"><code><div>0001131b 89 ce           MOV   ESI,ECX      ; ESI = puntero a argc/argv
0001131d 83 3e 03        CMP   dword ptr [ESI],0x3
00011320 74 0a           JZ    LAB_0001132c ; si argc == 3 -&gt; OK
00011322 83 ec 0c        SUB   ESP,0xc
00011325 6a ff           PUSH  -0x1
00011327 e8 54 fd ff ff  CALL  exit         ; si no, exit(-1)
</div></code></pre>
<p>donde:</p>
<ul>
<li><code>MOV   ESI,ECX</code> ➡ Lo que se hace es: <code>ESI = &amp;argc</code>. Es decir, se guarda ese puntero en ECX para no perder acceso a <code>argc</code> / <code>argv</code> / <code>envp</code>.</li>
<li>A partir de este momento:
<ul>
<li><code>[ESI]</code> = <code>argc</code>.</li>
<li><code>[ESI + 4]</code> = <code>argv</code>.</li>
<li><code>[ESI + 8]</code> = <code>envp</code>.</li>
</ul>
</li>
<li><code>CMP dword ptr [ESI],0x3</code> ➡ Compara el valor de <code>argc</code> con <code>3</code>.
<ul>
<li>Si <code>[ESI] ==3</code> ➡ El resultado de la resta es 0, entonces <code>ZF = 1</code>.</li>
</ul>
</li>
<li><code>JZ LAB_0001132c</code> ➡
<ul>
<li>Si <code>ZF = 1</code> → Salta a <code>LAB_0001132c</code>.</li>
<li>Si <code>ZF = 0</code> → No salta y sigue con la siguiente instrucción.</li>
</ul>
</li>
<li>Si no salta, continúa con el ejecución para preparar la llamada a <code>exit</code>:
<ul>
<li><code>SUB   ESP,0xc</code> ➡ Reserva 12 bytes en la pila. Esto lo hace para mantener la alineación de 16 bytes antes de llamar a una función.</li>
<li><code>PUSH -0x1</code> ➡ Empuja el valor -1 en la pila.</li>
<li><code>CALL exit</code> ➡ Termina el proceso inmediatamente con código de salida 255, porque -1 como unsigned char es 255.</li>
<li>No vuelve a main. Aquí se corta todo el flujo.</li>
</ul>
</li>
</ul>
<p><strong><mark>Es decir, para para superar la primera protección del programa, tenemos que pasar 3 argumentos: <code>argv[0]</code>, <code>argv[1]</code> y <code>argv[2])</code>.</mark></strong></p>
<p>Más adelante sabremos que estos argumentos deben ser:</p>
<ul>
<li><code>argv[0]</code> ➡ Nombre del programa que lo añade el sistema.</li>
<li><code>argv[1]</code> ➡ Argumento numérico, que más adelante se comprobará que sea <code>1729</code> → <code>(atoi(argv[1]) == 1729)</code>.</li>
<li><code>argv[2]</code> ➡ Cadena de texto a la que se aplicará la función <code>rot13</code>.</li>
</ul>
<hr>
<div style="page-break-before: always;"></div>
<h4 id="5-segunda-protecci%C3%B3n-el-primer-argumento-del-usuario-debe-ser-1729"><strong>5. Segunda Protección: El primer argumento del usuario debe ser 1729</strong></h4>
<p>Recordamos que:</p>
<ul>
<li><code>[ESI]</code> = <code>argc</code>.</li>
<li><code>[ESI + 4]</code> = <code>argv</code>.</li>
<li><code>[ESI + 8]</code> = <code>envp</code>.</li>
</ul>
<pre class="hljs"><code><div>0001132c 8b 46 04        MOV  EAX,dword ptr [ESI + 4]  ; EAX = *(ESI+4) = argv
0001132f 83 c0 04        ADD  EAX,0x4                  ; EAX = &amp;argv[1]
00011332 8b 00           MOV  EAX,dword ptr [EAX]      ; EAX = argv[1]
00011334 83 ec 0c        SUB  ESP,0xc
00011337 50              PUSH EAX                      ; push argv[1]
00011338 e8 73 fd ff ff  CALL atoi                     ; atoi(argv[1])
0001133d 83 c4 10        ADD  ESP,0x10
00011340 ba c1 06 00 00  MOV  EDX,0x6c1                ; 0x6c1 = 1729
00011345 39 d0           CMP  EAX,EDX                  ; atoi(argv[1]) ?= 1729
00011347 74 0a           JZ   LAB_00011353             ; si es igual -&gt; OK
00011349 83 ec 0c        SUB  ESP,0xc
0001134c 6a ff           PUSH -0x1
0001134e e8 2d fd ff ff  CALL exit                     ; si no, exit(-1)
</div></code></pre>
<p>donde:</p>
<ul>
<li><code>MOV EAX, [ESI + 4]</code> ➡ Carga en el registro <code>EAX</code> el valor de <code>argv</code>, es decir, un <code>char **</code>.</li>
<li><code>ADD EAX, 0x4</code> ➡
<ul>
<li>Suma 4 bytes a ese puntero: como cada entrada de <code>argv</code> es un puntero de 4 bytes, esto equivale a ir de <code>&amp;argv[0]</code> a <code>&amp;argv[1]</code>.</li>
<li>Ahora <code>EAX</code> apunta a <code>argv[1]</code>, a la posición donde está guardado el puntero.</li>
</ul>
</li>
<li><code>MOV EAX, [EAX]</code> ➡ Desreferencia: ahora EAX contiene directamente <code>argv[1]</code>, es decir, la cadena que se ha pasado como primer argumento de usuario, como por ejemplo <code>1729</code>.</li>
<li>Llamada a <code>atoi(argv[1])</code>:
<ul>
<li><code>SUB ESP, 0xC</code> ➡ Reserva 12 bytes en la pila para mantener la alineación.</li>
<li><code>PUSH EAX</code> ➡ Empuja <code>argv[1]</code> como argumento de <code>atoi</code>.</li>
<li><code>CALL atoi</code> ➡ Llama a la función estándar atoi.
<ul>
<li>El valor devuelto que es el entero convertido, queda en <code>EAX</code>.</li>
</ul>
</li>
</ul>
</li>
<li>Limpia la pila: <code>ADD ESP, 0x10</code> ➡
<ul>
<li>4 bytes del argumento: <code>PUSH EAX</code>.</li>
<li>12 bytes del <code>SUB ESP, 0xC</code> previo.</li>
<li>Total: 16 bytes.</li>
</ul>
</li>
<li>Comparación con 1729 ➡
<ul>
<li><code>MOV EDX, 0x6c1</code> ➡ Carga en el registro <code>EDX</code> el valor <code>0x6C1</code>, que en decimal es <code>1729</code>.</li>
<li><code>CMP EAX, EDX</code> ➡ Compara el resultado de <code>atoi(argv[1])</code> que está en <code>EAX</code> con <code>EDX</code> que contiene <code>1729</code>.</li>
<li><code>JZ LAB_00011353</code>  ➡ Jump if Zero: salta solo si <code>EAX == EDX</code>, es decir, si == 1729.
<ul>
<li>Si <code>ZF = 1</code> → Salta a <code>LAB_00011353</code>.</li>
<li>Si <code>ZF = 0</code> → No salta y sigue con la siguiente instrucción.</li>
</ul>
</li>
</ul>
</li>
<li>Si no salta, continúa con el ejecución para preparar la llamada a <code>exit</code>:
<ul>
<li><code>SUB   ESP,0xc</code> ➡ Reserva 12 bytes en la pila. Esto lo hace para mantener la alineación de 16 bytes antes de llamar a una función.</li>
<li><code>PUSH -0x1</code> ➡ Empuja el valor -1 en la pila.</li>
<li><code>CALL exit</code> ➡ Termina el proceso inmediatamente con código de salida 255, porque -1 como unsigned char es 255.</li>
<li>No vuelve a main. Aquí se corta todo el flujo.</li>
</ul>
</li>
</ul>
<p><strong><mark>Es decir, para para superar la segunda protección del programa, el primer argumento de usuario (después del nombre del programa) debe ser una cadena que, al convertirla con atoi a un número entero, sea exactamente 1729.</mark></strong></p>
<hr>
<h4 id="6-tercera-protecci%C3%B3n-la-variable-de-entorno"><strong>6. Tercera Protección: La variable de entorno</strong></h4>
<pre class="hljs"><code><div>LAB_00011353:
00011353 83 ec 0c        SUB  ESP,0xc
00011356 8d 83 2b e0 ff ff  LEA EAX,[EBX + 0xffffe02b] ; EAX = &amp;DAT_0001202b
                                                       ; (nombre de la variable de entorno, empieza por 'K')
0001135c 50              PUSH EAX                      ; push nombre
0001135d e8 ee fc ff ff  CALL getenv                  ; getenv(nombre)
00011362 83 c4 10        ADD  ESP,0x10
00011365 89 45 e4        MOV  [EBP + local_24],EAX    ; guardar retorno de getenv
00011368 83 7d e4 00     CMP  dword ptr [EBP + local_24],0x0
0001136c 75 0a           JNZ  LAB_00011378            ; si != NULL -&gt; OK
0001136e 83 ec 0c        SUB  ESP,0xc
00011371 6a ff           PUSH -0x1
00011373 e8 08 fd ff ff  CALL exit                    ; si NULL, exit(-1)
</div></code></pre>
<p>donde:</p>
<ul>
<li><code>SUB  ESP,0xc</code> ➡ Reserva 12 bytes en la pila para mantener la alineación.</li>
<li><code>LEA  EAX,[EBX + 0xffffe02b]</code> ➡ Calcula en EAX la dirección de la cadena en memoria en DAT_0001202b.
<ul>
<li>En esa dirección está la cadena: <code>0001202b  &quot;KEY&quot;</code>.</li>
<li>Por lo tanto: <code>EAX = &quot;KEY&quot;</code>.</li>
</ul>
</li>
<li><code>PUSH EAX</code> ➡ Se empuja el puntero a la cadena &quot;KEY&quot; en la pila.</li>
<li><code>CALL getenv</code> ➡ Se llama a la función estándar <code>getenv</code>. La función <code>getenv(&quot;KEY&quot;)</code> devuelve:
<ul>
<li>Un puntero al valor de la variable de entorno &quot;KEY&quot;, si existe.</li>
<li>NULL si la variable no está definida.</li>
</ul>
</li>
<li>Limpia la pila: <code>ADD ESP, 0x10</code> ➡
<ul>
<li>4 bytes del argumento: <code>PUSH EAX</code>.</li>
<li>12 bytes del <code>SUB ESP, 0xC</code> previo.</li>
<li>Total: 16 bytes.</li>
</ul>
</li>
<li>Comprueba si es NULL:
<ul>
<li><code>MOV [EBP + local_24],EAX</code> ➡ Guarda en la variable <code>local_24</code> el puntero devuelto por <code>getenv(&quot;KEY&quot;)</code>.</li>
<li><code>CMP  dword ptr [EBP + local_24],0x0</code> ➡ Compara <code>local_24</code> con <code>0</code>.</li>
<li><code>JNZ LAB_00011378</code> ➡ Jump if Zero:
<ul>
<li>Si <code>ZF = 1</code> → <code>getenv(&quot;KEY&quot;)</code> no es NULL → la variable existe → Salta a <code>LAB_00011378</code>.</li>
<li>Si <code>ZF = 0</code> → <code>getenv(&quot;KEY&quot;)</code> ha devuelto NULL → la variable no está definida → No salta y sigue con la siguiente instrucción.</li>
</ul>
</li>
</ul>
</li>
<li>Si no salta, continúa con el ejecución para preparar la llamada a <code>exit</code>:
<ul>
<li><code>SUB   ESP,0xc</code> ➡ Reserva 12 bytes en la pila. Esto lo hace para mantener la alineación de 16 bytes antes de llamar a una función.</li>
<li><code>PUSH -0x1</code> ➡ Empuja el valor -1 en la pila.</li>
<li><code>CALL exit</code> ➡ Termina el proceso inmediatamente con código de salida 255, porque -1 como unsigned char es 255.</li>
<li>No vuelve a main. Aquí se corta todo el flujo.</li>
</ul>
</li>
</ul>
<p><strong>Nota: La cadena en DAT_0001202b:</strong></p>
<pre class="hljs"><code><div>DAT_0001202b
0001202b 4b  K
0001202c 45  E
0001202d 59  Y
0001202e 00  \0
</div></code></pre>
<p>La cadena en DAT_0001202b es: &quot;KEY&quot;.</p>
<p><strong>Resumiendo, la llamada de main:</strong></p>
<pre class="hljs"><code><div>00011356 8d 83 2b e0 ff ff  LEA EAX,[EBX + 0xffffe02b] ; → &quot;KEY&quot;
0001135c 50                 PUSH EAX
0001135d e8 ee fc ff ff     CALL getenv                 ; getenv(&quot;KEY&quot;)
</div></code></pre>
<p>Lo que hace exactamente es: <code>char *env = getenv(&quot;KEY&quot;);</code>. Debe existir una variable de entorno KEY definida y correcta. Con un valor determinado que se explica justo en el siguiente punto.</p>
<p><strong><mark>Es decir, para para superar la tercera protección del programa, debe existir una variable de entorno llamada &quot;KEY&quot;. Si KEY no está definida en el entorno, el programa termina inmediatamente con exit(-1).</mark></strong></p>
<hr>
<div style="page-break-before: always;"></div>
<h4 id="7-cuarta-protecci%C3%B3n-holakase"><strong>7. Cuarta Protección: HOLAKASE</strong></h4>
<pre class="hljs"><code><div>00011378 8b 83 38 00 00 00  MOV EAX,dword ptr [EBX + 0x38] ; EAX = envkey = 0x12008
                              ; en 0x12008 está la cadena &quot;HOLAKASE&quot;
0001137e 83 ec 08           SUB ESP,0x8
00011381 ff 75 e4           PUSH dword ptr [EBP + local_24] ; push env
00011384 50                 PUSH EAX                        ; push &quot;HOLAKASE&quot;
00011385 e8 a6 fc ff ff     CALL strcmp                     ; strcmp(&quot;HOLAKASE&quot;, env)
0001138a 83 c4 10           ADD  ESP,0x10
0001138d 85 c0              TEST EAX,EAX
0001138f 74 0a              JZ   LAB_0001139b               ; si devuelve 0 -&gt; OK
00011391 83 ec 0c           SUB  ESP,0xc
00011394 6a ff              PUSH -0x1
00011396 e8 e5 fc ff ff     CALL exit                       ; si != 0, exit(-1)
</div></code></pre>
<p>donde:</p>
<ul>
<li><code>MOV EAX,dword ptr [EBX + 0x38]</code> ➡
<ul>
<li><code>EBX</code> apunta a la zona de datos/GOT, la base de datos del binario.</li>
<li><code>[EBX + 0x38]</code> contiene un puntero a la cadena &quot;HOLAKASE&quot;.</li>
<li>Luego <code>EAX</code> = dirección de la cadena &quot;HOLAKASE&quot;.</li>
</ul>
</li>
<li><code>SUB ESP,0x8</code> ➡ Ajusta la pila.</li>
<li><code>PUSH dword ptr [EBP + local_24]</code> ➡ Empuja como segundo argumento el puntero <code>env</code>, que viene de <code>getenv(&quot;KEY&quot;)</code>.</li>
<li><code>PUSH EAX</code> ➡ Empuja como primer argumento el puntero a &quot;HOLAKASE&quot;.</li>
<li><code>CALL strcmp</code> ➡ Llama a la función <code>strcmp</code> que compara cadenas y devuelve:
<ul>
<li>0 si las cadenas son exactamente iguales.</li>
<li>&lt;0 o &gt;0 si son distintas.</li>
</ul>
</li>
<li>Evalua el resultado de <code>strcmp</code> ➡
<ul>
<li><code>ADD  ESP,0x10</code> ➡ Limpia la pila, 8 bytes de los dos PUSH + 8 de la reserva previa.</li>
<li><code>TEST EAX,EAX</code> ➡ Hace un <code>AND</code> entre <code>EAX</code> y <code>EAX</code>:
<ul>
<li>Si EAX == 0 ➡ Zero Flag (ZF) = 1.</li>
<li>Si EAX != 0 ➡ ZF = 0.</li>
</ul>
</li>
<li><code>JZ LAB_0001139b</code> ➡ Jump if Zero:
<ul>
<li>Si <code>ZF = 1</code> ➡ strcmp(&quot;HOLAKASE&quot;, env) == 0 → env ES exactamente &quot;HOLAKASE&quot; → Salta a <code>LAB_0001139b</code>.</li>
<li>Si <code>ZF = 0</code> ➡ Si env NO es exactamente &quot;HOLAKASE&quot; → No salta y sigue con la siguiente instrucción.</li>
</ul>
</li>
</ul>
</li>
<li>Si no salta, continúa con el ejecución para preparar la llamada a <code>exit</code>:
<ul>
<li><code>SUB   ESP,0xc</code> ➡ Reserva 12 bytes en la pila. Esto lo hace para mantener la alineación de 16 bytes antes de llamar a una función.</li>
<li><code>PUSH -0x1</code> ➡ Empuja el valor -1 en la pila.</li>
<li><code>CALL exit</code> ➡ Termina el proceso inmediatamente con código de salida 255, porque -1 como unsigned char es 255.</li>
<li>No vuelve a main. Aquí se corta todo el flujo.</li>
</ul>
</li>
</ul>
<p><strong><mark>Es decir, para para superar la cuarta protección del programa, NO basta con que la variable de entorno KEY exista, su valor debe ser exactamente la cadena: &quot;HOLAKASE&quot;.</mark></strong> Sin espacios, sin minúsculas, sin caracteres extra. Es case-sensitive.</p>
<hr>
<h4 id="8-finalizaci%C3%B3n-del-programa"><strong>8. Finalización del Programa</strong></h4>
<p>Recordamos que:</p>
<ul>
<li><code>[ESI]</code> = <code>argc</code>.</li>
<li><code>[ESI + 4]</code> = <code>argv</code>.</li>
<li><code>[ESI + 8]</code> = <code>envp</code>.</li>
</ul>
<pre class="hljs"><code><div>    -- Flow Override: CALL_RETURN (CALL_TERMINATOR)
                             LAB_0001139b               XREF[1]:     0001138f(j)  
0001139b 8b 46 04        MOV        EAX,dword ptr [ESI + Stack[0x8]]
0001139e 83 c0 08        ADD        EAX,0x8
000113a1 8b 00           MOV        EAX,dword ptr [EAX]
000113a3 83 ec 0c        SUB        ESP,0xc
000113a6 50              PUSH       EAX
000113a7 e8 61 fe        CALL       rot13                undefined rot13()
         ff ff
000113ac 83 c4 10        ADD        ESP,0x10
000113af 83 ec 0c        SUB        ESP,0xc
000113b2 50              PUSH       EAX
000113b3 e8 b8 fc        CALL       &lt;EXTERNAL&gt;::puts     int puts(char * __s)
         ff ff
000113b8 83 c4 10        ADD        ESP,0x10
000113bb b8 00 00        MOV        EAX,0x0
         00 00
</div></code></pre>
<p>donde:</p>
<ul>
<li>Recupera <code>argv[2]</code> que es el texto va a transformar:
<ul>
<li><code>MOV  EAX,dword ptr [ESI + Stack[0x8]]</code> ➡
<ul>
<li>Ghidra aquí lo anota como Stack[0x8], pero funcionalmente es lo mismo que <code>[ESI + 4]</code>: está cogiendo <code>argv</code>.</li>
<li>Entonces <code>EAX = argv</code>.</li>
</ul>
</li>
<li><code>ADD EAX, 0x8</code>:
<ul>
<li>Cada entrada de <code>argv</code> es un puntero de 4 bytes.</li>
<li><code>argv + 2 * 4</code> = <code>&amp;argv[2]</code>.</li>
<li>Ahora <code>EAX</code> apunta a <code>argv[2]</code>.</li>
</ul>
</li>
<li><code>MOV EAX, [EAX]</code> ➡
<ul>
<li>Desreferencia ese puntero: <code>EAX = argv[2]</code>.</li>
<li>Es decir, EAX contiene la dirección de la cadena de texto que el usuario pasó como tercer argumento, el segundo argumento que escribe el usuario.</li>
</ul>
</li>
</ul>
</li>
<li>Llama a <code>rot13(argv[2])</code> ➡
<ul>
<li><code>SUB ESP, 0xC</code> ➡ Reserva 12 bytes para mantener alineación de la pila antes de la llamada.</li>
<li><code>PUSH EAX</code> ➡ Empuja como argumento el puntero <code>argv[2]</code>.</li>
<li><code>CALL rot13</code> ➡ Llama a la función <code>rot13(char *)</code> ➡ Esta función:
<ul>
<li>Reserva memoria.</li>
<li>Copia la cadena.</li>
<li>Aplica <code>ROT13</code> sobre esa copia.</li>
<li>Devuelve en <code>EAX</code> un puntero a la nueva cadena transformada.</li>
</ul>
</li>
</ul>
</li>
<li>Limpia la pila: <code>ADD ESP, 0x10</code> ➡
<ul>
<li>4 bytes del <code>PUSH EAX</code>.</li>
<li>12 bytes del <code>SUB ESP,0xC</code>.</li>
<li>Total 16 bytes ➡  <code>ESP</code> vuelve a su valor original antes de esta secuencia.</li>
</ul>
</li>
<li>Imprimir el resultado: <code>CALL puts</code> ➡ Imprime la cadena seguida de un salto de línea.</li>
<li>Limpia de nuevo: <code>ADD ESP,0x10</code> ➡
<ul>
<li>4 bytes del argumento.</li>
<li>12 de la reserva previa.</li>
</ul>
</li>
<li>Prepara el valor de retorno de <code>main</code>: <code>MOV EAX,0x0</code> ➡ Carga <code>0</code> en <code>EAX</code>, que es el valor de retorno de <code>main</code>.</li>
</ul>
<p><strong><mark>En este main vemos que hay 4 condiciones importantes y si alguna falla se hace exit(-1) inmediatamente. Así que si llegamos a ejecutar la instrucción <code>puts(rot13(argv2]))</code>, es que todas esas condiciones se han cumplido. El segundo argumento <code>(argv[2])</code> se pasa a la función <code>rot13</code>, y el resultado de aplicar esta función, se imprime con <code>puts</code>. La función <code>rot13</code> es el clásico cifrado de sustitución que desplaza letras 13 posiciones en el alfabeto, tanto para codificar como para decodificar.</mark></strong></p>
<hr>
<h4 id="9-ep%C3%ADlogo-de-la-funci%C3%B3n-y-restauraci%C3%B3n-de-la-pila-original"><strong>9. Epílogo de la función y restauración de la pila original</strong></h4>
<pre class="hljs"><code><div>000113c0 8d 65 f4        LEA        ESP=&gt;local_14,[EBP + -0xc]
000113c3 59              POP        ECX
000113c4 5b              POP        EBX
000113c5 5e              POP        ESI
000113c6 5d              POP        EBP
000113c7 8d 61 fc        LEA        ESP=&gt;local_res0,[ECX + -0x4]
000113ca c3              RET
</div></code></pre>
<p>donde:</p>
<ul>
<li><code>LEA ESP, [EBP - 0xC]</code> ➡ Mueve <code>ESP</code> a la zona donde estaban las variables locales. Es parte del desmontaje del frame (EBP-centrado).</li>
<li><code>POP ECX</code> ➡ Recupera el valor de <code>ECX</code> que se salvó al principio de main.</li>
<li><code>POP EBX</code>, <code>POP ESI</code>, <code>POP EBP</code> ➡ Restaura los registros callee-saved (<code>EBX</code>, <code>ESI</code>) y el <code>viejo EBP</code>, deshaciendo el prólogo clásico de función.</li>
<li><code>LEA ESP,[ECX - 0x4]</code> ➡
<ul>
<li><code>ECX</code> se usó para guardar el valor de la pila antes de la alineación (al principio de main).</li>
<li>Ahora se recalcula <code>ESP</code> en función de ese valor para dejar la pila exactamente como la esperaba el llamador, antes de entrar en <code>main</code>.</li>
<li>El <code>-0x4</code> tiene que ver con cómo se guardó la dirección de retorno al principio, el <code>local_res0</code>.</li>
</ul>
</li>
<li><code>RET</code> ➡ Devuelve al runtime (<code>_start</code> / <code>libc_start_main</code>), con:
<ul>
<li><code>EAX = 0</code> que es el valor de retorno de main.</li>
<li><code>ESP</code> restaurado de forma coherente.</li>
<li>Registros callee-saved restaurados.</li>
</ul>
</li>
</ul>
<hr>
<h4 id="resumen-de-la-funci%C3%B3n-main-escrita-en-c"><strong>Resumen de la función main escrita en C</strong></h4>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> **argv)</span> </span>{
    <span class="hljs-keyword">if</span> (argc != <span class="hljs-number">3</span>)
        <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);

    <span class="hljs-keyword">if</span> (atoi(argv[<span class="hljs-number">1</span>]) != <span class="hljs-number">1729</span>)
        <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);

    <span class="hljs-keyword">char</span> *env = getenv(NOMBRE_ENV);   <span class="hljs-comment">// NOMBRE_ENV = cadena en DAT_0001202b = KEY</span>
    <span class="hljs-keyword">if</span> (env == <span class="hljs-literal">NULL</span>)
        <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);

    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(<span class="hljs-string">"HOLAKASE"</span>, env) != <span class="hljs-number">0</span>)
        <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);

    <span class="hljs-keyword">char</span> *out = rot13(argv[<span class="hljs-number">2</span>]);
    <span class="hljs-built_in">puts</span>(out);

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</div></code></pre>
<hr>
<div style="page-break-before: always;"></div>
<h3 id="c%C3%B3mo-ejecutar-el-programa"><strong>Cómo ejecutar el programa</strong></h3>
<p>Para que el programa se ejecute, es decir, llegar a <code>rot13 + puts</code> se necesitan evadir &quot;las protecciones&quot; que hemos estudiado en el punto anterior.</p>
<h4 id="la-variable-de-entorno"><strong>La variable de entorno</strong></h4>
<p>Creamos una variable de entorno llamada Key y su valor = HOLAKASE:</p>
<pre class="hljs"><code><div>$ export KEY=HOLAKASE
</div></code></pre>
<p>donde:</p>
<ul>
<li>KEY es la variable de entorno que exige el programa.</li>
</ul>
<h4 id="ejecuci%C3%B3n-del-programa-con-sus-argumentos"><strong>Ejecución del programa con sus argumentos</strong></h4>
<pre class="hljs"><code><div>$ ./programa 1729 HOLA
UBYN
</div></code></pre>
<p>donde:</p>
<ul>
<li>1729 cumple la comparación con 0x6c1.</li>
<li>HOLA es argv[2], al que se aplica ROT13 →</li>
<li>UBYN, que es lo que se imprime.</li>
</ul>
<p><img src="capturas/ejecucion-tarea2-ejercicio1.png" alt="ejecucion-tarea2-ejercicio1"></p>
<div style="page-break-before: always;"></div>
<h4 id="ejecutando-el-programa-con-gdb"><strong>Ejecutando el programa con gdb</strong></h4>
<p>Ejecutamos gdb:</p>
<pre class="hljs"><code><div>gdb ./ejercicio6
</div></code></pre>
<p>Dentro de gdb:</p>
<pre class="hljs"><code><div>set disassembly-flavor intel

# Definimo la variable de entorno que necesitamos
set env KEY HOLAKASE

# Argumentos del programa
set args 1729 HOLA

# breakpoint en el inicio de main para que gdb calcule la dirección real y se pare en este breakpoint
break main

run
</div></code></pre>
<p>Cuando se pare en main, entonces añadimos unos breakpoints interesantes relativos al breakpoint anterior:</p>
<pre class="hljs"><code><div># 1ª protección: argc == 3      (0x112fd -&gt; 0x1131d = +0x20)
break *main+0x20

# 2ª protección: atoi(argv[1]) == 1729   (0x48)
break *main+0x48

# 3ª protección: getenv(&quot;KEY&quot;) != NULL   (0x6b)
break *main+0x6b

# 4ª protección: strcmp(&quot;HOLAKASE&quot;, env) == 0   (0x90)
break *main+0x90

# Entrada en la función rot13
break rot13
</div></code></pre>
<div style="page-break-before: always;"></div>
<p>Luego:</p>
<pre class="hljs"><code><div># Vamos moviéndonos entre los breakpoints
continue

# Ver registros (EAX, EBX, ESI, EBP, ESP...)
info registers

# Ver la instrucción actual
x/i $eip

# Ver unas pocas instrucciones alrededor
x/5i $eip-5
</div></code></pre>
<p><img src="capturas/ejecucion-tarea2-ejercicio1-2.png" alt="ejecucion-tarea2-ejercicio1-2"></p>
<p><strong>En la Primera Protección: <code>argc==3</code></strong><br>
<img src="capturas/ejecucion-tarea2-ejercicio1-5-ok.png" alt="ejecucion-tarea2-ejercicio1-5"><br>
donde:</p>
<ul>
<li><code>argc == 3</code> - Breakpoint (*main+0x20).</li>
<li><code>p *(int *)$esi</code> devuelve <code>argc</code> en decimal.</li>
<li><code>p/x $esi</code> devuelve la dirección donde está <code>argc</code>.</li>
<li><code>x/wx $esi</code> devuelve el valor crudo en hexadecimal.</li>
</ul>
<p><strong>En la Segunda Protección: <code>(atoi(argv[1]) == 1729</code></strong><br>
<img src="capturas/ejecucion-tarea2-ejercicio1-6.png" alt="ejecucion-tarea2-ejercicio1-6"><br>
donde:</p>
<ul>
<li>Breakpoint *main+0x48.</li>
<li>El retorno de <code>atoi</code> está en <code>EAX</code>.</li>
<li><code>EAX</code> = 1729.</li>
</ul>
<div style="page-break-before: always;"></div>
<p><strong>En la Tercera Protección: <code>getenv(&quot;KEY&quot;) != NULL</code></strong><br>
<img src="capturas/ejecucion-tarea2-ejercicio1-7.png" alt="ejecucion-tarea2-ejercicio1-7"><br>
donde:</p>
<ul>
<li>Breakpoint *main+0x6b.</li>
<li><code>p/x $eax</code> resuelve el puntero devuelto por <code>getenv</code>.</li>
<li><code>x/s $eax</code> devuelve la cadena a la que apunta, es decir, el valor de &quot;KEY&quot;.</li>
</ul>
<p><strong>En la Cuarta Protección: <code>strcmp(&quot;HOLAKASE&quot;, env) == 0</code></strong><br>
<img src="capturas/ejecucion-tarea2-ejercicio1-8.png" alt="ejecucion-tarea2-ejercicio1-8"><br>
donde:</p>
<ul>
<li>Breakpoint *main+0x90.</li>
<li><code>strcmp(&quot;HOLAKASE&quot;, env)</code> ya se ha ejecutado.</li>
<li>El resultado está en EAX:
<ul>
<li>0 → las cadenas son iguales.</li>
<li>≠0 → las cadenas son distintas → el programa hará exit(-1).</li>
</ul>
</li>
<li><code>p $eax</code> devuelve 0 ya que pasa la protección.</li>
</ul>
<p><strong>En rot13</strong><br>
<img src="capturas/ejecucion-tarea2-ejercicio1-9.png" alt="ejecucion-tarea2-ejercicio1-9"><br>
donde:</p>
<ul>
<li>Breakpoint rot13</li>
<li><code>x/s (char *)$esp+4</code> devuelve la cadena de entrada a <code>rot13</code>.</li>
<li>El puntero al texto <code>ROT13</code> está en <code>EAX</code>.</li>
<li><code>x/s $eax</code> devuelve la cadena ya transformada.</li>
</ul>
<p><strong>En la función puts</strong><br>
<img src="capturas/ejecucion-tarea2-ejercicio1-10.png" alt="ejecucion-tarea2-ejercicio1-10"></p>
<ul>
<li>Breakpoint puts.</li>
<li><code>x/s $eax</code> devuelve lo que la función <code>puts</code> va a imprimir.</li>
</ul>
<p><strong>Llega al final del programa</strong><br>
<img src="capturas/ejecucion-tarea2-ejercicio1-11.png" alt="ejecucion-tarea2-ejercicio1-11"></p>
<div style="page-break-before: always;"></div>
<h2 id="tarea-2-ejercicio-1"><strong>Tarea 2. Ejercicio 1</strong></h2>
<p>El programa, además de “main”, solo tiene una única función. Encontradla y explicad que hace y como lo hace esta función mostrando el código ensamblador correspondiente.</p>
<h3 id="identificar-las-funciones-de-usuario"><strong>Identificar las Funciones de Usuario</strong></h3>
<p><img src="capturas/tabla-simbolos-ok-2.png" alt="tabla-simbolos">
Para identificar las funciones de usuario sin incurrir en falsos positivos, como las funciones de gestión de clones del compilador (register_tm_clones), aplicamos un doble filtrado:</p>
<ul>
<li>Filtrado por Sección: Verificamos que la dirección de la función se encuentre dentro del rango de la sección <code>.text</code>, que es donde se encuentra el código ejecutable principal. Esto descarta inmediatamente funciones de infraestructura situadas en .plt (como FUN_00011020).</li>
<li>Filtrado por Convención de Nombres: Dentro de <code>.text</code>, descartamos aquellas funciones que, aunque marcadas como 'Global', comienzan con guiones bajos o contienen términos técnicos del compilador, como <code>_start</code>, <code>deregister_tm_clones</code> o <code>__x86.get_pc_thunk</code>).</li>
</ul>
<p>Mostramos el mapa de memoria en ghidra → → → Window → → → Memory Map:
<img src="capturas/memory-map.png" alt="memory-map">
donde:</p>
<ul>
<li>Las funciones de usuario siempre residen en la sección .text, mientras que las funciones de enlace dinámico (como la FUN_00011020) residen en la sección .plt.</li>
<li>La sección <code>.text</code> va desde: <code>000110d0</code>, hasta:	<code>00011434</code>.</li>
<li>rot13 está en 0001120d, dentro de <code>.text</code>.</li>
<li>writeofile está en 00112ed, dentro de <code>.text</code>.</li>
<li>main está en 000112fd, obviamente dentro de <code>.text</code>.</li>
<li>FUN_00011020 que está en 00011020, esta situado fuera de <code>.text</code>. Está donde empieza <code>.plt</code>.</li>
<li>register_tm_clones está dentro de <code>.text</code>, pero se descarta por contener guiones en su nombre.</li>
</ul>
<p><mark>Bajo estos criterios, <strong>vemos que no sólo hay una función de usuario, hay dos</strong>. Además de <code>main</code>, identificamos claramente las funciones <code>rot13</code> y <code>writetofile</code> como las funciones de usuario. Se descartan FUN_00011020, register_tm_clones, deregister_tm_clones</mark> como posibles funciones de usuario.</p>
<div style="page-break-before: always;"></div>
<h3 id="las-2-funciones-de-usuario"><strong>Las 2 Funciones de usuario</strong></h3>
<h4 id="1-writetofile"><strong>1. writetofile</strong></h4>
<pre class="hljs"><code><div>                             **************************************************************
                             *                          FUNCTION                          *
                             **************************************************************
                             undefined writetofile()
             undefined         &lt;UNASSIGNED&gt;   &lt;RETURN&gt;
                             writetofile                                     XREF[3]:     Entry Point(*), 0001205c, 
                                                                                          00012134(*)  
        000112ed 55              PUSH       EBP
        000112ee 89 e5           MOV        EBP,ESP
        000112f0 e8 d6 00        CALL       __x86.get_pc_thunk.ax                            undefined __x86.get_pc_thunk.ax()
                 00 00
        000112f5 05 0b 2d        ADD        EAX=&gt;_GLOBAL_OFFSET_TABLE_,0x2d0b                = 00013efc
                 00 00
        000112fa 90              NOP
        000112fb 5d              POP        EBP
        000112fc c3              RET
</div></code></pre>
<p>donde:</p>
<ul>
<li><code>PUSH EBP / MOV EBP, ESP</code>: Es el prólogo de la función. Prepara el marco de la pila para esta función.</li>
<li><code>CALL __x86.get_pc_thunk.ax</code>: Esta es una técnica común en binarios Linux (ELF) de 32 bits para obtener la dirección actual del código. Se usa para lograr PIC (Position Independent Code). Básicamente, carga la dirección de memoria actual en el registro <code>EAX</code>.</li>
<li><code>ADD EAX, 0x2d0b</code>: Ajusta el valor de <code>EAX</code> para apuntar a la <code>_GLOBAL_OFFSET_TABLE_</code> (<code>GOT</code>). Esto permite que la función sepa dónde están los datos globales o las bibliotecas externas en memoria.</li>
<li><code>NOP</code>: Una instrucción que no hace nada, <code>No Operation</code>.</li>
<li><code>POP EBP / RET</code>: Es el epílogo de la función. Limpia la pila y regresa el control al programa que llamó a la función.</li>
</ul>
<p>Aunque tiene el nombre <code>writetofile</code>, es inusual porque no contiene ninguna lógica para escribir en un archivo. En realidad, parece ser una función que fue vaciada por algún motivo. A pesar de su nombre, esta función es prácticamente nula:</p>
<ul>
<li>No abre archivos: No hay llamadas a fopen, open o similares.</li>
<li>No escribe datos: No hay llamadas a fwrite, write o fprintf.</li>
<li>No tiene argumentos: Aunque se llama writetofile, no parece recibir parámetros en este bloque de código.</li>
<li>Solo configura el entorno: Lo único que hace es inicializar el acceso a la tabla global de desplazamientos (GOT) y terminar inmediatamente.</li>
<li>Aunque aparezca en XREFs (Entry Point, tablas internas), su cuerpo no afecta al flujo ni a las condiciones que debe satisfacer el programa para que termine la ejecución.</li>
</ul>
<p><strong><mark>El nombre de la función parece un señuelo para despistar.</mark></strong></p>
<h4 id="2-rot13"><strong>2. rot13</strong></h4>
<p><strong>¿Qué hace rot13 y cómo lo hace?</strong></p>
<ul>
<li>Recibe un <code>char *</code>.</li>
<li>Si el puntero es NULL, devuelve NULL.</li>
<li>Calcula la longitud de la cadena con <code>strlen</code>.</li>
<li>Reserva memoria dinámica con <code>malloc(strlen(s))</code> y copia ahí la cadena con <code>strcpy</code>.</li>
<li>Recorre la copia carácter a carácter:
<ul>
<li>Si es letra minúscula a..z o mayúscula A..Z, aplica <code>ROT13</code>:
<ul>
<li>a..m / A..M → suma 13.</li>
<li>n..z / N..Z → resta 13.</li>
</ul>
</li>
<li>Si no es letra, lo deja igual.</li>
</ul>
</li>
<li>Devuelve el puntero a la nueva cadena transformada.</li>
</ul>
<h5 id="encabezado-de-funci%C3%B3n-rot13"><strong>Encabezado de función rot13</strong></h5>
<pre class="hljs"><code><div>                         **************************************************************
                         *                          FUNCTION                          *
                         **************************************************************
                         undefined rot13()
         undefined         &lt;UNASSIGNED&gt;   &lt;RETURN&gt;
         undefined4        Stack[-0x8]:4  local_8                                 XREF[1]:     000112e8(R)  
         undefined4        Stack[-0x10]:4 local_10                                XREF[14]:    0001126a(W), 
                                                                                               0001126f(R), 
                                                                                               00011279(R), 
                                                                                               00011283(R), 
                                                                                               0001128d(R), 
                                                                                               00011297(R), 
                                                                                               000112a1(R), 
                                                                                               000112ab(R), 
                                                                                               000112b5(R), 
                                                                                               000112c0(R), 
                                                                                               000112c7(R), 
                                                                                               000112d2(R), 
                                                                                               000112d7(RW), 
                                                                                               000112db(R)  
         undefined4        Stack[-0x14]:4 local_14                                XREF[5]:     00011249(W), 
                                                                                               0001124c(R), 
                                                                                               0001125c(R), 
                                                                                               00011267(R), 
                                                                                               000112e5(R)  
                         rot13                                           XREF[4]:     Entry Point(*), main:000113a7(c), 
                                                                                      00012054, 00012110(*)  
</div></code></pre>
<p>donde:</p>
<ul>
<li>Se muestra el resumen de la función que el decompilador ha detectado:
<ul>
<li>Nombre y punto de entrada: <code>rot13()</code> aparece como función y además está referenciada desde el Entry Point y desde main: El programa llama a rot13 en algún momento del flujo principal.</li>
<li>Tipo undefined <code>rot13()</code>: el analizador no está seguro del tipo de retorno. Es por ello que no lo ha tipado.</li>
</ul>
</li>
<li>Variables locales (stack) que se ven:
<ul>
<li><code>local_14</code> en <code>Stack[-0x14]</code>. Tiene pocas referencias (5). Suele ser una variable “base”, por ejemplo un puntero o un valor inicial que luego se reutiliza.</li>
<li><code>local_10</code> en <code>Stack[-0x10]</code>. Tiene muchas referencias (14) repartidas por toda la función, incluyendo lecturas y escrituras. Esto normalmente indica que es la variable “de trabajo” principal: por ejemplo un contador de bucle o un puntero que se va incrementando mientras recorre una cadena/buffer.</li>
<li><code>local_8</code> en <code>Stack[-0x8</code>. Solo aparece una vez (lectura al final). Suele ser un temporal usado en una comprobación final o para preparar algo justo antes de retornar.</li>
</ul>
</li>
</ul>
<div style="page-break-before: always;"></div>
<h5 id="pr%C3%B3logo-de-la-funcion-rot13"><strong>Prólogo de la funcion rot13</strong></h5>
<pre class="hljs"><code><div>    0001120d 55              PUSH       EBP
    0001120e 89 e5           MOV        EBP,ESP
    00011210 53              PUSH       EBX
    00011211 83 ec 14        SUB        ESP,0x14
</div></code></pre>
<p>donde:</p>
<ul>
<li><code>PUSH EBP</code>: Guarda el valor anterior del registro EBP en la pila.</li>
<li><code>MOV EBP, ESP</code>: Establece el marco de pila de la función: a partir de aquí, EBP se usa como referencia estable para acceder a variables locales y parámetros.</li>
<li><code>PUSH EBX</code>: Guarda EBX porque la función lo va a usar y, por convención, debe restaurarlo antes de volver (registro “callee-saved”).</li>
<li><code>SUB ESP, 0x14</code>: Reserva 0x14 bytes (20 bytes) en la pila para variables locales/temporales.</li>
</ul>
<h5 id="c%C3%B3mo-accede-el-programa-a-sus-datos-globales"><strong>Cómo accede el programa a sus datos globales</strong></h5>
<pre class="hljs"><code><div>00011214 e8 f7 fe        CALL       __x86.get_pc_thunk.bx                            undefined __x86.get_pc_thunk.bx()
         ff ff
00011219 81 c3 e7        ADD        EBX,0x2de7
</div></code></pre>
<p>donde:</p>
<ul>
<li><code>CALL __x86.get_pc_thunk.bx</code> ➡ Se inicializa EBX para código posición-independiente (PIC). Lo que hace es copiar la dirección de retorno en EBX. Es decir: al volver de la llamada, EBX contiene la dirección de la siguiente instrucción. Llama a una rutina auxiliar que normalmente carga en EBX un valor relacionado con la dirección actual del código (PC). Esto es muy común en binarios compilados como PIC/PIE (código independiente de posición), para poder calcular direcciones de datos o constantes usando EBX como base.</li>
<li><code>ADD EBX,0x2de7</code> ➡ Suma un desplazamiento constante a ese valor:
<ul>
<li>EBX = (dirección actual de código) + 0x2de7.</li>
</ul>
</li>
</ul>
<p>Como el ejecutable está compilado como código posición-independiente (PIC), significa que:</p>
<ul>
<li>No puede usar direcciones absolutas “hardcodeadas” a datos globales.</li>
<li>En su lugar, obtiene la dirección actual de código (con get_pc_thunk) y le suma un offset fijo para llegar a la base de su tabla de datos.</li>
<li>A partir de ahí, accede a cadenas y variables globales como DAT_0001202b (&quot;KEY&quot;) o envkey (&quot;HOLAKASE&quot;) usando desplazamientos respecto a EBX.</li>
</ul>
<div style="page-break-before: always;"></div>
<h5 id="comprobaci%C3%B3n-inicial-y-una-salida-temprana-de-la-funci%C3%B3n"><strong>Comprobación inicial y una salida temprana de la función</strong></h5>
<pre class="hljs"><code><div>0001121f 83 7d 08 00     CMP        dword ptr [EBP + Stack[0x4]],0x0
00011223 75 0a           JNZ        LAB_0001122f
00011225 b8 00 00        MOV        EAX,0x0
         00 00
0001122a e9 b9 00        JMP        LAB_000112e8
         00 00
</div></code></pre>
<p>donde:</p>
<ul>
<li><code>CMP dword ptr [EBP + 0x8], 0x0</code>: Compara el valor del primer argumento de la función que está en <code>[EBP+8]</code> con <code>NULL / 0</code>. Aquí está comprobando si el puntero/parámetro que le han pasado es cero.</li>
<li><code>JNZ LAB_0001122f</code>: Si no es cero (es decir, el parámetro es válido), salta a LAB_0001122f para continuar con la lógica principal.</li>
<li><code>MOV EAX, 0x0</code>: En caso de que sea cero, pone <code>EAX = 0</code>. Esto suele ser el valor de retorno, o un código de estado.</li>
<li><code>JMP LAB_000112e8</code>: Salta al final de la función (epílogo/return). Es la ruta de salida temprana.</li>
</ul>
<h5 id="preparaci%C3%B3n-de-llamada-a-strlen-e-invocaci%C3%B3n-para-obtener-la-longitud-del-texto-de-entrada"><strong>Preparación de llamada a strlen e invocación para obtener la longitud del texto de entrada</strong></h5>
<pre class="hljs"><code><div>                         LAB_0001122f                                    XREF[1]:     00011223(j)  
    0001122f 83 ec 0c        SUB        ESP,0xc
    00011232 ff 75 08        PUSH       dword ptr [EBP + Stack[0x4]]
    00011235 e8 56 fe        CALL       &lt;EXTERNAL&gt;::strlen                               size_t strlen(char * __s)
             ff ff
</div></code></pre>
<p>donde:</p>
<ul>
<li><code>LAB_0001122f</code>: Etiqueta a la que se salta cuando el parámetro no era NULL.</li>
<li><code>SUB ESP, 0x0c</code>: Reserva 12 bytes en la pila antes de la llamada.</li>
<li><code>PUSH dword ptr [EBP + 0x8]</code>: Empuja el primer argumento de la función, probablemente un char *, o el puntero a la cadena, como parámetro para strlen.</li>
<li><code>CALL strlen</code>: Llama a la función externa <code>strlen(char *s)</code>, que devuelve en <code>EAX</code> la longitud de la cadena (hasta el byte <code>\0</code>).</li>
</ul>
<div style="page-break-before: always;"></div>
<h5 id="gesti%C3%B3n-de-la-pila-tras-strlen-y-luego-reserva-memoria-din%C3%A1mica-con-malloc-usando-esa-longitud"><strong>Gestión de la pila tras <code>strlen</code> y luego reserva memoria dinámica con <code>malloc</code> usando esa longitud</strong></h5>
<pre class="hljs"><code><div>    0001123a 83 c4 10        ADD        ESP,0x10
    0001123d 83 ec 0c        SUB        ESP,0xc
    00011240 50              PUSH       EAX
    00011241 e8 1a fe        CALL       &lt;EXTERNAL&gt;::malloc                               void * malloc(size_t __size)
             ff ff
</div></code></pre>
<p>donde:</p>
<ul>
<li><code>ADD ESP, 0x10</code>: Limpia/recupera espacio de la pila tras la llamada anterior.</li>
<li><code>SUB ESP, 0x0c</code>: Vuelve a reservar 12 bytes en la pila. Otra vez para alineación/preparación de la siguiente llamada.</li>
<li><code>PUSH EAX</code>: Empuja como argumento el valor que está en <code>EAX</code>. Dado que <code>EAX</code> viene de <code>strlen</code>, aquí está pasando a malloc el tamaño a reservar, la longitud de la cadena.</li>
<li><code>CALL malloc</code>: Llama a <code>malloc(size)</code>. El puntero devuelto queda en <code>EAX</code>.</li>
</ul>
<h5 id="gesti%C3%B3n-del-resultado-de-malloc-comprobaci%C3%B3n-de-errores-y-si-todo-va-bien-copia-la-cadena-original-al-nuevo-buffer"><strong>Gestión del resultado de malloc. Comprobación de errores y, si todo va bien, copia la cadena original al nuevo buffer</strong></h5>
<pre class="hljs"><code><div>    00011246 83 c4 10        ADD        ESP,0x10
    00011249 89 45 f0        MOV        dword ptr [EBP + local_14],EAX
    0001124c 83 7d f0 00     CMP        dword ptr [EBP + local_14],0x0
    00011250 0f 84 8f        JZ         LAB_000112e5
             00 00 00
    00011256 83 ec 08        SUB        ESP,0x8
    00011259 ff 75 08        PUSH       dword ptr [EBP + Stack[0x4]]
    0001125c ff 75 f0        PUSH       dword ptr [EBP + local_14]
    0001125f e8 dc fd        CALL       &lt;EXTERNAL&gt;::strcpy                               char * strcpy(char * __dest, cha
             ff ff
</div></code></pre>
<p>donde:</p>
<ul>
<li><code>ADD ESP, 0x10</code>: Limpia la pila tras la llamada a malloc.</li>
<li><code>MOV [EBP + local_14], EAX</code>: Guarda en <code>local_14</code> el puntero devuelto por malloc (<code>EAX</code>). Es decir, <code>local_14</code> pasa a ser el buffer recién reservado.</li>
<li><code>CMP [EBP + local_14], 0x0 / JZ LAB_000112e5</code>: Comprueba si malloc devolvió NULL. Si es NULL, salta a una ruta de salida/gestión de error (LAB_000112e5).</li>
<li><code>SUB ESP, 0x8</code>: Reserva 8 bytes para preparar la siguiente llamada.</li>
<li><code>PUSH [EBP + 0x8]</code>: Empuja el primer argumento original: puntero a la cadena fuente.</li>
<li><code>PUSH [EBP + local_14]</code>: Empuja el puntero destino: el buffer reservado.</li>
<li><code>CALL strcpy</code>: Copia la cadena fuente en el destino: <code>strcpy(dest, src)</code>.</li>
</ul>
<div style="page-break-before: always;"></div>
<h5 id="preparaci%C3%B3n-simple-de-variables-y-salto-al-inicio-de-un-bucle"><strong>Preparación simple de variables y salto al inicio de un bucle</strong></h5>
<pre class="hljs"><code><div>    00011264 83 c4 10        ADD        ESP,0x10
    00011267 8b 45 f0        MOV        EAX,dword ptr [EBP + local_14]
    0001126a 89 45 f4        MOV        dword ptr [EBP + local_10],EAX
    0001126d eb 6c           JMP        LAB_000112db
</div></code></pre>
<p>donde:</p>
<ul>
<li><code>ADD ESP, 0x10</code>: Limpia la pila tras la llamada a <code>strcpy</code>, ya se habían empujado argumentos y reservado espacio antes de llamar.</li>
<li><code>MOV EAX, [EBP + local_14]</code>: Carga en <code>EAX</code> el valor de <code>local_14</code>, que por el contexto anterior es el puntero al buffer recién reservado y ya copiado, la cadena que se va a transformar.</li>
<li><code>MOV [EBP + local_10], EAX</code>: Guarda ese puntero en <code>local_10</code>.</li>
<li><code>JMP LAB_000112db</code>: Salta a una etiqueta más adelante. Esto es típico de la estructura de un while/for, donde se salta primero a la comprobación de condición del bucle y luego se entra al cuerpo si procede.</li>
</ul>
<h5 id="bucle-sobre-la-cadena"><strong>Bucle sobre la cadena</strong></h5>
<pre class="hljs"><code><div>LAB_000112db:
000112db 8b 45 f4           MOV  EAX,[EBP + local_10] ; p
000112de 0f b6 00           MOVZX EAX,byte ptr [EAX]  ; *p
000112e1 84 c0              TEST AL,AL
000112e3 75 8a              JNZ  LAB_0001126f         ; mientras *p != 0
</div></code></pre>
<p>donde:</p>
<ul>
<li>Se recorre una cadena de texto.</li>
<li>Representan la condición de control de un bucle <code>while</code> o <code>for</code>.</li>
<li>La función está comprobando si ha llegado al final de la cadena. Si hay una letra, vuelve al cuerpo del bucle para transformarla; si encuentra el cero final, el bucle termina y la función continúa con las siguientes instrucciones.</li>
</ul>
<h5 id="la-l%C3%B3gica-del-algoritmo-rot13"><strong>La lógica del Algoritmo ROT13</strong></h5>
<pre class="hljs"><code><div>                         LAB_0001126f                                    XREF[1]:     000112e3(j)  
    0001126f 8b 45 f4        MOV        EAX,dword ptr [EBP + local_10]
    00011272 0f b6 00        MOVZX      EAX,byte ptr [EAX]
    00011275 3c 60           CMP        AL,0x60
    00011277 7e 0a           JLE        LAB_00011283
    00011279 8b 45 f4        MOV        EAX,dword ptr [EBP + local_10]
    0001127c 0f b6 00        MOVZX      EAX,byte ptr [EAX]
    0001127f 3c 7a           CMP        AL,0x7a
    00011281 7e 14           JLE        LAB_00011297
                         LAB_00011283                                    XREF[1]:     00011277(j)  
    00011283 8b 45 f4        MOV        EAX,dword ptr [EBP + local_10]
    00011286 0f b6 00        MOVZX      EAX,byte ptr [EAX]
    00011289 3c 40           CMP        AL,0x40
    0001128b 7e 4a           JLE        LAB_000112d7
    0001128d 8b 45 f4        MOV        EAX,dword ptr [EBP + local_10]
    00011290 0f b6 00        MOVZX      EAX,byte ptr [EAX]
    00011293 3c 5a           CMP        AL,0x5a
    00011295 7f 40           JG         LAB_000112d7
                         LAB_00011297                                    XREF[1]:     00011281(j)  
    00011297 8b 45 f4        MOV        EAX,dword ptr [EBP + local_10]
    0001129a 0f b6 00        MOVZX      EAX,byte ptr [EAX]
    0001129d 3c 6d           CMP        AL,0x6d
    0001129f 7f 14           JG         LAB_000112b5
    000112a1 8b 45 f4        MOV        EAX,dword ptr [EBP + local_10]
    000112a4 0f b6 00        MOVZX      EAX,byte ptr [EAX]
    000112a7 3c 4d           CMP        AL,0x4d
    000112a9 7e 1c           JLE        LAB_000112c7
    000112ab 8b 45 f4        MOV        EAX,dword ptr [EBP + local_10]
    000112ae 0f b6 00        MOVZX      EAX,byte ptr [EAX]
    000112b1 3c 5a           CMP        AL,0x5a
    000112b3 7f 12           JG         LAB_000112c7
</div></code></pre>
<p>donde:</p>
<ul>
<li>El filtro de minúsculas (<code>LAB_0001126f</code>): Aquí el programa intenta determinar si el carácter está entre la 'a' <code>(0x61)</code> y la 'z' <code>(0x7a)</code>.
<ul>
<li><code>CMP AL, 0x60</code>: Compara con el carácter previo a la 'a'. Si es menor o igual (<code>JLE</code>), salta a <code>LAB_00011283</code> para ver si es mayúscula.</li>
<li><code>CMP AL, 0x7a</code>: Si sobrevivió al primer filtro, comprueba si es menor o igual a 'z'. Si lo es (<code>JLE</code>), salta a <code>LAB_00011297</code> para rotarlo.</li>
</ul>
</li>
<li>El filtro de mayúsculas (L<code>AB_00011283</code>): Si no fue minúscula, entra aquí para buscar el rango 'A' <code>(0x41)</code> a 'Z' <code>(0x5a)</code>.
<ul>
<li><code>CMP AL, 0x40</code>: Si es menor o igual a @, salta a <code>LAB_000112d7</code> (no es una letra, se ignora).</li>
<li><code>CMP AL, 0x5a</code>: Si es mayor a 'Z' (<code>JG</code>), también salta a <code>LAB_000112d7</code>.</li>
</ul>
</li>
<li>La decisión de rotación (<code>LAB_00011297</code>): Esta es la parte más interesante. Para que el ROT13 funcione, las letras de la primera mitad del alfabeto se &quot;adelantan&quot; 13 puestos y las de la segunda mitad se &quot;atrasan&quot; 13.
<ul>
<li>Caso Minúsculas Altas: Compara con <code>0x6d </code>('m'). Si el carácter es mayor (<code>JG</code>), salta a <code>LAB_000112b5</code> (donde seguramente se ejecuta un <code>SUB AL, 0x0d</code>).</li>
<li>Caso Mayúsculas Bajas: Compara con <code>0x4d</code> ('M'). Si es menor o igual (<code>JLE</code>), salta a <code>LAB_000112c7</code> (don de se ejecutará un <code>ADD AL, 0x0d</code>).</li>
<li>Última validación: La instrucción en <code>000112b3</code> (<code>JG LAB_000112c7</code>) es un seguro adicional para enviar las mayúsculas restantes a la zona de suma.</li>
</ul>
</li>
</ul>
<div style="page-break-before: always;"></div>
<h5 id="operaci%C3%B3n-de-la-resta-necesaria-para-el-cifrado--descifrado"><strong>Operación de la resta necesaria para el cifrado / descifrado</strong></h5>
<pre class="hljs"><code><div>                         LAB_000112b5                                    XREF[1]:     0001129f(j)  
    000112b5 8b 45 f4        MOV        EAX,dword ptr [EBP + local_10]
    000112b8 0f b6 00        MOVZX      EAX,byte ptr [EAX]
    000112bb 83 e8 0d        SUB        EAX,0xd
    000112be 89 c2           MOV        EDX,EAX
    000112c0 8b 45 f4        MOV        EAX,dword ptr [EBP + local_10]
    000112c3 88 10           MOV        byte ptr [EAX],DL
    000112c5 eb 10           JMP        LAB_000112d7
</div></code></pre>
<p>donde:</p>
<ul>
<li>Este bloque de código realiza la operación de resta necesaria para el cifrado/descifrado ROT13. Se ejecuta específicamente cuando el programa determina que el carácter es una letra que se encuentra en la &quot;segunda mitad&quot; del alfabeto (por ejemplo, de la 'n' a la 'z' o de la 'N' a la 'Z').</li>
</ul>
<h5 id="lee-un-car%C3%A1cter"><strong>Lee un carácter</strong></h5>
<pre class="hljs"><code><div>                         LAB_000112c7                                    XREF[2]:     000112a9(j), 000112b3(j)  
    000112c7 8b 45 f4        MOV        EAX,dword ptr [EBP + local_10]
    000112ca 0f b6 00        MOVZX      EAX,byte ptr [EAX]
    000112cd 83 c0 0d        ADD        EAX,0xd
    000112d0 89 c2           MOV        EDX,EAX
    000112d2 8b 45 f4        MOV        EAX,dword ptr [EBP + local_10]
    000112d5 88 10           MOV        byte ptr [EAX],DL
</div></code></pre>
<p>donde:</p>
<ul>
<li><code>MOVZX EAX,byte ptr [EAX]</code>: Lee el byte, el carácter, de la dirección de memoria.</li>
<li><code>ADD EAX,0xd</code>: Aquí está la clave del algoritmo ROT13. <code>0xd</code> es <code>13</code> en hexadecimal. Le suma 13 posiciones al carácter.</li>
<li><code>MOV byte ptr [EAX],DL</code>: Guarda el resultado, <code>DL</code>, la parte baja de <code>EDX</code>, en la misma dirección de memoria (<code>[EAX]</code>), modificando la cadena original.</li>
<li>En resumen: Se lee un carácter, se le suma 13, y se escribe de vuelta en el mismo buffer, usando <code>local_10</code> como puntero al carácter actual. En el flujo completo de la función, normalmente este bloque se ejecuta sólo cuando el carácter está en un rango que permite la rotación.</li>
</ul>
<div style="page-break-before: always;"></div>
<h5 id="avance-y-condici%C3%B3n-del-bucle-que-recorre-la-cadena-car%C3%A1cter-a-car%C3%A1cter"><strong>Avance y condición del bucle que recorre la cadena carácter a carácter</strong></h5>
<pre class="hljs"><code><div>                         LAB_000112d7                                    XREF[3]:     0001128b(j), 00011295(j), 
                                                                                      000112c5(j)  
    000112d7 83 45 f4 01     ADD        dword ptr [EBP + local_10],0x1
                         LAB_000112db                                    XREF[1]:     0001126d(j)  
    000112db 8b 45 f4        MOV        EAX,dword ptr [EBP + local_10]
    000112de 0f b6 00        MOVZX      EAX,byte ptr [EAX]
    000112e1 84 c0           TEST       AL,AL
    000112e3 75 8a           JNZ        LAB_0001126f
</div></code></pre>
<p>donde:</p>
<ul>
<li><code>ADD dword ptr [EBP + local_10],0x1</code>: Incrementa el contador o puntero en 1. Es el equivalente a i++ o ptr++. Pasa al siguiente carácter.</li>
<li><code>MOVZX EAX,byte ptr [EAX]</code>: Lee el carácter que hay en esa nueva posición.</li>
<li><code>TEST AL,AL</code>: Comprueba si el carácter leído es <code>0</code>, el byte nulo <code>\0</code> que marca el final de los textos en C.</li>
<li><code>JNZ LAB_0001126f</code>: Jump if Not Zero, Salta si no es cero. Si el carácter no es el final de la cadena, salta de nuevo al principio (<code>LAB_0001126f</code>) para procesar la siguiente letra.</li>
<li>En resumen: Avanza el puntero a la siguiente posición de memoria y verifica si ha llegado al final de la cadena, el carácter nulo, para decidir si debe repetir el bucle.</li>
</ul>
<h5 id="ep%C3%ADlogo-de-la-funci%C3%B3n-rot13"><strong>Epílogo de la función rot13</strong></h5>
<p>Este bloque final representa el epílogo de la función rot13. Su objetivo es limpiar el entorno de trabajo (la pila o stack), restaurar los registros que el programa estaba usando y devolver el control a la función que la llamó, main.</p>
<pre class="hljs"><code><div>                         LAB_000112e5                                    XREF[1]:     00011250(j)  
    000112e5 8b 45 f0        MOV        EAX,dword ptr [EBP + local_14]
                         LAB_000112e8                                    XREF[1]:     0001122a(j)  
    000112e8 8b 5d fc        MOV        EBX,dword ptr [EBP + local_8]
    000112eb c9              LEAVE
    000112ec c3              RET
</div></code></pre>
<p>donde:</p>
<ul>
<li>Preparación del Valor de Retorno (LAB_000112e5 ): <code>MOV EAX, dword ptr [EBP + local_14]</code>: El registro EAX se utiliza por convención en x86 para almacenar el valor que una función devuelve. Aquí, el programa carga una variable local en EAX. En el contexto de rot13, esto suele ser el puntero a la cadena ya procesada.</li>
<li>Restauración de Registros y Limpieza (LAB_000112e8)
<ul>
<li><code>MOV EBX, dword ptr [EBP + local_8]</code>: Antes de terminar, la función restaura el valor original del registro EBX que guardó al principio. Esto es una &quot;norma de cortesía&quot; en programación: si una función usa ciertos registros, debe devolverlos como los encontró para no romper la lógica de la función principal.</li>
<li><code>LEAVE</code>: Es una instrucción de alto nivel que simplifica dos pasos: deshace el marco de la pila (<code>MOV ESP, EBP</code>) y restaura el puntero base anterior (<code>POP EBP</code>). Básicamente, &quot;recoge&quot; todo lo que la función usó en la memoria temporal.</li>
</ul>
</li>
<li>El Retorno Final: <code>RET</code>: Finaliza la ejecución de la función y salta de vuelta a la siguiente instrucción en main.</li>
</ul>
<h2 id="nota-curiosa-aplicamos-reglas-capa-al-ejercicio"><strong>Nota curiosa: Aplicamos Reglas Capa al ejercicio</strong></h2>
<p><img src="capturas/capa-ejercicio6.png" alt="capa-ejercicio6">
donde:</p>
<ul>
<li>La dirección <code>0x1120D</code> es el inicio de rot13. En rot13 hay claramente un bucle que recorre la cadena carácter a carácter.
<ul>
<li>Las reglas de capa tienen una regla muy genérica “contain loop” que se dispara cuando detecta características de bucle (saltos condicionales hacia atrás, etc.).</li>
</ul>
</li>
<li>Capa detecta que el binario consulta variables de entorno: <code>getenv(&quot;KEY&quot;)</code>.</li>
<li>Capa detecta <code>terminate process</code>. Capa ha encontrado varias llamadas a exit.</li>
<li>Consultar variable de entorno → típico en malware para leer configuración / entorno.</li>
<li>Terminar proceso con exit en varios puntos → coincide con reglas genéricas de “terminate process”.</li>
<li>Bucle sobre datos → característica típica de transformaciones, cifrados, etc. (ROT13 en tu caso).</li>
<li>Por eso capa saca etiquetas como:
<ul>
<li>host-interaction/environment-variable</li>
<li>host-interaction/process/terminate</li>
<li>Discovery::System Information Discovery [T1082]</li>
<li>Process::Terminate Process [C0018]</li>
</ul>
</li>
</ul>
<div style="page-break-before: always;"></div>
<hr>
<h1 id="ejercicio-2"><strong>Ejercicio 2</strong></h1>
<p>Babuk es un ransomware. El código fuente está disponible en el siguiente repositorio: https://github.com/Hildaboo/BabukRansomwareSourceCode</p>
<h2 id="tarea-1-ejercicio-2"><strong>Tarea 1. Ejercicio 2</strong></h2>
<p>Una de las características del malware es que ejecuta una rutina o función que detiene ciertos procesos.</p>
<ul>
<li>Localizad el código de la función (de nuevo, NO DONDE ES LLAMADA).</li>
<li>Realizad un análisis de código de la función.</li>
<li>Enumerar los procesos que tiene en cuenta esta función para que sean detenenidos.</li>
<li>Documentad profusamente el proceso que habéis realizado. Cuanto más detallada (en calidad) esté hecho el análisis mayor será la puntuación.</li>
</ul>
<p><img src="capturas/ransomware-babuk.png" alt="ransomware-babuk"></p>
<hr>
<h3 id="crear-una-bd-simb%C3%B3lica-con-global"><strong>Crear una BD simbólica con Global</strong></h3>
<p>Vamos a usar:</p>
<ul>
<li>Global.</li>
<li>VS Code con las extensiones C/C++ de Microsoft y Go.</li>
</ul>
<pre class="hljs"><code><div>sudo apt install global
gtags
</div></code></pre>
<p>donde:</p>
<ul>
<li>Instalamos global.</li>
<li><code>gtags</code>: Se generan 3 archivos: GTAGS, GRTAGS, GPATH.
<img src="capturas/M3-T2-Ej2-1.png" alt="M3-T2-Ej2-1"></li>
</ul>
<hr>
<h3 id="mostrar-un-recuento-de-entradas-en-la-base-de-datos-de-global"><strong>Mostrar un recuento de entradas en la base de datos de Global</strong></h3>
<pre class="hljs"><code><div>usuario@usuario-1-2:~/global -c
ARGS_H
BABUK_FILEMETA
BABUK_KEYS
BABUK_SESSION
BLKSIZE
BUILD
CONST_BLOCK_MINUS
CONST_BLOCK_PLUS
CONST_LARGE_FILE
CONST_MEDIUM_FILE
CRC32_H_INCLUDED
Ch
....
....
IsWow64
MALLOC
MGF1_ERROR_BASE
Maj
_decrypt_file
_encrypt_file
_halloc
_hfree
_load_hidden_partitions
_mem_initialize
_memcpy
_memset
_processDrive
_que_initialize
_que_pop
_que_push
_remove_shadows
_stop_processes  *******************************************
_stop_services
....
....
writeD
writeE
writeK
xcrc32
xor
</div></code></pre>
<p>donde:</p>
<ul>
<li>Obtenemos un listado de símbolos indexados (funciones, macros, etc.).</li>
<li>En ese listado aparece un candidato muy claro para hacer el objetivo que indica el ejercicio ➡ &quot;detiene ciertos procesos del sistema | detiene su propia ejecución&quot; ➡ <code>_stop_processes</code>.</li>
</ul>
<p><strong>Símbolos de interés para: Control del sistema y evasión:</strong></p>
<ul>
<li><code>_stop_processes</code>: terminación de procesos. ************************************************</li>
<li><code>_stop_services</code>: parada de servicios.</li>
<li><code>_remove_shadows</code>: típico anti-forense para eliminar Shadow Copies / VSS y dificultar recuperación.</li>
<li><code>VERSION_MUTEX</code>: indicador de mutex para control de instancia única. Evalúa si ya se está ejecutando.</li>
<li><code>IsWow64</code>: detección de entorno WOW64 (arquitectura), a veces usada para selección de payload o evasión.</li>
<li><code>_dbg_initialize</code>, <code>_dbg_report</code>, <code>_dbg_uninitialize</code>, <code>__H_DEBUG_</code>: funciones/macros de debug/telemetría interna; pueden delatar flags de compilación o rutas alternativas.</li>
</ul>
<p><strong>Símbolos de interés para: Cifrado y generación de material criptográfico:</strong></p>
<ul>
<li><code>_encrypt_file</code>, <code>_decrypt_file</code>: pipeline directo de cifrado/descifrado de ficheros.</li>
<li><code>generate_keystream</code>, <code>ECRYPT_* (ctx, init, keysetup, ivsetup, encrypt/decrypt_*)</code>: uso de un cifrado tipo stream (o framework ECRYPT) para cifrar datos.</li>
<li><code>BABUK_KEYS</code>, <code>BABUK_SESSION</code>, <code>BABUK_FILEMETA</code>: estructuras/estado de claves, sesión y metadatos por archivo.</li>
<li><code>et_entropy</code>, <code>ENTROPY_CMD</code>, <code>HMAC_DRBG_*</code>, <code>SHA256_HMAC_DRBG</code>, <code>DRBG_*</code>: obtención de entropía y DRBG, crítico para nonces/keys.</li>
<li><code>NTRU_*</code> y variantes <code>NTRU_EES*</code>: indica criptografía <code>NTRU</code> que es habitual para envolver/transportar claves simétricas.</li>
<li><code>curve25519_donna</code>: curva elíptica (<code>Curve25519</code>) para acuerdo de claves/cripto asimétrica.</li>
<li><code>SHA512_*</code>: hashing (derivación, integridad, etc.).</li>
</ul>
<p><strong>Símbolos de interés para: Descubrimiento y selección de ficheros/objetivos:</strong></p>
<ul>
<li><code>find_files_recursive</code>, <code>find_paths_recursive</code>, <code>find_files_network</code>: lógica de búsqueda/recorrido (local y red). Define el alcance real del cifrado.</li>
<li><code>find_needle</code>: utilitario de búsqueda, a menudo usado para localizar extensiones, patrones o marcadores.</li>
<li><code>_processDrive</code>: procesamiento por unidad/drive; normalmente enlaza con enumeración de volúmenes y posterior cifrado.</li>
</ul>
<p><strong>Símbolos de interés para: Infraestructura interna / coordinación:</strong></p>
<ul>
<li><code>QUEUE</code>, <code>_que_initialize</code>, <code>_que_push</code>, <code>_que_pop</code>, <code>QUEUE_ERR_TIMEOUT</code>: cola interna (hilos/productor-consumidor), muy útil para entender paralelismo y rendimiento del cifrado.</li>
<li><code>_mem_initialize</code>, <code>_memcpy</code>, <code>_memset</code>: gestión de memoria.</li>
</ul>
<p><strong>Símbolos de interés para: Flujo de ejecución:</strong></p>
<ul>
<li><code>main</code>, <code>entry</code>: puntos de entrada: Ayudan a mapear la secuencia de etapas.</li>
</ul>
<hr>
<h3 id="localizar-el-c%C3%B3digo-de-la-funci%C3%B3n"><strong>Localizar el código de la función</strong></h3>
<p>El ejercicio nos pide: &quot;Localizar el código de la función (NO dónde se llama)”, para ello le vamos a pedir a Global que nos lleve a la definición del símbolo y nos diga archivo + línea.</p>
<pre class="hljs"><code><div>global -x _stop_processes
_stop_processes   208 Babyk/another.cpp void _stop_processes() {
</div></code></pre>
<p>donde:</p>
<ul>
<li><code>-x</code> hace que, además de la ruta, nos muestra el número de línea y el contenido de la línea.</li>
<li>Símbolo: <code>_stop_processes</code>.</li>
<li>Archivo: <code>Babyk/another.cpp</code></li>
<li>Línea: <code>208</code>.</li>
<li>Inicio del cuerpo: <code>void _stop_processes() {</code></li>
</ul>
<p><strong>Abrimos exactamente esa ruta y línea en VS</strong>
<img src="capturas/M3-T2-Ej2-2.png" alt="M3-T2-Ej2-2"></p>
<hr>
<h3 id="ver-todas-las-referencias-a-la-funci%C3%B3n-stop-processes"><strong>Ver todas las referencias a la función stop processes</strong></h3>
<p>Aunque el ejercicio dice explícitamente que &quot;no se pide donde se llama a _stop_processes”, sólo por curiosidad:</p>
<pre class="hljs"><code><div>global -rx _stop_processes
_stop_processes     7 Babyk/another.h  void _stop_processes();
_stop_processes   590 Babyk/entry.cpp          _stop_processes();
</div></code></pre>
<p>donde:</p>
<ul>
<li>Vemos que la función <code>_stop_processes</code> es llamada en <code>entry.cpp</code>.</li>
</ul>
<hr>
<div style="page-break-before: always;"></div>
<h3 id="an%C3%A1lisis-de-la-funci%C3%B3n"><strong>Análisis de la función</strong></h3>
<pre class="hljs"><code><div>void _stop_processes() {
    HANDLE hSnapShot = CreateToolhelp32Snapshot(TH32CS_SNAPALL, 0);
    PROCESSENTRY32W pEntry;
    pEntry.dwSize = sizeof(pEntry);
    BOOL hRes = Process32FirstW(hSnapShot, &amp;pEntry);
    while (hRes)
    {
        for (int i = 0; i &lt; _countof(processes_to_stop); i++) {
            if (lstrcmpW(processes_to_stop[i], pEntry.szExeFile) == 0) {
                HANDLE hProcess = OpenProcess(PROCESS_TERMINATE, 0, (DWORD)pEntry.th32ProcessID);
                if (hProcess != NULL)
                {
                    TerminateProcess(hProcess, 9);
                    CloseHandle(hProcess);
                }
                break;
            }
        }
        hRes = Process32NextW(hSnapShot, &amp;pEntry);
    }
    CloseHandle(hSnapShot);
}
</div></code></pre>
<p>donde:</p>
<ul>
<li>Obtiene una snapshot del sistema para poder enumerar procesos: <code>HANDLE hSnapShot = CreateToolhelp32Snapshot(TH32CS_SNAPALL, 0);</code></li>
<li>Inicializa la estructura de enumeración:
<ul>
<li><code>PROCESSENTRY32W pEntry;</code></li>
<li><code>pEntry.dwSize = sizeof(pEntry);</code></li>
<li>Esto es imprescindible para que <code>Process32FirstW / Process32NextW</code> funcionen.</li>
</ul>
</li>
<li>Empieza a enumerar procesos:
<ul>
<li><code>BOOL hRes = Process32FirstW(hSnapShot, &amp;pEntry);</code></li>
<li><code>while (hRes) { ...; hRes = Process32NextW(hSnapShot, &amp;pEntry); }</code></li>
<li>Recorre todos los procesos visibles en el snapshot.</li>
</ul>
</li>
<li>Compara el nombre del ejecutable de cada proceso contra una lista:<pre class="hljs"><code><div>for (int i = 0; i &lt; _countof(processes_to_stop); i++) {
  if (lstrcmpW(processes_to_stop[i], pEntry.szExeFile) == 0) {
      ...
      break;
  }
}
</div></code></pre>
<ul>
<li><code>pEntry.szExeFile</code>: Contiene el nombre del ejecutable. Uso de <code>wide string</code>.</li>
<li><code>processes_to_stop</code>: Es un array con los nombres objetivo. ***********************************************</li>
<li><code>lstrcmpW(...) == 0</code>: Implica coincidencia exacta y case-sensitive.</li>
</ul>
</li>
<li>Si hay match (coincidencia), intenta terminar el proceso<pre class="hljs"><code><div>HANDLE hProcess = OpenProcess(PROCESS_TERMINATE, 0, (DWORD)pEntry.th32ProcessID);
if (hProcess != NULL) {
    TerminateProcess(hProcess, 9);
    CloseHandle(hProcess);
}
</div></code></pre>
<ul>
<li>Abre el proceso con permiso <code>PROCESS_TERMINATE</code>.</li>
<li>Llama a <code>TerminateProcess</code> con código de salida <code>9</code> que es terminación abrupta.</li>
<li>Cierra el handle.</li>
<li>Si <code>OpenProcess</code> falla (por permisos, procesos protegidos, etc.), no lo mata y sigue.</li>
</ul>
</li>
<li>Cierra el snapshot: <code>CloseHandle(hSnapShot);</code>.</li>
</ul>
<hr>
<h3 id="apis-de-windows-que-usa-esta-funci%C3%B3n"><strong>APIs de Windows que usa esta función</strong></h3>
<p>Resumen de APIS de windows que usa para &quot;detener ciertos procesos del sistema | detener su propia ejecución&quot;:</p>
<ul>
<li><code>CreateToolhelp32Snapshot</code>: El malware llama a esta función para obtener una &quot;fotografía&quot; o enumeración de todos los procesos que se están ejecutando en el sistema en ese instante.</li>
<li><code>Process32FirstW</code> / <code>Process32NextW</code>: Estas funciones permiten al malware &quot;caminar&quot; por esa fotografía. Comienza con el primer proceso y va saltando al siguiente en un bucle do-while.</li>
<li>Comparación de nombres: Dentro del bucle, el malware compara el nombre del proceso actual con cada uno de los nombres de la lista <code>processes_to_stop</code>.</li>
<li><code>OpenProcess</code>. Si encuentra una coincidencia, usa esta API para obtener permisos de &quot;limpieza&quot; o acceso al proceso usando su ID (PID).</li>
<li><code>TerminateProcess</code>. Es la ejecución final. Una vez tiene el permiso (<code>handle</code>), le ordena al kernel de Windows cerrar el proceso inmediatamente</li>
</ul>
<hr>
<h3 id="l%C3%B3gica-de-esta-funci%C3%B3n"><strong>Lógica de esta función</strong></h3>
<p>Esta función toma un snapshot de todos los procesos del sistema con la <code>API Toolhelp</code>, recorre uno a uno cada proceso y compara su nombre (<code>szExeFile</code>) con los nombres almacenados en una lista estática <code>processes_to_stop</code>. Si encuentra coincidencia, abre el proceso con privilegio de terminación (<code>OpenProcess con PROCESS_TERMINATE</code>) y lo finaliza mediante <code>TerminateProcess</code>, cerrando después el <code>handle</code>. A continuación continúa la enumeración con <code>Process32NextW</code> hasta agotar todos los procesos y al final, libera el snapshot con <code>CloseHandle</code>, consiguiendo así detener selectivamente los procesos considerados “objetivo” por el ransomware.</p>
<hr>
<div style="page-break-before: always;"></div>
<h3 id="enumeraci%C3%B3n-de-los-procesos-que-tiene-en-cuenta-esta-funci%C3%B3n"><strong>Enumeración de los procesos que tiene en cuenta esta función</strong></h3>
<p>La lista de los procesos que tiene en cuenta esta función para que sean detenidos, está referenciada como <code>processes_to_stop</code>. Debemos localizar la definición de ese array ya que, ahí estarán los nombres de procesos.</p>
<pre class="hljs"><code><div>global -x processes_to_stop
</div></code></pre>
<p>Pero no devuelve nada, Parece que Global no lo ha indexado como un Símbolo. Probablemente no es una función ni una variable global que gtags haya considerado lo suficientemente importante como para indexar como <code>punto de entrada</code>.</p>
<p>Hacemos una búsqueda tipo grep:</p>
<pre class="hljs"><code><div>global -g processes_to_stop
Babyk/another.cpp
</div></code></pre>
<p>donde:</p>
<ul>
<li><code>-g</code>: Le indica a Global que ignore el índice de símbolos y realice una búsqueda de expresión regular en todo el texto del proyecto.</li>
<li>Archivo: <code>Babyk/another.cpp</code>. Resulta que la lista de los procesos a detener está en el mismo archivo, un poco más arriba.</li>
<li>Línea: <code>10</code>.</li>
</ul>
<p><img src="capturas/M3-T2-Ej2-3.png" alt="capturas/M3-T2-Ej2-3"></p>
<div style="page-break-before: always;"></div>
<pre class="hljs"><code><div>static const WCHAR* processes_to_stop[] = { L&quot;sql.exe&quot;, L&quot;oracle.exe&quot;, L&quot;ocssd.exe&quot;, L&quot;dbsnmp.exe&quot;, L&quot;synctime.exe&quot;, 
L&quot;agntsvc.exe&quot;, L&quot;isqlplussvc.exe&quot;, L&quot;xfssvccon.exe&quot;, L&quot;mydesktopservice.exe&quot;, L&quot;ocautoupds.exe&quot;, L&quot;encsvc.exe&quot;, 
L&quot;firefox.exe&quot;, L&quot;tbirdconfig.exe&quot;, L&quot;mydesktopqos.exe&quot;, L&quot;ocomm.exe&quot;, L&quot;dbeng50.exe&quot;, L&quot;sqbcoreservice.exe&quot;, 
L&quot;excel.exe&quot;, L&quot;infopath.exe&quot;, L&quot;msaccess.exe&quot;, L&quot;mspub.exe&quot;, L&quot;onenote.exe&quot;, L&quot;outlook.exe&quot;, L&quot;powerpnt.exe&quot;, 
L&quot;steam.exe&quot;, L&quot;thebat.exe&quot;, L&quot;thunderbird.exe&quot;, L&quot;visio.exe&quot;, L&quot;winword.exe&quot;, L&quot;wordpad.exe&quot;, L&quot;notepad.exe&quot; };
</div></code></pre>
<p>En el sistema operativo Windows, cuando un proceso tiene un archivo abierto, el SO impone un bloqueo de escritura. Por ejemplo, si el ransomware intentara cifrar un archivo de base de datos mientras sql.exe o bien, oracle.exe mientras están activos, la operación fallará con un error de &quot;Acceso Denegado&quot;. Al finalizar forzosamente estos procesos mediante la lista <code>processes_to_stop</code>, el malware garantiza que estos archivos sean sobrescritos por el algoritmo de cifrado.</p>
<div style="page-break-before: always;"></div>
<h2 id="tarea-2-ejercicio-2"><strong>Tarea 2. Ejercicio 2</strong></h2>
<p>Aquí (https://github.com/Hildaboo/BabukRansomwareSourceCode/blob/main/nas/enc/main.go#L810), se encuentra la función “main” del código del cifrador escrito en Go de la versión para dispositivos NAS de Babuk.</p>
<p>Esa función representa el punto de entrada del ejecutable. Dicho ejecutable es el que utilizan los cibercriminales para cifrar un sistema. Es decir, explotan un sistema, filtran el ejecutable y este se encarga de ir cifrando todos los archivos de la víctima en ese sistema.</p>
<p>Comentad el funcionamiento de la función referenciada con todo el detalle posible. Si no entendéis algunas partes saltadlas y proseguid o al menos comentad....</p>
<p>Código: https://github.com/Hildaboo/BabukRansomwareSourceCode/blob/main/nas/enc/main.go#L810</p>
<hr>
<h3 id="entendiendo-qu%C3%A9-pide-el-ejercicio"><strong>Entendiendo qué pide el ejercicio</strong></h3>
<p>Parece que tenemos que realizar una revisión de código fuente de la pieza central del ransomware Babuk en su versión para sistemas de almacenamiento en red (NAS), específicamente la escrita en el lenguaje de programación Go.</p>
<p>El enlace dado en el ejercicio apunta a <code>nas/enc/main.go</code>, en la <code>línea 810</code>, está la función <code>main()</code> del cifrador para dispositivos NAS:</p>
<pre class="hljs"><code><div>func main() {
	var notesize = 0
	for i := 0; i &lt; 8192; i++ {
		if notebytes[i] == 0x00 {
			notesize = i + 1
			break
		}
	}

	var queue_max = runtime.GOMAXPROCS(0) * 2
	var queue_counter = 0

	var note = make([]byte, notesize)
	for i := 0; i &lt; notesize; i++ {
		note[i] = notebytes[i]
	}

	if len(os.Args) == 2 {
		var wg sync.WaitGroup

		err := filepath.Walk(os.Args[1], func(path string, info os.FileInfo, err error) error {
			if err != nil {
				return err
			}
			if info.IsDir() == false {
				if strings.Contains(info.Name(), &quot;.babyk&quot;) == false &amp;&amp; info.Name() != &quot;README_babyk.txt&quot; {
					fmt.Printf(&quot;Pushing to queue: %s\n&quot;, path)

					if queue_counter &gt;= queue_max {
						wg.Wait()
						queue_counter = 0
					}
					wg.Add(1)
					go encrypt_file(&amp;wg, path)
					queue_counter += 1
				}
			} else {
				if strings.Contains(info.Name(), &quot;/proc&quot;) ||
					strings.Contains(path, &quot;/boot&quot;) ||
					strings.Contains(path, &quot;/sys&quot;) ||
					strings.Contains(path, &quot;/run&quot;) ||
					strings.Contains(path, &quot;/dev&quot;) ||
					strings.Contains(path, &quot;/etc&quot;) ||
					strings.Contains(path, &quot;/home/httpd&quot;) ||
					strings.Contains(path, &quot;.system/thumbnail&quot;) ||
					strings.Contains(path, &quot;.system/opt&quot;) ||
					strings.Contains(path, &quot;.config&quot;) ||
					strings.Contains(path, &quot;.qpkg&quot;) ||
					strings.Contains(path, &quot;/mnt/ext/opt&quot;) {
					return filepath.SkipDir
				}

				ioutil.WriteFile(path+&quot;/README_babyk.txt&quot;, note, 0777)
			}
			return nil
		})
		if err != nil {
			fmt.Println(err)
		}

		wg.Wait()
	} else {
		fmt.Printf(&quot;%s /path/to/be/encrypted\n&quot;, os.Args[0])
	}
}
</div></code></pre>
<p>Esta función main actúa como el motor principal del cifrador Babuk para sistemas NAS, encargándose de orquestar el proceso de infección mediante la <code>concurrencia nativa de Go</code>. El código comienza preparando la nota de rescate (README_babyk.txt) en memoria y calculando un límite de hilos de ejecución, basado en el doble de núcleos de CPU disponibles, para maximizar la velocidad de destrucción sin bloquear el sistema.</p>
<p>Una vez configurado, realiza un recorrido recursivo por el directorio objetivo, donde aplica:</p>
<ul>
<li>Esquiva carpetas críticas del sistema (como /proc, /etc o /sys) para evitar que el dispositivo deje de funcionar antes de completar el ataque.</li>
<li>Deposita la nota de rescate en cada carpeta y lanza <code>goroutines</code> para cifrar archivos de forma paralela (<code>go encrypt_file</code>), utilizando un grupo de espera (<code>sync.WaitGroup</code>) para garantizar que el programa no termine hasta que el último archivo haya sido procesado.</li>
</ul>
<hr>
<h3 id="entendiendo-que-es-goroutine"><strong>Entendiendo que es Goroutine</strong></h3>
<ul>
<li>Una goroutine es una “tarea concurrente” muy ligera en Go, parecida a un hilo, pero más barata y gestionada por el runtime de Go.</li>
<li>Qué hace en la práctica
<ul>
<li>Si llamamoss una función normal: el programa espera a que termine antes de seguir.</li>
<li>Si la llamamos con go delante: esa función se ejecuta en paralelo (concurrentemente) y el programa puede seguir haciendo otras cosas.</li>
</ul>
</li>
<li>En este main, usa este concepto de goroutine en:
<ul>
<li><code>go encrypt_file(&amp;wg, path)</code>.</li>
<li>Significa: “empieza a cifrar ese archivo en segundo plano mientras el programa sigue recorriendo más archivos”.</li>
<li>Se usa para cifrar muchos archivos a la vez y acelerar el proceso, en vez de cifrarlos uno por uno.</li>
</ul>
</li>
<li>Cómo se evita que el programa termine demasiado pronto:
<ul>
<li>Como las goroutines corren “por detrás”, main usa un <code>sync.WaitGroup (wg)</code> y llama a <code>wg.Wait()</code> para esperar a que todas las goroutines acaben antes de salir.</li>
</ul>
</li>
</ul>
<hr>
<h3 id="variables-y-estado-inicial-para-la-nota"><strong>Variables y estado inicial para la nota</strong></h3>
<ul>
<li>
<p><code>notesize</code>:</p>
<pre class="hljs"><code><div>var notesize = 0
for i := 0; i &lt; 8192; i++ {
    if notebytes[i] == 0x00 {
        notesize = i + 1
        break
    }
}
</div></code></pre>
<p>donde:</p>
<ul>
<li>Ese bloque calcula cuántos bytes de notebytes se van a usar para construir la nota de rescate (<code>note</code>).</li>
<li>Inicializa el tamaño: <code>var notesize = 0</code>. Aún no sabe cuánto mide la nota.</li>
<li>Recorre notebytes buscando un terminador:
<ul>
<li><code>for i := 0; i &lt; 8192; i++ { ... }</code>.</li>
<li>Recorre desde i = 0 hasta i = 8191.</li>
<li>Ese 8192 es un límite fijo: está asumiendo que notebytes tiene al menos 8192 posiciones.</li>
</ul>
</li>
<li>Detecta el final de la nota: <code>if notebytes[i] == 0x00 { ... }</code>:
<ul>
<li><code>0x00</code> es el byte NUL, cero.</li>
<li>En muchos formatos estilo C, las cadenas se almacenan como bytes y terminan con un <code>0x00</code> para marcar hasta dónde llega el texto.</li>
</ul>
</li>
<li>Fija <code>notesize</code> e incluye el byte NUL: <code>notesize = i + 1</code>:
<ul>
<li>Si el <code>0x00</code> está en la posición <code>i</code>, el tamaño “útil” que va a copiar será <code>i+1</code> bytes.</li>
<li>Eso incluye el propio <code>0x00</code> como último byte.</li>
<li>Con ese <code>i + 1</code>, preserva el terminador, como si quisieran mantener el formato <code>string terminada en NUL</code>.</li>
<li>Ejemplo: si la nota es <code>HELLO</code> y en bytes fuera <code>H E L L O 0x00 ...</code>, el <code>0x00</code> estaría en <code>i=5</code>, entonces <code>notesize=6</code>, y se copiaría <code>HELLO\0</code>.</li>
</ul>
</li>
<li>Sale del bucle al encontrarlo:
<ul>
<li><code>break</code></li>
<li>En cuanto encuentra el primer <code>0x00</code>, deja de buscar.</li>
<li>Esto evita seguir recorriendo y asegura que usa el primer terminador como <code>fin</code> de la nota.</li>
</ul>
</li>
<li>Si NO encuentra ningún <code>0x00</code> en esos 8192 bytes:
<ul>
<li><code>notesize</code> se queda en <code>0</code>.</li>
<li>Luego, como el código hace <code>note := make([]byte, notesize)</code>, acabaría creando un slice vacío y escribiría una nota vacía, con cero bytes en disco.</li>
</ul>
</li>
</ul>
</li>
<li>
<p><code>queue_max</code>: Límite de concurrencia por lote; calculado como <code>runtime.GOMAXPROCS(0) * 2</code>.</p>
</li>
<li>
<p><code>queue_counter</code>: Contador de tareas encoladas en el lote actual; usado para aplicar el límite de <code>queue_max</code>.</p>
</li>
<li>
<p><code>note</code>:</p>
<pre class="hljs"><code><div>var note = make([]byte, notesize)
for i := 0; i &lt; notesize; i++ {
    note[i] = notebytes[i]
}
</div></code></pre>
<p>donde:</p>
<ul>
<li>Ese fragmento crea el buffer real que se va a escribir como nota de rescate y copia dentro el contenido desde notebytes.</li>
<li><code>var note = make([]byte, notesize)</code>:
<ul>
<li>Crea un slice de bytes (<code>[]byte</code>) llamado <code>note</code>.</li>
<li>Tiene longitud exacta <code>notesize</code>.</li>
<li>Todos sus bytes empiezan en <code>0x00</code> por defecto, pero en seguida se van a sobrescribir.</li>
</ul>
</li>
<li>Copia byte a byte desde <code>notebytes</code>: <code>for i := 0; i &lt; notesize; i++ { .... }</code>:
<ul>
<li>Recorre <code>i</code> desde <code>0</code> hasta <code>notesize-1</code>.</li>
<li>Para cada posición, copia el byte correspondiente de <code>notebytes</code> hacia <code>note</code>.</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<div style="page-break-before: always;"></div>
<h3 id="configuraci%C3%B3n-y-estado-inicial"><strong>Configuración y estado inicial</strong></h3>
<ul>
<li>
<p><code>notesize</code>: se inicializa a <code>0</code> y luego se recorre <code>notebytes</code> hasta el primer <code>0x00</code>. Al encontrarlo, se fija <code>notesize = i + 1</code> y se rompe el bucle. Esto implica que el tamaño incluye el byte nulo terminal.</p>
</li>
<li>
<p><code>queue_max</code>:</p>
<pre class="hljs"><code><div>var queue_max = runtime.GOMAXPROCS(0) * 2
</div></code></pre>
<p>donde:</p>
<ul>
<li>Propósito: establecer un límite de paralelismo para el cifrado.</li>
<li>Qué representa: <code>runtime.GOMAXPROCS(0)</code> devuelve el número de hilos OS que Go permite ejecutar simultáneamente. Al multiplicarlo por 2 define un umbral agresivo pero acotado de goroutines de cifrado en vuelo.</li>
<li>Configuración derivada del entorno: depende de la configuración del runtime (y potencialmente de <code>GOMAXPROCS</code> si estuviera ajustado externamente).</li>
</ul>
</li>
<li>
<p><code>queue_counter</code></p>
<pre class="hljs"><code><div>var queue_counter = 0
</div></code></pre>
<p>donde:</p>
<ul>
<li>Propósito: contador local de tareas lanzadas en el “lote” actual.</li>
<li>Uso posterior: cuando alcanza <code>queue_max</code>, el programa hace <code>wg.Wait()</code> y reinicia a <code>0</code> para continuar en el siguiente lote.</li>
<li>Implicación: es un control de concurrencia por batches, no es una cola real, sino un contador + barrera.</li>
</ul>
</li>
<li>
<p><code>wg</code> (WaitGroup)</p>
<pre class="hljs"><code><div>var wg sync.WaitGroup
</div></code></pre>
<p>donde:</p>
<ul>
<li>Propósito: estado de sincronización para esperar a que terminen todas las goroutines <code>encrypt_file</code>.</li>
<li>Se usa como estado global práctico: aunque sea local a main, se pasa por puntero a <code>encrypt_file(&amp;wg, path)</code>, de modo que la función de cifrado debe llamar a <code>wg.Done()</code> al finalizar (o equivalente).</li>
<li>Función en el flujo: garantiza que el proceso no termina hasta completar el cifrado de todos los ficheros encolados.</li>
</ul>
</li>
</ul>
<hr>
<h3 id="los-argumentos-flagsargs"><strong>Los Argumentos (Flags/Args)</strong></h3>
<p>En este main() la gestión de argumentos es mínima ya que sólo acepta una ruta como argumento y no hay flags opcionales.​</p>
<p><strong>Fuente de argumentos: os.Args</strong></p>
<ul>
<li><code>os.Args[0]</code>: Nombre del ejecutable invocado.</li>
<li><code>os.Args[1]</code>: Único argumento esperado, que representa la ruta que se va a cifrar.</li>
</ul>
<p><strong>Validación: solo por número de argumentos</strong></p>
<pre class="hljs"><code><div>if len(os.Args) == 2 {
   ...
   ...
} else {
  fmt.Printf(&quot;%s /path/to/be/encrypted\n&quot;, os.Args[0])
}
</div></code></pre>
<p>donde:</p>
<ul>
<li>Condición de ejecución “válida”: <code>len(os.Args) == 2 (programa + 1 parámetro)</code>.</li>
<li>Si no se cumple:
<ul>
<li>No cifra nada.</li>
<li>Solo imprime un mensaje de uso con el formato: <code>&lt;ejecutable&gt; /path/to/be/encrypted</code></li>
</ul>
</li>
<li>No hay validación semántica previa; se delega a <code>filepath.Walk(os.Args[1], ...)</code>. Cualquier error devuelto por <code>Walk</code> o por la función visitor se imprime.</li>
<li>No hay flags ni modos alternativos: No existe <code>-h</code>, <code>--help</code>, <code>-q</code>, <code>--threads</code>, etc.</li>
</ul>
<hr>
<div style="page-break-before: always;"></div>
<h3 id="prepara-sincronizaci%C3%B3n-de-goroutines"><strong>Prepara sincronización de goroutines</strong></h3>
<pre class="hljs"><code><div>....
	if len(os.Args) == 2 {
		var wg sync.WaitGroup

		err := filepath.Walk(os.Args[1], func(path string, info os.FileInfo, err error) error {
			if err != nil {
				return err
			}
			if info.IsDir() == false {
				if strings.Contains(info.Name(), &quot;.babyk&quot;) == false &amp;&amp; info.Name() != &quot;README_babyk.txt&quot; {
					fmt.Printf(&quot;Pushing to queue: %s\n&quot;, path)

					if queue_counter &gt;= queue_max {
						wg.Wait()
						queue_counter = 0
					}
					wg.Add(1)
					go encrypt_file(&amp;wg, path)
					queue_counter += 1
				}
			} 
.....
</div></code></pre>
<p>donde:</p>
<ul>
<li>
<p>Modelo de Concurrencia: <code>var wg sync.WaitGroup</code>:</p>
<ul>
<li>Un <code>WaitGroup</code> es un contador de trabajos pendientes.</li>
<li>Cada vez que se lanza una goroutine para cifrar un archivo, el programa hace <code>wg.Add(1)</code>.</li>
<li>La goroutine, dentro de <code>encrypt_file</code>) debería hacer <code>wg.Done()</code> al terminar.</li>
<li><code>wg.Wait()</code> bloquea hasta que el contador vuelva a <code>0</code>.</li>
</ul>
</li>
<li>
<p>Recorre recursivamente la ruta indicada: <code>err := filepath.Walk(os.Args[1], func(path string, info os.FileInfo, err error) error { ... })</code></p>
<ul>
<li><code>filepath.Walk</code> recorre todo el árbol desde la ruta raíz <code>os.Args[1]</code>.</li>
<li>Para cada archivo/carpeta, llama al callback con:
<ul>
<li>path: ruta completa del elemento encontrado.</li>
<li>info: metadata (nombre, si es directorio, etc.).</li>
<li>err: error si no se pudo acceder a esa entrada.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Propaga errores de acceso: <code>if err != nil { return err }</code>:</p>
<ul>
<li>Si <code>Walk</code> encuentra un problema al leer una entrada, permisos, enlaces rotos, etc., el callback devuelve ese error.</li>
<li>Eso hace que <code>filepath.Walk</code> interrumpa el recorrido y devuelva el error al final (<code>a err := ...</code>).</li>
<li>Ojo: esto es un <code>fail fast</code>: ante el primer error serio, DEJA DE FUNCIONAR.</li>
</ul>
</li>
<li>
<p>Solo actúa sobre archivos, no directorios, en esta rama: <code>if info.IsDir() == false { ... }</code></p>
<ul>
<li>Aquí se procesan archivos; el siguiente bloque else (que analizaremos después) manejará directorios, nota de rescate, exclusiones...</li>
</ul>
</li>
<li>
<p>Filtra qué archivos encolar: <code>if strings.Contains(info.Name(), &quot;.babyk&quot;) == false &amp;&amp; info.Name() != &quot;README_babyk.txt&quot; { ... }</code></p>
<ul>
<li><code>info.Name()</code> es el nombre base del archivo.</li>
<li>Excluye:
<ul>
<li>Archivos que ya contienen .babyk en el nombre (muy probablemente “ya cifrados” / ya procesados).</li>
<li>README_babyk.txt para no cifrar la nota de rescate que el propio programa escribe.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Encola el cifrado y controla la carga, por lotes: <code>fmt.Printf(&quot;Pushing to queue: %s\n&quot;, path)</code></p>
<ul>
<li><code>Log</code>: imprime qué archivo va a procesar.</li>
<li>Control de límite: <code>if queue_counter &gt;= queue_max { wg.Wait(); queue_counter = 0 }</code>
<ul>
<li><code>queue_max</code> se calculó como <code>GOMAXPROCS*2</code>: límite de trabajos simultáneos por lote.</li>
<li>Cuando llega al máximo, espera a que terminen todos los cifrados lanzados hasta ese momento y reinicia el contador.</li>
</ul>
</li>
<li>Lanzamiento:
<ul>
<li><code>wg.Add(1)</code>.</li>
<li><code>go encrypt_file(&amp;wg, path)</code> → lanza una goroutine que cifra ese archivo.</li>
<li><code>queue_counter += 1</code>.</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<div style="page-break-before: always;"></div>
<h3 id="exclusi%C3%B3n-de-ciertos-directorios-y-la-nota"><strong>Exclusión de ciertos directorios y la Nota</strong></h3>
<pre class="hljs"><code><div>else {
				if strings.Contains(info.Name(), &quot;/proc&quot;) ||
					strings.Contains(path, &quot;/boot&quot;) ||
					strings.Contains(path, &quot;/sys&quot;) ||
					strings.Contains(path, &quot;/run&quot;) ||
					strings.Contains(path, &quot;/dev&quot;) ||
					strings.Contains(path, &quot;/etc&quot;) ||
					strings.Contains(path, &quot;/home/httpd&quot;) ||
					strings.Contains(path, &quot;.system/thumbnail&quot;) ||
					strings.Contains(path, &quot;.system/opt&quot;) ||
					strings.Contains(path, &quot;.config&quot;) ||
					strings.Contains(path, &quot;.qpkg&quot;) ||
					strings.Contains(path, &quot;/mnt/ext/opt&quot;) {
					return filepath.SkipDir
				}

				ioutil.WriteFile(path+&quot;/README_babyk.txt&quot;, note, 0777)
			}
</div></code></pre>
<p>donde:</p>
<ul>
<li>
<p>Es la rama que se ejecuta cuando el elemento actual del recorrido sí es un directorio (<code>info.IsDir() == true</code>). Tiene dos responsabilidades:</p>
<ul>
<li>(1) decidir si se salta el directorio completo, y</li>
<li>(2) si no se salta, escribir la nota de rescate dentro.</li>
</ul>
</li>
<li>
<p>Lista de exclusión de directorios:</p>
<ul>
<li>Este <code>if strings.Contains(...) || ... { return filepath.SkipDir }</code> actúa como lista negra. Si el directorio actual coincide con cualquiera de esas condiciones, devuelve <code>filepath.SkipDir</code>.</li>
<li><code>filepath.SkipDir</code> no es un error fatal: es una señal especial para <code>filepath.Walk</code> que significa:
<ul>
<li>No entres a este directorio y</li>
<li>No recorras nada que cuelgue de él,</li>
<li>pero continúa con el resto del recorrido fuera de ese subárbol.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Qué rutas intenta excluir y por qué</p>
<ul>
<li><code>strings.Contains(path, &quot;/boot&quot;), &quot;/sys&quot;, &quot;/run&quot;, &quot;/dev&quot;, &quot;/etc&quot;</code>: Son rutas típicas de sistema / virtuales / arranque / configuración en Linux. Tocarlas puede romper el sistema o dar muchos errores de permisos.</li>
<li><code>strings.Contains(path, &quot;/home/httpd&quot;)</code>: Suele ser un directorio de servicio web, excluirlo puede ser para evitar tumbar servicios.</li>
<li><code>strings.Contains(path, &quot;.system/thumbnail&quot;), &quot;.system/opt&quot;, &quot;.qpkg&quot;, &quot;/mnt/ext/opt&quot;</code>: En entornos tipo NAS/appliance, son carpetas del sistema / paquetes / opt extendido.</li>
<li><code>strings.Contains(path, &quot;.config&quot;)</code>: Evita directorios de configuración (p. ej. <code>~/.config</code>). Esto puede reducir miles de ficheros pequeños o evitar romper configuración.</li>
</ul>
</li>
<li>
<p>Detalle importante: la condición de <code>proc</code> está mal planteada:</p>
<ul>
<li><code>strings.Contains(info.Name(), &quot;/proc&quot;)</code> probablemente no funciona como se espera.</li>
<li><code>info.Name()</code> normalmente devuelve solo el nombre base del directorio (ej. proc), no una ruta con barras.</li>
<li>Buscar <code>/proc</code> dentro de <code>info.Name()</code> casi nunca coincidirá.</li>
<li>Si querían excluir <code>proc</code>, lo correcto sería comprobar <code>path</code>, como hacen con el resto.</li>
</ul>
</li>
<li>
<p>Riesgo/efecto colateral de usar <code>strings.Contains</code>: No comprueba “ruta exacta”, solo “subcadena”. Por ejemplo:</p>
<ul>
<li>Un directorio llamado <code>/data/etc_backup</code> contiene <code>/etc</code> → sería excluido aunque no sea <code>etc</code>.</li>
<li>Cualquier ruta con <code>.config</code> en medio sería excluida.</li>
<li>Esto puede causar exclusiones “accidentales”.</li>
</ul>
</li>
<li>
<p>Escritura de la nota de rescate: Si NO se activó la exclusión, ejecuta: <code>ioutil.WriteFile(path+&quot;/README_babyk.txt&quot;, note, 0777)</code>:</p>
<ul>
<li>Crea (o sobrescribe) el archivo <code>README_babyk.txt</code> dentro del directorio actual (<code>path</code>).</li>
<li>Escribe como contenido el buffer <code>note</code>, que antes se copió desde <code>notebytes</code>.</li>
<li>Usa permisos <code>0777</code>. Intención: que cualquiera pueda leerlo/escribirlo/ejecutarlo; en la práctica el sistema puede recortarlo con <code>umask</code>.</li>
</ul>
</li>
<li>
<p>Nota: No comprueba el <code>error</code> devuelto por <code>WriteFile</code>. Si falla por permisos, FS read-only, etc., el programa no lo registra y sigue.</p>
</li>
</ul>
<hr>
<div style="page-break-before: always;"></div>
<h3 id="cierre-del-recorrido-y-sincronizaci%C3%B3n-final"><strong>Cierre del recorrido y sincronización final</strong></h3>
<pre class="hljs"><code><div>....
....
return nil
		})
		if err != nil {
			fmt.Println(err)
		}

		wg.Wait()
	} else {
		fmt.Printf(&quot;%s /path/to/be/encrypted\n&quot;, os.Args[0])
	}
</div></code></pre>
<p>donde:</p>
<ul>
<li>
<p><code>return nil</code>: (dentro del callback de <code>filepath.Walk</code>):</p>
<ul>
<li>Ese <code>return nil</code> es el valor de retorno de la función callback que <code>Walk</code> ejecuta por cada entrada (archivo o directorio).</li>
<li>En <code>filepath.Walk</code>, el callback devuelve:
<ul>
<li><code>nil</code> → todo ok con esta entrada, sigue el recorrido.</li>
<li><code>filepath.SkipDir</code> → salta este directorio (y su contenido).</li>
<li>cualquier otro error → detén el recorrido y propaga este error.</li>
</ul>
</li>
<li>En este caso, después de procesar la entrada (o ignorarla), devuelve <code>nil</code> para continuar.</li>
</ul>
</li>
<li>
<p><code>})</code>: Cierre de la función y fin del <code>Walk</code>:</p>
<ul>
<li>Aquí termina la definición del callback y también la llamada completa: <code>err := filepath.Walk(os.Args[1], callback)</code>.</li>
<li>Cuando <code>Walk</code> termina, <code>err</code> contendrá:
<ul>
<li><code>nil</code> si recorrió todo sin errores.</li>
<li>un <code>error</code> si el callback devolvió un error.</li>
<li>Importante: <code>SkipDir</code> no se considera un error fatal.</li>
</ul>
</li>
</ul>
</li>
<li>
<p><code>if err != nil { fmt.Println(err) }</code>:</p>
<ul>
<li>Si <code>Walk</code> terminó con error, el programa lo imprime en <code>stdout/stderr</code>. Aaquí es <code>fmt.Println</code>, normalmente stdout.</li>
<li>No reintenta, no acumula errores, no continúa el recorrido, y no fuerza salida con <code>os.Exit(1)</code>.</li>
<li>O sea: manejo de errores mínimo = Log y seguir con la fase de cierre.</li>
</ul>
</li>
<li>
<p><code>wg.Wait()</code>: Eespera final de cifrados.</p>
<ul>
<li>Este <code>wg.Wait()</code> es clave, ya que garantiza que el programa no sale hasta que hayan terminado todas las goroutines lanzadas con <code>go encrypt_file(&amp;wg, path)</code>.</li>
<li>Aunque <code>Walk</code> haya terminado, con éxito o con error, puede haber goroutines aún cifrando archivos. Este <code>Wait()</code> las drena.</li>
</ul>
</li>
<li>
<p><code>} else { fmt.Printf(&quot;%s /path/to/be/encrypted\n&quot;, os.Args[0]) }</code>:</p>
<ul>
<li>Esta rama es para cuando <code>len(os.Args) != 2</code>.</li>
<li>No intenta cifrar nada ni recorrer directorios.</li>
<li>Solo imprime la forma correcta de ejecutar el binario, un mensaje de ayuda/uso.</li>
<li>Después main termina y el proceso finaliza.</li>
</ul>
</li>
</ul>
<hr>
<h3 id="resumen-del-modelo-de-concurrencia"><strong>Resumen del Modelo de Concurrencia</strong></h3>
<ul>
<li>Usa <code>sync.WaitGroup</code> para coordinar la finalización de goroutines que llaman <code>encrypt_file(&amp;wg, path)</code>. Se asume que <code>encrypt_file()</code> hace <code>wg.Done()</code> al terminar.</li>
<li><code>queue_counter</code> se incrementa por cada archivo encolado y se compara con <code>queue_max</code>:
<ul>
<li>Cuando <code>queue_counter &gt;= queue_max</code>, llama <code>wg.Wait()</code>: Espera a que terminen todas las goroutines en vuelo y luego reinicia <code>queue_counter = 0.</code></li>
</ul>
</li>
<li>Patrón aplicado: procesamiento por lotes. Se lanzan hasta <code>queue_max</code> goroutines, se espera a que todas terminen, y se continúa con el siguiente lote. Esto limita la carga simultánea y evita desborde de goroutines/CPU.</li>
<li>Al final del recorrido (<code>Walk</code>), se hace un <code>wg.Wait()</code> adicional para garantizar que no queden tareas pendientes antes de salir.</li>
</ul>
<hr>
<h3 id="resumen-de-la-l%C3%B3gica-de-exclusi%C3%B3n"><strong>Resumen de la Lógica de Exclusión</strong></h3>
<ul>
<li>Para archivos:
<ul>
<li>Omite aquellos cuyo nombre contiene <code>.babyk</code> (probable extensión de archivos ya cifrados).</li>
<li>Omite el archivo <code>README_babyk.txt</code> (la propia nota de rescate), para no re-procesarlo.</li>
</ul>
</li>
<li>Para directorios:
<ul>
<li>Si el path contiene alguno de: <code>boot, sys, run, dev, etc, /home/httpd, .system/thumbnail, .system/opt, .config, .qpkg, /mnt/ext/opt</code> → retorna <code>filepath.SkipDir</code>: Se salta el subárbol completo.</li>
</ul>
</li>
<li>Motivación de exclusión: proteger rutas del sistema y de runtime (<code>proc/sys/run/dev/etc</code>) que son críticas, virtuales o de difícil manejo, y evitar carpetas de servicios/appliances (<code>httpd, .qpkg</code>, etc.), minimizando riesgo de bloqueo del sistema y errores de permisos. También evita re-cifrar y re-escribir notas.</li>
</ul>
<hr>
<h3 id="resumen-de-las-acciones-del-sistema"><strong>Resumen de las Acciones del Sistema</strong></h3>
<ul>
<li>Creación de notas de rescate: en cada directorio no excluido, escribe <code>README_babyk.txt</code> con permisos <code>0777</code> usando <code>ioutil.WriteFile(path+&quot;/README_babyk.txt&quot;, note, 0777)</code>. El contenido proviene de <code>note</code>, copiado de <code>notebytes</code>.</li>
<li>Recorrido de directorios: <code>filepath.Walk</code> itera de forma recursiva sobre <code>os.Args[1]</code>. Para cada entrada:
<ul>
<li>Si es archivo y no está excluido, se encola para cifrado en una goroutine.</li>
<li>Si es directorio y no está excluido, se deposita la nota de rescate en ese directorio y se continúa el recorrido.</li>
<li>Si el directorio coincide con las rutas/sufijos excluidos, se retorna <code>filepath.SkipDir</code> para saltar el subárbol completo.</li>
</ul>
</li>
</ul>
<hr>
<h3 id="resumen-de-la-inicializaci%C3%B3n-criptogr%C3%A1fica"><strong>Resumen de la Inicialización Criptográfica</strong></h3>
<p>El ransomware necesita llaves para cifrar. Observaremos si la función main genera una llave nueva, si carga una llave pública &quot;embebida&quot; en el código, o si llama a otras funciones para preparar el cifrado (como el intercambio de llaves Curve25519).</p>
<p>En main, no hay inicialización criptográfica real, sólo disparo/encolado del cifrado vía <code>encrypt_file</code>.</p>
<p>Este main no crea ni configura ningún <code>cipher</code>, no deriva claves, no inicializa <code>PRNG/semillas</code>, ni carga llaves desde disco/red.</p>
<p>Lo único directamente conectado con el cifrado es que, al encontrar un archivo válido, lanza una goroutine que llama a <code>encrypt_file(&amp;wg, path)</code>. Es decir: main actúa como orquestador que seleciona objetivos + concurrencia, y la criptografía real (algoritmo, clave, IV, modo, etc.) necesariamente vive dentro de <code>encrypt_file </code>o en variables/globales usadas por esa función.</p>
<hr>
<h3 id="resumen-de-la-l%C3%B3gica-de-cifrado"><strong>Resumen de la Lógica de Cifrado</strong></h3>
<ul>
<li>
<p>El cifrado no ocurre en main directamente: main delega a <code>encrypt_file(&amp;wg, path)</code> para cada archivo elegible.</p>
</li>
<li>
<p>Cada vez que encuentra un archivo que pasa los filtros, hace:</p>
<ul>
<li><code>wg.Add(1)</code></li>
<li><code>go encrypt_file(&amp;wg, path)</code> → esto crea una goroutine (hilo ligero) por archivo.</li>
<li><code>queue_counter += 1</code></li>
</ul>
</li>
<li>
<p>Resultado: Intenta cifrar muchos archivos en paralelo, pero con un límite.</p>
</li>
<li>
<p>Cómo recorre carpetas</p>
<ul>
<li>Usa <code>filepath.Walk(os.Args[1], callback)</code>, que hace un recorrido recursivo del árbol de directorios desde la ruta raíz que le pasas como argumento.</li>
<li>En el callback:
<ul>
<li>Si <code>info.IsDir() == false</code>: es archivo → potencialmente se encola para cifrado.</li>
<li>Si es directorio: puede saltarse el directorio completo con <code>filepath.SkipDir</code>, o si no, escribe la nota y sigue entrando en sus subdirectorios.</li>
</ul>
</li>
<li>No implementa recursividad, la recursión la hace <code>filepath.Walk internamente</code>.</li>
</ul>
</li>
<li>
<p>El “bucle” y el límite de concurrencia, para evitar saturar.</p>
<ul>
<li><code>queue_max := runtime.GOMAXPROCS(0) * 2</code> define cuántas goroutines permite por lote (aprox. 2× CPUs lógicas).</li>
<li>Antes de lanzar una nueva goroutine, chequea:
<ul>
<li>Si <code>queue_counter &gt;= queue_max</code> → hace <code>wg.Wait()</code> y reinicia <code>queue_counter = 0</code>.</li>
</ul>
</li>
<li>Esto crea un patrón por “bloques”:
<ul>
<li>Lanza hasta <code>queue_max</code> cifrados concurrentes.</li>
<li>Espera a que todos terminen.</li>
<li>Continúa con el siguiente bloque.</li>
</ul>
</li>
<li>Al finalizar el <code>Walk</code>, hace un <code>wg.Wait()</code> final para asegurarse de que no queden goroutines pendientes.</li>
</ul>
</li>
<li>
<p>Filtros directos que afectan el cifrado</p>
<ul>
<li>Solo encola archivos cuyo nombre:
<ul>
<li>NO contiene <code>.babyk</code>, es una marca de “ya cifrado”.</li>
<li>NO es <code>README_babyk.txt</code> ,la nota de rescate que él mismo crea.</li>
</ul>
</li>
<li>Esto evita re-procesar salidas propias y reduce ciclos/errores.</li>
</ul>
</li>
</ul>
<hr>
<h3 id="resumen-sobre-la-nota-de-rescate"><strong>Resumen sobre La Nota de Rescate</strong></h3>
<ul>
<li>
<p>Qué es la “nota de rescate” en este main</p>
<ul>
<li>Es un fichero que el programa intenta dejar en cada directorio visitado (salvo los excluidos) con nombre fijo <code>README_babyk.txt</code>.</li>
<li>Su contenido no se construye como texto en main: sale de un buffer embebido llamado <code>notebytes</code>.</li>
</ul>
</li>
<li>
<p>Cómo se construye el contenido, <code>note</code>:</p>
<ul>
<li>Primero calcula <code>notesize</code> buscando el primer byte <code>0x00</code> dentro de <code>notebytes</code>, hasta 8192 posiciones. Cuando lo encuentra, usa <code>notesize = i + 1</code>, así que incluye el byte nulo terminal en el tamaño.</li>
<li>Luego crea <code>note := make([]byte, notesize)</code> y copia byte a byte desde <code>notebytes</code> hacia <code>note</code>.</li>
<li>Implicación: si <code>notebytes</code> representa un “string estilo C” terminado en <code>\0</code>, el fichero escrito contendrá el texto “normal” y un byte nulo al final. Para un visor de texto suele ser invisible, pero a nivel binario está ahí.</li>
</ul>
</li>
<li>
<p>Dónde y cuándo se escribe</p>
<ul>
<li>La escritura ocurre dentro del callback de <code>filepath.Walk</code>, en la rama “es directorio”, y solo si ese directorio no está en la lista de exclusión.</li>
<li>Para cada directorio permitido ejecuta: <code>ioutil.WriteFile(path+&quot;/README_babyk.txt&quot;, note, 0777)</code>.</li>
<li>Esto significa que intenta dejar la nota de forma “omnipresente”, una por carpeta, que es típico para maximizar la visibilidad del mensaje.</li>
</ul>
</li>
<li>
<p>Permisos y comportamiento en disco</p>
<ul>
<li>Usa <code>modo 0777</code>, lectura/escritura/ejecución para todos. En sistemas Linux el permiso final puede quedar recortado por <code>umask</code>, pero la intención es que sea accesible por cualquiera.</li>
<li><code>WriteFile</code> sobrescribe el fichero si ya existe. No hay comprobación previa, así que si en una carpeta ya existía <code>README_babyk.txt</code>, lo reemplaza.</li>
<li>El <code>error de WriteFile</code> se ignora, no se chequea el error devuelto, así que fallos por permisos/FS de solo lectura/etc. no se registran ni detienen el recorrido.</li>
</ul>
</li>
<li>
<p>Relación con el cifrado. ¿por qué evita cifrarla?</p>
<ul>
<li>En la rama de archivos, main evita encolar <code>README_babyk.txt</code> para cifrado (<code>info.Name() != &quot;README_babyk.txt&quot;</code>). Eso evita que el propio programa cifre su nota y la vuelva ilegible.</li>
</ul>
</li>
<li>
<p>Relación con las exclusiones. ¿dónde NO deja nota?</p>
<ul>
<li>Si el directorio actual coincide con rutas sensibles, por ejemplo boot, sys, run, dev, etc, etc., retorna <code>filepath.SkipDir</code>, lo que implica:
<ul>
<li>no entra a ese subárbol</li>
<li>y por tanto no deja la nota allí</li>
</ul>
</li>
<li>Detalle: la comprobación <code>strings.Contains(info.Name(), &quot;/proc&quot;)</code> es sospechosa, porque <code>info.Name()</code> suele ser solo el nombre base (p. ej. proc), no una ruta con <code>/</code>. Aun así, otras exclusiones sí usan path y funcionan como filtro de rutas.</li>
</ul>
</li>
</ul>
<hr>
<h3 id="resumen-sobre-cu%C3%A1ndo-termina-condiciones-de-salida"><strong>Resumen sobre cuándo termina. Condiciones de salida</strong></h3>
<ul>
<li>Termina inmediatamente si no se pasa exactamente 1 argumento de ruta (imprime uso y retorna).</li>
<li>Si sí hay ruta:
<ul>
<li>Ejecuta <code>filepath.Walk</code>.</li>
<li>Si <code>Walk</code> devuelve error, lo imprime, pero no aborta inmediatamente antes de esperar goroutines.</li>
</ul>
</li>
<li>Finalmente hace <code>wg.Wait()</code>, otra vez y solo cuando todas las goroutines han terminado, main retorna y el proceso finaliza.</li>
</ul>

</body>
</html>
