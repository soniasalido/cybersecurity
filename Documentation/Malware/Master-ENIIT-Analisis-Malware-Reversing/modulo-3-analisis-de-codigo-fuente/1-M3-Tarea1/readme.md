

## Nota
Para el ejercicio: variable puntero: se guarda en las variables de entorno de main? Video 2 de tutorias, minuto 45. Revisar. El valor esta en pila, pero donde apunta es el heap. Son direcciones mas alta de la pila. 

Usar detect it easy para ver que está empaquetado.



## Herramientas para ver memoria
### 1. IDEs con depurador integrado (lo más fácil)
Si estás programando tú el “pequeño programa”, lo más sencillo es usar un IDE que ya traiga depurador:
- Windows
  - Visual Studio Community
    - Soporta C/C++, C#, etc.
    - Ventanas útiles:
      - Locals / Autos: ves nombres de variables, tipos y valores.
      - Watch: añades variables específicas para vigilarlas.
      - Memory: ves la memoria cruda (hexadecimal) en una dirección concreta, por ejemplo la dirección de una variable.
      - Call Stack: muestra la pila de llamadas (stack).
    - Todo con botones de “Start debugging”, “Step over”, etc., sin escribir comandos.
  - x64dbg (más bajo nivel, para ejecutables ya compilados)
    - Interfaz gráfica: ves código ensamblador, memoria, registros, stack, etc.
    - Muy útil si te interesa ver exactamente cómo se almacenan variables en el stack o heap de un binario.

- Linux (y también Windows/macOS en muchos casos)
  - CLion, Qt Creator, Eclipse CDT, KDevelop, Code::Blocks:
    - Todos usan gdb/lldb por debajo, pero te dan:
      - Ventana de variables locales.
      - Ventana de memoria.
      - Vista de stack.
    - No necesitas escribir gdb ni comandos; solo configurar el proyecto y usar el botón de depuración.


- Multiplataforma
  - Visual Studio Code + extensiones de depuración (por ejemplo C/C++ o Python):
    - Interfaz de depuración con:
      - Variables.
      - Watches.
      - Call Stack.
      - Panel para ver memoria (según extensión / configuración).
    - Es muy ligero y funciona en Windows, Linux y macOS.


### 2. Depuradores gráficos para binarios (cuando no tienes el código fuente)
Si lo que quieres es ver memoria de un programa ya compilado (por ejemplo, para aprender cómo se distribuyen stack/heap/datos):

- x64dbg (Windows). Permite ver:
  - Mapa de memoria: qué rangos corresponden a código, datos, heap, stack, etc.
  - Contenido de memoria en tiempo real.
  - Direcciones y valores de variables (si las encuentras por dirección) y registros.
    
- Ghidra (multiplataforma, con depurador desde ciertas versiones)
  - Tiene vistas de memoria, stack y registros, además de desensamblador.
    
- IDA Free (similar idea, algo más técnico)
  - Estos son más “reverse engineering” que programación normal, pero para estudiar zonas de memoria son potentes y todo es visual.


### 3. Cómo te ayudan a ver las “zonas de memoria”
Independientemente de la herramienta, la idea suele ser así:
- Compilar con información de depuración (en C/C++ por ejemplo, con -g), o cargar el ejecutable en el depurador.
- Poner un breakpoint en una línea interesante (por ejemplo, después de declarar e inicializar variables).
- Ejecutar hasta el breakpoint.
- Usar las ventanas del depurador:
  - Variables locales (Locals):
    - Ves nombre, tipo, valor, a veces dirección.
    - Si ves la dirección, puedes usarla para abrir la ventana de Memory en ese punto y ver los bytes exactos.
  - Call Stack / Stack:
    - Ves cómo se apilan las funciones, y muchas veces el contenido de la pila (stack frame: parámetros, variables locales).
  - Memory / Hex view:
    - Te permite navegar por direcciones y ver los bytes, lo que te muestra físicamente cómo están organizados los datos.

Con eso ya puedes relacionar:
- Variables locales → stack.
- Variables globales/estáticas → segmento de datos.
- Objetos creados con malloc/new (o similares) → heap.

### 4. ¿Qué elegir en la práctica?

Si quieres algo sencillo y estás programando tú:

En Windows:
→ Usa Visual Studio Community.

En Linux/macOS:
→ Usa CLion o Qt Creator, o VS Code con el depurador para tu lenguaje.

Si quieres aprender viendo la memoria de un ejecutable ya hecho, más “cercano al ensamble”:

x64dbg (Windows) o Ghidra (multiplataforma) son buenas opciones.


-------------------------------------------

¿Qué te da gdbgui (comparado con Compiler Explorer)?

Vista código + ensamblador

Muestra tu código C y la desensamblación; la instrucción actual aparece resaltada (similar al coloreado de CE).
PyPI

Variables y expresiones

Panel de variables locales; puedes hacer clic y expandir estructuras, ver punteros, etc.
GDB GUI
+1

Memory Viewer

Ventana de memoria cruda en hexadecimal.

Si haces clic en una dirección (por ejemplo, una dirección que aparece en una variable puntero), se abre esa zona de memoria.

Puedes configurar cuántos bytes ver por fila.
GDB GUI
+1

Todo en el navegador

Aunque arrancas gdbgui con un comando, luego trabajas desde una interfaz gráfica en http://localhost:5000 (o similar).
GDB GUI
+1

Uso básico paso a paso (resumen)

Compila tu programa con símbolos de depuración y sin optimizar
Ejemplo en C:

gcc -g -O0 programa.c -o programa


Arranca gdbgui
Una vez instalado (vía pip install gdbgui), se ejecuta con:

gdbgui


Se abrirá una pestaña en el navegador.
GDB GUI
+1

Carga el binario

En la parte superior, pones la ruta de programa y pulsas Load Binary.

gdbgui agrega un breakpoint en main() automáticamente (configurable).
GDB GUI

Ejecuta y mira memoria

Pulsas Run / Continue hasta el punto donde te interese.

En el panel de variables ves, por ejemplo, la dirección de c o de cualquier puntero.

Copias/seleccionas esa dirección y la usas en el Memory Viewer para ver los bytes de esa zona.

Con esto puedes reproducir lo que ves en tu captura: código C, ensamblador alineado y, además, observar directamente cómo cambian los valores en memoria a medida que se ejecuta el bucle.


https://www.gdbgui.com/

```
# 1) Preparar
sudo apt install python3 python3-pip python3-venv gdb

# 2) Proyecto + venv
mkdir ~/gdbgui_project
cd ~/gdbgui_project
python3 -m venv venv
source venv/bin/activate
pip install --upgrade pip
pip install gdbgui

# 3) Ejecutar
gdbgui
```

