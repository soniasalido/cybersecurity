

# 1. Identificación y propósito

## 1.1 Nombre y contexto
- ¿En qué archivo/módulo/DLL está definida la función?
- ¿Cómo se llama la función?

## 1.2 Descripción general
- Describe qué hace la función (en palabras, sin código).

# 2. Naturaleza de la función
## 2.1 Tipo básico
- ¿Es función (devuelve un valor) o procedimiento (no devuelve valor “útil”)?

## 2.2 Origen
- ¿Es una función de usuario?
- ¿Es o no es una función de sistema (pertenece a la biblioteca estándar, al SO, etc.)?

## 2.3 Clasificación lógica
- ¿Es o no es un predicado?
(¿Devuelve un booleano, verdadero/falso, sí/no?)

- ¿Es o no es una función hoja?
(No llama a otras funciones → sólo operaciones básicas.)

- ¿Es una función que no cambia el estado del programa (tiene transparencia referencial)?

- ¿Es una función pura?
(Sin efectos secundarios y siempre el mismo resultado con los mismos parámetros.)


# 3. Sistema de tipos

## 3.1 Sistema de tipos usado
- ¿El sistema de tipos del lenguaje es estático o dinámico para esta función?
- Estático: tipos conocidos en compilación.
- Dinámico: tipos comprobados en ejecución.

# 4. Signatura y parámetros

## 4.1 Signatura
- Describe la signatura de la función:
nombre(tipo_param1, tipo_param2, ...) -> tipo_retorno

## 4.2 Aridad
- ¿Qué n-ariedad tiene la función?
- ¿Es nula (0 parámetros)?
- ¿Unaria** (1 parámetro)?
- Binaria (2 parámetros)?
- Ternaria, etc.

## 4.3 Parámetros
- Define los tipos de parámetros que recibe.
- Para cada parámetro:
  - ¿Está pasado por valor o por referencia?
  - ¿Es un parámetro constante (no se puede modificar dentro de la función)?
- ¿La función posee parámetros constantes en su lista de parámetros?
- ¿Es o no es una función con parámetros variables (varargs, número variable de parámetros)?
- ¿Tiene parámetros por defecto?
  - Si los tiene, ¿qué valores por defecto poseen?

# 5. Valor de retorno

## 5.1 Tipo de retorno
- Define qué tipo de dato devuelve.

## 5.2 Contenido del retorno
- Define qué devuelve la función exactamente (semántica):
  - ¿Devuelve un objeto creado dentro de ella?
  - ¿Devuelve un valor calculado a partir de los parámetros?
  - ¿Devuelve un código de error/estado?

# 6. Efectos secundarios y estado
## 6.1 Uso de parámetros
- ¿La función modifica algún parámetro (por referencia, objetos mutables) o solo lee los valores recibidos?

## 6.2 Ámbito y estado global
- ¿Define o usa variables globales?
- ¿Define o usa variables locales?
- ¿Usa variables estáticas dentro de la función (persisten entre llamadas)?
- ¿Modifica objetos globales?
- ¿Muta o lee valores fuera de su ámbito?
  (Valores no creados dentro de la función ni recibidos como parámetros.)

# 7. Ámbito y visibilidad de la función

## 7.1 Visibilidad
- ¿Cuál es el ámbito de la función (su visibilidad)?
  - Pública, privada, interna del módulo, protegida, etc.
- ¿Estamos en un módulo, una clase, una DLL, etc.?

## 7.2 Ámbito interno
- Define las variables que usa:
  - ¿Son globales?
  - ¿Son locales?
  - ¿Son estáticas?

# 8. Relaciones con otras funciones y librerías

## 8.1 Llamadas internas
- ¿La función llama a otras funciones?
  - ¿Cuáles? ¿De usuario? ¿De sistema?

## 8.2 Importación / Exportación
- ¿La función se importa o exporta desde/para una librería o módulo?
- ¿Cómo importa/exporta funciones el programa?
  - Mediante enlace estático.
  - Mediante enlace dinámico (DLL, SO, etc.).
  - Mediante carga dinámica durante la ejecución (carga de librerías en runtime).

# 9. Aspectos de ejecución y depuración

## 9.1 Runtime y símbolos
- ¿Depende de algún runtime específico (VM, intérprete, framework, runtime de lenguaje)?
- ¿El binario tiene símbolos de depuración para esta función (nombres, líneas, etc.)?

# 10. Estructuras de control (bifurcación, repetición, saltos)

## 10.1 Bifurcación
- ¿Qué estructuras de bifurcación usa?
  - if / else, switch / case, condicional ternario, pattern matching, etc.
- ¿En qué condiciones toma cada rama?

## 10.2 Repetición
- ¿Qué estructuras de repetición usa?
  - for, while, do-while, for-each, etc.
- ¿Cuáles son las condiciones de entrada y de salida de los bucles?

## 10.3 Saltos y control de flujo
- ¿Utiliza sentencias de salto?
  - break, continue, return anticipado.
  - goto (si el lenguaje lo soporta).
  - Manejo de excepciones (try/catch/finally, throw).
- ¿Hay caminos de ejecución que puedan quedar sin retorno o sin terminar un bucle?


# 11. Análisis de malware / seguridad (solo si aplica)

## 11.1 Contexto dentro del binario/módulo
- ¿En qué parte del programa aparece esta función?
  - ¿Loader, desencriptador, función “principal” de la carga útil, módulo de red, módulo de persistencia, etc.?

- ¿Es una función exportada (puerta de entrada desde fuera) o solo interna?
- ¿Se llama:
  - Muy temprano (posible inicialización/persistencia)?
  - Periódicamente (posible beaconing o tarea recurrente)?
  - Como callback de APIs del sistema (hooks, filtros, etc.)?

## 11.2 Interacción con el sistema operativo
- ¿La función:
  - Crea, lee, modifica o borra archivos o directorios sospechosos?
  - Crea o modifica claves de registro (en Windows), especialmente en rutas de inicio automático o configuración del sistema?
  - Crea, detiene o modifica servicios del sistema?
  - Crea tareas programadas (scheduler, cron, etc.)?
- ¿Manipula procesos?
  - Inyección en procesos, creación de procesos hijos con parámetros raros, CreateRemoteThread, etc.
- ¿Carga drivers, controladores o módulos en el kernel?

## 11.3 Comportamiento de red
- ¿La función realiza alguna comunicación de red?
  - Apertura de sockets.
  - Uso de HTTP(S), DNS, SMTP, IRC, websockets u otros protocolos.
- ¿Existen dominios, IPs, puertos o rutas incrustadas (hardcoded)?
- ¿Se observa comportamiento típico de C2 (Command & Control)?
  - Peticiones periódicas (beacons).
  - Descarga y ejecución de payloads adicionales.
- ¿Los datos se envían:
  - En claro.
  - Con cifrado propio (algoritmos, claves incrustadas).
  - Con protocolos “encapsulados” (por ejemplo, datos binarios dentro de HTTP).

## 11.4 Persistencia
- ¿La función contribuye a que el malware se ejecute de nuevo tras reinicio/cierre?
  - Modificando claves de arranque.
  - Copiándose en directorios especiales (inicio, system32, etc.).
  - Registrando tareas programadas.
  - Registrando hooks o extensiones (por ejemplo, BHO en navegadores antiguos, shell extensions, etc.).

## 11.5 Obfuscación y anti-análisis
- ¿El código de la función está:
  - Ofuscado (control de flujo raro, saltos innecesarios, código basura, opaque predicates)?
  - ¿Hace desencriptado/decodificación de otras partes del binario o strings?

- ¿Resuelve funciones de sistema dinámicamente?
  - Uso de GetProcAddress/LoadLibrary, dlsym/dlopen, tablas de nombres hash, etc.

- ¿Tiene técnicas de auto-modificación?
  - Escribir en su propio código o en memoria marcada como ejecutable.

- ¿Usa técnicas de anti-debug / anti-VM?
  - Detección de depuradores, breakpoints, stepping.
  - Comprobación de tiempo (sleep-skipping, medidas de latencia).
  - Búsqueda de artefactos de VM (drivers, dispositivos, nombres de procesos típicos de sandbox).

- ¿Hay comprobaciones de integridad (checksums) sobre el binario para detectar modificación?

## 11.6 Privilegios, credenciales y espionaje
- ¿Intenta elevar privilegios?
  - Modificación de tokens, bypass de UAC, exploits de escalado de privilegios.
- ¿Accede a:
  - LSASS, SAM, ficheros de contraseñas, bases de datos de credenciales, llaveros, etc.?
  - Entradas del teclado (keylogging), portapapeles, capturas de pantalla?
- ¿Lee datos de:
  - Navegadores (cookies, sesiones, contraseñas guardadas)?
  - Clientes de correo, VPN, gestores de contraseñas?

## 11.7 Propagación y movimiento lateral
- ¿La función:
  - Escanea la red (rangos de IP, puertos) en busca de otras máquinas?
  - Aprovecha vulnerabilidades conocidas (patrones de payload, nombres de servicios, etc.)?
  - Copia el binario a discos externos, recursos compartidos, USB, etc.?

- ¿Intenta explotar credenciales para acceder a otros hosts o recursos?

## 11.8 Exfiltración y daño
- ¿Qué tipos de datos selecciona?
  - Documentos, bases de datos, imágenes, ficheros con extensiones específicas, etc.
- ¿Comprimes y/o cifra datos antes de enviarlos?
- ¿Se observan patrones típicos de:
  - Ransomware (cifrado masivo de archivos, cambio de extensiones, creación de notas de rescate)?
  - Wipers (borrado o corrupción deliberada de datos)?
  - Crypto-minería (uso intenso de CPU/GPU, conexión a pools, algoritmos de minería)?
  - DDoS (envío masivo de tráfico a ciertos destinos)?

## 11.9 Configuración, constantes e IOCs
- ¿Contiene strings interesantes (dominios, rutas, nombres de usuarios, IDs de campaña, claves, mutex, etc.)?
- ¿Hay identificadores únicos de la campaña o familia de malware (versiones, build ids, nombres internos)?
-   ¿Se pueden extraer de la función:
  - Dominios, IPs, puertos.
  - Rutas de ficheros, nombres de registro.
  - Claves o sal para cifrado.
- Marca aquellos datos que podrían servir como Indicadores de Compromiso (IoCs) para detección.

## 11.10 Comportamiento condicional y “kill switches”
- ¿La función sólo actúa en ciertas condiciones?
  - Idioma/locale del sistema.
  - Zona geográfica (por IP, configuración regional).
  - Detección de entorno de análisis (si hay debugger/VM, no hace nada).
- ¿Comprueba algún dominio o recurso remoto que, si responde de cierta manera, desactiva el comportamiento (kill switch)?
- ¿Tiene rutas de ejecución que acaban en “no hacer nada” o auto-borrado del malware?

## 11.11 Relación con detección y mitigación (desde la función)
- A partir del comportamiento de esta función:
  - ¿Qué patrones de comportamiento podrían usarse en reglas de detección (sandbox, EDR, etc.)?
  - ¿Qué cadenas, rutas, APIs llamadas o secuencias de acciones serían útiles para reglas de detección (por ejemplo YARA, IDS/IPS), sin entrar en detalles de implementación?

- ¿La función incluye mecanismos para evadir detecciones?
  - Cambios de nombre frecuentes.
  - Descarga/creación de módulos temporales en memoria.
  - Borrado de logs o rastros.
