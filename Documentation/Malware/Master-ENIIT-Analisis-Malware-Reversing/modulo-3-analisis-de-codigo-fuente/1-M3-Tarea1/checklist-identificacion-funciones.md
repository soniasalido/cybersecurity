

# 1. Identificación y propósito

## 1.1 Nombre y contexto
- ¿En qué archivo/módulo/DLL está definida la función?
- ¿Cómo se llama la función?

## 1.2 Descripción general
- Describe qué hace la función (en palabras, sin código).

# 2. Naturaleza de la función
## 2.1 Tipo básico
- ¿Es función (devuelve un valor) o procedimiento (no devuelve valor “útil”)?

## 2.2 Origen
- ¿Es una función de usuario?
- ¿Es o no es una función de sistema (pertenece a la biblioteca estándar, al SO, etc.)?

## 2.3 Clasificación lógica
- ¿Es o no es un predicado?
(¿Devuelve un booleano, verdadero/falso, sí/no?)

- ¿Es o no es una función hoja?
(No llama a otras funciones → sólo operaciones básicas.)

- ¿Es una función que no cambia el estado del programa (tiene transparencia referencial)?

- ¿Es una función pura?
(Sin efectos secundarios y siempre el mismo resultado con los mismos parámetros.)


# 3. Sistema de tipos

## 3.1 Sistema de tipos usado
- ¿El sistema de tipos del lenguaje es estático o dinámico para esta función?
- Estático: tipos conocidos en compilación.
- Dinámico: tipos comprobados en ejecución.

# 4. Signatura y parámetros

## 4.1 Signatura
- Describe la signatura de la función:
nombre(tipo_param1, tipo_param2, ...) -> tipo_retorno

## 4.2 Aridad
- ¿Qué n-ariedad tiene la función?
- ¿Es nula (0 parámetros)?
- ¿Unaria** (1 parámetro)?
- Binaria (2 parámetros)?
- Ternaria, etc.

## 4.3 Parámetros
- Define los tipos de parámetros que recibe.
- Para cada parámetro:
  - ¿Está pasado por valor o por referencia?
  - ¿Es un parámetro constante (no se puede modificar dentro de la función)?
- ¿La función posee parámetros constantes en su lista de parámetros?
- ¿Es o no es una función con parámetros variables (varargs, número variable de parámetros)?
- ¿Tiene parámetros por defecto?
  - Si los tiene, ¿qué valores por defecto poseen?

# 5. Valor de retorno

## 5.1 Tipo de retorno
- Define qué tipo de dato devuelve.

## 5.2 Contenido del retorno
- Define qué devuelve la función exactamente (semántica):
  - ¿Devuelve un objeto creado dentro de ella?
  - ¿Devuelve un valor calculado a partir de los parámetros?
  - ¿Devuelve un código de error/estado?

# 6. Efectos secundarios y estado
## 6.1 Uso de parámetros
- ¿La función modifica algún parámetro (por referencia, objetos mutables) o solo lee los valores recibidos?

## 6.2 Ámbito y estado global
- ¿Define o usa variables globales?
- ¿Define o usa variables locales?
- ¿Usa variables estáticas dentro de la función (persisten entre llamadas)?
- ¿Modifica objetos globales?
- ¿Muta o lee valores fuera de su ámbito?
  (Valores no creados dentro de la función ni recibidos como parámetros.)

# 7. Ámbito y visibilidad de la función

## 7.1 Visibilidad
- ¿Cuál es el ámbito de la función (su visibilidad)?
  - Pública, privada, interna del módulo, protegida, etc.
- ¿Estamos en un módulo, una clase, una DLL, etc.?

## 7.2 Ámbito interno
- Define las variables que usa:
  - ¿Son globales?
  - ¿Son locales?
  - ¿Son estáticas?

# 8. Relaciones con otras funciones y librerías

## 8.1 Llamadas internas
- ¿La función llama a otras funciones?
  - ¿Cuáles? ¿De usuario? ¿De sistema?

## 8.2 Importación / Exportación
- ¿La función se importa o exporta desde/para una librería o módulo?
- ¿Cómo importa/exporta funciones el programa?
  - Mediante enlace estático.
  - Mediante enlace dinámico (DLL, SO, etc.).
  - Mediante carga dinámica durante la ejecución (carga de librerías en runtime).

# 9. Aspectos de ejecución y depuración

## 9.1 Runtime y símbolos
- ¿Depende de algún runtime específico (VM, intérprete, framework, runtime de lenguaje)?
- ¿El binario tiene símbolos de depuración para esta función (nombres, líneas, etc.)?

# 10. Estructuras de control (bifurcación, repetición, saltos)

## 10.1 Bifurcación
- ¿Qué estructuras de bifurcación usa?
  - if / else, switch / case, condicional ternario, pattern matching, etc.
- ¿En qué condiciones toma cada rama?

## 10.2 Repetición
- ¿Qué estructuras de repetición usa?
  - for, while, do-while, for-each, etc.
- ¿Cuáles son las condiciones de entrada y de salida de los bucles?

## 10.3 Saltos y control de flujo
- ¿Utiliza sentencias de salto?
  - break, continue, return anticipado.
  - goto (si el lenguaje lo soporta).
  - Manejo de excepciones (try/catch/finally, throw).
- ¿Hay caminos de ejecución que puedan quedar sin retorno o sin terminar un bucle?


# 11. Análisis de malware / seguridad (solo si aplica)

## 11.1 Contexto dentro del binario/módulo
- ¿En qué parte del programa aparece esta función?
  - ¿Loader, desencriptador, función “principal” de la carga útil, módulo de red, módulo de persistencia, etc.?

- ¿Es una función exportada (puerta de entrada desde fuera) o solo interna?
- ¿Se llama:
  - Muy temprano (posible inicialización/persistencia)?
  - Periódicamente (posible beaconing o tarea recurrente)?
  - Como callback de APIs del sistema (hooks, filtros, etc.)?

## 11.2 Interacción con el sistema operativo
- ¿La función:
  - Crea, lee, modifica o borra archivos o directorios sospechosos?
  - Crea o modifica claves de registro (en Windows), especialmente en rutas de inicio automático o configuración del sistema?
  - Crea, detiene o modifica servicios del sistema?
  - Crea tareas programadas (scheduler, cron, etc.)?
- ¿Manipula procesos?
  - Inyección en procesos, creación de procesos hijos con parámetros raros, CreateRemoteThread, etc.
- ¿Carga drivers, controladores o módulos en el kernel?

## 11.3 Comportamiento de red
- ¿La función realiza alguna comunicación de red?
  - Apertura de sockets.
  - Uso de HTTP(S), DNS, SMTP, IRC, websockets u otros protocolos.
- ¿Existen dominios, IPs, puertos o rutas incrustadas (hardcoded)?
- ¿Se observa comportamiento típico de C2 (Command & Control)?
  - Peticiones periódicas (beacons).
  - Descarga y ejecución de payloads adicionales.
- ¿Los datos se envían:
  - En claro.
  - Con cifrado propio (algoritmos, claves incrustadas).
  - Con protocolos “encapsulados” (por ejemplo, datos binarios dentro de HTTP).

## 11.4 Persistencia
- ¿La función contribuye a que el malware se ejecute de nuevo tras reinicio/cierre?
  - Modificando claves de arranque.
  - Copiándose en directorios especiales (inicio, system32, etc.).
  - Registrando tareas programadas.
  - Registrando hooks o extensiones (por ejemplo, BHO en navegadores antiguos, shell extensions, etc.).

## 11.5 Obfuscación y anti-análisis
- ¿El código de la función está:
  - Ofuscado (control de flujo raro, saltos innecesarios, código basura, opaque predicates)?
  - ¿Hace desencriptado/decodificación de otras partes del binario o strings?

- ¿Resuelve funciones de sistema dinámicamente?
  - Uso de GetProcAddress/LoadLibrary, dlsym/dlopen, tablas de nombres hash, etc.

- ¿Tiene técnicas de auto-modificación?
  - Escribir en su propio código o en memoria marcada como ejecutable.

- ¿Usa técnicas de anti-debug / anti-VM?
  - Detección de depuradores, breakpoints, stepping.
  - Comprobación de tiempo (sleep-skipping, medidas de latencia).
  - Búsqueda de artefactos de VM (drivers, dispositivos, nombres de procesos típicos de sandbox).

- ¿Hay comprobaciones de integridad (checksums) sobre el binario para detectar modificación?

## 11.6 Privilegios, credenciales y espionaje
- ¿Intenta elevar privilegios?
  - Modificación de tokens, bypass de UAC, exploits de escalado de privilegios.
- ¿Accede a:
  - LSASS, SAM, ficheros de contraseñas, bases de datos de credenciales, llaveros, etc.?
  - Entradas del teclado (keylogging), portapapeles, capturas de pantalla?
- ¿Lee datos de:
  - Navegadores (cookies, sesiones, contraseñas guardadas)?
  - Clientes de correo, VPN, gestores de contraseñas?

## 11.7 Propagación y movimiento lateral
- ¿La función:
  - Escanea la red (rangos de IP, puertos) en busca de otras máquinas?
  - Aprovecha vulnerabilidades conocidas (patrones de payload, nombres de servicios, etc.)?
  - Copia el binario a discos externos, recursos compartidos, USB, etc.?

- ¿Intenta explotar credenciales para acceder a otros hosts o recursos?

## 11.8 Exfiltración y daño
- ¿Qué tipos de datos selecciona?
  - Documentos, bases de datos, imágenes, ficheros con extensiones específicas, etc.
- ¿Comprimes y/o cifra datos antes de enviarlos?
- ¿Se observan patrones típicos de:
  - Ransomware (cifrado masivo de archivos, cambio de extensiones, creación de notas de rescate)?
  - Wipers (borrado o corrupción deliberada de datos)?
  - Crypto-minería (uso intenso de CPU/GPU, conexión a pools, algoritmos de minería)?
  - DDoS (envío masivo de tráfico a ciertos destinos)?

## 11.9 Configuración, constantes e IOCs
- ¿Contiene strings interesantes (dominios, rutas, nombres de usuarios, IDs de campaña, claves, mutex, etc.)?
- ¿Hay identificadores únicos de la campaña o familia de malware (versiones, build ids, nombres internos)?
-   ¿Se pueden extraer de la función:
  - Dominios, IPs, puertos.
  - Rutas de ficheros, nombres de registro.
  - Claves o sal para cifrado.
- Marca aquellos datos que podrían servir como Indicadores de Compromiso (IoCs) para detección.

## 11.10 Comportamiento condicional y “kill switches”
- ¿La función sólo actúa en ciertas condiciones?
  - Idioma/locale del sistema.
  - Zona geográfica (por IP, configuración regional).
  - Detección de entorno de análisis (si hay debugger/VM, no hace nada).
- ¿Comprueba algún dominio o recurso remoto que, si responde de cierta manera, desactiva el comportamiento (kill switch)?
- ¿Tiene rutas de ejecución que acaban en “no hacer nada” o auto-borrado del malware?

## 11.11 Relación con detección y mitigación (desde la función)
- A partir del comportamiento de esta función:
  - ¿Qué patrones de comportamiento podrían usarse en reglas de detección (sandbox, EDR, etc.)?
  - ¿Qué cadenas, rutas, APIs llamadas o secuencias de acciones serían útiles para reglas de detección (por ejemplo YARA, IDS/IPS), sin entrar en detalles de implementación?

- ¿La función incluye mecanismos para evadir detecciones?
  - Cambios de nombre frecuentes.
  - Descarga/creación de módulos temporales en memoria.
  - Borrado de logs o rastros.


-----------------------------------
----------------------------------
# Análisis de función

## 1. Identificación y propósito

**1.1 Nombre y contexto**
- Archivo / Módulo / DLL: _______________________________
- Nombre de la función: _________________________________

**1.2 Descripción general**
- ¿Qué hace la función?  
  > _____________________________________________________  
  > _____________________________________________________  
  > _____________________________________________________  


## 2. Naturaleza de la función

**2.1 Tipo básico**
- [ ] Función (devuelve un valor)
- [ ] Procedimiento (no devuelve un valor útil)

**2.2 Origen**
- [ ] Función de usuario
- [ ] Función de sistema / biblioteca estándar
- [ ] Otra: _____________________________________________

**2.3 Clasificación lógica**
- ¿Es predicado (devuelve booleano / sí-no)?
  - [ ] Sí  
  - [ ] No  

- ¿Es función hoja (no llama a otras funciones)?
  - [ ] Sí  
  - [ ] No  

- ¿Tiene transparencia referencial (no cambia el estado del programa y siempre devuelve lo mismo con los mismos parámetros)?
  - [ ] Sí  
  - [ ] No  

- ¿Es función pura (sin efectos secundarios)?
  - [ ] Sí  
  - [ ] No  


## 3. Sistema de tipos

**3.1 Sistema de tipos usado**
- [ ] Tipos estáticos (conocidos en compilación)  
- [ ] Tipos dinámicos (resueltos en ejecución)  
- Detalles / comentarios:  
  > _________________________________________________  
  > _________________________________________________  


## 4. Signatura y parámetros

**4.1 Signatura (formato general)**
- `nombre(tipo_param1, tipo_param2, ...) -> tipo_retorno`  
  - Signatura concreta:  
    > _________________________________________________  

**4.2 Aridad**
- Número de parámetros (n-ariedad): _______
- [ ] 0 (nula)  
- [ ] 1 (unaria)  
- [ ] 2 (binaria)  
- [ ] 3 (ternaria)  
- [ ] >3 (especificar): _____________  

**4.3 Parámetros (para cada parámetro)**

_Repite este bloque por cada parámetro:_

- Nombre del parámetro: ____________________
- Tipo: ___________________________________
- Forma de paso:
  - [ ] Por valor
  - [ ] Por referencia
- ¿Es constante (no modificable dentro de la función)?
  - [ ] Sí
  - [ ] No
- ¿Tiene valor por defecto?
  - [ ] No  
  - [ ] Sí → Valor por defecto: __________________
- Notas:  
  > ___________________________________________  

**4.4 Resumen de parámetros**

- ¿La función tiene parámetros constantes?
  - [ ] Sí
  - [ ] No

- ¿La función tiene parámetros variables (varargs, número variable de parámetros)?
  - [ ] Sí
  - [ ] No

- Lista resumida de parámetros:  
  > ___________________________________________  
  > ___________________________________________  


## 5. Valor de retorno

**5.1 Tipo de retorno**
- Tipo devuelto: ___________________________

**5.2 Contenido del retorno**
- ¿Qué significa lo que devuelve?  
  > ___________________________________________  
  > ___________________________________________  

- ¿Devuelve un objeto creado dentro de la función?
  - [ ] Sí
  - [ ] No

- ¿Devuelve un código de error / estado?
  - [ ] Sí
  - [ ] No

- Otros detalles:  
  > ___________________________________________  


## 6. Efectos secundarios y estado

**6.1 Uso de parámetros**
- ¿Modifica algún parámetro (por referencia / objeto mutable)?
  - [ ] Sí
  - [ ] No  
- En caso afirmativo, ¿cuáles y cómo?  
  > ___________________________________________  

**6.2 Ámbito y estado global**
- Variables que usa:

  - Globales:
    - [ ] Sí usa globales
    - [ ] No usa globales  
    - ¿Cuáles?  
      > ______________________________________  

  - Locales:
    - [ ] Sí usa locales  
    - Ejemplos:  
      > ______________________________________  

  - Estáticas (persisten entre llamadas):
    - [ ] Sí
    - [ ] No  
    - Detalle:  
      > ______________________________________  

- ¿Modifica objetos globales?
  - [ ] Sí
  - [ ] No  

- ¿Lee o muta valores fuera de su ámbito (no creados dentro ni pasados como parámetros)?
  - [ ] Sí
  - [ ] No  
  - ¿Cuáles / cómo?  
    > ___________________________________________  


## 7. Ámbito y visibilidad de la función

**7.1 Visibilidad**
- [ ] Pública  
- [ ] Privada  
- [ ] Protegida  
- [ ] Interna al módulo / paquete  
- [ ] Otra: _______________________________

**7.2 Contexto**
- ¿Dónde está definida?
  - [ ] Archivo suelto / script  
  - [ ] Módulo  
  - [ ] Clase / objeto  
  - [ ] DLL / biblioteca compartida  
  - [ ] Otro: ______________________________

**7.3 Variables usadas (resumen)**
- Globales: ________________________________
- Locales: _________________________________
- Estáticas: _______________________________


## 8. Relaciones con otras funciones y librerías

**8.1 Llamadas internas**
- ¿Llama a otras funciones?
  - [ ] Sí
  - [ ] No  

- Si la respuesta es sí, listar principales:
  - Funciones de usuario:  
    > ____________________________________  
  - Funciones de sistema / librerías:  
    > ____________________________________  

**8.2 Importación / exportación**
- ¿La función se exporta para que otros módulos la usen?
  - [ ] Sí
  - [ ] No  

- Tipo de enlace:
  - [ ] Enlace estático  
  - [ ] Enlace dinámico (librerías cargadas al inicio por el SO)  
  - [ ] Carga dinámica en tiempo de ejecución (`dlopen`, `LoadLibrary`, etc.)  

- Notas sobre cómo se importa/exporta:  
  > ___________________________________________  


## 9. Aspectos de ejecución y depuración

**9.1 Runtime**
- ¿Depende de un runtime específico (VM, intérprete, framework)?  
  - [ ] Sí → ¿Cuál? _________________________  
  - [ ] No

**9.2 Símbolos de depuración**
- ¿Hay símbolos de depuración para esta función (nombres, líneas, etc.)?
  - [ ] Sí
  - [ ] No
- Comentarios:  
  > ___________________________________________  


## 10. Estructuras de control

**10.1 Bifurcación**
- Estructuras usadas:
  - [ ] if / else
  - [ ] switch / case
  - [ ] Operador ternario
  - [ ] Pattern matching
  - [ ] Otras: ___________________________

- Condiciones importantes de decisión:
  > ___________________________________________  

**10.2 Repetición**
- Estructuras usadas:
  - [ ] for
  - [ ] while
  - [ ] do-while
  - [ ] for-each / iteradores
  - [ ] Otras: ___________________________

- Condiciones de salida de los bucles:
  > ___________________________________________  

**10.3 Saltos y control de flujo**
- ¿Utiliza?
  - [ ] break
  - [ ] continue
  - [ ] return anticipado
  - [ ] goto
  - [ ] Excepciones (try / catch / finally, throw)
- Comentarios sobre rutas de ejecución peligrosas o complejas:
  > ___________________________________________  


## 11. Análisis de malware / seguridad

_(Usar solo si se analiza código potencialmente malicioso o sospechoso)_

**11.1 Contexto dentro del binario / módulo**
- Rol aparente de la función (loader, payload, red, persistencia, etc.):  
  > ___________________________________________  

- ¿Es exportada o interna?
  - [ ] Exportada
  - [ ] Interna

- ¿Cuándo se llama?
  - [ ] Al inicio del programa
  - [ ] Periódicamente
  - [ ] Como callback / hook
  - [ ] Otro: ___________________________

**11.2 Interacción con el sistema operativo**
- ¿Opera sobre archivos/directorios de forma sospechosa?
  - [ ] Sí
  - [ ] No  

- ¿Modifica registro (Windows) u otros mecanismos de configuración/persistencia?
  - [ ] Sí
  - [ ] No  

- ¿Crea/modifica servicios o tareas programadas?
  - [ ] Sí
  - [ ] No  

- ¿Manipula procesos (inyección, creación extraña)?
  - [ ] Sí
  - [ ] No  

**11.3 Comportamiento de red**
- ¿Abre sockets o realiza comunicación de red?
  - [ ] Sí
  - [ ] No  

- Dominios/IP/puertos hardcodeados:
  > ___________________________________________  

- ¿Patrones tipo C2 (beaconing, descarga de payloads)?
  - [ ] Sí
  - [ ] No  

- ¿Usa cifrado / ofuscación de tráfico?
  - [ ] Sí
  - [ ] No  

**11.4 Persistencia**
- ¿Ayuda a que el programa se ejecute tras reinicio?
  - [ ] Sí
  - [ ] No  
- ¿Cómo?  
  > ___________________________________________  

**11.5 Ofuscación y anti-análisis**
- ¿Control de flujo ofuscado / código basura?
  - [ ] Sí
  - [ ] No  
- ¿Desencripta / decodifica otras partes del binario o strings?
  - [ ] Sí
  - [ ] No  
- ¿Resuelve APIs de forma dinámica (GetProcAddress, dlsym, etc.)?
  - [ ] Sí
  - [ ] No  
- ¿Anti-debug / Anti-VM?
  - [ ] Sí
  - [ ] No  
  - Detalles:  
    > _______________________________________  

**11.6 Privilegios y espionaje**
- ¿Intenta elevar privilegios?
  - [ ] Sí
  - [ ] No  
- ¿Accede a credenciales, LSASS, gestores de contraseñas, etc.?
  - [ ] Sí
  - [ ] No  
- ¿Keylogging / captura de pantalla / lectura de portapapeles?
  - [ ] Sí
  - [ ] No  

**11.7 Propagación y movimiento lateral**
- ¿Escanea red / puertos?
  - [ ] Sí
  - [ ] No  
- ¿Copia el binario a otros equipos / dispositivos?
  - [ ] Sí
  - [ ] No  

**11.8 Exfiltración y daño**
- Tipos de datos que recoge:
  > ___________________________________________  

- ¿Cifra/compacta datos antes de enviarlos?
  - [ ] Sí
  - [ ] No  

- ¿Comportamiento típico de:**
  - [ ] Ransomware
  - [ ] Wiper
  - [ ] Cripto-minería
  - [ ] DDoS
  - [ ] Otro: ___________________________

**11.9 Configuración, constantes e IoCs**
- Strings interesantes (dominios, rutas, claves, IDs, mutex, etc.):  
  > ___________________________________________  

- Posibles IoCs extraídos de esta función:  
  > ___________________________________________  

**11.10 Comportamiento condicional / Kill switches**
- ¿Se ejecuta solo bajo ciertas condiciones (idioma, región, detección de VM/debugger)?
  - [ ] Sí
  - [ ] No  
- ¿Tiene algún “kill switch” (dominio/condición que desactiva el malware)?
  - [ ] Sí
  - [ ] No  

**11.11 Detección y mitigación (derivadas de esta función)**
- Patrones de comportamiento aprovechables para detección:
  > ___________________________________________  

- Mecanismos de evasión de detección observados:
  > ___________________________________________  

