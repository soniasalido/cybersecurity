
# Ejercicio 1
Cuando nos dan un código para que lo estudiemos, lo primero de todo es averiguar **en que lenguaje está escrito**. Ya sea **ensamblador o un lenguaje de alto nivel**, nuestro primer movimiento es observar los detalles del código para responder las siguientes preguntas: **¿Es un ensamblador o es código de alto nivel? ¿El sistema de tipos es dinámico o estático? ¿Es un lenguaje compilado o se trata de un lenguaje interpretado?** Para ello, vamos a entrenar la vista con trozos (la expresión angosajona sería “snippet”) de código sobre los que debéis averiguar en que lenguaje esta escrito e indicar como lo habéis averiguado. Es decir, no basta con decir: “Es Perl.”

## Trozo 1

![Trozo 1](capturas/trozo1.png)


### La definición de función
```go
func InMemLoads() (map[string]Image, error) {
```
donde:
- Los tipos de retorno van después de los paréntesis, e incluso son múltiples `(map[string]Image, error)`. Esto es algo **muy típico de Go.**

---------------------------

### Declaraciones con :=
```go
ret := make(map[string]Image)
s, si, p := GetModuleLoadedOrder(0)
start := p
i := 1
```
donde:
- La declaración corta (short variable declaration) con `:=` es una **característica distintiva de Go.**


---------------------------

### Uso de make para mapas
```
make(map[string]Image)
```
donde: 
- make es una **función predefinida de Go (builtin)** que sirve específicamente para inicializar mapas (map), canales (chan) y slices.

---------------------------

### Conversión de tipos al estilo Go
```
Image{uint64(s), uint64(si)}
```
donde:
- **En Go** las conversiones se escriben como llamadas de función: `uint64(...)`.

---------------------------

### Uso de nil como valor nulo
```
return ret, nil
```
donde:
- **En Go**, nil representa el “valor cero” para ciertos tipos de referencia (punteros, interfaces, mapas, slices, canales y funciones) y significa “no hay valor / no apunta a nada”.


---------------------------

### Conclusión
Este trozo está en Go (Golang) porque los tipos de retorno van después de los paréntesis para definir funciones, devuelve `map[string]Image`, inicializa mapas con `make`, utiliza la asignación corta `:=` y las conversiones de tipo explícitas `uint64(...)`, elementos característicos de Go y no presentes juntos en otros lenguajes de alto nivel y compilado.
- Es un lenguaje de alto nivel.
- Usa un tipado estático `(map[string]Image, error, uint64, etc.)`.
- Es compilado. El código fuente de Go se traduce mediante el compilador go build directamente a binario nativo (código máquina). 

---------------------------

## Trozo 2
![Trozo 1](capturas/trozo-2.png)


### La cabecera de la clase
```
export default class Encoder {
```
donde:
- `export default` es sintaxis de módulos ES6 (JS/TS), que forma parte de JavaScript.
- `export default class Encoder` junto con anotaciones de tipo (`value: number`, `bytes: Uint8Array | Buffer | number[]`). Esa mezcla de módulos ES6 + tipos estáticos **apunta claramente a TypeScript.**

---------------------------

### Anotaciones de tipos exclusivos de Typescript
```
data: number[] = []
pushByte(value: number) {
pushInt(value: number, n: number, littleEndian=false) {
pushBytes(bytes: Uint8Array | Buffer | number[]) {
```
donde:
- El uso de tipos unidos con `| (Uint8Array | Buffer | number[])` y de tipos primitivos en los parámetros (`n: number, littleEndian=false`) **es sintaxis típica de TypeScript para tipado estático.​​**

---------------------------

### Uso de Javascript
```
let
const
b => this.data.push(b).
>>
&
```
donde:
- Usos de let, const.
- Arrow function: b => this.data.push(b).
- Operadores bit a bit: >>, & 0xff.


---------------------------

### Conclusión
Este trozo usa JavaScript moderno, y la combinación “JS + anotaciones de tipo” es precisamente lo que **demuestra el uso de TypeScript**.
- Es un lenguaje de alto nivel.
- Tiene tipado estático (aunque se borra al compilar a JS).
- TypeScript se considera un lenguaje compilado (o más precisamente “transpilado”).
  - El código TypeScript no se ejecuta directamente en el navegador ni en Node; primero pasa por un compilador (tsc) que lo convierte a JavaScript estándar.
  - El resultado de esa compilación es JavaScript, y ese JavaScript sí se ejecuta de forma interpretada (o JIT‑compilada) por el motor correspondiente.

---------------------------

## Trozo 3
![Trozo 1](capturas/trozo-3.png)

### Directiva al principio
```
Option Explicit
``` 
donde:
- **Es muy típica de VB/VBA** para obligar a declarar variables.

---------------------------

### Definición de procedimientos
```
Sub PDF2Workbook()
...
End Sub
``` 
donde:
- El uso de Sub ... End Sub para procedimientos es **propio de Visual Basic.**


----------------------------

### Llamada a métodos de la aplicación host
```
Application.Run "PDFTables2Workbook", , True
``` 
donde:
- `Application.Run` es **típico en VBA dentro de Excel/Word.**

---------------------------

### Cuadros de mensaje y constantes “vb*”
```
MsgBox PDFTablesPages, vbOKOnly + vbInformation, " PDFTables"
``` 
donde:
- `MsgBox` y constantes como `vbOKOnly`, `vbInformation`, `vbNullString` **son constantes predefinidas de VBA.**

---------------------------

### Firma de procedimiento con Optional, ByVal, As Tipo
```
ub PDFTables2Workbook(Optional ByVal InitialFolderFile As String = vbNullString, _
                       Optional ByVal AllowMultiSelect As Boolean = False)
``` 
donde:
- Esta **Sintaxis es característica de Visual Basic/VBA.**


---------------------------

###  Conclusión
Es Visual Basic for Applications (VBA) porque usa la directiva `Option Explicit`, define procedimientos con `Sub ... End Sub`, utiliza parámetros `Optional ByVal ... As String/Boolean` y constantes predefinidas como `vbNullString y vbInformation`, todo ello típico de Visual Basic for Applications en macros de Office.
- Es un lenguaje de alto nivel.
- VBA usa un tipado estático:
  - Si declaramoss `Dim x As String o Dim y As Boolean`, el tipo de esa variable queda fijado y el compilador comprueba compatibilidad de tipos.
  - `Option Explicit` obliga a declarar las variables antes de usarlas.
- En el contexto de VBA (macros de Office) se compila a p-code y lo ejecuta el intérprete de VBA dentro de la aplicación; a efectos prácticos en esta clasificación se suele considerar interpretado (no se produce un binario nativo independiente), pero realmente es “compilado a bytecode e interpretado por el runtime de Office”.



-----------------------------------

## Trozo 4
![Trozo 1](capturas/trozo-4.png)

### La definición de la función
```
long uv__idna_toascii(const char* s, const char* se, char* d, char* de) {
``` 
donde:
- El Tipo de retorno al principio `(long)` y el uso de parámetros con **tipos clasicos de C** `(const char*)`.
- No hay clases, ni namespace, ni referencias (& en parámetros), nada “orientado a objetos” → **parece más C que C++.**

----------------------------------------

### Declaraciones de variables locales
```
const char* si;
const char* st;
unsigned c;
char* ds;
int rc;
``` 
donde:
- Uso de punteros `(char*)` y del tipo `unsigned` “a secas”, **muy típico en código C.**

----------------------------------------

### Estructura del bucle y llamada a función
```
while (si < se) {
    st = si;
    c = uv__utf8_decode1(&si, se);
    if (c == -1u)
        return UV_EINVAL;
}
``` 
donde:
- Sintaxis de control `(while, if)` **típica de la familia C.**
- Macros estilo `UV_EINVAL` **también son muy de C** (constantes definidas con #define).


----------------------------------------

### Conclusión
Es C porque declara funciones y variables con tipos primitivos `(long, unsigned, int)` y punteros `(const char*)`, usa un `while` con comparación de punteros, llama a funciones con paso de direcciones `(&si)` y no aparece ninguna característica propia de C++ como referencias, new, class o namespace.
- Es código de alto nivel, lenguaje C.
- C tiene tipado estático: todos los identificadores tienen tipo en tiempo de compilación (long, int, char*, unsigned, …).
- C es un lenguaje compilado: se traduce a código máquina (normalmente a través de un compilador como gcc, clang, etc.).


----------------------------------------


## Trozo 5
![Trozo 1](capturas/trozo-5.png)

### Cmdlets con guiones y parámetros con `-`
```
Out-File -FilePath $PayloadPath -InputObject $Payload -Encoding ascii
```
donde:
- `Out-File`, `Get-WmiObject`, `Write-Output`, `Write-Verbose` son `cmdlets` **típicos de PowerShell.**

---------------------------

### Variables con el símbolo `$` delante
```
$PayloadPath
$OSVersion = (Get-WmiObject -Class win32_OperatingSystem).BuildNumber
```
donde:
- Las variables con prefijo $ ($OSVersion, $PayloadPath, $env:temp) **son características de PowerShell.**

---------------------------

### Uso de switch con strings entre comillas:
```
switch($method)
{
    "Sysprep"
    {
        ...
    }
}
```
donde:
- Sigue la **gramática propia de PowerShell.**

---------------------------

### Operador `-match` para expresiones regulares:
```
if ($OSVersion -match "76")
```
donde:
- Sigue la **gramática propia de PowerShell.**

---------------------------

### Tipos .NET entre corchetes y llamadas estáticas
```
[Byte[]] $temp = $DllBytes -split ' '
[System.IO.File]::WriteAllBytes($PathToDll, $temp)
```
donde:
- Muestran la **integración directa de PowerShell con .NET**, algo distintivo frente a otros shells.

---------------------------

### Conclusión
Concluimos que este trozo está escrito en PowerShell.
- Es un lenguaje de alto nivel (script de PowerShell).
- PowerShell usa tipado dinámico (aunque permite anotar tipos como [Byte[]]). Por defecto el sistema es dinámicamente tipado y resuelve tipos en tiempo de ejecución, no en compilación.
- Se considera un lenguaje interpretado / de scripting: el motor de PowerShell ejecuta el script directamente (sobre .NET).

---------------------------

# Ejercicio 2

- Describe que hace la función.
- Define si es función o procedimiento.
- Define el tipo de la función.
- ¿Es o no es predicado?
- ¿Es o no es una función hoja?
- ¿Es o no es una función de sistema?
- ¿Es o no es una función con parámetros variables?
- Describe la signatura de la función.
  - Define los tipos de parámetros que recibe.
  - Define si una parámetros por defecto y qué valores poseen.
  - Define que tipo de dato devuelve.
  - Los parámetros que usa la función están pasado por valor o por referencia?

- Define que devuelve la función.
- Define si llama a otras funciones.
- Define si modifica algún parámetro o solo lee los valores recibidos?.
- Define si devuelve un objeto creado dentro de ella.
- Define si modifica objetos globales.
- Define el Sistema de tipos usados, son dinámicos, son estáticos.
- Funciones que importa o exporta. ¿Cómo el programa importa/exporta funciones de una librería? Mediante
  - Enlace dinámico.
  - Enlace estático.
  - Carga dinámica, dureante la ejecución.
- ¿Es una función de usuario?
- ¿es una función que no cambia el estado del programa, es decir tiene transparencia referencial?
- ¿Es una función pura?
- ¿cual es el ámbito de la función (su visibilidad)?
- Define las variales que usa, son globales? son locales? son estaticas?
- Si muta o lee valores fuera de su ámbito. Es decir, valores no creados dentro de la función o que no forman parte de los parámetros de la función.
- ¿Posee o no parámetros constantes?
- tiene runtime?
- tiene simbolos de depuración?
- estamos en un modulo? una dll?
- Definir el ambito: estamos en un modulo? una función?
- Ecplicar estructuras de bifurcación, repetición, saltos...


## Función 1
![funcion-1](capturas/funcion-1.png)

### 1. Identificación y propósito
- **Nombre:** aeResizeSetSize
- **Contexto:** función C relacionada con un bucle de eventos (aeEventLoop).
- **Descripción:** La función aeResizeSetSize se encarga de redimensionar la capacidad del bucle de eventos (eventLoop). Intenta expandir los arrays que almacenan los eventos registrados y los eventos disparados (events y fired) para acomodar un nuevo tamaño (setsize). Si la redimensión es exitosa, inicializa las nuevas ranuras (slots) creadas con una máscara vacía (AE_NONE).


### 2. Naturaleza de la función
- **Clasificación:** Es una función porque devuelve un valor (`int`) usado típicamente como código de error/éxito. 
- Tiene efectos secundarios significativos (modifica el estado del programa), por lo que actúa semánticamente como un procedimiento con código de estado.
- Origen: Función de usuario, no forma parte de la biblioteca estándar del lenguaje. No es una función de sistema. Es código definido por el programador (o la librería), no una llamada directa al kernel del sistema operativo.
- ¿Predicado? No estrictamente; devuelve un código de error/éxito, no un booleano puro. (Un predicado suele devolver un booleano (verdadero/falso) evaluando una condición lógica.)
- ¿Función hoja? No. Llama a otras funciones: aeApiResize y zrealloc. Por lo tanto, no es una hoja (leaf function) en el árbol de llamadas.
- ¿Transparencia referencial / pura? No. Modifica el estado de eventLoop y la memoria dinámica asociada → tiene efectos secundarios.



### 3. Signatura y parámetros
- Signatura: `int aeResizeSetSize(aeEventLoop *eventLoop, int setsize)`
- Aridad: 2 parámetros → función binaria.
- Parámetro 1:
  - Nombre: eventLoop
  - Tipo: aeEventLoop * (Un puntero a una estructura aeEventLoop).
  - Paso: por valor, pero es un puntero → permite modificar la estructura apuntada.
  - No está declarado const.

- Parámetro 2:
  - Nombre: setsize.
  - Tipo: int. Un entero que representa el nuevo tamaño deseado.
  - Paso: por valor.
  - Tampoco está declarado const, aunque en la práctica no se modifica.

- Parámetros constantes / valores por defecto / varargs:
  - No hay palabra clave const en ninguno. Ninguno de los parámetros está marcado con el calificador const.
  - No tiene parámetros por defecto. El lenguaje C no soporta parámetros por defecto. Ambos deben ser provistos al llamar la función.
  - No es una función con parámetros variables. Tiene un número fijo de argumentos.



### 4. Valor de retorno
- Tipo devuelto: int. (Entero con signo).
- ¿Qué devuelve la función?: Devuelve constantes simbólicas (macros):
  - AE_OK → Si la operación fue exitosa.
  - AE_ERR → Si hubo un error. Por:
    - setsize demasiado pequeño (maxfd >= setsize), o
    - fallo de aeApiResize.
- No devuelve objetos nuevos, solo devuelve un código de estado.

- Paso de parámetros (Valor vs. Referencia):
  - eventLoop: Se pasa por valor (el valor de la dirección de memoria), pero se usa para simular el paso por referencia, permitiendo modificar el objeto original.
  - setsize: Se pasa por valor.

- ¿Devuelve un objeto creado dentro de ella?: No. Solo devuelve un código de estado entero.


### 5. Comportamiento y Efectos secundarios
- ¿Llama a otras funciones?: Sí.
  - aeApiResize(eventLoop, setsize)
  - zrealloc(...) (Una envoltura de realloc).
- ¿Modifica algún parámetro o solo lee?: Modifica el contenido apuntado por el parámetro eventLoop. Específicamente actualiza sus punteros internos (events, fired) y el campo setsize.
- ¿Modifica objetos globales?: Técnicamente modifica memoria en el heap (montículo) a través de zrealloc. Si la estructura eventLoop a la que apunta el puntero es global, entonces sí modifica un objeto global.
- Muta o lee valores fuera de su ámbito: Sí. Al acceder a eventLoop->events y eventLoop->fired, está mutando memoria que fue asignada fuera del ámbito de esta función específica.



### 6. Pureza y Estado
- ¿Es una función pura?: No.
  - Depende de estado externo (el contenido de eventLoop).
  - Tiene efectos secundarios (modifica eventLoop, realiza asignación de memoria).
- Transparencia referencial: No tiene. No se puede reemplazar la llamada a la función simplemente por su valor de retorno sin perder la lógica de redimensionamiento del sistema.
- ¿Es una función que no cambia el estado del programa?: Falso, su propósito principal es cambiar el estado del programa (redimensionar estructuras de datos).


### 7. Sistema de tipos y visibilidad
- Lenguaje C, tipado estático. Los tipos se verifican en tiempo de compilación.
- Los tipos se conocen en compilación: int, aeEventLoop *, aeFileEvent, aeFiredEvent.


xxx Ámbito y visibilidad
- Es una función de nivel superior en C (no está dentro de otra función). La función tiene ámbito global (es pública).
- No tiene static delante, así que por defecto tiene enlace externo (visible desde otros archivos si se declara en un header).


### 8. Relaciones con otras funciones y librerías
- Llama a:
  - aeApiResize(eventLoop, setsize) → parte dependiente del sistema/implementación del backend de eventos.
  - zrealloc(...) → wrapper de realloc (muy probablemente), función de memoria.
- No importa/exporta directamente librerías en el propio código; eso ocurre a nivel de compilación/enlace del módulo donde está definida.
- Mecanismo de importación/exportación: Depende de la compilación. Normalmente, en C, esto se resuelve mediante el Enlace (Linking). Si es parte de un ejecutable monolítico, es enlace estático. Si ae.c se compila en una .dll o .so, se usaría enlace dinámico.


### 9 Ejecución y depuración
- Usa el runtime estándar de C (para memoria dinámica, aunque envuelto en zrealloc).
- El fragmento es código fuente; si el binario se compila con símbolos de depuración o no depende de las opciones del compilador, aquí no se ve.

### 10. Estructuras de control
- **Bifurcación:**
  - Tres if seguidos con return temprano:
    - Igualdad de tamaños.
    - Comprobación maxfd >= setsize.
    - Resultado de aeApiResize.
- **Repetición:**
  - Un bucle `for (i = eventLoop->maxfd+1; i < setsize; i++)`: Inicializa las nuevas posiciones de events con AE_NONE.
- **Saltos / flujo:**
  - `return` múltiple (salidas tempranas en caso de error o no-cambio).
  - No hay break, continue, goto, ni manejo de excepciones (en C estándar no hay try/catch).

### 11. Análisis de malware / seguridad
- Desde el punto de vista de malware, esta función no muestra comportamiento típico malicioso:
  - No accede a disco, registro, red, procesos externos, servicios, etc.
  - Solo toca memoria dinámica y campos de una estructura de bucle de eventos.
  - No hay ofuscación, anti-debug, ni resolución dinámica de APIs “sospechosa”; las llamadas son directas (aeApiResize, zrealloc).
  - No implementa persistencia, exfiltración, keylogging, cifrado de archivos, etc.
- Conclusión en clave malware: Es una función de infraestructura interna de un event loop (gestión de arrays de eventos). Por sí sola no es indicio de comportamiento malicioso.


---------------------------

## Función 2
![funcion-2](capturas/funcion-2-ok.png)
### 1. Identificación y propósito
- **Nombre:** args_cmp
- ***Contexto:** función C, probablemente usada como función de comparación.
- **Descripción:** La función args_cmp compara dos estructuras del tipo struct args_entry. Resta el valor del campo flag de la segunda estructura (a2) al de la primera (a1).
  - El propósito de este patrón es servir como función de comparación, típicamente utilizada por algoritmos de ordenamiento como qsort o de búsqueda como bsearch.
  - Si el resultado es < 0: a1 es menor que a2.
  - Si el resultado es 0: Son iguales.
  - Si el resultado es > 0: a1 es mayor que a2.


### 2. Naturaleza de la función
- **Clasificación:** Es una función, ya que su objetivo principal es calcular y devolver un valor (int) sin generar efectos secundarios.
- **Origen:** Función de usuario, no forma parte de la biblioteca estándar. Función auxiliar / Comparador (Helper function).
- **¿Predicado?:** No, devuelve un valor de comparación, no un booleano puro.
- **¿Función hoja?:** Sí. No llama a ninguna otra función; solo hace una operación aritmética.


### 3. Signatura y parámetros
- **Signatura:** `static int args_cmp(struct args_entry *a1, struct args_entry *a2);`
- **Aridad:** 2 parámetros → función binaria.
- **Parámetros:**
  - `a1`:
    - Tipo: struct args_entry *. Puntero a la primera estructura (LHS - Left Hand Side).
    - Paso: por valor (puntero), se copian las direcciones de memoria, actuando como referencia a los datos. Evita la copia costosa de toda la estructura.
    - No es const.

  - `a2
    - Tipo: struct args_entry *. Puntero a la segunda estructura (RHS - Right Hand Side).
    - Paso: por valor (puntero), se copian las direcciones de memoria, actuando como referencia a los datos. Evita la copia costosa de toda la estructura.
    - No es const.

- **No hay `const` en los parámetros.**
- **Parámetros por defecto:** No.
- **No es varargs.**


### 4. Valor de retorno
- **Tipo:** int (Entero con signo).
- **Qué devuelve exactamente:** `a1->flag - a2->flag` → un entero negativo, cero o positivo según la relación de orden entre ambos flag.
- **No devuelve objetos** ni códigos complejos, solo el resultado de la comparación.



### 5. Comportamiento y Efectos secundarios
- **Lectura:** Lee memoria del heap/stack (flag).
- **Escritura:** Ninguna.
- **Estado Global:** No accede ni modifica nada fuera de sus parámetros.
- **Conclusión:** Sin efectos secundarios observables.



### 6. Pureza y Estado
- **¿Es una función pura?:** Sí.
  - Su valor de retorno depende exclusivamente de sus argumentos.
  - No tiene efectos secundarios (no imprime, no escribe en archivos, no modifica variables globales).

- **Transparencia referencial:** Sí. Podemos reemplazar la llamada a la función por el resultado de la resta (si tuvieramos acceso a los punteros) y el programa funcionaría igual.



### 7. Sistema de tipos y Visibilidad
- **Lenguaje:** C → tipado estático.
- **Usa tipos:** int, struct args_entry *.
- **Enlace (Linkage):** Interno.
  - La palabra clave static restringe la visibilidad al archivo fuente actual (Unidad de traducción).
  - No puede ser invocada directamente desde otros archivos .c (no se exporta el símbolo).


### 8. Relaciones con otras funciones y librerías
- No llama a otras funciones.
- Exporta: No. La palabra clave static al inicio de la declaración restringe la visibilidad de esta función únicamente al archivo fuente (.c) actual. No es visible para otros módulos (Enlace interno).

  
### 9. Ejecución y depuración
- Usa solo el runtime mínimo de C (operación aritmética).
- Mecanismo de carga: Al ser estática, su dirección se resuelve en tiempo de compilación/enlace dentro de su propia unidad de traducción.


### 10. Estructuras de control
- No hay estructuras de control (if, for, etc.).
- **Es un bloque lineal** simple que ejecuta una instrucción y retorna.
- Usa return para finalizar.


### 11. Análisis de malware / seguridad
Desde la óptica de malware, esta función:
- Solo lee un campo de dos estructuras y devuelve una resta.
- No accede a red, disco, procesos, registro, ni memoria dinámica.
- No hace ofuscación, ni anti-debug, ni nada similar.
- Segura en memoria: No realiza aritmética de punteros peligrosa ni escribe en memoria.

---------------------------

## Función 3
![funcion-3](capturas/funcion-3.png)

### 1. Identificación y propósito
- **Nombre:** checksum_generic
- **Contexto:** Algoritmo de verificación de integridad (Checksum).
- **¿Qué hace?:** Implementa el cálculo del Checksum de Internet (RFC 1071), estándar en protocolos como IP, TCP y UDP. Recorre un bloque de memoria apuntado por addr, suma palabras de 16 bits en una variable de mayor tamaño (unsigned long), maneja el posible byte sobrante y finalmente pliega la suma a 16 bits y le hace el complemento a uno. Devuelve ese checksum de 16 bits.

### 2. Naturaleza de la función
- **Clasificación:** Es función, devuelve un valor numérico explícito (`uint16_t`).
- **Origen:** Función de usuario.
- **¿Predicado?:** No; devuelve un valor numérico de checksum, no un booleano.
- **¿Función hoja?:** Sí. No realiza llamadas a otras funciones.


### 3. Signatura y parámetros
- **Signatura:** `uint16_t checksum_generic(uint16_t *addr, uint32_t count);`
- **Aridad:** 2 parámetros → función binaria.
- **Parámetros:**
  - `addr`:
    - Tipo: uint16_t *. Puntero a enteros sin signo de 16 bits (el buffer de datos).
    - Paso: Se pasa por valor (la dirección de memoria), actuando como referencia al buffer.
    - No está declarado como const, aunque no se modifica la memoria apuntada.

  - `count`:
    - Tipo: uint32_t. Entero sin signo de 32 bits (la cantidad de bytes a procesar).
    - Paso: por valor.
    - Se utiliza como contador de longitud: en el bucle for se va decrementando (count -= 2); esta modificación solo afecta al valor local dentro de la función.

- **Parámetros constantes:** No. Ninguno está declarado const, aunque semánticamente se usan como entrada solo.
- **Parámetros por defecto:** No tiene.
- **Varargs:** No, no hay ....



### 4. Valor de retorno
- **Tipo devuelto:** `uint16_t`. Entero sin signo de 16 bits.
- **Devuelve:** El valor del checksum calculado.
- **¿Devuelve un objeto creado dentro de ella?:** No, devuelve un valor primitivo.



### 5. Comportamiento y Efectos secundarios
- **Efectos Secundarios:** Ninguno.
- **Lectura de Memoria:** Solo lee el rango especificado por addr.
- **Mutación:** Solo muta sus propias variables locales (sum, copias locales de addr y count).
- **Conclusión: no tiene efectos secundarios observables.**


### 6. Pureza y Estado
- **¿Es pura?:** Sí. No modifica estado global ni parámetros. Solo lee la memoria a la que apuntan sus parámetros. Si el contenido de la memoria no cambia, siempre devuelve lo mismo → se puede considerar función pura (a efectos prácticos de análisis de código).
- Transparencia referencial: Sí.


### 7. Sistema de tipos y visibilidad
- **Lenguaje:** C → tipado estático.
- **Tipos Clave:** uint16_t (datos), uint32_t (contador), unsigned long (acumulador).  
- **Enlace (Linkage):** Enlace estático o dinámico dependiendo de cómo se compile el archivo objet


### 8. Relaciones con otras funciones y librerías
- No llama a ninguna otra función.
- **Exporta:** Sí.
- 

### 9. Ejecución y depuración
- Usa solo el runtime básico de C (operaciones aritméticas y de desplazamiento).
- Si el binario se compila con símbolos de depuración, aparecerá con el nombre checksum_generic, pero esto depende de las opciones de compilación, no del código fuente.


### 10. Estructuras de control
- **Bifurcación:**
  - Un if (count == 1) para tratar el caso en que queda un byte sobrante.

- **Repetición:**
  - Bucle for (sum = 0; count > 1; count -= 2)
    Lee de dos en dos bytes (una palabra de 16 bits) mientras queden al menos 2 bytes.

- **Saltos / flujo:**
  - Solo un return al final (return ~sum;).
  - No hay break, continue, goto, ni excepciones (en C no hay try/catch).

### 11. Análisis de malware / seguridad
- No toca disco, red, registro, procesos ni servicios.
- No carga librerías dinámicas ni hace llamadas de sistema sospechosas.
- No hay ofuscación ni anti-debug; es una rutina matemática clara.
- Es un cálculo de checksum genérico:
  - Este tipo de función puede aparecer tanto en software legítimo (protocolos de red, verificación de integridad) como en malware (para validar payloads, comprobar integridad de código, etc.).
  - Por sí sola no es indicador de comportamiento malicioso.

- Conclusión en clave malware: Es una rutina de checksum genérica, muy neutra; el posible uso malicioso dependería de qué datos se le pasan y desde dónde se llama, no de la función en sí.


---------------------------


## Función 4
![funcion-4](capturas/funcion-4.png)
### 1. Identificación y propósito
- **Nombre:** rand_str.
- **Contexto:** Rutina de llenado de memoria con datos pseudo-aleatorios (Memory Fill / Random Generator).
- **Descripción:** Rellena un búfer apuntado por str con len bytes de datos aleatorios.
  - Estrategia de Optimización: En lugar de escribir byte a byte (lento), intenta escribir bloques de palabra de 32 bits (4 bytes) y media palabra (2 bytes) para reducir el número de accesos a memoria.
- **Nota Importante:** El comentario "not alphanumeric!" confirma que genera datos binarios crudos, no texto legible. Los bytes pueden tener cualquier valor entre 0x00 y 0xFF.


### 2. Naturaleza de la función
- **Clasificación:** Es un procedimiento (retorna void).
- **Origen:** Código de usuario (User-defined).
- **Nivel:** Bajo nivel (manipulación directa de punteros y memoria).
- **¿Predicado?:** No.
- **¿Función Hoja?:** No. Depende de rand_next().





### 3. Signatura y parámetros
- **Signatura:** `void rand_str(char *str, int len);`
- **Aridad:** 2 parámetros → función binaria.
- **Parámetros:**
  - `str` (Entrada/Salida): char *.
    - Puntero al inicio del bloque de memoria a llenar. Paso por valor.
    - No es const: explícitamente se usa para escritura.
    - Riesgo de Alineación: Al hacer cast a (uint32_t *), si la dirección de str no es múltiplo de 4, podría provocar un fallo de segmentación (Bus Error) en arquitecturas estrictas (como SPARC o ARM antiguos), aunque x86 lo tolera con penalización de rendimiento.
  - `len` (Entrada): int.
    - Entero que indica la longitud (cantidad de bytes) a escribir. Paso por valor.
    - Se usa como contador de bytes restantes; se va decrementando en el while.
    - Longitud en bytes. Se modifica localmente (decrementa) para controlar el bucle.

- **Parámetros `const`:** No.
- **Valores por defecto:** No.
- **No es varargs.**




### 4. Valor de retorno
- **Tipo devuelto:** void.
- **Qué “devuelve” en la práctica:** No hay valor de retorno; el “resultado” es el contenido del búfer str, que queda rellenado con valores pseudo-aleatorios.
- **Resultado:** La función opera exclusivamente mediante efectos secundarios (mutación del búfer).




### 5. Comportamiento y Efectos secundarios
- **Muta o lee valores fuera de su ámbito:** Muta valores en el heap o stack (el búfer str) que pertenece al ámbito del llamador ⇒ Tiene efectos secundarios claros, no es pura.
- **Mutación de Memoria:** Escribe directamente en el heap o stack del llamador.
- **Llamadas:** Invoca repetidamente a rand_next() para obtener entropía.
- **Estado Global:** Modifica implícitamente el estado del generador de números aleatorios (la "semilla" interna de rand_next).





### 6. Pureza y Estado
- **¿Es pura?:** No.
  - Depende de un generador externo (rand_next).
  - Muta la memoria externa (str).
  - No es determinista.
- **Transparencia Referencial:** No.


### 7. Sistema de tipos y Visibilidad
- **Lenguaje:** C (Tipado estático pero con punteros "débiles").
- **Casting (Type Punning):** La función realiza conversiones de tipo explícitas y arriesgadas: convierte un puntero char* a uint32_t* y uint16_t*.
  - Esto indica que el compilador debe tratar la misma dirección de memoria como diferentes tipos de datos para optimizar la escritura.
- **Enlace (Linkage):** Externo.
  - Al no tener la keyword static, la función es exportada y visible para cualquier otro archivo del proyecto que la enlace.



### 8. Relaciones con otras funciones y librerías
- Llama a: `rand_next()`: generador de números pseudo-aleatorios (probablemente implementado en el mismo proyecto o en una librería).
- No se ven otras dependencias directas (no hace llamadas de sistema, ni I/O, etc.).


### 9. Ejecución y depuración
- Requiere el runtime del generador de PRNG (rand_next()), pero por lo demás solo operaciones aritméticas / de punteros.
- No hay información en el código fuente sobre símbolos de depuración; eso depende de cómo se compile.


### 10. Estructuras de control
- **Repetición:** Un bucle while (len > 0) que va consumiendo longitud.

- **Bifurcación:**
  - Dentro del while, un if / else if / else:
    - len >= 4 → escribe 4 bytes de golpe (cast a uint32_t *).
    - len >= 2 → escribe 2 bytes (uint16_t *).
    - Si no, escribe 1 byte.

- **Saltos / flujo:**
  - No hay break, continue, goto.
  - El bucle termina cuando len llega a 0.


### 11. Análisis de malware / seguridad
- **Riesgo Técnico (Crash):** El mencionado problema de alineación de punteros.
- **Calidad Criptográfica:** Depende totalmente de rand_next(). Si rand_next es un generador lineal simple (LCG), estos datos no son seguros para generar claves criptográficas o IVs.
- **Perspectiva de Malware:**
  - Polimorfismo: El malware usa funciones así para generar "basura" (junk code/data) y cambiar su firma (hash) en cada infección.
  - Ofuscación: Generar claves XOR dinámicas para cifrar el payload.
  - Tráfico Falso: Generar contenido aleatorio para enviar por red y confundir a los analistas o herramientas de monitoreo.


---------------------------

## Función 5
![funcion-5](capturas/funcion-5.png)
### 1. Identificación y Propósito
- **Nombre:** TextFormat
- **Contexto:** Función envoltorio (wrapper) para formateo de cadenas en C.
- **Descripción:** Utilidad para formatear texto con argumentos variables (similar a printf) y devolverlo como una cadena utilizable.
  - Toma una cadena de formato (text) y argumentos variables (...).
  - Procesa los argumentos usando vsprintf.
  - Almacena el resultado en un búfer estático interno (buffer).
  - Devuelve un puntero a dicho búfer.
- **Nota Crítica:** Debido al uso de un static char buffer, el contenido devuelto es volátil: se sobrescribirá en la siguiente llamada a la función. No es persistente más allá de la siguiente invocación.

### 2. Naturaleza de la función
- **Clasificación:** Es una función (devuelve un valor explícito const char *).
- **Origen:** Función de usuario (User-defined function).
- **¿Es Predicado?:** No.
- **¿Es Función Hoja?: No.** Realiza llamadas a la biblioteca estándar (va_start, vsprintf, va_end).
- **¿Parámetros Variables?:** Sí. Es una función variádica (variadic function).


### 3. Signatura y parámetros
- **Signatura:** `static const char *TextFormat(const char *text, ...);`
- **Aridad:** función de aridad variable (varargs):
  - Al menos 1 parámetro fijo (text).
  - Luego ... (lista de argumentos variables).
- **Parámetros por defecto:** No.

- **Parámetros:**
  - `text` (Fijo): const char *. Cadena de formato. Pasado por valor (el puntero), de solo lectura.
  - `...` (Variables): Lista de argumentos gestionada mediante macros de stdarg.h. Se pasan a través de la pila (stack).

### 4. Valor de retorno
- **Tipo:** const char * (Puntero a caracteres constantes).
- **Valor:** La dirección de memoria del arreglo estático buffer.
- **Semántica:** Devuelve una referencia a una zona de memoria compartida y mutable internamente.


### 5. Comportamiento y Efectos (Side Effects)
- **Modificación de Estado:** Sí. Modifica la variable estática buffer.
  - Aunque `buffer` está declarada dentro de la función, su almacenamiento es estático (vive durante toda la ejecución del programa) y mantiene su valor entre llamadas hasta que es sobrescrito.
- **Modificación de Globales:** Técnicamente modifica una variable con almacenamiento estático, que actúa funcionalmente como una variable global privada (con visibilidad restringida al ámbito de la función).
- **Llamadas:** Invoca a vsprintf (con efectos secundarios de escritura en memoria).


### 6. Pureza y Estado
- **¿Función Pura?:** No.
  - Depende de estado mutable (buffer).
  - No tiene transparencia referencial.

- **Seguridad de Hilos (Thread-Safety):** No.
  - No es reentrante. Si dos hilos llaman a TextFormat simultáneamente, se producirá una condición de carrera (race condition) corrompiendo el contenido del buffer.


### 7. Sistema de Tipos y Visibilidad
- **Sistema de Tipos:** Estático (C).
- **Ámbito (Scope):** De archivo / Módulo.
- **Enlace (Linkage):** Interno.
  - La palabra clave static en la declaración de la función (static const char *...) impide que esta función sea visible o enlazada desde otros archivos objeto (.o). Es privada para este módulo.


### 8. Relaciones con otras funciones y librerías
- Llama a:
  - va_start, va_end (macros/funciones de <stdarg.h>).
  - vsprintf (función de la libc para formatear en un buffer con va_list).


### 9. Ejecución y depuración
- Usa el runtime estándar de C (libc).
- Depuración normal; al ser static, su símbolo es interno al módulo.

### 10. Estructuras de control
- No tiene bucles ni condicionales.
- **Flujo lineal:**
  - Preparar va_list.
  - Llamar a vsprintf.
  - Cerrar va_list.
  - return buffer;.

### 11. Análisis de malware / seguridad
- **Vulnerabilidad Crítica (Buffer Overflow)**:
  - Uso de vsprintf (en lugar de vsnprintf) en un búfer de tamaño fijo muy pequeño (`MAX_FORMATTEXT_LENGTH = 64 bytes`) → riesgo de desbordamiento de buffer si el resultado supera MAX_FORMATTEXT_LENGTH.
  - Si el texto formateado excede los 63 caracteres (+ terminador nulo), vsprintf escribirá fuera de los límites del arreglo buffer, corrompiendo la memoria adyacente (stack o sección de datos estáticos, dependiendo del compilador).


---------------------------


## Comparativas de las funciones - Tabla 1 – Características generales
| # | Nombre             | Tipo (función / proc.)     | Aridad               | Tipo de retorno              | ¿Varargs?      | ¿Hoja?                               | ¿Función pura?                           | ¿Modifica memoria/estado?                                      | Visibilidad            |
| - | ------------------ | -------------------------- | -------------------- | ---------------------------- | -------------- | ------------------------------------ | ---------------------------------------- | -------------------------------------------------------------- | ---------------------- |
| 1 | `aeResizeSetSize`  | Función                    | 2 (binaria)          | `int` (`AE_OK/AE_ERR`)       | No             | No (llama `aeApiResize`, `zrealloc`) | No                                       | Sí: `realloc` de `events`/`fired`, cambia `setsize` y máscaras | Externa (sin `static`) |
| 2 | `args_cmp`         | Función                    | 2 (binaria)          | `int` (diferencia de `flag`) | No             | Sí                                   | Sí (solo lee `a1->flag` y `a2->flag`)    | No, solo lectura                                               | Interna (`static`)     |
| 3 | `checksum_generic` | Función                    | 2 (binaria)          | `uint16_t`                   | No             | Sí                                   | Sí (solo lee memoria y calcula checksum) | No, solo lectura de `*addr`                                    | Externa                |
| 4 | `rand_str`         | **Procedimiento** (`void`) | 2 (binaria)          | `void`                       | No             | No (llama `rand_next`)               | No                                       | Sí: escribe en el búfer apuntado por `str`, avanza PRNG        | Externa                |
| 5 | `TextFormat`       | Función                    | Aridad variable (≥1) | `const char *`               | **Sí** (`...`) | No (usa `va_*`, `vsprintf`)          | No                                       | Sí: escribe en `static char buffer[]`                          | Interna (`static`)     |


## Comparativas de las funciones - Seguridad / malware
| # | Nombre             | Efectos secundarios clave                                                     | Riesgos técnicos / bugs típicos                                                                                                                | Interés desde análisis de malware                                                                                                                                                |
| - | ------------------ | ----------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 1 | `aeResizeSetSize`  | Reasigna arrays del event loop y cambia su tamaño; inicializa máscaras nuevas | Posibles errores si `zrealloc` puede devolver `NULL` y no se comprueba; posible leak si no se maneja bien en otros sitios                      | Infraestructura de bucle de eventos; típica en servidores. No es indicio de malware por sí sola.                                                                                 |
| 2 | `args_cmp`         | Ninguno (solo cálculo `a1->flag - a2->flag`)                                  | Cuidado teórico con overflow de `int` si `flag` es grande, pero en práctica casi siempre irrelevante                                           | Función comparadora totalmente neutra; cero interés directo para malware.                                                                                                        |
| 3 | `checksum_generic` | Lee memoria y calcula checksum de 16 bits                                     | Si `count` no corresponde al tamaño real del búfer, podría leer fuera de límites (bug lógico del llamador)                                     | Rutina de checksum genérica; usada tanto en código legítimo como en malware (p.ej. para verificar payloads), pero no es sospechosa por sí sola.                                  |
| 4 | `rand_str`         | Rellena un búfer con bytes pseudo-aleatorios usando `rand_next()`             | Posibles problemas de alineación con casts a `uint32_t *` / `uint16_t *` en arquitecturas estrictas; calidad del PRNG depende de `rand_next()` | Genera datos aleatorios: en malware podría servir para claves, IVs, nombres aleatorios, etc., pero también es muy común en software normal. El contexto de uso manda.            |
| 5 | `TextFormat`       | Escribe en `static buffer[64]` y devuelve puntero a ese buffer compartido     | Uso de `vsprintf` sin límite → riesgo claro de **desbordamiento de buffer** si la salida >64; no reentrante ni thread-safe (buffer estático)   | No es maliciosa, pero es interesante a nivel de **vulnerabilidades**: overflow y condiciones de carrera podrían ser explotables si se usa con datos controlados por un atacante. |
