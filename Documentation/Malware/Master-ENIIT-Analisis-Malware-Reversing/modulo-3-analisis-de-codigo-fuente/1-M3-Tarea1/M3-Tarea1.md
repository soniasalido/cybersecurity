
# Ejercicio 1
Cuando nos dan un código para que lo estudiemos, lo primero de todo es averiguar **en que lenguaje está escrito**. Ya sea **ensamblador o un lenguaje de alto nivel**, nuestro primer movimiento es observar los detalles del código para responder las siguientes preguntas: **¿Es un ensamblador o es código de alto nivel? ¿El sistema de tipos es dinámico o estático? ¿Es un lenguaje compilado o se trata de un lenguaje interpretado?** Para ello, vamos a entrenar la vista con trozos (la expresión angosajona sería “snippet”) de código sobre los que debéis averiguar en que lenguaje esta escrito e indicar como lo habéis averiguado. Es decir, no basta con decir: “Es Perl.”

## Trozo 1

![Trozo 1](capturas/trozo1.png)


### La definición de función
```go
func InMemLoads() (map[string]Image, error) {
```
donde:
- Los tipos de retorno van después de los paréntesis, e incluso son múltiples (map[string]Image, error). Esto es algo **muy típico de Go.**

---------------------------

### Declaraciones con :=
```go
ret := make(map[string]Image)
s, si, p := GetModuleLoadedOrder(0)
start := p
i := 1
```
donde:
- La declaración corta (short variable declaration) con := es una **característica distintiva de Go.**


---------------------------

### Uso de make para mapas
```
make(map[string]Image)
```
donde: 
- make es **builtin de Go** para crear map, chan y slice.

---------------------------

### Conversión de tipos al estilo Go
```
Image{uint64(s), uint64(si)}
```
donde:
- En Go las conversiones se escriben como llamadas de función: uint64(...).

---------------------------

### Uso de nil como valor nulo y sintaxis de mapa
```
ret[p] = ...
return ret, nil
```
donde:
- En Go, nil representa el “valor cero” para ciertos tipos de referencia (punteros, interfaces, mapas, slices, canales y funciones) y significa “no hay valor / no apunta a nada”.

---------------------------

### Conclusión
Este trozo está en Go (Golang) porque usa la sintaxis func para definir funciones, devuelve map[string]Image, inicializa mapas con make, utiliza la asignación corta := y las conversiones de tipo explícitas uint64(...), elementos característicos de Go y no presentes juntos en otros lenguajes de alto nivel y compilado. Usa un tipado estático `(map[string]Image, error, uint64, etc.)`.


---------------------------

## Trozo 2
![Trozo 1](capturas/trozo-2.png)


### La cabecera de la clase
```
export default class Encoder {
```
donde:
- export default es sintaxis de módulos ES6 (JS/TS).

---------------------------

### Anotaciones de tipos exclusivos de Javascript
```
data: number[] = []
pushByte(value: number) {
pushInt(value: number, n: number, littleEndian=false) {
pushBytes(bytes: Uint8Array | Buffer | number[]) {
```
donde:
- data: number[] → campo de clase con tipo number[].
- Parámetros con tipo (value: number, n: number).
- Unión de tipos Uint8Array | Buffer | number[], sintaxis típica de TypeScript.

---------------------------

### Uso de Javascript
```
let
const
b => this.data.push(b).
>>
&
```
donde:
- Usos de let, const.
- Arrow function: b => this.data.push(b).
- Operadores bit a bit: >>, & 0xff.


---------------------------
Perplexity:

La declaración export default class Encoder { ... } es propia de los módulos ES6, pero aquí cada parámetro y atributo lleva anotaciones de tipo explícitas (data: number[] = [], value: number, bytes: Uint8Array | Buffer | number[]), lo que encaja con TypeScript y no con JavaScript “puro”.​​

El uso de tipos unidos con | (Uint8Array | Buffer | number[]) y de tipos primitivos en los parámetros (n: number, littleEndian=false) es sintaxis típica de TypeScript para tipado estático opcional.​​

El resto de la sintaxis (clases, for (let i = 0; i < n; i++), this.data.push(...), bytes.forEach(b => ...)) coincide con JavaScript moderno, y la combinación “JS + anotaciones de tipo” es precisamente la seña de identidad de TypeScript.


---------------------------

### Conclusión
Este trozo está escrito en TypeScript. Es código de alto nivel (TypeScript). TypeScript tiene tipado estático (aunque se borra al compilar a JS). TypeScript se compila (transpila) a JavaScript, y luego el JavaScript resultante se ejecuta en un motor JS (interpretado/JIT).

Es TypeScript porque usa sintaxis de clases y módulos de JavaScript (export default class), pero además tiene anotaciones de tipo (value: number, data: number[]) y tipos unión (Uint8Array | Buffer | number[]), propios de TypeScript y ausentes en JavaScript estándar.

---------------------------

## Trozo 3
![Trozo 1](capturas/trozo-3.png)

### Directiva al principio
```
Option Explicit
``` 
donde:
- Es muy típica de VB/VBA para obligar a declarar variables.

---------------------------

### Definición de procedimientos
```
Sub PDF2Workbook()
...
End Sub
``` 
donde:
- El uso de Sub ... End Sub para procedimientos es propio de Visual Basic.


----------------------------

### Llamada a métodos de la aplicación host
```
Application.Run "PDFTables2Workbook", , True
``` 
donde:
- `Application.Run` es típico en VBA dentro de Excel/Word.

---------------------------

### Cuadros de mensaje y constantes “vb*”
```
MsgBox PDFTablesPages, vbOKOnly + vbInformation, " PDFTables"
``` 
donde:
- `MsgBox` y constantes como `vbOKOnly`, `vbInformation`, `vbNullString` son constantes predefinidas de VBA.

---------------------------

### Firma de procedimiento con Optional, ByVal, As Tipo
```
ub PDFTables2Workbook(Optional ByVal InitialFolderFile As String = vbNullString, _
                       Optional ByVal AllowMultiSelect As Boolean = False)
``` 
donde:
- Esta Sintaxis es característica de Visual Basic/VBA.


---------------------------

###  Conclusión
Este trozo está en Visual Basic for Applications (VBA), típico de macros de Office (Excel, etc.).

Es un lenguaje de alto nivel (VBA).

VBA usa un tipado estático cuando declaras tipos (As String, As Boolean) y Option Explicit obliga a declarar variables. Eso sí, tiene el tipo Variant que permite algo de dinamismo.

En el contexto de VBA (macros de Office) se compila a p-code y lo ejecuta el intérprete de VBA dentro de la aplicación; a efectos prácticos en esta clasificación se suele considerar interpretado.

------------------------------

### Perplexity



Es VBA porque usa la directiva Option Explicit, define procedimientos con Sub ... End Sub, utiliza parámetros Optional ByVal ... As String/Boolean y constantes predefinidas como vbNullString y vbInformation, todo ello típico de Visual Basic for Applications en macros de Office.

-----------------------------------

## Trozo 4
![Trozo 1](capturas/trozo-4.png)

### La definición de la función
```
long uv__idna_toascii(const char* s, const char* se, char* d, char* de) {
``` 
donde:
- Tipo de retorno al principio (long) y parámetros con tipos C clásicos (const char*).
- No hay clases, ni namespace, ni referencias (& en parámetros), nada “orientado a objetos” → suena a C más que a C++.

----------------------------------------

### Declaraciones de variables locales
```
const char* si;
const char* st;
unsigned c;
char* ds;
int rc;
``` 
donde:
- Uso de punteros (char*) y del tipo unsigned “a secas”, muy típico en código C.

----------------------------------------

### Estructura del bucle y llamada a función
```
while (si < se) {
    st = si;
    c = uv__utf8_decode1(&si, se);
    if (c == -1u)
        return UV_EINVAL;
}
``` 
donde:
- Sintaxis de control (while, if) típica de la familia C.
- Macros estilo UV_EINVAL también son muy de C (constantes definidas con #define).


----------------------------------------

### Conclusión
Este trozo está escrito en C. Podría compilar como C++ también, pero el estilo y las construcciones están claramente pensados como C puro (es típico de librerías del sistema como libuv).

Es código de alto nivel, lenguaje C.

C tiene tipado estático: todos los identificadores tienen tipo en tiempo de compilación (long, int, char*, unsigned, …).

C es un lenguaje compilado: se traduce a código máquina (normalmente a través de un compilador como gcc, clang, etc.).


Es C porque declara funciones y variables con tipos primitivos (long, unsigned, int) y punteros (const char*), usa un while con comparación de punteros, llama a funciones con paso de direcciones (&si) y no aparece ninguna característica propia de C++ como referencias, new, class o namespace.

----------------------------------------

### Perplexity

La firma de la función long uv__idna_toascii(const char* s, const char* se, char* d, char* de) usa tipos primitivos (long, char*, int) y el calificador const con punteros, exactamente con la sintaxis de C.​​

Las declaraciones separadas al inicio del bloque (const char* si;, unsigned c;, int rc;), el uso de while (si < se) { ... } y la llamada a una función estilo C c = uv__utf8_decode1(&si, se); encajan con el estilo C clásico (sin referencias ni clases ni sobrecarga, como habría en C++).


Todo el código se basa en funciones y tipos primitivos (long, unsigned, char*, int), sin la presencia de clases, objetos, referencias (&ref como variable, no como dirección), funciones sobrecargadas, espacios de nombres (namespace), plantillas (template), constructores o destructores automáticos ni la palabra clave new o delete, que sí son propios de C++

----------------------------------------


## Trozo 5
![Trozo 1](capturas/trozo-5.png)

### Cmdlets con guiones y parámetros con `-`
```
Out-File -FilePath $PayloadPath -InputObject $Payload -Encoding ascii
```
donde:
- `Out-File`, `Get-WmiObject`, `Write-Output`, `Write-Verbose` son `cmdlets` típicos de PowerShell.

---------------------------

### Variables con el símbolo `$` delante
```
$PayloadPath
$OSVersion = (Get-WmiObject -Class win32_OperatingSystem).BuildNumber
```
donde:
- xxxx

---------------------------

### Uso de switch con strings entre comillas como caso
```
switch($method)
{
    "Sysprep"
    {
        ...
    }
}
```
donde:
- xxxx

---------------------------

### Operador `-match` para expresiones regulares:
```
if ($OSVersion -match "76")
```
donde:
- xxxx

---------------------------

### Tipos .NET entre corchetes y llamadas estáticas
```
[Byte[]] $temp = $DllBytes -split ' '
[System.IO.File]::WriteAllBytes($PathToDll, $temp)
```
donde:
- xxxx

---------------------------

### Conclusión
Este trozo está escrito en PowerShell.

Es un lenguaje de alto nivel (script de PowerShell).

PowerShell usa tipado dinámico (aunque permite anotar tipos como [Byte[]]).

Se considera un lenguaje interpretado / de scripting: el motor de PowerShell ejecuta el script directamente (sobre .NET).



### Perplexity

Usa cmdlets típicos de PowerShell con el patrón Verbo‑Sustantivo, por ejemplo Out-File, Get-WmiObject, Write-Output, Write-Verbose.​​

La sintaxis de parámetros con guion (-FilePath, -InputObject, -Class win32_OperatingSystem) y variables con prefijo $ ($OSVersion, $PayloadPath, $env:temp) es característica de PowerShell.

El uso de switch($method) con un case de cadena "Sysprep" y el operador -match para expresiones regulares (if ($OSVersion -match "76")) sigue la gramática propia del lenguaje.​​

La notación de tipo [Byte[]] y las llamadas a clases .NET con el formato [System.IO.File]::WriteAllBytes(...) muestran la integración directa de PowerShell con .NET, algo distintivo frente a otros shells.

---------------------------

# Ejercicio 2


- Describe que hace la función.
- Describe la signatura de la función, define los tipos de parámetros que usa, qué recibe y que devuelve la función.
- Los parámetro que usa la función están pasado por valor o por referencia?
- ¿tiene la función parámetros por defecto?
- Sistema de tipos usados, son dinámicos, son estáticos
- Funciones que importa o exporta. ¿Cómo el programa importa/exporta funciones de una librería? Mediante
  - Enlace dinámico.
  - Enlace estático.
  - Carga dinámica, dureante la ejecución.
- ¿Es una función de usuario?
- ¿es una función que no cambia el estado del programa, es decir tiene transparencia referencial?
- ¿Es una función pura?
- ¿cual es el ámbito de la función (su visibilidad)?
- Define las variales que usa, son globales? locales? estaticas?


