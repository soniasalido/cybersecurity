
![portada-tarea1-modulo2](capturas/portada-tarea1-modulo2-.jpg)
--------------------------------
# 2. Hashes

## 2.1 Colisi√≥n.
**Usa los archivos de la carpeta "hashes": archivo_1 y archivo_2.**

**Calcula el hash SHA-1 (haz captura de pantalla) y explica que est√° ocurriendo y por qu√© sucede.**

**¬øQu√© algoritmo utilizar√≠as para obtener hashes diferentes? Explica como lo soluciona. Razona tu respuesta (a√±ade captura de pantalla).**

----------------
### Marco Te√≥rico: SHA-1

**<mark>Las siglas SHA corresponden a Algoritmo de Hash Seguro</mark>**, un algoritmo de resumen propuesto por la `NSA` y adoptado como est√°ndar Federal por el `NIST` (National Institute of Standards and Technology) en 1993. Antes de los 2 a√±os se detectan vulnerabilidades por lo en 1995 proponen un nuevo algoritmo conocido como `SHA 1`, pasando el anterior a denominarse `SHA 0`, y no recomendarse su uso.


**<mark>El dise√±o de `SHA 1` es muy similar al de `md5`</mark>**. MD5 y SHA-1 son funciones hash criptogr√°ficas. Toman un mensaje de cualquier tama√±o (un archivo, un texto, etc.) y devuelven una `‚Äúhuella‚Äù fija llamada resumen o digest.`
- **Tama√±o del digest (resumen):**
  - MD5 produce 128 bits ‚Üí 16 bytes ‚Üí 32 caracteres hexadecimales.
  - SHA-1 produce 160 bits ‚Üí 20 bytes ‚Üí 40 caracteres hexadecimales.
    
  M√°s bits = m√°s combinaciones posibles de huellas. Cuantas m√°s combinaciones tengamos, m√°s dif√≠cil es encontrar dos mensajes distintos con la misma huella (colisi√≥n) o recuperar el mensaje original (preimagen).

**<mark>Una funci√≥n hash no cifra</mark>, sino que crea un resumen o ¬´firma¬ª de un conjunto de datos, que es pasado como par√°metro a esta funci√≥n.**

**<mark>SHA1 es √∫til para verificar la integridad</mark>, por ejemplo, de un archivo.** Aplicamos dicha funci√≥n sobre un archivo verificamos que el hash obtenido es el mismo que el anunciado por el emisor.


**<mark>Paradoja del cumplea√±os:</mark>** la dificultad de colisi√≥n crece como 2<sup>(n/2)</sup>, siendo n los bits del hash.
- MD5 (128 bits) ‚âà 2<sup>64</sup> intentos.
- SHA-1 (160 bits) ‚âà 2<sup>80</sup> intentos.
Por eso, SHA-1 era considerado m√°s robusto que MD5: su digest es m√°s largo y, en dise√±o, mejora algunas partes.


**<mark>Esquema del algoritmo SHA-1</mark>**  
Al igual que en md5, el mensaje se agrupa en bloques de 512 bits con 16 palabras de 32 bits. Para completar el √∫ltimo bloque de 512 bits, se aplicar√° un relleno de un 1, seguido de tantos 0 como sea necesario, reservando los √∫ltimos 64 bits para indicar el tama√±o del mensaje o archivo. Internamente **SHA1 trata las palabras en representaci√≥n Big Endian**, es decir, primero se leen los bytes m√°s significativos y despu√©s, los bytes menos significativos (manera natural a la que estamos acostumbrados).

Por ejemplo la palabra de 32 bits "amor", que en hexadecimal es: `41 6D 6F 72`, se leer√°: `41 6D 6F 72`.

**SHA1 usa 5 vectores p√∫blicos de 32 bits, conocidos como `A, B, C, D y E` que se mezclar√°n con las palabras del texto en claro, tambi√©n de 32 bits.** Realizando para cada bloque de entrada de 512 bits, un total de 80 vueltas. Terminadas las primeras 80 vueltas, los vectores iniciales `A, B, C, D y E` habr√°n cambiado varias veces de valor y ser√°n los nuevos 5 vectores que se mezclar√°n con el segundo bloque de 512 bits de entrada. Esta acci√≥n se va encadenando con los siguientes bloques, hasta que el √∫ltimo valor de los vectores `A, B, C, D y E` es el resumen de 160 bits de todo el documento.

**<mark>Las 80 vueltas de SHA1</mark>**  
A cada bloque del texto de entrada se le aplicar√°n 20 vueltas con 4 funciones distintas, de forma tal que el n√∫mero total de vueltas por bloque ser√° igual a 20 *4 = 80.
Pero, ¬øc√≥mo podemos generar 80 palabras de 32 bits a partir s√≥lo de los 512 bits de entrada? Cada bloque de 16 palabras del mensaje se expandir√° en 80 palabras, de forma que las palabras 0 a 15 se corresponden a los 512 bits del bloque y las 64 palabras restantes, de la 16 a la 79, se obtienen mediante una operaci√≥n l√≥gica entre las palabras anteriores.


**<mark>La fortaleza de SHA1. La ‚Äúparadoja del cumplea√±os‚Äù.</mark>**  
**Para un hash de n bits, el coste esperado de encontrar una colisi√≥n por fuerza bruta (dos mensajes cualesquiera con el mismo hash) no es 2<sup>ùëõ</sup>, sino ~2<sup>ùëõ/2</sup>.  A esto se le llama l√≠mite de cumplea√±os.**

Para SHA-1, ùëõ = 160 ‚Üí l√≠mite ideal ‚âà 2<sup>80</sup> evaluaciones del hash.

**<mark>Qu√© pas√≥ con SHA-1 en la pr√°ctica</mark>**
La criptoan√°lisis redujo ese coste muy por debajo de 2<sup>80</sup>:
- 2017 (SHAttered): colisi√≥n pr√°ctica con complejidad ~2<sup>63</sup> (orden de magnitud), muy inferior al ideal.
- 2020 (‚ÄúSHA-1 is a Shambles‚Äù): colisi√≥n de prefijo elegido tambi√©n con coste ~2<sup>63</sup> (orden de magnitud).
Es decir: no baj√≥ ‚Äúa menos de 2<sup>50</sup>‚Äù en ataques reales al SHA-1 completo; los mejores ataques pr√°cticos est√°n en torno a 2<sup>63</sup> (en equivalentes de evaluaciones de la funci√≥n de compresi√≥n), que ya es devastador para seguridad.


> [!TIP]
> **<mark>Conclusi√≥n </mark>**
> - Fortaleza de colisi√≥n de SHA-1: cay√≥ de ~2<sup>80</sup> (ideal) a ~2<sup>63</sup> (ataques pr√°cticos).
> - Eso es preocupante (y suficiente para retirar SHA-1 de usos de seguridad: firmas, certificados, integridad con adversario).
> - Se pas√≥ a SHA-256 (colisi√≥n ideal ~2<sup>128</sup> o SHA-3-256/BLAKE2/3.

#### <mark>Coste ideal por paradoja del cumplea√±os</mark>
| Algoritmo               | Bits del hash (n) | Colisi√≥n ideal ‚âà (2<sup>n/2</sup>) | Nota pr√°ctica conocida                                                              |
| ----------------------- | ----------------: | -------------------------: | ----------------------------------------------------------------------------------- |
| **SHA-1**               |               160 |                   (2<sup>80</sup>) | Colisiones **pr√°cticas** ‚âà (2<sup>63</sup>) (SHAttered, 2017; CPC 2020) ‚Üí **desaconsejado** |
| **SHA-256** (SHA-2)     |               256 |                  (2<sup>128</sup>) | Sin colisiones conocidas                                                            |
| **SHA-3-256** (Keccak)  |               256 |                  (2<sup>128</sup>) | Sin colisiones conocidas                                                            |
| **SHA-512/256** (SHA-2) |               256 |                  (2<sup>128</sup>) | Sin colisiones conocidas                                                            |
| **BLAKE2s/BLAKE3-256**  |               256 |                  (2<sup>128</sup>) | Sin colisiones conocidas                                                            |


#### <mark>Demostraci√≥n de colisi√≥n en SHA-1 - SHAttered</mark>
10 a√±os despu√©s de la introducci√≥n del algoritmo SHA-1 como funci√≥n hash, se anunci√≥ la primera t√©cnica pr√°ctica para generar una colisi√≥n. Esto es dado un ¬´archivo A¬´, generar otro ¬´archivo B¬ª que produzca el mismo hash que el del ¬´archivo A¬´.

Tras dos a√±os de investigaci√≥n y la colaboraci√≥n del CWI Institute en Amsterdamy Google, este equipo de investigadores consigui√≥ crear un m√©todo para generar colisiones. Como prueba del ataque, publican dos archivos PDF que tienen hash SHA-1 id√©nticos pero con contenido diferente (PDF 1 y PDF 2).


#### <mark>Referencias</mark>
[P√≠ldora 45 - C√≥mo funciona el hash SHA-1]https://www.youtube.com/watch?v=pG8785ZEFuM&list=PL8bSwVy8_IcNNS5QDLjV7gUg8dIeMFSER&index=45


https://unaaldia.hispasec.com/2017/02/demostracion-practica-de-colision-en-sha-1.html


--------------------------------------------

### An√°lisis del problema

**<mark>Vemos que los documentos son diferentes:</mark>**  
![tarea-2](capturas/tarea-2.png)

**<mark>Usamos comando `file` y `ls` para obtener informaci√≥n de los ficheros:</mark>**  
![info-generica](capturas/info-generica.png)
- Comprobamos que ambos ficheros son documentos pdfs.
- Tienen exactamente el mismo tama√±o.


**<mark>Calculamos hash-1:</mark>**  
![sha1sum](capturas/sha1sum.png)
- SHA-1 de los archivos son iguales: 38762cf7f55934b34d179ae6a4c80cadccbb7f0a


**<mark>Usamos la funci√≥n hash criptogr√°fica sha-256:</mark>**  
![sha256sum](capturas/sha256sum.png)

SHA-256 de los archivos son distintos:
- archivo_1: 2bb787a73e37352f92383abe7e2902936d1059ad9f1ba6daaa9c1e58ee6970d0
- archivo_2: d4488775d29bdef7993367d541064dbdda50d383f89f0aa13a6ff2e0894ba5ff


**<mark>Propiedades criptogr√°ficas de sha-256:</mark>**
- Resistencia a colisiones: encontrar dos entradas distintas con el mismo hash cuesta ‚âà 2<sup>128</sup> operaciones (por el ataque de cumplea√±os).
- Estado actual: no hay colisiones pr√°cticas conocidas para SHA-256; sigue consider√°ndose seguro (a diferencia de SHA-1).


**<mark>Comparamos los dos archivos con el comando linux `cmp`:</mark>**
El comando `cmp` comparar√° byte a byte ambos archivos y mostrar√° sus diferencias. Usaremos la opci√≥n `-l` para listar todas las posiciones donde difieren.
```bash
usuario@usuario-1-2:$ cmp -l archivo_1 archivo_2 
   193 163 177
   196 221 223
   197 146 246
   200  21   1
   201 217  73
   204 266 252
   205  41  35
   208  17  13
   209 371 105
   212 314 326
   213 250 210
   216 133 113
   217 250 214
   220   3  37
   221  14 340
   224 342 366
   225  30  24
   228 263 261
   229 251 151
   232 325 305
   233 337 153
   236 117 123
   237  46  12
   240 263 267
   241 334 140
   244 152 162
   245 302 162
   248 275 255
   252 105 111
   253 274   4
   256 322 302
   257  74  60
   260 353 351
   261  24 324
   264 273 253
   265 125 341
   268 240 274
   269 250 224
   272  61  65
   273 376 102
   276  67  55
   277 270 230
   280  37  17
   281  16  52
   284 337 303
   285 223 177
   288   0  24
   289 353 347
   292  15  17
   293 354  54
   296 144 164
   297 171 315
   300  54  60
   301 166 132
   304 140 144
   305 335 141
   308 221 211
   309 320 140
   312 257 277
   316 244 250
   317 274   4
   320 261 241
```
La salida del comando `cmp` muestra cada diferencia encontrada entre los archivos, estableciendo tres columnas:
- N√∫mero de byte (empieza en 1, no en 0).
- Valor del byte en archivo_1 en octal.
- Valor del byte en archivo_2 en octal.

Por ejemplo, el byte 193 (contado desde el 1):
- En el archivo 1, aparece: 163 (octal) ‚Üí es 0x73 (hex) = 115 (dec) ‚Üí car√°cter ASCII: 's' (min√∫scula).
- En el archivo 2, aparece: 177 (octal) ‚Üí es 0x7F (hex) = 127 (dec) ‚Üí car√°cter ASCII: DEL (no imprimible).


**<mark>Extraemos las diferencias:</mark>**
Vamos a mostar el primer y el ultimo offset distintos entre ambos ficheros (contado desde 1).
- Primer offset que difiere: `cmp -l archivo_1 archivo_2 | awk 'NR==1{print $1; exit}'` ‚Üí 193
- √öltimo offset que difiere: `cmp -l archivo_1 archivo_2 | tail -n1 | awk '{print $1}'` ‚Üí 320

donde:
- `awk 'NR==1{print $1; exit}'`‚Üí toma solo la primera l√≠nea (NR==1), imprime la primera columna ($1, el offset) y sale para no procesar m√°s.
- `| tail -n1 | awk '{print $1}'` ‚Üí se queda s√≥lo con la √∫ltima l√≠nea del flujo e imprime el primer campo.
  
![offsets diferentes](capturas/offsets-diferentes.png)


**<mark>Mostramos el contenido en todo el tramo 193‚Äì320 (base 1) con hexdump:</mark>**
```bash
hexdump -Cv -s 192 -n 128 archivo_1
hexdump -Cv -s 192 -n 128 archivo_2
```
![hexdump](capturas/hexdump.png)

Donde:
- Inicio de las diferencias en base 0: 192
- Fin de las diferencias en base 0: 319
- Tama√±o a mostrar: 319 ‚àí 192 + 1 = 128 bytes
- -s 192 ‚Üí  salta 192 bytes (empieza en el offset 193 en base 1)
- -n 128 ‚Üí  muestra justo 128 bytes.

**<mark>Sha-1 y los bloques de colisi√≥n:</mark>**
- SHA-1 trabaja en bloques de 512 bits = 64 bytes, contados desde el byte 0 del archivo.
- El primer byte distinto est√° en 193 (base 1) ‚áí 192 (base 0), y el √∫ltimo en 320 (base 1) ‚áí 319 (base 0).
- El rango 192..319 (base 0) tiene 128 bytes, o sea exactamente 2 bloques de 64 bytes consecutivos:
   - Bloque 3: 192‚Äì255
   - Bloque 4: 256‚Äì319
     
**Podemos decir que el tramo 192‚Äì319 son los bloques de colisi√≥n (dos bloques) que hacen que ambos archivos terminen con el mismo SHA-1.**


**<mark>Comprobaci√≥n de que todo lo dem√°s es id√©ntico:</mark>**
Aplicamos la funci√≥n criptogr√°fica sha256 a la parte del archivo antes de que empiece las diferencias para ver que son **IDENTICOS**:  
![hash256-primer-bloque](capturas/hash256-primer-bloque.png)

Alicar la funci√≥n criptogr√°fica sha256 a la parte del archivo al finalizar las diferencias para ver que son **IDENTICOS**:  
![hash256-ultimo-bloque](capturas/hash256-ultimo-bloque.png)

**<mark>Esto corrobora que s√≥lo difieren en esos 128 bytes y que son los dos bloques de colisi√≥n de SHA-1.</mark>**


--------------------------------------------

### Algoritmo que utilizar√≠a para obtener hashes diferentes
Para evitar que dos ficheros distintos tengan el mismo hash, usar√≠a algoritmos modernos como por ejemplo:
- SHA-256
- SHA-512
- MD5


**<mark>Usamos la funci√≥n hash criptogr√°fica sha-256:</mark>**  
![sha256sum](capturas/sha256sum.png)

Tal y como vimos en la parte del √°nalisis del problema, si usamos SHA-256 obtenemos hashes diferentes:
- archivo_1: 2bb787a73e37352f92383abe7e2902936d1059ad9f1ba6daaa9c1e58ee6970d0
- archivo_2: d4488775d29bdef7993367d541064dbdda50d383f89f0aa13a6ff2e0894ba5ff


**C√≥mo soluciona SHA-256 las colisiones:**
- Sha256 no parchea SHA-1; es un redise√±o:
- Aumenta el tama√±o de hash (de 160 ‚Üí 256 bits).
- Reestructura el compresor para romper correlaciones lineales.
- Usa constantes y rotaciones adicionales para mejorar la difusi√≥n (peque√±os cambios ‚Üí hash completamente distinto).
- A d√≠a de hoy contin√∫a sin colisiones conocidas.


----------------
### Nota hist√≥rica:
Los pdfs del ejercicio se corresponden con los que usaron en el experimento Google y CWI Amsterdam para demostrar la primera colisi√≥n pr√°ctica de SHA-1: llamada SHAttered (2017) ‚Üí  https://shattered.io/

Desde entonces se usa como ejemplo acad√©mico cl√°sico de por qu√© **SHA-1 no debe emplearse para seguridad criptogr√°fica.**

----------------
## 2.2 SSDEEP.

### Marco Te√≥rico: `ssdeep`
ssdeep es un hash difuso (fuzzy hashing) que se usa para medir similitud entre ficheros. Detecta variaciones o alteraciones en un archivo. 

ssdeep divide el archivo en trozos seg√∫n el contenido y genera una firma de esos trozos. Al comparar dos firmas, calcula un score de similitud.

**No se usa para detectar colisiones criptogr√°ficas. No es un hash criptogr√°fico: sirve para detecci√≥n de contenido similar** (malware, documentos parecidos, versiones, etc.).

ssdeep fragmenta el fichero en bloques y compara las cadenas resultantes; si la mayor√≠a de bloques coinciden, la similitud es alta aunque haya diferencias localizadas.


### An√°lisis del problema: Usando ssdeep obtenemos una salida similar pero no id√©ntica.

![ssdeep](capturas/ssdeep.png)

donde:
- 6144 bytes es el Blocksize ‚Üí ssdeep eligi√≥ bloques de 6144 bytes (‚âà6 KB) para construir el fuzzy hash
- archivo_1 ‚Üí 6144:**Y**twCbnsK7bdKenCpg9aP4zcrS8066ivrfNpNnJNt5S1k82URbx1sgcUyBtBuzdo3:**Y**tN7bAg9D4rNpNnJ5Ek8fbn6
- archivo_2 ‚Üí 6144:**o**twCbnsK7bdKenCpg9aP4zcrS8066ivrfNpNnJNt5S1k82URbx1sgcUyBtBuzdo3:**o**tN7bAg9D4rNpNnJ5Ek8fbn6
- <mark>La √∫nica diferencia es una letra inicial (‚ÄúY‚Äù - ‚Äúo‚Äù), lo que indica que ssdeep percibe una similitud muy alta, pero no id√©ntica.</mark>

Vemos que ssdeep no devuelve un simple hash; devuelve una huella sensible a los cambios. Aqu√≠, el algoritmo detect√≥ que los archivos son casi id√©nticos, con una peque√±a variaci√≥n (esas 128 bytes modificadas para provocar la colisi√≥n SHA-1). Esa peque√±a diferencia cambi√≥ apenas un car√°cter del fuzzy hash.

Porcentaje de similitud: Usamos la opci√≥n `-d` para que calcule dicho porcentaje:  
![ssdeep-d](capturas/ssdeep-d.png)

**Porcentaje de similitud detetada: 99**

--------------------------------------------

# 3. REGLAS YARA
## 3.1 YARA I
Usa los archivos de la carpeta "yara1".

Escribe una regla YARA por cada archivo.

Cada una de ellas deber√° detectar la presencia de uno solo de los archivos. Es decir, la regla, pongamos "regla_1.yara", detecta el file1' y no el resto. As√≠ con las otras dos.

Escribe una cuarta regla yara que detecte dos archivos de tu elecci√≥n pero no detecte el que has descartado.

En el documento pdf de entrega, a√±ade que estrategia has seguido para conseguirlo, as√≠ como la elecci√≥n de la sintaxis yara y tu razonamiento para encontrar la soluci√≥n. Documenta con capturas de pantalla.


--------------------------------------------

### An√°lisis del problema

El nombre del archivo por s√≠ solo no puede usarse como patr√≥n de detecci√≥n en una regla YARA est√°ndar, ya que YARA analiza el contenido interno de los archivos y no su nombre en el sistema de archivos. As√≠, las condiciones deben referirse a datos o cadenas que est√©n realmente presentes dentro del contenido del archivo.

<mark>Para una detecci√≥n precisa y exclusiva, buscaremos una cadena √∫nica dentro de cada archivo.</mark> Para ello usaremos el comando `cmp` para estudiar las diferencias que comparten los archivos.

![yara-1-diferencias](capturas/yara-1.png)

donde:
- En el byte 5951, file1 tiene 000 (NUL) y file2 tiene 364‚Çà (= 244‚ÇÅ‚ÇÄ = 0xF4).
- En el byte 8265, file1 tiene 275‚Çà (= 189‚ÇÅ‚ÇÄ = 0xBD) y file3 333‚Çà (= 219‚ÇÅ‚ÇÄ = 0xDB).
- En 5951: file2 = 364‚Çà y file3 = 000 (mismo que file1).
- En 8265: file2 = 275‚Çà (mismo que file1) y file3 = 333‚Çà.

**<mark>Utilizaremos estas diferencias para escribir reglas yara con las que detectar unos u otros ficheros:</mark>**
- En los offsets (considerando el primer offset: 0):
	- `5950`.
	- `8264`.
- Valores:
	- `364‚Çà = 0xF4`.
	- `275‚Çà = 0xBD`.
	- `333‚Çà = 0xDB`.

--------------------------------------------
## Detecci√≥n de file1
```
rule regla_1 : detection
{
	meta:
		author = "soniasalido"
		email = "soniasalido@gmail.com"
		version	= "1.5"
		created	= "2025-10-09"
		last_modified = "2025-10-26"
		description	= "Detecta s√≥lo file1 usando dos bytes caracter√≠sticos del file1"
		nota1 = "Offset 5950 --> 0x00 -> Excluye a file2 que tiene en esa posici√≥n 364)octal -> 0xF4"
		nota2 = "Offset 8264 --> 275)octal --> 0xBD --> Excluye file 3: tiene 333)octal --> 0xDB"
		nota3 = "Al combinar ambas reglas, s√≥lo puede cumplirse en file1"
		license	= "CC BY-SA 4.0"
	condition:
		uint8(5950) == 0x00 and uint8(8264) == 0xBD

}
```
![regla-yara-I-1](capturas/regla-yara-I-1.png)


--------------------------------------------
## Detecci√≥n de file2
```
rule regla_2 : detection
{
	meta:
		author = "soniasalido"
		email = "soniasalido@gmail.com"
		version	= "1.5"
		created	= "2025-10-09"
		last_modified = "2025-10-26"
		description	= "Detecta s√≥lo file2 usando el Offset base 0: 5950 del file2"
		nota1 = "En file2 el Offset: 5950 --> 364)octal --> 0xF4"
		nota2 = "En file1 el Offset: 5950 --> 0x0"
		nota3 = "En file3 el Offset: 5950 --> 0x0"
		license	= "CC BY-SA 4.0"
	
	condition:
		uint8(5950) == 0xF4

}
```
![regla-yara-I-2](capturas/regla-yara-I-2.png)


--------------------------------------------
## Detecci√≥n de file3
```
rule regla_3 : detection
{
	meta:
		author = "soniasalido"
		email = "soniasalido@gmail.com"
		version	= "1.5"
		created	= "2025-10-09"
		last_modified = "2025-10-26"
		description = "Detecta s√≥lo file3 usando dos bytes caracter√≠sticos del file2"
		nota1 = "File3 el Offset 8264 --> 333)octal --> 0xDB --> Exluye a file1, tiene: 0xBD"
		nota2 = "File3 el Offset 5950 --> 0)octal -->  0x0 --> Excluye a file2, tiene 364)octal --> 0xF4"
		nota3 = "Al combinar ambas reglas, s√≥lo puede cumplirse en file3"
		license	= "CC BY-SA 4.0"
		
	condition:
		uint8(8264) == 0xDB and uint8(5950) == 0x0

}
```
![regla-yara-I-3](capturas/regla-yara-I-3.png)

--------------------------------------------
## Detecta file1 y file3
```
rule regla_4 : detection
{
	meta:
		author = "soniasalido"
		email = "soniasalido@gmail.com"
		version = "1.5"
		created	= "2025-10-09"
		last_modified = "2025-10-26"
		description	= "Detecta dos archivos: file1 y file3, pero no detecta file2"
		nota1 = "En file1 el Offset 5950 --> 0)octal -->  0x0"
		nota2 = "En file3 el Offset 5950 --> 0)octal -->  0x0"
		nota3 = "En file2 el Offset 5950 --> 364)octal --> 0xF4"
		nota4 = "En 5950 debe tener 0x00 (file1 y file3 lo tienen; file2 no)."
		nota5 = "En 8264 debe tener 0xBD √≥ 0xDB (file1 = 0xBD, file3 = 0xDB)."
		license	= "CC BY-SA 4.0"
		
	condition:
		uint8(5950) == 0x00 and
		(uint8(8264) == 0xBD or uint8(8264) == 0xDB)

}
```
![regla-yara-I-4](capturas/regla-yara-I-4.png)


## 3.2 YARA II
Usa el/los archivos de la carpeta "yara2 ".

Tenemos un archivo "sospechoso" en la carpeta "yara2" (no es malware, puedes ejecutarlo) que se comunica con un dominio.

Crea una regla yara que detecte dicho dominio en el ejecutable.

Cuando se te eval√∫e, se har√° contra un ejecutable id√©ntico pero sin ese dominio exacto. Es decir: o creas la regla para detectar el uso del dominio exacto o no va a funcionar.

En el documento pdf de entrega, a√±ade que estrategia has seguido para conseguirlo, as√≠ como la elecci√≥n de la sintaxis yara y tu razonamiento para encontrar la soluci√≥n.

## An√°lisis del problema: Investigamos el fichero ejecutable
Vamos a usar el comando `strings` para investigar las cadenas de texto que se encuentran en dicho ejecutable:
```
usuario@usuario-1-2:~/Escritorio/material_eval_1/yara2$ strings -a -n 2 ejecutable 
ELF
`1
td
td
td
td
/lib64/ld-linux-x86-64.so.2
GNU
GNU
GNU
libc.so.6
strcpy
inet_ntoa
puts
__stack_chk_fail
strlen
herror
gethostbyname
__cxa_finalize
__libc_start_main
GLIBC_2.4
GLIBC_2.2.5
_ITM_deregisterTMCloneTable
__gmon_start__
_ITM_registerTMCloneTable
ii
i	
h!
 @
5j/
%k/
%M/
^H
PTL
H9
n.
t	
H)
?H
E.
=].
u+UH
=".
=&.
5.
UH
SH
<?v
H+E
[]
UH
AUATSH
<?v
H+E
~B
~FH
~CH
)E
[A\A]]
UH
0H
lH
t7
UH
AWAVAUATSH
HdH
%(
Hk
H)
H9
H)
dH34%(
[A\A]A^A_]
f.
AWL
AVI
AUI
ATA
UH
SL)
H9
[]A\A]A^A_
ff.
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@>@@@?456789:;<=@@@@@@@
@@@@@@
 !"#$%&'()*+,-./0123@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/
d3d3LmNhbXB1c2NpYmVyc2VndXJpZGFkLmNvbQ==
www.dominiochungoono.com
d3d3LmRvbWluaW9jaHVuZ29vbm8uY29t
gethostbyname
;\
zR
:*3$"
@n
8A
0A
(B
 B
h!
GCC: (Ubuntu 9.4.0-1ubuntu1~20.04.2) 9.4.0
.shstrtab
.interp
.note.gnu.property
.note.gnu.build-id
.note.ABI-tag
.gnu.hash
.dynsym
.dynstr
.gnu.version
.gnu.version_r
.rela.dyn
.rela.plt
.init
.plt.got
.plt.sec
.text
.fini
.rodata
.eh_frame_hdr
.eh_frame
.init_array
.fini_array
.dynamic
.data
.bss
.comment
@"
@"
(@
(0
(0
S0
usuario@usuario-1-2:~/Escritorio/material_eval_1/yara2$ 
```
<mark>Aparece un dominio: www.dominiochungoono.com</mark>

## Regla yara que detecte el dominio encontrado
Creamos una regla YARA que contenga ese literal exacto:
- Usamos `ASCII` y `WIDE` por si el ejecutable lo guarda como Unicode.
- Usamos `nocase` para que en el dominio no se distinga entre may√∫sculas/min√∫sculas.

```
rule regla_detecta_dominio : detection
{
	meta:
		author = "soniasalido"
		email = "soniasalido@gmail.com"
		version	= "1.1"
		created	= "2025-10-15"
		last_modified = "2025-10-26"
		description = "Detecta si aparece el dominio www.dominiochungoono.com en el ejecutable"
		license	= "CC BY-SA 4.0"

	strings:
		$dominio_ascii = "www.dominiochungoono.com" ascii wide nocase
	condition:
		$dominio_ascii

}
```

![regla-yara-2](capturas/regla-yara-2.png)
donde:
- 0x2191 es el offset (desplazamiento) en bytes desde el inicio del archivo donde empieza la coincidencia del string, expresado en hexadecimal.

Usaremos el comando `hexdump` para ver el texto ASCII que aparece en ese desplazamiento del archivo: 0x2191 que se corresponde con el dominio que est√°bamos buscando ‚Üí 
![regla-yara-2-B](capturas/regla-yara-2-B.png)


--------------------------------
## 3.3 YARA III
Crea una regla que detecte el archivo 1 y 3.

Crea otra regla que detecte el archivo 2 y 4.

En el documento pdf de entrega, a√±ade que estrategia has seguido para conseguirlo, as√≠ como la elecci√≥n de la sintaxis yara y tu razonamiento para encontrar la soluci√≥n.
Documenta con capturas de pantalla.

## An√°lisis del problema

### An√°lisis de las diferencias entre fichero1 y fichero3
Vamos a usar el comando `diff <(xxd -p 1.bin) <(xxd -p 3.bin)` para analizar las diferencias entre estos ficheros para poder hacer una regla yara que los detecte.
![regla-yara-3-file1-file3](capturas/regla-yara-3-file1-file3.png)

donde: 
- `xxd -p` imprime 60 caracteres hexadecimales por l√≠nea (= 30 bytes).
- `10000a10001,10005` ‚Üí Significa que en la l√≠nea 10000 del volcado en crudo del fichero 1.bin se a√±aden las l√≠neas 10001 a 10005 de 3.bin.
- **3.bin tiene 5 l√≠neas extra respecto a 1.bin: las l√≠neas 10001 a 10005.**
- Estas 5 l√≠neas a√±adidas muestran `abcdefabcdef...`, que es el patr√≥n hexadecimal `ab cd ef....`.
- Estas 5 l√≠neas extra son ‚âà 150 bytes insertados en 3.bin.


Usamos el comando ls para verificar ese extra de tama√±o de 150 bytes del fichero 3.bin:  
![regla-yara-3-ls.png](capturas/regla-yara-3-ls-2.png)


### An√°lisis de las diferencias entre fichero1 y fichero2
![regla-yara-3-file1-file2](capturas/regla-yara-3-file1-file2.png)

El fichero 2.bin sigue el patr√≥n anterior: en la l√≠nea 10000 del volcado en crudo del fichero 1.bin se a√±aden una l√≠nea 10001 con el patr√≥n `abcdef` en hexadecimal.

Estos 6 caracteres hexadecimales son 3 bytes, que se pueden ver en la captura de pantalla que muestra el tama√±o de los ficheros.



### An√°lisis de las diferencias entre fichero1 y fichero4
![regla-yara-3-file1-file4](capturas/regla-yara-3-file1-file4.png)

El fichero 4.bin sigue el patr√≥n anterior: en la l√≠nea 10000 del volcado en crudo del fichero 1.bin se a√±aden 500 l√≠neas con el patr√≥n `abcdefabcdef...`, que es el patr√≥n hexadecimal `ab cd ef....`.

Se a√±aden desde la 10001 hasta la 10500. Son 500 l√≠neas extra √ó 30 bytes/l√≠nea = 15000 bytes a√±adidos. Que se corresponden con la captura de pantalla que muestra el tama√±o de los ficheros.



## Regla Yara que de positivo para los ficheros: 1.bin y 3.bin:
Sabemos que:
- 1.bin se identifica por su tama√±o exacto (300000 bytes).
- 3.bin es igual que 1.bin pero con un ap√©ndice al final de 150 bytes formado por \xAB\xCD\xEF repetido 50 veces.

```
rule detecta_1_y_3_solo {
	meta:	
		author = "soniasalido"
		email = "soniasalido@gmail.com"
		version	= "1.1"
		created	= "2025-10-17"
		last_modified = "2025-10-26"
		description	= "Detecta al archivo 1 y 3"
		nota1 = "1.bin se identifica por su tama√±o exacto (300000 bytes)."
		nota2 = "3.bin es igual que 1.bin pero con un ap√©ndice al final de 150 bytes formado por \xAB\xCD\xEF repetido 50 veces"
		nota3 = "Contiene ese bloque al final del fichero."
		license	= "CC BY-SA 4.0"
	strings:
		$tail = /(\xAB\xCD\xEF){50}/
	condition:
		filesize == 300000
		or (filesize == 300150 and $tail at 300000 and $tail at (filesize - 150))
}
```
donde:
- Detecta 1.bin por tama√±o exacto (300000) ‚Üí `filesize == 300000`.
- Detecta 3.bin por
	- Tama√±o exacto (300150) ‚Üí `filesize == 300150`.
	- Contiene ese bloque de 150 bytes (AB CD EF √ó 50) empezando en el offset 300000 ‚Üí `$tail at 300000`.
 	- Contiene ese bloque al final del fichero ‚Üí `$tail at (filesize - 150)`.

![regla-yara3-solucion-1](capturas/regla-yara3-solucion-1.png)

## Regla Yara que de positivo para los ficheros: 2.bin y 4.bin:
```
rule detecta_2_y_4_solo
{
	meta:
		author = "soniasalido"
		email = "soniasalido@gmail.com"
		version = "1.3"
		created	= "2025-10-18"
		last_modified	= "2025-10-26"
		description = "Detecta al archivo 2 y 4"
		nota1 = "Debe contener al menos 50 repeticiones del patr√≥n en la parte final del fichero. Lo cumplen 3.bin y 4.bin"
		nota2 = "Excluye a 3.bin por su tama√±o. Es diferente de 300150"
		nota3a = "Detecta 2.bin exigiendo AB CD EF exactamente en el offset 300000 y..."
		nota3b = "... asegurando que no se repite dentro de esa ‚Äúl√≠nea‚Äù (siguiente rango de 29 bytes),...
		nota3c = "... de modo que sea solo esos 3 bytes."
		license	= "CC BY-SA 4.0"
	strings:
		$tail = /(\xAB\xCD\xEF){50}/
		$once = { AB CD EF }
	condition:
		//($tail in (300000..filesize-1) and filesize != 300150)
		(filesize > 300000 and $tail at (filesize -150) and filesize != 300150)
		or
		(filesize > 300002 and $once at 300000 and not ($once in (300003..300029)))
}
```
donde:
- Debe contener al menos 50 repeticiones del patr√≥n en la parte final del fichero ‚Üí  `$tail in (300000..filesize-1)`. Esto lo cumplen 3.bin y 4.bin.
- Excluye a 3.bin por el tama√±o ‚Üí `filesize != 300150`.
- Detecta 2.bin por para ‚Äúl√≠nea 10001‚Äù en un volcado xxd -p (cada l√≠nea = 30 bytes). La l√≠nea 10001 empieza en el offset 300000 (10000 √ó 30)..
- nota1: se satisface con `$tail at (filesize - 150)` ‚Üí el patr√≥n aparece al final.
- nota2: se excluye 3.bin con `filesize != 300150`.
- nota3: se detecta 2.bin exigiendo AB CD EF exactamente en el offset 300000 y asegurando que no se repite dentro de esa ‚Äúl√≠nea‚Äù (siguiente rango de 29 bytes), de modo que sea solo esos 3 bytes.


--------------------------------
# 4. Sandboxes

## 4.1 Sandbox I

Usando cualquier sandbox de uso gratuito tienes que encontrar una muestra que tenga estas caracter√≠sticas:
- Que sea maliciosa.
- Que tenga actividad maliciosa de red.
- Que cree archivos en el sistema.

Cuando la hayas encontrado, deber√°s escribir un an√°lisis explicando c√≥mo funciona y qu√© hace la muestra.


### Muestra de malware

He escogido una muestra que aparece en ANY.run en: https://app.any.run/tasks/65317167-d24d-47f2-bac3-2d244dc4f23b

**<mark>Arquitectura de destino del malware:</mark>**
| Field                                 | Value                                                                                               |
|---------------------------------------|-----------------------------------------------------------------------------------------------------|
| file > sha256                         | D1BFC02DB9922F89DA0CEF14B514B63AF3703F1AB7BD88D558431151BFAC92E2                                     |
| file > first 32 bytes (hex)           | 4D 5A 90 00 03 00 00 00 04 00 00 00 FF FF 00 00 B8 00 00 00 00 00 00 00 40 00 00 00 00 00 00 00       |
| file > first 32 bytes (text)          | MZ............................................@..............                                        |
| file > info                           | size: 37376 bytes, entropy: 6.314                                                                    |
| file > type                           | executable, 32-bit, GUI                                                                              |
| file > version                        | n/a                                                                                                  |
| file > description                    | n/a                                                                                                  |
| entry-point > first 32 bytes (hex)    | 55 8B EC 6A FF 68 78 91 40 00 68 C4 5E 40 00 64 A1 00 00 00 00 50 64 89 25 00 00 00 00 83 EC 10       |
| entry-point > location                | 0x0000352F (section[.text])                                                                          |
| file > signature                      | Microsoft Linker 6.0 \| Visual Studio 6.0 MASM \| Microsoft Visual C++ \| Microsoft Visual C++ 6.0 - 8.0 |

![anyrun-summary](capturas/anyrun-summary.png)



**<mark>Conexi√≥n con el servidor:</mark>**  
El malware intent√≥ resolver el FQDN para obtener la IP de su infraestructura C2 (us.t28.net) y, si la resoluci√≥n ten√≠a √©xito, abrir despu√©s una conexi√≥n (HTTP/HTTPS/TCP) a ese host.

![anyrun-dns-request](capturas/anyrun-dns-request.png)


**<mark>Procesos:</mark>**  
En esta captura vemos los procesos que ha generado este malware.  
![anyrun-general-procesos](capturas/anyrun-general-procesos.png)

- Procesos totales: 137
- Monitoreados: 2
- Sospechosos: 1 ‚Üí lab_03-2.malware.exe (arrancado por el sandbox).
- slui.exe aparece en un hilo separado y con ‚Äúno specs‚Äù. Este proceso slui.exe (Windows Activation UI) no figura como hijo de la muestra ni marcado sospechoso ‚Üí probablemente sea actividad del sistema no relacionada con el malware.

El √°rbol de procesos muestra que el archivo ‚ÄúLab_03-2.malware.exe‚Äù fue ejecutado por el usuario ‚Äúadmin‚Äù con la l√≠nea de comandos \"C:\\Users\\admin\\AppData\\Local\\Temp\\Lab_03-2.malware.exe\". El archivo se encuentra en la carpeta temporal del usuario:  
![anyrun-procesos](capturas/anyrun-procesos.png)

**1. Masquerading:**
El primero proceso vemos que el malware crea C:\Users\admin\java.exe (37 376 bytes) y que su hash es identico al del fichero malware, luego indica que es una copia exacta del mismo.  
![any-run-java](capturas/anyrun-java2.png)



**2. Persistencia en Registro**
Escribe en `HKLM\SOFTWARE\WOW6432Node...\Run` una entrada llamada `sysinfo` con valor `C:\DOCUME~1\admin\java.exe`.  
![any-run-cambio-registro](capturas/anyrun-cambio-registro.png)


**3. Lee el nombre del equipo**  
![anyrun-lee-nombre-equipo](capturas/anyrun-lee-nombre-equipo.png)


**4. Ejecuta fichero desde una clave del registro**  
El clon del malware que se cre√≥ es ejecutado desde la clave de registro: `sysinfo`. 
![anyrun-ejecuta-fichero](capturas/anyrun-ejecuta-fichero.png)


**5. Chequea idioma**  
![anyrun-chequea-idioma](capturas/anyrun-chequea-idioma.png)


**<mark>M√≥dulos usados por el malware:</mark>**  
![anyrun-modules](capturas/anyrun-modules.png)  
A destacar:
- WS2_32.dll ‚Üí sockets y C2. Hooks/BP: WSAStartup, socket, connect, send, recv, closesocket, inet_addr, inet_ntoa, htons.
- MSWSOCK.dll ‚Üí extensiones Winsock (resoluci√≥n/conexiones avanzadas). √ötil si el sample usa ConnectEx/optimizaciones.
- DNSAPI.dll ‚Üí resoluci√≥n de dominios (encaja con el dns requeste para  us.t28.net).
- ADVAPI32.dll ‚Üí Registro y seguridad. Hooks: RegCreateKeyExA/W, RegSetValueExA/W, RegOpenKeyEx, RegCloseKey.
- KERNEL32.dll / KernelBase.dll ‚Üí file I/O y creaci√≥n de procesos/pipes. Hooks: CreateFileA/W, WriteFile, CopyFileA/W, DeleteFileA/W...



**<mark>APIS claves detectadas:</mark>**  
![imports-malware-lab3.2](capturas/imports-malware-lab3.2.png)
Pasado el malware por la aplicaci√≥n pestudio para ver las APIs que usa el malware, destacamos:
- Red (WS2_32): socket, connect, send, recv, WSAStartup, inet_addr/ntoa, htons.
- Ficheros: CopyFileA, CreateFileA, WriteFile, ReadFile, DeleteFileA, mapeo (CreateFileMapping/MapViewOfFile/UnmapViewOfFile).
- Procesos: CreateProcessA con pipes an√≥nimos para capturar salida, CreateToolhelp32Snapshot + Process32First/Next (enumeraci√≥n), OpenProcess, TerminateProcess.
- Registro: RegSetValueExA (persistencia en Run key).


**<mark>T√©cnicas MITRE ATT&CK observadas:</mark>**  
![anyrun-mitre-attack.png](capturas/anyrun-mitre-attack.png)
- Persistencia: T1547.001 ‚Äì Boot or Logon Autostart::Run Keys (ya que crea una clave de registro `HKLM\...\Run\sysinfo` apuntando a su propia copia java.exe).

- Evasi√≥n:
	- T1027 (ya que usa codificaci√≥n XOR).
	- T1036 / T1036.005 ‚Äì Masquerading (Match Legitimate Name or Location - Ya que hace una copia de s√≠ mismo en local, no la descarga del servidor)

- T1027 ‚Äì Obfuscated/Compressed Files or Information (ya que usa vodificaciones simples/XOR).

- Descubrimiento:
	- T1082 ‚Äì System Information Discovery (ya que lee nombre del equipo).
	- T1614.001 ‚Äì System Location::System Language Discovery (ya que consulta NLS/idioma).
	- T1012 ‚Äì Query Registry (ya que lee claves de registro para recoger info del sistema).

- Command and Control (C2):
	- T1071.004 ‚Äì Application Layer Protocol: DNS (ya que usa DNS como parte del canal de C2/bootstrapping).
	- T1568 ‚Äì Dynamic Resolution (ya que hace una resoluci√≥n de dominio para localizar su C2; aplica aunque no haya respuesta del C2).


**<mark>Conclusiones:</mark>**
Esta muestra de malware es un PE32 (GUI) compilado con Visual C++ sin packer aparente que, al ejecutarse, se copia a s√≠ mismo con otro nombre (java.exe) y persiste por registro para arrancar en cada inicio de Windows. La muestra tiene comunicaci√≥n por red / conexi√≥n C2 y espera la orden del servidor para llevar a cabo. La recepci√≥n de esta orden nunca se produce ya que el servidor parece caido.


La secci√≥n de archivos modificados indica que el archivo ‚Äújava.exe‚Äù fue modificado y ahora es un ejecutable. Este archivo est√° en la carpeta temporal del usuario y tiene el PID (Identificador de Proceso) 3148.

La secci√≥n de escritura en el registro muestra que se cre√≥ una clave llamada ‚Äúsysinfo‚Äù en el registro con el valor C:\\DOCUME~1\\admin\\java.exe. La clave fue creada por el proceso con PID 3148.

Artefactos clave / IOCs:
- Archivo: C:\Users\admin\java.exe (sin firma/metadata de Oracle).
- Registro: HKLM\SOFTWARE\WOW6432Node\...\Run\sysinfo = C:\DOCUME~1\admin\java.exe.
- Comportamiento: creaci√≥n de EXE en perfil/Temp ‚Üí escritura en Run ‚Üí ejecuci√≥n posterior.



----------------------

# 5. REGLAS SIGMA
## 5.1 Sigma I

Debes recrear el entorno SIGMA que se expone en el temario y convertir una regla a tu elecci√≥n que no sea la mostrada en los materiales.

Explica brevemente el proceso con tus palabras. E importante, que hace (detecta) la regla que has elegido y c√≥mo lo hace.

Ilustra los pasos de la conversi√≥n de la regla con capturas de pantalla en tu documento de entrega PDF.

------------------------

### <mark>1. Preparando el entorno. Instalaci√≥n de Python</mark>
Instalaci√≥n de python y creamos un entorno virtual para instalar sigma-cli en este entorno virtual:
```
sudo apt update
sudo apt install -y python3 python3-pip python3-venv
python3 -m venv ~/sigma-venv
source ~/sigma-venv/bin/activate
python -m pip install --upgrade pip
```
![sigma-instalacion-sigma-cli](capturas/sigma-instalacion-sigma-cli-0.png)


### <mark>2. Instalamos sigma-cli</mark>
```
pip install sigma-cli
```
![sigma-instalacion-sigma-cli-3](capturas/sigma-instalacion-sigma-cli-3.png)


### <mark>3. Mostramos qu√© plugins/backends hay</mark>
```
sigma plugin list
```
![sigma-plugin-list](capturas/sigma-plugin-list.png)


### <mark>4. Instalamos backend de Elastic (EQL) y pipelines de Windows/Sysmon</mark>
```
sigma plugin install elasticsearch
sigma plugin install windows
sigma plugin install sysmon
```
![sigma-instalacion-plugins](capturas/sigma-instalacion-plugins.png)


### <mark>5. Descargamos las reglas oficiales para practicar con una de ellas</mark>
```
git clone https://github.com/SigmaHQ/sigma
```
![sigma-clonando-repositorio-sigma-rules](capturas/sigma-clonando-repositorio-sigma-rules.png)


### <mark>5. La Regla elegida</mark>
En concreto he elegido una regla con detectar ofuscaci√≥n con XOR en powershell: https://github.com/SigmaHQ/sigma/blob/master/rules/windows/process_creation/proc_creation_win_powershell_xor_commandline.yml
```
title: Suspicious XOR Encoded PowerShell Command
id: bb780e0c-16cf-4383-8383-1e5471db6cf9
related:
    - id: 5b572dcf-254b-425c-a8c5-d9af6bea35a6
      type: obsolete
status: test
description: Detects presence of a potentially xor encoded powershell command
references:
    - https://speakerdeck.com/heirhabarov/hunting-for-powershell-abuse?slide=65
    - https://redcanary.com/blog/yellow-cockatoo/
    - https://zero2auto.com/2020/05/19/netwalker-re/
    - https://mez0.cc/posts/cobaltstrike-powershell-exec/
author: Sami Ruohonen, Harish Segar, Tim Shelton, Teymur Kheirkhabarov, Vasiliy Burov, oscd.community, Nasreddine Bencherchali
date: 2018-09-05
modified: 2023-01-30
tags:
    - attack.defense-evasion
    - attack.execution
    - attack.t1059.001
    - attack.t1140
    - attack.t1027
logsource:
    category: process_creation
    product: windows
detection:
    selection_img:
        - Image|endswith:
              - '\powershell.exe'
              - '\pwsh.exe'
        - OriginalFileName:
              - 'PowerShell.EXE'
              - 'pwsh.dll'
        - Description: 'Windows PowerShell'
        - Product: 'PowerShell Core 6'
    selection_cli_xor:
        CommandLine|contains: 'bxor'
    selection_cli_other:
        CommandLine|contains:
            - 'ForEach'
            - 'for('
            - 'for '
            - '-join '
            - "-join'"
            - '-join"'
            - '-join`'
            - '::Join'
            - '[char]'
    condition: all of selection_*
falsepositives:
    - Unknown
level: medium
```
donde:
- Esta regla busca l√≠neas de comando de PowerShell que puedan desofuscar/decodificar contenido usando el operador `XOR`.
- Sus creadores: Sami Ruohonen, Harish Segar, Tim Shelton, Teymur Kheirkhabarov, Vasiliy Burov, oscd.community, Nasreddine Bencherchali.
- Fecha de creaci√≥n: 2018-09-05.
- Fecha de modificaci√≥n: 2023-01-30.
- `status: test` ‚Üí considerada en pruebas. Podr√≠a requerir tuning: puede requerir ajustes (tuning) en el entorno para reducir falsos positivos u otros ajustes.
- `level: medium` ‚Üí severidad media. Indica que la detecci√≥n es relevante y se necesita un triage para corroborar si existe indicios de compromiso cr√≠tico.
- `falsepositives: Unknown` ‚Üí no catalogados. Los autores no tienen identificados (o no han documentado) casos t√≠picos en los que la regla pueda disparar alertas leg√≠timas (falsos positivos).
- Etiquetas MITRE ATT&CK que posee ‚Üí Para que podamos podamos hacer mejores triages o correlaciones.
	- `t1059.001` (PowerShell) ‚Äì Ejecuci√≥n.
	- `t1140` (Deobfuscate/Decode) y `t1027` (Ofuscaci√≥n) ‚Äì Evasi√≥n de defensas.
	- T√°cticas: `attack.execution, attack.defense-evasion`.

- D√≥nde mira esta regla ‚Üí Se aplica a eventos de creaci√≥n de procesos en Windows.
  ```
  logsource:
    category: process_creation
    product: windows
  ```

- Los filtros que aplica este regla: Tiene tres bloques y exige que todos se cumplan, ya que usa la condici√≥n: `condition: all of selection_*`.
	- Bloque `selection_img` ‚Üí Identifica que el proceso sea PowerShell.  Usa la condici√≥n `OR` ‚Üí  Basta con que se cumpla uno de los puntos para ser positivo.
		- `Image|endswith: \powershell.exe` o `\pwsh.exe` ‚Üí hace un match si la ruta acaba en \powershell.exe  `OR` \pwsh.exe. (Dentro del mismo campo, una lista implica OR)
  		- `OriginalFileName: PowerShell.EXE` o `pwsh.dll` ‚Üí la regla intenta identificar PowerShell por su identidad interna, no solo por la ruta (Image). Esto es √∫til si el atacante renombra powershell.exe por otra cosa.
    	- `Description: Windows PowerShell` ‚Üí la regla filtra por el metadato de descripci√≥n del archivo (FileDescription) del ejecutable que cre√≥ el proceso.
     	- `Product: PowerShell Core 6` ‚Üí la regla pide que el proceso pertenezca al producto llamado exactamente PowerShell Core 6. Por eso filtra por el metadato `ProductName`. Esta regla puede no cubrir si se usa PowerShell 7+.

        Objetivo: cubrir tanto Windows PowerShell cl√°sico como PowerShell Core (pwsh) y evitar binarios renombrados.
   
	- Bloque `selection_cli_xor` ‚Üí Busca la presencia de XOR. La l√≠nea de comando debe contener `-bxor`.
		- `CommandLine|contains: 'bxor'`  ‚Üí la regla exige que el valor del campo `CommandLine` del evento (la l√≠nea de comandos con la que se lanz√≥ el proceso) contenga la subcadena 'bxor'.

    	Objetivo: el operador -bxor de PowerShell (bitwise XOR) es la pista clave del uso de descifrado.

	- Bloque `selection_cli_other` ‚Üí selection_cli_other agrupa pistas t√≠picas de reconstrucci√≥n de payload alrededor del XOR en PowerShell. Busca patrones t√≠picos alrededor del XOR.  Usa la condici√≥n `OR` ‚Üí  Basta con que se cumpla uno de los puntos para ser positivo.
		- `ForEach`, `for( ` .... Para iterar  datos.
  		- `-join `, `-join', `-join"`.... ‚Üí Para recomponer las cadenas de texto.
    	- `[char]` ‚Üí Para conversi√≥n de bytes a car√°cter

       	Objetivo: detectar la reconstrucci√≥n del payload (concatenado/iterado) tras el XOR.


### <mark>6. Comprobamos la sintaxis de la regla sigma con `check`</mark>
```
sigma check sigma/rules/windows/process_creation/proc_creation_win_powershell_xor_commandline.yml
```
![sigma-check-rule](capturas/sigma-check-rule.png)


### <mark>7. Convertimos la regla a Elastic </mark>
Comprobada que la sintaxis de la regla es correcta, la convertimos a Elastic (consulta EQL directa para Kibana). Tomamos la regla Sigma que hemos elegido, que es una regla gen√©rica (.YAML) y la traducimos al lenguaje que entiende la plataforma Elastic (Kibana/Elastic Security), usando sigma-cli.
```
sigma convert \
  -t eql \
  -p sysmon \
  -f default \
  ./sigma/rules/windows/process_creation/proc_creation_win_powershell_xor_commandline.yml
```
donde:
- `-t eql` ‚Üí  El backend elegido es eql (Elastic Query Language). Con este backend, la salida por defecto es una consulta EQL que podremos pegar en Kibana (EQL search/Timelines).
- `-p sysmon` ‚Üí  La pipeline mapea los campos de Sigma a los campos reales de nuestros logs.
- `-f default` ‚Üí  Pide el formato por defecto del backend eql, que es justo una query EQL en texto plano.
- Ruta del YAML es la regla Sigma a convertir.

![sigma-conversion-regla-a-elastic-eql-kibana](capturas/sigma-conversion-regla-a-elastic-eql-kibana.png)


### <mark>8. Convertimos la regla a Splunk </mark>
Instalamos el backend y pipelines necesarios:
```
sigma plugin install splunk
sigma plugin install sysmon
sigma plugin install windows
```


Convertimos la regla a Splunk:
```
sigma convert \
  -t splunk \
  -p sysmon \
  -f default \
  ./sigma/rules/windows/process_creation/proc_creation_win_powershell_xor_commandline.yml
```
donde:
- `-t splunk` ‚Üí  El backend elegido es splunk.


El resultado es que devuelve el comando anterior es la **consulta SPL que luego copiaremos para pegarlo en la plataforma Splunk en app Search & Reporting**, barra de b√∫squeda.
```
Parsing Sigma rules  [####################################]  100%
EventID=1 Image IN ("*\\powershell.exe", "*\\pwsh.exe") OR OriginalFileName IN ("PowerShell.EXE", "pwsh.dll") OR Description="Windows PowerShell" OR Product="PowerShell Core 6" CommandLine="*bxor*" CommandLine IN ("*ForEach*", "*for(*", "*for *", "*-join *", "*-join'*", "*-join\"*", "*-join`*", "*::Join*", "*[char]*")
```

Vamos a conprobar si la regla convertida funciona. Para ello en una MV Windows, instalamos sysmon:

![sysmon-install](capturas/sysmon-install.png)


Comprobamos que el servicio sysmon est√° funcionando:
![sysmon-funcionando](capturas/sysmon-funcionando.png)


exportamos el eventos a un documento .evtx:
```
wevtutil epl Microsoft-Windows-Sysmon/Operational "%USERPROFILE%\Desktop\sysmon.evtx"
```
![evtx.png](capturas/evtx.png)


Lanzamos un proceso que use ofuscacion xor y generamos un documento con los eventos del sistema que luego pasaremos a splunk:
![eventos-xor](capturas/eventos-xor.png)


Abrimos Splunk y lanzamos la b√∫squeda:



**<mark>Instalamos chainsaw para evaluar Sigma sobre EVTX directamente:</mark>**
Creamos las siguientes carpetas:
```
New-Item -ItemType Directory -Force -Path C:\tools\chainsaw | Out-Null
New-Item -ItemType Directory -Force -Path C:\sigma\mappings | Out-Null
```

Descargamos, descomprimimos y colocamos [Chainsaw](https://github.com/WithSecureLabs/chainsaw) en: `C:\tools\chainsaw`.
![chainsaw](capturas/chainsaw.png)



Descargamos un mapping listo para Windows --> Chainsaw trae mapeos de ejemplo; el m√°s c√≥modo para empezar es `[mappings/sigma-event-logs-all.yml[(https://github.com/WithSecureLabs/chainsaw/blob/master/mappings/sigma-event-logs-all.yml)` del propio repositorio de Chainsaw. Lo descargamos lo guardamos en `C:\sigma\mappings\winlogbeat.yml`.
```
chainsaw.exe hunt "C:\Windows\System32\winevt\Logs" `
  --sigma "C:\sigma\rules\proc_creation_win_powershell_xor_commandline.yml" `
  --mapping "C:\sigma\mappings\sigma-event-logs-all.yml" `
  --json -o C:\tools\chainsaw\findings.json
```







