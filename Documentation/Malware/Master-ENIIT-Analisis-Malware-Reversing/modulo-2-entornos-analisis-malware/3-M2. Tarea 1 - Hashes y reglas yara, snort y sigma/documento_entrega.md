
# 2. Hashes

## 2.1 Colisi√≥n.
**Usa los archivos de la carpeta "hashes": archivo_1 y archivo_2.**

**Calcula el hash SHA-1 (haz captura de pantalla) y explica que est√° ocurriendo y por qu√© sucede.**

**¬øQu√© algoritmo utilizar√≠as para obtener hashes diferentes? Explica como lo soluciona. Razona tu respuesta (a√±ade captura de pantalla).**

----------------
### Marco Te√≥rico: SHA-1

**<mark>Las siglas SHA corresponden a Algoritmo de Hash Seguro</mark>**, un algoritmo de resumen propuesto por la `NSA` y adoptado como est√°ndar Federal por el `NIST` (National Institute of Standards and Technology) en 1993. Antes de los 2 a√±os se detectan vulnerabilidades por lo en 1995 proponen un nuevo algoritmo conocido como `SHA 1`, pasando el anterior a denominarse `SHA 0`, y no recomendarse su uso.


**<mark>El dise√±o de `SHA 1` es muy similar al de `md5`</mark>**. MD5 y SHA-1 son funciones hash criptogr√°ficas. Toman un mensaje de cualquier tama√±o (un archivo, un texto, etc.) y devuelven una `‚Äúhuella‚Äù fija llamada resumen o digest.`
- **Tama√±o del digest (resumen):**
  - MD5 produce 128 bits ‚Üí 16 bytes ‚Üí 32 caracteres hexadecimales.
  - SHA-1 produce 160 bits ‚Üí 20 bytes ‚Üí 40 caracteres hexadecimales.
    
  M√°s bits = m√°s combinaciones posibles de huellas. Cuantas m√°s combinaciones tengamos, m√°s dif√≠cil es encontrar dos mensajes distintos con la misma huella (colisi√≥n) o recuperar el mensaje original (preimagen).

**<mark>Una funci√≥n hash no cifra</mark>, sino que crea un resumen o ¬´firma¬ª de un conjunto de datos, que es pasado como par√°metro a esta funci√≥n.**

**<mark>SHA1 es √∫til para verificar la integridad</mark>, por ejemplo, de un archivo.** Aplicamos dicha funci√≥n sobre un archivo verificamos que el hash obtenido es el mismo que el anunciado por el emisor.


**<mark>Paradoja del cumplea√±os:</mark>** la dificultad de colisi√≥n crece como 2<sup>(n/2)</sup>, siendo n los bits del hash.
- MD5 (128 bits) ‚âà 2<sup>64</sup> intentos.
- SHA-1 (160 bits) ‚âà 2<sup>80</sup> intentos.
Por eso, SHA-1 era considerado m√°s robusto que MD5: su digest es m√°s largo y, en dise√±o, mejora algunas partes.


**<mark>Esquema del algoritmo SHA-1</mark>**  
Al igual que en md5, el mensaje se agrupa en bloques de 512 bits con 16 palabras de 32 bits. Para completar el √∫ltimo bloque de 512 bits, se aplicar√° un relleno de un 1, seguido de tantos 0 como sea necesario, reservando los √∫ltimos 64 bits para indicar el tama√±o del mensaje o archivo. Internamente **SHA1 trata las palabras en representaci√≥n Big Endian**, es decir, primero se leen los bytes m√°s significativos y despu√©s, los bytes menos significativos (manera natural a la que estamos acostumbrados).

Por ejemplo la palabra de 32 bits "amor", que en hexadecimal es: `41 6D 6F 72`, se leer√°: `41 6D 6F 72`.

**SHA1 usa 5 vectores p√∫blicos de 32 bits, conocidos como `A, B, C, D y E` que se mezclar√°n con las palabras del texto en claro, tambi√©n de 32 bits.** Realizando para cada bloque de entrada de 512 bits, un total de 80 vueltas. Terminadas las primeras 80 vueltas, los vectores iniciales `A, B, C, D y E` habr√°n cambiado varias veces de valor y ser√°n los nuevos 5 vectores que se mezclar√°n con el segundo bloque de 512 bits de entrada. Esta acci√≥n se va encadenando con los siguientes bloques, hasta que el √∫ltimo valor de los vectores `A, B, C, D y E` es el resumen de 160 bits de todo el documento.

**<mark>Las 80 vueltas de SHA1</mark>**  
A cada bloque del texto de entrada se le aplicar√°n 20 vueltas con 4 funciones distintas, de forma tal que el n√∫mero total de vueltas por bloque ser√° igual a 20 *4 = 80.
Pero, ¬øc√≥mo podemos generar 80 palabras de 32 bits a partir s√≥lo de los 512 bits de entrada? Cada bloque de 16 palabras del mensaje se expandir√° en 80 palabras, de forma que las palabras 0 a 15 se corresponden a los 512 bits del bloque y las 64 palabras restantes, de la 16 a la 79, se obtienen mediante una operaci√≥n l√≥gica entre las palabras anteriores.


**<mark>La fortaleza de SHA1. La ‚Äúparadoja del cumplea√±os‚Äù.</mark>**  
**Para un hash de n bits, el coste esperado de encontrar una colisi√≥n por fuerza bruta (dos mensajes cualesquiera con el mismo hash) no es 2<sup>ùëõ</sup>, sino ~2<sup>ùëõ/2</sup>.  A esto se le llama l√≠mite de cumplea√±os.**

Para SHA-1, ùëõ = 160 ‚Üí l√≠mite ideal ‚âà 2<sup>80</sup> evaluaciones del hash.

**<mark>Qu√© pas√≥ con SHA-1 en la pr√°ctica</mark>**
La criptoan√°lisis redujo ese coste muy por debajo de 2<sup>80</sup>:
- 2017 (SHAttered): colisi√≥n pr√°ctica con complejidad ~2<sup>63</sup> (orden de magnitud), muy inferior al ideal.
- 2020 (‚ÄúSHA-1 is a Shambles‚Äù): colisi√≥n de prefijo elegido tambi√©n con coste ~2<sup>63</sup> (orden de magnitud).
Es decir: no baj√≥ ‚Äúa menos de 2<sup>50</sup>‚Äù en ataques reales al SHA-1 completo; los mejores ataques pr√°cticos est√°n en torno a 2<sup>63</sup> (en equivalentes de evaluaciones de la funci√≥n de compresi√≥n), que ya es devastador para seguridad.


> [!TIP]
> **<mark>Conclusi√≥n </mark>**
> - Fortaleza de colisi√≥n de SHA-1: cay√≥ de ~2<sup>80</sup> (ideal) a ~2<sup>63</sup> (ataques pr√°cticos).
> - Eso es preocupante (y suficiente para retirar SHA-1 de usos de seguridad: firmas, certificados, integridad con adversario).
> - Se pas√≥ a SHA-256 (colisi√≥n ideal ~2<sup>128</sup> o SHA-3-256/BLAKE2/3.

#### <mark>Coste ideal por paradoja del cumplea√±os</mark>
| Algoritmo               | Bits del hash (n) | Colisi√≥n ideal ‚âà (2<sup>n/2</sup>) | Nota pr√°ctica conocida                                                              |
| ----------------------- | ----------------: | -------------------------: | ----------------------------------------------------------------------------------- |
| **SHA-1**               |               160 |                   (2<sup>80</sup>) | Colisiones **pr√°cticas** ‚âà (2<sup>63</sup>) (SHAttered, 2017; CPC 2020) ‚Üí **desaconsejado** |
| **SHA-256** (SHA-2)     |               256 |                  (2<sup>128</sup>) | Sin colisiones conocidas                                                            |
| **SHA-3-256** (Keccak)  |               256 |                  (2<sup>128</sup>) | Sin colisiones conocidas                                                            |
| **SHA-512/256** (SHA-2) |               256 |                  (2<sup>128</sup>) | Sin colisiones conocidas                                                            |
| **BLAKE2s/BLAKE3-256**  |               256 |                  (2<sup>128</sup>) | Sin colisiones conocidas                                                            |


#### <mark>Demostraci√≥n de colisi√≥n en SHA-1 - SHAttered</mark>
10 a√±os despu√©s de la introducci√≥n del algoritmo SHA-1 como funci√≥n hash, se anunci√≥ la primera t√©cnica pr√°ctica para generar una colisi√≥n. Esto es dado un ¬´archivo A¬´, generar otro ¬´archivo B¬ª que produzca el mismo hash que el del ¬´archivo A¬´.

Tras dos a√±os de investigaci√≥n y la colaboraci√≥n del CWI Institute en Amsterdamy Google, este equipo de investigadores consigui√≥ crear un m√©todo para generar colisiones. Como prueba del ataque, publican dos archivos PDF que tienen hash SHA-1 id√©nticos pero con contenido diferente (PDF 1 y PDF 2).


#### <mark>Referencias</mark>
[P√≠ldora 45 - C√≥mo funciona el hash SHA-1]https://www.youtube.com/watch?v=pG8785ZEFuM&list=PL8bSwVy8_IcNNS5QDLjV7gUg8dIeMFSER&index=45


https://unaaldia.hispasec.com/2017/02/demostracion-practica-de-colision-en-sha-1.html


--------------------------------------------

### An√°lisis del problema

**<mark>Vemos que los documentos son diferentes:</mark>**  
![tarea-2](capturas/tarea-2.png)

**<mark>Usamos comando `file` y `ls` para obtener informaci√≥n de los ficheros:</mark>**  
![info-generica](capturas/info-generica.png)
- Comprobamos que ambos ficheros son documentos pdfs.
- Tienen exactamente el mismo tama√±o.


**<mark>Calculamos hash-1:</mark>**  
![sha1sum](capturas/sha1sum.png)
- SHA-1 de los archivos son iguales: 38762cf7f55934b34d179ae6a4c80cadccbb7f0a


**<mark>Usamos la funci√≥n hash criptogr√°fica sha-256:</mark>**  
![sha256sum](capturas/sha256sum.png)

SHA-256 de los archivos son distintos:
- archivo_1: 2bb787a73e37352f92383abe7e2902936d1059ad9f1ba6daaa9c1e58ee6970d0
- archivo_2: d4488775d29bdef7993367d541064dbdda50d383f89f0aa13a6ff2e0894ba5ff


**<mark>Propiedades criptogr√°ficas de sha-256:</mark>**
- Resistencia a colisiones: encontrar dos entradas distintas con el mismo hash cuesta ‚âà 2<sup>128</sup> operaciones (por el ataque de cumplea√±os).
- Estado actual: no hay colisiones pr√°cticas conocidas para SHA-256; sigue consider√°ndose seguro (a diferencia de SHA-1).


**<mark>Comparamos los dos archivos con el comando linux `cmp`:</mark>**
El comando `cmp` comparar√° byte a byte ambos archivos y mostrar√° sus diferencias. Usaremos la opci√≥n `-l` para listar todas las posiciones donde difieren.
```bash
usuario@usuario-1-2:$ cmp -l archivo_1 archivo_2 
   193 163 177
   196 221 223
   197 146 246
   200  21   1
   201 217  73
   204 266 252
   205  41  35
   208  17  13
   209 371 105
   212 314 326
   213 250 210
   216 133 113
   217 250 214
   220   3  37
   221  14 340
   224 342 366
   225  30  24
   228 263 261
   229 251 151
   232 325 305
   233 337 153
   236 117 123
   237  46  12
   240 263 267
   241 334 140
   244 152 162
   245 302 162
   248 275 255
   252 105 111
   253 274   4
   256 322 302
   257  74  60
   260 353 351
   261  24 324
   264 273 253
   265 125 341
   268 240 274
   269 250 224
   272  61  65
   273 376 102
   276  67  55
   277 270 230
   280  37  17
   281  16  52
   284 337 303
   285 223 177
   288   0  24
   289 353 347
   292  15  17
   293 354  54
   296 144 164
   297 171 315
   300  54  60
   301 166 132
   304 140 144
   305 335 141
   308 221 211
   309 320 140
   312 257 277
   316 244 250
   317 274   4
   320 261 241
```
La salida del comando `cmp` muestra cada diferencia encontrada entre los archivos, estableciendo tres columnas:
- N√∫mero de byte (empieza en 1, no en 0).
- Valor del byte en archivo_1 en octal.
- Valor del byte en archivo_2 en octal.

Por ejemplo, el byte 193 (contado desde el 1):
- En el archivo 1, aparece: 163 (octal) ‚Üí es 0x73 (hex) = 115 (dec) ‚Üí car√°cter ASCII: 's' (min√∫scula).
- En el archivo 2, aparece: 177 (octal) ‚Üí es 0x7F (hex) = 127 (dec) ‚Üí car√°cter ASCII: DEL (no imprimible).


**<mark>Extraemos las diferencias:</mark>**
Vamos a mostar el primer y el ultimo offset distintos entre ambos ficheros (contado desde 1).
- Primer offset que difiere: `cmp -l archivo_1 archivo_2 | awk 'NR==1{print $1; exit}'` ‚Üí 193
- √öltimo offset que difiere: `cmp -l archivo_1 archivo_2 | tail -n1 | awk '{print $1}'` ‚Üí 320

donde:
- `awk 'NR==1{print $1; exit}'`‚Üí toma solo la primera l√≠nea (NR==1), imprime la primera columna ($1, el offset) y sale para no procesar m√°s.
- `| tail -n1 | awk '{print $1}'` ‚Üí se queda s√≥lo con la √∫ltima l√≠nea del flujo e imprime el primer campo.
  
![offsets diferentes](capturas/offsets-diferentes.png)


**<mark>Mostramos el contenido en todo el tramo 193‚Äì320 (base 1) con hexdump:</mark>**
```bash
hexdump -Cv -s 192 -n 128 archivo_1
hexdump -Cv -s 192 -n 128 archivo_2
```
![hexdump](capturas/hexdump.png)

Donde:
- Inicio de las diferencias en base 0: 192
- Fin de las diferencias en base 0: 319
- Tama√±o a mostrar: 319 ‚àí 192 + 1 = 128 bytes
- -s 192 ‚Üí  salta 192 bytes (empieza en el offset 193 en base 1)
- -n 128 ‚Üí  muestra justo 128 bytes.

**<mark>Sha-1 y los bloques de colisi√≥n:</mark>**
- SHA-1 trabaja en bloques de 512 bits = 64 bytes, contados desde el byte 0 del archivo.
- El primer byte distinto est√° en 193 (base 1) ‚áí 192 (base 0), y el √∫ltimo en 320 (base 1) ‚áí 319 (base 0).
- El rango 192..319 (base 0) tiene 128 bytes, o sea exactamente 2 bloques de 64 bytes consecutivos:
   - Bloque 3: 192‚Äì255
   - Bloque 4: 256‚Äì319
     
**Podemos decir que el tramo 192‚Äì319 son los bloques de colisi√≥n (dos bloques) que hacen que ambos archivos terminen con el mismo SHA-1.**


**<mark>Comprobaci√≥n de que todo lo dem√°s es id√©ntico:</mark>**
Aplicamos la funci√≥n criptogr√°fica sha256 a la parte del archivo antes de que empiece las diferencias para ver que son **IDENTICOS**:  
![hash256-primer-bloque](capturas/hash256-primer-bloque.png)

Alicar la funci√≥n criptogr√°fica sha256 a la parte del archivo al finalizar las diferencias para ver que son **IDENTICOS**:  
![hash256-ultimo-bloque](capturas/hash256-ultimo-bloque.png)

**<mark>Esto corrobora que s√≥lo difieren en esos 128 bytes y que son los dos bloques de colisi√≥n de SHA-1.</mark>**


--------------------------------------------

### Algoritmo que utilizar√≠a para obtener hashes diferentes
Para evitar que dos ficheros distintos tengan el mismo hash, usar√≠a algoritmos modernos como por ejemplo:
- SHA-256
- SHA-512
- MD5


**<mark>Usamos la funci√≥n hash criptogr√°fica sha-256:</mark>**  
![sha256sum](capturas/sha256sum.png)

Tal y como vimos en la parte del √°nalisis del problema, si usamos SHA-256 obtenemos hashes diferentes:
- archivo_1: 2bb787a73e37352f92383abe7e2902936d1059ad9f1ba6daaa9c1e58ee6970d0
- archivo_2: d4488775d29bdef7993367d541064dbdda50d383f89f0aa13a6ff2e0894ba5ff


**C√≥mo soluciona SHA-256 las colisiones:**
- Sha256 no parchea SHA-1; es un redise√±o:
- Aumenta el tama√±o de hash (de 160 ‚Üí 256 bits).
- Reestructura el compresor para romper correlaciones lineales.
- Usa constantes y rotaciones adicionales para mejorar la difusi√≥n (peque√±os cambios ‚Üí hash completamente distinto).
- A d√≠a de hoy contin√∫a sin colisiones conocidas.


----------------
### Nota hist√≥rica:
Los pdfs del ejercicio se corresponden con los que usaron en el experimento Google y CWI Amsterdam para demostrar la primera colisi√≥n pr√°ctica de SHA-1: llamada SHAttered (2017) ‚Üí  https://shattered.io/

Desde entonces se usa como ejemplo acad√©mico cl√°sico de por qu√© **SHA-1 no debe emplearse para seguridad criptogr√°fica.**

----------------
## 2.2 SSDEEP.

### Marco Te√≥rico: `ssdeep`
ssdeep es un hash difuso (fuzzy hashing) que se usa para medir similitud entre ficheros. Detecta variaciones o alteraciones en un archivo. 

ssdeep divide el archivo en trozos seg√∫n el contenido y genera una firma de esos trozos. Al comparar dos firmas, calcula un score de similitud.

**No se usa para detectar colisiones criptogr√°ficas. No es un hash criptogr√°fico: sirve para detecci√≥n de contenido similar** (malware, documentos parecidos, versiones, etc.).

ssdeep fragmenta el fichero en bloques y compara las cadenas resultantes; si la mayor√≠a de bloques coinciden, la similitud es alta aunque haya diferencias localizadas.


### An√°lisis del problema: Usando ssdeep obtenemos una salida similar pero no id√©ntica.

![ssdeep](capturas/ssdeep.png)

donde:
- 6144 bytes es el Blocksize ‚Üí ssdeep eligi√≥ bloques de 6144 bytes (‚âà6 KB) para construir el fuzzy hash
- archivo_1 ‚Üí 6144:**Y**twCbnsK7bdKenCpg9aP4zcrS8066ivrfNpNnJNt5S1k82URbx1sgcUyBtBuzdo3:**Y**tN7bAg9D4rNpNnJ5Ek8fbn6
- archivo_2 ‚Üí 6144:**o**twCbnsK7bdKenCpg9aP4zcrS8066ivrfNpNnJNt5S1k82URbx1sgcUyBtBuzdo3:**o**tN7bAg9D4rNpNnJ5Ek8fbn6
- <mark>La √∫nica diferencia es una letra inicial (‚ÄúY‚Äù - ‚Äúo‚Äù), lo que indica que ssdeep percibe una similitud muy alta, pero no id√©ntica.</mark>

Vemos que ssdeep no devuelve un simple hash; devuelve una huella sensible a los cambios. Aqu√≠, el algoritmo detect√≥ que los archivos son casi id√©nticos, con una peque√±a variaci√≥n (esas 128 bytes modificadas para provocar la colisi√≥n SHA-1). Esa peque√±a diferencia cambi√≥ apenas un car√°cter del fuzzy hash.

Porcentaje de similitud: Usamos la opci√≥n `-d` para que calcule dicho porcentaje:  
![ssdeep-d](capturas/ssdeep-d.png)

**Porcentaje de similitud detetada: 99**

--------------------------------------------

# 3. REGLAS YARA
## 3.1 YARA I
Usa los archivos de la carpeta "yara1".

Escribe una regla YARA por cada archivo.

Cada una de ellas deber√° detectar la presencia de uno solo de los archivos. Es decir, la regla, pongamos "regla_1.yara", detecta el file1' y no el resto. As√≠ con las otras dos.

Escribe una cuarta regla yara que detecte dos archivos de tu elecci√≥n pero no detecte el que has descartado.

En el documento pdf de entrega, a√±ade que estrategia has seguido para conseguirlo, as√≠ como la elecci√≥n de la sintaxis yara y tu razonamiento para encontrar la soluci√≥n. Documenta con capturas de pantalla.


--------------------------------------------

### An√°lisis del problema

El nombre del archivo por s√≠ solo no puede usarse como patr√≥n de detecci√≥n en una regla YARA est√°ndar, ya que YARA analiza el contenido interno de los archivos y no su nombre en el sistema de archivos. As√≠, las condiciones deben referirse a datos o cadenas que est√©n realmente presentes dentro del contenido del archivo.

<mark>Para una detecci√≥n precisa y exclusiva, buscaremos una cadena √∫nica dentro de cada archivo.</mark> Para ello usaremos el comando `cmp` para estudiar las diferencias que comparten los archivos.

![yara-1-diferencias](capturas/yara-1.png)

donde:
- En el byte 5951, file1 tiene 000 (NUL) y file2 tiene 364‚Çà (= 244‚ÇÅ‚ÇÄ = 0xF4).
- En el byte 8265, file1 tiene 275‚Çà (= 189‚ÇÅ‚ÇÄ = 0xBD) y file3 333‚Çà (= 219‚ÇÅ‚ÇÄ = 0xDB).
- En 5951: file2 = 364‚Çà y file3 = 000 (mismo que file1).
- En 8265: file2 = 275‚Çà (mismo que file1) y file3 = 333‚Çà.

**<mark>Utilizaremos estas diferencias para escribir reglas yara con las que detectar unos u otros ficheros:</mark>**
- En los offsets (considerando el primer offset: 0):
	- `5950`.
	- `8264`.
- Valores:
	- `364‚Çà = 0xF4`.
	- `275‚Çà = 0xBD`.
	- `333‚Çà = 0xDB`.

--------------------------------------------
## Detecci√≥n de file1
```
rule regla_1 : detection
{
	meta:
		autor = "soniasalido"
		email = "soniasalido@gmail.com"
		version	= "1.5"
		created	= "2025-10-09"
		last_modified = "2025-10-26"
		description	= "Detecta s√≥lo file1 usando dos bytes caracter√≠sticos del file1"
		nota1 = "Offset en base 0: 5950 --> 0x00 --> Excluye a file2 que tiene en esa posici√≥n 364)octal --> 0xF4"
		nota2 = "Offset en base 0: 8264 --> 275)octal --> 0xBD --> Excluye file 3: tiene 333)octal --> 0xDB"
		nota3 = "Al combinar ambas reglas, s√≥lo puede cumplirse en file1"
		license	= "CC BY-SA 4.0"
	condition:
		uint8(5950) == 0x00 and uint8(8264) == 0xBD

}
```
![regla-yara-I-1](capturas/regla-yara-I-1.png)


--------------------------------------------
## Detecci√≥n de file2
```
rule regla_2 : detection
{
	meta:
		autor = "soniasalido"
		email = "soniasalido@gmail.com"
		version	= "1.5"
		created	= "2025-10-09"
		last_modified = "2025-10-26"
		description	= "Detecta s√≥lo file2 usando el Offset base 0: 5950 del file2"
		nota1 = "En file2 el Offset en base 0: 5950 --> 364)octal --> 0xF4"
		nota2 = "En file1 el Offset en base 0: 5950 --> 0x0"
		nota3 = "En file3 el Offset en base 0: 5950 --> 0x0"
		license	= "CC BY-SA 4.0"
	
	condition:
		uint8(5950) == 0xF4

}
```
![regla-yara-I-2](capturas/regla-yara-I-2.png)


--------------------------------------------
## Detecci√≥n de file3
```
rule regla_3 : detection
{
	meta:
		autor = "soniasalido"
		email = "soniasalido@gmail.com"
		version	= "1.5"
		created	= "2025-10-09"
		last_modified = "2025-10-26"
		description = "Detecta s√≥lo file3 usando dos bytes caracter√≠sticos del file2"
		nota1 = "En file3 el Offset en base 0: 8264 -> 333)octal --> 0xDB --> Exluye a file1, tiene: 0xBD"
		nota2 = "En file3 el Offset en base 0: 5950 -> 0)octal -->  0x0 -> Excluye a file2, tiene 364)octal -> 0xF4"
		nota3 = "Al combinar ambas reglas, s√≥lo puede cumplirse en file3"
		license	= "CC BY-SA 4.0"
		
	condition:
		uint8(8264) == 0xDB and uint8(5950) == 0x0

}
```
![regla-yara-I-3](capturas/regla-yara-I-3.png)

--------------------------------------------
## Detecta file1 y file3
```
rule regla_4 : detection
{
	meta:
		autor = "soniasalido"
		email = "soniasalido@gmail.com"
		version = "1.5"
		created	= "2025-10-09"
		last_modified = "2025-10-26"
		description	= "Detecta dos archivos: file1 y file3, pero no detecta file2"
		nota1 = "En file1 el Offset en base 0: 5950 -> 0)octal -->  0x0"
		nota2 = "En file3 el Offset en base 0: 5950 -> 0)octal -->  0x0"
		nota3 = "En file2 el Offset en base 0: 5950 -> 364)octal --> 0xF4"
		nota4 = "En 5950 debe tener 0x00 (file1 y file3 lo tienen; file2 no)."
		nota5 = "En 8264 debe tener 0xBD √≥ 0xDB (file1 = 0xBD, file3 = 0xDB)."
		license	= "CC BY-SA 4.0"
		
	condition:
		uint8(5950) == 0x00 and
		(uint8(8264) == 0xBD or uint8(8264) == 0xDB)

}
```
![regla-yara-I-4](capturas/regla-yara-I-4.png)


## 3.2 YARA II
Usa el/los archivos de la carpeta "yara2 ".

Tenemos un archivo "sospechoso" en la carpeta "yara2" (no es malware, puedes ejecutarlo) que se comunica con un dominio.

Crea una regla yara que detecte dicho dominio en el ejecutable.

Cuando se te eval√∫e, se har√° contra un ejecutable id√©ntico pero sin ese dominio exacto. Es decir: o creas la regla para detectar el uso del dominio exacto o no va a funcionar.

En el documento pdf de entrega, a√±ade que estrategia has seguido para conseguirlo, as√≠ como la elecci√≥n de la sintaxis yara y tu razonamiento para encontrar la soluci√≥n.

## An√°lisis del problema: Investigamos el fichero ejecutable
Vamos a usar el comando `strings` para investigar las cadenas de texto que se encuentran en dicho ejecutable:
```
usuario@usuario-1-2:~/Escritorio/material_eval_1/yara2$ strings -a -n 2 ejecutable 
ELF
`1
td
td
td
td
/lib64/ld-linux-x86-64.so.2
GNU
GNU
GNU
libc.so.6
strcpy
inet_ntoa
puts
__stack_chk_fail
strlen
herror
gethostbyname
__cxa_finalize
__libc_start_main
GLIBC_2.4
GLIBC_2.2.5
_ITM_deregisterTMCloneTable
__gmon_start__
_ITM_registerTMCloneTable
ii
i	
h!
 @
5j/
%k/
%M/
^H
PTL
H9
n.
t	
H)
?H
E.
=].
u+UH
=".
=&.
5.
UH
SH
<?v
H+E
[]
UH
AUATSH
<?v
H+E
~B
~FH
~CH
)E
[A\A]]
UH
0H
lH
t7
UH
AWAVAUATSH
HdH
%(
Hk
H)
H9
H)
dH34%(
[A\A]A^A_]
f.
AWL
AVI
AUI
ATA
UH
SL)
H9
[]A\A]A^A_
ff.
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@>@@@?456789:;<=@@@@@@@
@@@@@@
 !"#$%&'()*+,-./0123@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/
d3d3LmNhbXB1c2NpYmVyc2VndXJpZGFkLmNvbQ==
www.dominiochungoono.com
d3d3LmRvbWluaW9jaHVuZ29vbm8uY29t
gethostbyname
;\
zR
:*3$"
@n
8A
0A
(B
 B
h!
GCC: (Ubuntu 9.4.0-1ubuntu1~20.04.2) 9.4.0
.shstrtab
.interp
.note.gnu.property
.note.gnu.build-id
.note.ABI-tag
.gnu.hash
.dynsym
.dynstr
.gnu.version
.gnu.version_r
.rela.dyn
.rela.plt
.init
.plt.got
.plt.sec
.text
.fini
.rodata
.eh_frame_hdr
.eh_frame
.init_array
.fini_array
.dynamic
.data
.bss
.comment
@"
@"
(@
(0
(0
S0
usuario@usuario-1-2:~/Escritorio/material_eval_1/yara2$ 
```
<mark>Aparece un dominio: www.dominiochungoono.com</mark>

## Regla yara que detecte el dominio encontrado
Creamos una regla YARA que contenga ese literal exacto:
- Usamos `ASCII` y `WIDE` por si el ejecutable lo guarda como Unicode.
- Usamos `nocase` para que en el dominio no se distinga entre may√∫sculas/min√∫sculas.

```
rule regla_detecta_dominio : detection
{
	meta:
		autor = "soniasalido"
		email = "soniasalido@gmail.com"
		version	= "1.1"
		created	= "2025-10-15"
		last_modified = "2025-10-26"
		description = "Detecta si aparece el dominio www.dominiochungoono.com en el ejecutable"
		license	= "CC BY-SA 4.0"

	strings:
		$dominio_ascii = "www.dominiochungoono.com" ascii wide nocase
	condition:
		$dominio_ascii

}
```

![regla-yara-2](capturas/regla-yara-2.png)
donde:
- 0x2191 es el offset (desplazamiento) en bytes desde el inicio del archivo donde empieza la coincidencia del string, expresado en hexadecimal.

Usaremos el comando `hexdump` para ver el texto ASCII que aparece en ese desplazamiento del archivo: 0x2191 que se corresponde con el dominio que est√°bamos buscando ‚Üí 
![regla-yara-2-B](capturas/regla-yara-2-B.png)


--------------------------------
## 3.3 YARA III
Crea una regla que detecte el archivo 1 y 3.

Crea otra regla que detecte el archivo 2 y 4.

En el documento pdf de entrega, a√±ade que estrategia has seguido para conseguirlo, as√≠ como la elecci√≥n de la sintaxis yara y tu razonamiento para encontrar la soluci√≥n.
Documenta con capturas de pantalla.

## An√°lisis del problema

### An√°lisis de las diferencias entre fichero1 y fichero3
Vamos a usar el comando `diff <(xxd -p 1.bin) <(xxd -p 3.bin)` para analizar las diferencias entre estos ficheros para poder hacer una regla yara que los detecte.
![regla-yara-3-file1-file3](capturas/regla-yara-3-file1-file3.png)

donde: 
- `xxd -p` imprime 60 caracteres hexadecimales por l√≠nea (= 30 bytes).
- `10000a10001,10005` ‚Üí Significa que en la l√≠nea 10000 del volcado en crudo del fichero 1.bin se a√±aden las l√≠neas 10001 a 10005 de 3.bin.
- **3.bin tiene 5 l√≠neas extra respecto a 1.bin: las l√≠neas 10001 a 10005.**
- Estas 5 l√≠neas a√±adidas muestran `abcdefabcdef...`, que es el patr√≥n hexadecimal `ab cd ef....`.
- Estas 5 l√≠neas extra son ‚âà 150 bytes insertados en 3.bin.


Usamos el comando ls para verificar ese extra de tama√±o de 150 bytes del fichero 3.bin:  
![regla-yara-3-ls.png](capturas/regla-yara-3-ls-2.png)


### An√°lisis de las diferencias entre fichero1 y fichero2
![regla-yara-3-file1-file2](capturas/regla-yara-3-file1-file2.png)

El fichero 2.bin sigue el patr√≥n anterior: en la l√≠nea 10000 del volcado en crudo del fichero 1.bin se a√±aden una l√≠nea 10001 con el patr√≥n `abcdef` en hexadecimal.

Estos 6 caracteres hexadecimales son 3 bytes, que se pueden ver en la captura de pantalla que muestra el tama√±o de los ficheros.



### An√°lisis de las diferencias entre fichero1 y fichero4
![regla-yara-3-file1-file4](capturas/regla-yara-3-file1-file4.png)

El fichero 4.bin sigue el patr√≥n anterior: en la l√≠nea 10000 del volcado en crudo del fichero 1.bin se a√±aden 500 l√≠neas con el patr√≥n `abcdefabcdef...`, que es el patr√≥n hexadecimal `ab cd ef....`.

Se a√±aden desde la 10001 hasta la 10500. Son 500 l√≠neas extra √ó 30 bytes/l√≠nea = 15000 bytes a√±adidos. Que se corresponden con la captura de pantalla que muestra el tama√±o de los ficheros.



## Regla Yara que de positivo para los ficheros: 1.bin y 3.bin:
Sabemos que:
- 1.bin se identifica por su tama√±o exacto (300000 bytes).
- 3.bin es igual que 1.bin pero con un ap√©ndice al final de 150 bytes formado por \xAB\xCD\xEF repetido 50 veces.

```
rule detecta_1_y_3_solo {
	meta:	
		autor = "soniasalido"
		email = "soniasalido@gmail.com"
		version	= "1.1"
		created	= "2025-10-17"
		last_modified = "2025-10-26"
		description	= "Detecta al archivo 1 y 3"
		nota1 = "1.bin se identifica por su tama√±o exacto (300000 bytes)."
		nota2 = "3.bin es igual que 1.bin pero con un ap√©ndice al final de 150 bytes formado por \xAB\xCD\xEF repetido 50 veces"
		nota3 = "Contiene ese bloque al final del fichero."
		license	= "CC BY-SA 4.0"
	strings:
		$tail = /(\xAB\xCD\xEF){50}/
	condition:
		filesize == 300000
		or (filesize == 300150 and $tail at 300000 and $tail at (filesize - 150))
}
```
donde:
- Detecta 1.bin por tama√±o exacto (300000) ‚Üí `filesize == 300000`.
- Detecta 3.bin por
	- Tama√±o exacto (300150) ‚Üí `filesize == 300150`.
	- Contiene ese bloque de 150 bytes (AB CD EF √ó 50) empezando en el offset 300000 ‚Üí `$tail at 300000`.
 	- Contiene ese bloque al final del fichero ‚Üí `$tail at (filesize - 150)`.

![regla-yara3-solucion-1](capturas/regla-yara3-solucion-1.png)

## Regla Yara que de positivo para los ficheros: 2.bin y 4.bin:
```
rule detecta_2_y_4_solo
{
	meta:
		autor = "soniasalido"
		email = "soniasalido@gmail.com"
		version = "1.3"
		created	= "2025-10-18"
		last_modified	= "2025-10-26"
		description = "Detecta al archivo 2 y 4"
		nota1 = "Debe contener al menos 50 repeticiones del patr√≥n en la parte final del fichero. Lo cumplen 3.bin y 4.bin"
		nota2 = "Excluye a 3.bin por su tama√±o. Es diferente de 300150"
		nota3a = "Detecta 2.bin exigiendo AB CD EF exactamente en el offset 300000 y..."
		nota3b = "... asegurando que no se repite dentro de esa ‚Äúl√≠nea‚Äù (siguiente rango de 29 bytes),...
		nota3c = "... de modo que sea solo esos 3 bytes."
		license	= "CC BY-SA 4.0"
	strings:
		$tail = /(\xAB\xCD\xEF){50}/
		$once = { AB CD EF }
	condition:
		//($tail in (300000..filesize-1) and filesize != 300150)
		(filesize > 300000 and $tail at (filesize -150) and filesize != 300150)
		or
		(filesize > 300002 and $once at 300000 and not ($once in (300003..300029)))
}
```
donde:
- Debe contener al menos 50 repeticiones del patr√≥n en la parte final del fichero ‚Üí  `$tail in (300000..filesize-1)`. Esto lo cumplen 3.bin y 4.bin.
- Excluye a 3.bin por el tama√±o ‚Üí `filesize != 300150`.
- Detecta 2.bin por para ‚Äúl√≠nea 10001‚Äù en un volcado xxd -p (cada l√≠nea = 30 bytes). La l√≠nea 10001 empieza en el offset 300000 (10000 √ó 30)..
- nota1: se satisface con `$tail at (filesize - 150)` ‚Üí el patr√≥n aparece al final.
- nota2: se excluye 3.bin con `filesize != 300150`.
- nota3: se detecta 2.bin exigiendo AB CD EF exactamente en el offset 300000 y asegurando que no se repite dentro de esa ‚Äúl√≠nea‚Äù (siguiente rango de 29 bytes), de modo que sea solo esos 3 bytes.


--------------------------------
# 4. Sandboxes

## 4.1 Sandbox I

Usando cualquier sandbox de uso gratuito tienes que encontrar una muestra que tenga estas caracter√≠sticas:
- Que sea maliciosa.
- Que tenga actividad maliciosa de red.
- Que cree archivos en el sistema.

Cuando la hayas encontrado, deber√°s escribir un an√°lisis explicando c√≥mo funciona y qu√© hace la muestra.


### Muestra 3.2 del Laboratorio RPISEC

He escogido una muestra de un laboratorio de malware: https://github.com/RPISEC/Malware/tree/master/Labs/Lab_03.

Esta muestra aparece en ANY.run en: https://app.any.run/tasks/65317167-d24d-47f2-bac3-2d244dc4f23b

Escog√≠ este laboratorio hace unos meses para practicar: https://github.com/soniasalido/cybersecurity/blob/main/LABS/Investigating%20Malware/github_RPISEC/Labs/Lab_03/Lab-3.2/analisis-estatico/analisis-estatico.md

**Arquitectura de destino del malware:**
| Field                                 | Value                                                                                               |
|---------------------------------------|-----------------------------------------------------------------------------------------------------|
| file > sha256                         | D1BFC02DB9922F89DA0CEF14B514B63AF3703F1AB7BD88D558431151BFAC92E2                                     |
| file > first 32 bytes (hex)           | 4D 5A 90 00 03 00 00 00 04 00 00 00 FF FF 00 00 B8 00 00 00 00 00 00 00 40 00 00 00 00 00 00 00       |
| file > first 32 bytes (text)          | MZ............................................@..............                                        |
| file > info                           | size: 37376 bytes, entropy: 6.314                                                                    |
| file > type                           | executable, 32-bit, GUI                                                                              |
| file > version                        | n/a                                                                                                  |
| file > description                    | n/a                                                                                                  |
| entry-point > first 32 bytes (hex)    | 55 8B EC 6A FF 68 78 91 40 00 68 C4 5E 40 00 64 A1 00 00 00 00 50 64 89 25 00 00 00 00 83 EC 10       |
| entry-point > location                | 0x0000352F (section[.text])                                                                          |
| file > signature                      | Microsoft Linker 6.0 \| Visual Studio 6.0 MASM \| Microsoft Visual C++ \| Microsoft Visual C++ 6.0 - 8.0 |



En resumen esta muestra de malware es un PE32 (GUI) compilado con Visual C++ que, al ejecutarse, se copia a s√≠ misma con otro nombre (java.exe) y persiste por registro para arrancar en cada inicio de Windows. La muestra tiene comunicaci√≥n por red / conexi√≥n C2. Se conecta a un servidor y espera la orden que debe ejecutar entre 13 posibles:

- [FUN_004018c0](../decompilado/FUN_004018C0-opcode1.md): **Opcode 1**. Realiza una enumeraci√≥n de unidades l√≥gicas (discos) del sistema y recopila informaci√≥n sobre ellas.
  
- [FUN_00401a20](../decompilado/FUN_00401A20-opcode2.md): **Opcode 2**. Procesar una cadena, aplicar una decodificaci√≥n XOR, y luego intentar acceder al sistema de archivos usando FindFirstFileA.
  
- [FUN_00402050](../decompilado/FUN_00402050-opcode3.md): **Opcode 3**. Ejecuta un binario XOR codificado, y reporta el resultado al servidor C2
  
- [FUN_004020a0](../decompilado/FUN_004020A0-opcode4.md): **Opcode 4**. Elimina un archivo remoto y reportar el resultado al C2.
  
- [FUN_004020f0](../decompilado/FUN_004020F0-opcode5.md): **Opcode 5**.Recibe datos por red y los guarda como archivo.
  
- [FUN_00402210](../decompilado/FUN_00402210-opcode6.md): **Opcode 6**. Recibe una cadena XOR 0x55, la descifra y luego la pasa como nombre de archivo a CreateFileA.

- [FUN_00402310](../decompilado/FUN_00402310-opcode7.md): **Opcode 7**. Captura una snapshot de los procesos.Itera sobre cada proceso. Lo desofusca y lo env√≠a por socket.

- [FUN_00402440](../decompilado/FUN_00402440-opcode8.md): **Opcode 8**. Terminar un proceso dado por ID. Notifica al servidor C2  si tuvo √©xito o no.

- [FUN_00402490](../decompilado/FUN_00402490-opcode9.md): **Opcode 9**. Ejecuta un proceso, captura su salida est√°ndar, la descifra con XOR 0x55, y la env√≠a al servidor C2.

- [FUN_00402660](../decompilado/FUN_00402660-opcode10.md): **Opcode 10**. Recibe comandos en texto (ofuscados con XOR 0x55), los desofusca y los interpreta. 

- [FUN_00402620](../decompilado/FUN_00402620-opcode11.md): **Opcode 11**. Cierra todos los handle usados. Env√≠a un byte 0x71 ('q') a trav√©s del socket, probablemente indicando "terminar sesi√≥n".

- [FUN_00402880](../decompilado/FUN_00402880-opcode12.md):  **Opcode 12**. Recibe datos de un socket (probablemente un comando remoto), usando funciones de WS2_32.DLL (recv).

- [FUN_004028C0](../decompilado/FUN_004028C0-opcode13.md):  **Opcode 13**. Toma como entrada una direcci√≥n a una cadena (char*) y Lo convierte en un n√∫mero (signed int) y lo pasa a Sleep.


Para hacer este ejercicio voy a usar exclusivamente la Funcion 004012a0 que es d√≥nde se desarrolla la persistencia del malware: [FUN_004012a0 - DAT_0040a0d8](../decompilado/FUN_004012a0-persistencia.md): **Persistencia.**





---------------------------

### 1. Inicializaci√≥n del entorno y recopilaci√≥n de informaci√≥n

- Instalaci√≥n de un manejador de excepciones estructurado (SEH).
- Llamadas a GetModuleFileNameA, GetSystemDirectoryA y GetUserNameA para obtener:
    - Ruta del ejecutable actual.
    - Ruta del sistema (C:\Windows\System32).
    - Nombre de usuario.
- Construcci√≥n de rutas tipo:
    - C:\DOCUME~1\<usuario>\java.exe
    - El malware se autocopia en esta ruta (persistencia).

- Adem√°s, llama a CopyFileA y a FUN_004012a0("sysinfo"), lo que sugiere:
    - Que el binario intenta autocopiado en una carpeta del sistema.
    - Que inicializa una estructura de configuraci√≥n con ese nombre (posiblemente archivo o mutex).

Comprobamos que se autocopia, analizando el hash de la copia y de la muestra del malware:
![java.exe](../analisis-dinamico/capturas/java.exe.png)

### 2. Comunicaci√≥n por red / conexi√≥n C2: Esta parte establece una comunicaci√≥n de red basada en WinSock:
- Usa funciones como:
    - Ordinal_52 ‚Üí gethostbyname
    - Ordinal_23 ‚Üí socket
    - Ordinal_9 ‚Üí htons
    - Ordinal_4 ‚Üí connect
    - Ordinal_19 ‚Üí send
    - Ordinal_16 ‚Üí recv

- Se conecta a un dominio que contiene la cadena "fxftest" (esto aparece en .rdata como s_fxftest_0040a120).

- Intercambia datos con el servidor:
    - Espera una cadena de 7 bytes, la compara con algo.
    - Si coincide, contin√∫a con la ejecuci√≥n.
    - Aqu√≠ es donde se activa la l√≥gica condicional del malware: solo ejecuta el siguiente paso si el servidor env√≠a la cadena esperada.


### 3. Despacho de comandos remotos (switch). Una vez conectado, el malware espera un byte y salta a un switch-case (dispatcher):
```
switch (comando) {
  case 1: FUN_004018c0
  case 2: FUN_00401a20
  case 3: FUN_00402050
  ...
  case 13: FUN_004028c0
}
```
- [FUN_004018c0](FUN_004018C0-opcode1.md) --> Opcode 1
- [FUN_00401a20](FUN_00401A20-opcode2.md) --> Opcode 2
- [FUN_00402050](FUN_00402050-opcode3.md) --> Opcode 3
....
- [FUN_004028C0](FUN_004028C0.md)

Cada funci√≥n parece representar un comando recibido del servidor, lo que indica que el malware act√∫a como un bot que:
- Espera instrucciones del atacante.
- Ejecuta funciones dependiendo de lo que reciba (ej: exfiltraci√≥n, ejecuci√≥n, escritura en disco‚Ä¶).


### 4. Limpieza o persistencia. Despu√©s de ejecutar las acciones, puede:
- Copiar strings y buffers internamente.
- Actualizar variables de estado (DAT_0040a0c0).
- Usar funciones que parecen manejar hilos, nombres de archivo y estructuras en memoria.
