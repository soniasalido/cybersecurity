#!/usr/bin/env python3
"""
STIX 2.1 bundle for the Google TAG report:
"Internet Explorer 0-day exploited by North Korean actor APT37"

This version is built to ensure the STIX Visualization graph shows the
THREAT ACTOR icon by:
- creating an explicit ThreatActor SDO (type: "threat-actor")
- connecting it with relationships so it is rendered in the graph:
  * campaign — attributed-to → threat-actor (APT37)
  * intrusion-set — attributed-to → threat-actor (APT37)
  * indicator — indicates → threat-actor (APT37)
  * threat-actor — uses → infrastructure / attack-pattern

Requirements:
  pip install stix2

Run:
  python3 paquete_stix_apt37.py --out apt37_campaign_stix.json --pretty
"""

from __future__ import annotations

import argparse
from datetime import datetime, timezone
from typing import List, Optional

from stix2 import (
    AttackPattern,
    Bundle,
    Campaign,
    Identity,
    Indicator,
    Infrastructure,
    IntrusionSet,
    Location,
    Malware,
    Note,
    Relationship,
    Report,
    ThreatActor,
    Vulnerability,
)

# -----------------------------
# Source / report metadata
# -----------------------------
ARTICLE_URL = "https://blog.google/threat-analysis-group/internet-explorer-0-day-exploited-by-north-korean-actor-apt37/"
ARTICLE_TITLE = "Internet Explorer 0-day exploited by North Korean actor APT37"
ARTICLE_PUBLISHED = datetime(2022, 12, 7, 0, 0, 0, tzinfo=timezone.utc)

# Timeline anchors (from TAG’s described timeline)
OBSERVED_FIRST = datetime(2022, 10, 31, 0, 0, 0, tzinfo=timezone.utc)
PATCH_TUESDAY = datetime(2022, 11, 8, 0, 0, 0, tzinfo=timezone.utc)

# -----------------------------
# IOCs from TAG
# -----------------------------
INITIAL_DOC_SHA256 = [
    "56ca24b57c4559f834c190d50b0fe89dd4a4040a078ca1f267d0bbc7849e9ed7",
    "af5fb99d3ff18bc625fb63f792ed7cd955171ab509c2f8e7c7ee44515e09cebf",
    "926a947ea2b59d3e9a5a6875b4de2bd071b15260370f4da5e2a60ece3517a32f",
    "3bff571823421c013e79cc10793f238f4252f7d7ac91f9ef41435af0a8c09a39",
    "c49b4d370ad0dcd1e28ee8f525ac8e3c12a34cfcf62ebb733ec74cca59b29f82",
]

REMOTE_RTF_TEMPLATE_SHA256 = "08f93351d0d3905bee5b0c2b9215d448abb0d3cf49c0f8b666c46df4fcc007cb"

C2_DOMAINS = [
    "word-template.net",
    "openxmlformat.org",
    "ms-office.services",
    "ms-offices.com",
    "template-openxml.com",
]


def utc(dt: datetime) -> str:
    """Return RFC3339 UTC string accepted by STIX."""
    if dt.tzinfo is None:
        dt = dt.replace(tzinfo=timezone.utc)
    return dt.astimezone(timezone.utc).isoformat().replace("+00:00", "Z")


def make_file_hash_indicator(
    sha256: str,
    name: str,
    description: str,
    created_by_ref: str,
    valid_from: datetime,
) -> Indicator:
    return Indicator(
        spec_version="2.1",
        name=name,
        description=description,
        pattern_type="stix",
        pattern=f"[file:hashes.'SHA-256' = '{sha256}']",
        valid_from=utc(valid_from),
        labels=["file-hash", "malicious-activity"],
        created_by_ref=created_by_ref,
    )


def make_domain_indicator(
    domain: str,
    created_by_ref: str,
    valid_from: datetime,
) -> Indicator:
    return Indicator(
        spec_version="2.1",
        name=f"C2 domain indicator: {domain}",
        description="Domain reported as command-and-control / campaign infrastructure in the TAG report.",
        pattern_type="stix",
        pattern=f"[domain-name:value = '{domain}']",
        valid_from=utc(valid_from),
        labels=["domain", "c2", "malicious-activity"],
        created_by_ref=created_by_ref,
    )


def rel(
    source_ref: str,
    relationship_type: str,
    target_ref: str,
    created_by_ref: str,
    description: Optional[str] = None,
    confidence: Optional[int] = None,
) -> Relationship:
    kwargs = {}
    if description:
        kwargs["description"] = description
    if confidence is not None:
        kwargs["confidence"] = confidence
    return Relationship(
        spec_version="2.1",
        relationship_type=relationship_type,
        source_ref=source_ref,
        target_ref=target_ref,
        created_by_ref=created_by_ref,
        **kwargs,
    )


def main() -> None:
    ap = argparse.ArgumentParser(description="Generate STIX 2.1 bundle for APT37 IE 0-day campaign (Google TAG).")
    ap.add_argument("--out", default="apt37_ie0day_campaign_stix.json", help="Output JSON file path.")
    ap.add_argument("--pretty", action="store_true", help="Pretty-print JSON.")
    args = ap.parse_args()

    # -----------------------------
    # Producer identity (who wrote the intel)
    # -----------------------------
    google_tag = Identity(
        spec_version="2.1",
        name="Google Threat Analysis Group (TAG)",
        identity_class="organization",
        description="Google Threat Analysis Group; publisher of the referenced report.",
    )

    # -----------------------------
    # Victimology / targeting
    # Location requires country/region or lat/long
    # -----------------------------
    south_korea = Location(
        spec_version="2.1",
        name="South Korea",
        country="South Korea",
        region="eastern-asia",
        description="Primary target geography mentioned in the report.",
        created_by_ref=google_tag.id,
    )

    # -----------------------------
    # Threat Actor (ensures Threat Actor icon appears in STIX Visualization)
    # -----------------------------
    apt37_ta = ThreatActor(
        spec_version="2.1",
        name="APT37",
        aliases=["APT37"],
        threat_actor_types=["nation-state"],  # helps semantics; optional
        description="North Korea-linked threat actor. Google TAG attributes the observed activity to APT37.",
        created_by_ref=google_tag.id,
    )

    # Intrusion Set (grouping of intrusion activity; kept for your rubric)
    apt37_is = IntrusionSet(
        spec_version="2.1",
        name="APT37",
        aliases=["APT37"],
        description=(
            "North Korea-linked intrusion set associated with APT37 reporting. "
            "Included to support group/campaign modeling and explicit linkage to the Threat Actor object."
        ),
        first_seen=utc(OBSERVED_FIRST),
        created_by_ref=google_tag.id,
    )

    # -----------------------------
    # Campaign (observed activity)
    # -----------------------------
    campaign = Campaign(
        spec_version="2.1",
        name="APT37 IE 0-day via Office remote template (CVE-2022-41128)",
        description=(
            "Observed exploitation chain leveraging a malicious Office document, remote RTF template, and remote HTML "
            "rendered by Internet Explorer, leading to exploitation of CVE-2022-41128 in jscript9.dll."
        ),
        first_seen=utc(OBSERVED_FIRST),
        last_seen=utc(PATCH_TUESDAY),
        created_by_ref=google_tag.id,
    )

    # -----------------------------
    # Vulnerability
    # -----------------------------
    vuln = Vulnerability(
        spec_version="2.1",
        name="CVE-2022-41128",
        description=(
            "Internet Explorer JScript (jscript9.dll) 0-day exploited in the wild. Root cause described as a JIT "
            "optimization issue leading to type confusion and arbitrary code execution when rendering attacker-controlled content."
        ),
        external_references=[
            {
                "source_name": "cve",
                "external_id": "CVE-2022-41128",
                "url": "https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2022-41128",
            },
            {"source_name": "google-tag", "url": ARTICLE_URL},
        ],
        created_by_ref=google_tag.id,
    )

    # -----------------------------
    # Attack patterns (ATT&CK)
    # -----------------------------
    ap_template_injection = AttackPattern(
        spec_version="2.1",
        name="Template Injection",
        description="Use of a remote template (RTF) pulled by Office to load attacker content.",
        external_references=[
            {"source_name": "mitre-attack", "external_id": "T1221", "url": "https://attack.mitre.org/techniques/T1221/"}
        ],
        created_by_ref=google_tag.id,
    )

    ap_exploit_client = AttackPattern(
        spec_version="2.1",
        name="Exploitation for Client Execution",
        description="Exploitation of a client-side application vulnerability to execute attacker-controlled code.",
        external_references=[
            {"source_name": "mitre-attack", "external_id": "T1203", "url": "https://attack.mitre.org/techniques/T1203/"}
        ],
        created_by_ref=google_tag.id,
    )

    ap_indicator_removal = AttackPattern(
        spec_version="2.1",
        name="Indicator Removal on Host",
        description="Post-exploitation cleanup such as clearing browser cache/history to reduce forensic artifacts.",
        external_references=[
            {"source_name": "mitre-attack", "external_id": "T1070", "url": "https://attack.mitre.org/techniques/T1070/"}
        ],
        created_by_ref=google_tag.id,
    )

    ap_spearphish_attach = AttackPattern(
        spec_version="2.1",
        name="Spearphishing Attachment (assessed)",
        description=(
            "Plausible initial delivery technique for the malicious Office document. "
            "Note: the TAG report does not explicitly specify the delivery channel; this mapping is an analyst assessment."
        ),
        external_references=[
            {
                "source_name": "mitre-attack",
                "external_id": "T1566.001",
                "url": "https://attack.mitre.org/techniques/T1566/001/",
            }
        ],
        created_by_ref=google_tag.id,
    )

    # -----------------------------
    # Infrastructure (C2 / hosting)
    # -----------------------------
    infra = Infrastructure(
        spec_version="2.1",
        name="APT37 campaign infrastructure (C2 / hosting)",
        description=(
            "Infrastructure used to serve remote templates/HTML and to receive telemetry/C2 beacons. "
            "TAG reports cookie-based gating (unique cookie set on RTF fetch, required for exploit stage) and beaconing "
            "before and after exploitation."
        ),
        infrastructure_types=["command-and-control"],
        created_by_ref=google_tag.id,
    )

    # -----------------------------
    # Indicators (hashes + domains)
    # -----------------------------
    indicators: List[Indicator] = []

    for i, h in enumerate(INITIAL_DOC_SHA256, start=1):
        indicators.append(
            make_file_hash_indicator(
                sha256=h,
                name=f"Initial Office document SHA-256 (#{i})",
                description="SHA-256 for an initial malicious Office document reported by TAG in this campaign.",
                created_by_ref=google_tag.id,
                valid_from=OBSERVED_FIRST,
            )
        )

    indicators.append(
        make_file_hash_indicator(
            sha256=REMOTE_RTF_TEMPLATE_SHA256,
            name="Remote RTF template SHA-256",
            description="SHA-256 for the remote RTF template used in the Office → RTF → HTML exploitation chain.",
            created_by_ref=google_tag.id,
            valid_from=OBSERVED_FIRST,
        )
    )

    indicators.extend([make_domain_indicator(d, google_tag.id, OBSERVED_FIRST) for d in C2_DOMAINS])

    # -----------------------------
    # Optional malware families (historical association, not confirmed payload here)
    # -----------------------------
    rokrat = Malware(
        spec_version="2.1",
        name="ROKRAT",
        is_family=True,
        description=(
            "Malware family historically associated with APT37 per TAG reporting; not confirmed as the final payload "
            "in this specific CVE-2022-41128 exploitation chain."
        ),
        created_by_ref=google_tag.id,
    )
    bluelight = Malware(
        spec_version="2.1",
        name="BLUELIGHT",
        is_family=True,
        description=(
            "Malware family historically associated with APT37 per TAG reporting; not confirmed as the final payload "
            "in this specific campaign."
        ),
        created_by_ref=google_tag.id,
    )
    dolphin = Malware(
        spec_version="2.1",
        name="DOLPHIN",
        is_family=True,
        description=(
            "Malware family historically associated with APT37 per TAG reporting; not confirmed as the final payload "
            "in this specific campaign."
        ),
        created_by_ref=google_tag.id,
    )

    # -----------------------------
    # Notes (non-IOC behaviors)
    # -----------------------------
    note_protected_view = Note(
        spec_version="2.1",
        abstract="Protected View / MOTW dependency",
        content=(
            "TAG notes that, in a typical scenario, the malicious Office document is marked with Mark-of-the-Web (MOTW), "
            "and the victim must disable Protected View to allow remote template retrieval and subsequent exploitation. "
            "This is modeled as analyst narrative (not an IOC)."
        ),
        created_by_ref=google_tag.id,
        object_refs=[campaign.id],
    )

    note_cookie_gate = Note(
        spec_version="2.1",
        abstract="Cookie-based gating and double beaconing",
        content=(
            "TAG observed cookie-based gating: the server sets a unique cookie when the remote RTF template is fetched; "
            "the exploit stage checks for that cookie before running. The JavaScript reports to C2 both before attempting "
            "exploitation and after success."
        ),
        created_by_ref=google_tag.id,
        object_refs=[campaign.id, infra.id],
    )

    note_spearphish_assessment = Note(
        spec_version="2.1",
        abstract="ATT&CK mapping caveat: Spearphishing Attachment",
        content=(
            "The mapping to ATT&CK T1566.001 (Spearphishing Attachment) is an analyst assessment based on the presence of "
            "a malicious Office document as the initial artifact; the TAG report does not explicitly state the delivery channel."
        ),
        created_by_ref=google_tag.id,
        object_refs=[ap_spearphish_attach.id, campaign.id],
    )

    # -----------------------------
    # Relationships (ensures threat-actor is connected and visible)
    # -----------------------------
    relationships: List[Relationship] = []

    # campaign — attributed-to → threat-actor (APT37)
    relationships.append(rel(campaign.id, "attributed-to", apt37_ta.id, google_tag.id, confidence=80))

    # intrusion-set — attributed-to → threat-actor (APT37)
    relationships.append(rel(apt37_is.id, "attributed-to", apt37_ta.id, google_tag.id, confidence=80))

    # threat-actor — uses → infrastructure/attack-pattern (to force graph connectivity and show icon)
    relationships.append(rel(apt37_ta.id, "uses", infra.id, google_tag.id, confidence=70))
    relationships.append(rel(apt37_ta.id, "uses", ap_template_injection.id, google_tag.id, confidence=60))
    relationships.append(rel(apt37_ta.id, "uses", ap_exploit_client.id, google_tag.id, confidence=60))
    relationships.append(rel(apt37_ta.id, "uses", ap_indicator_removal.id, google_tag.id, confidence=50))
    relationships.append(
        rel(
            apt37_ta.id,
            "uses",
            ap_spearphish_attach.id,
            google_tag.id,
            description="Analyst assessment; delivery channel not specified in the TAG report.",
            confidence=40,
        )
    )

    # Campaign structure
    relationships.append(rel(campaign.id, "targets", south_korea.id, google_tag.id, confidence=70))
    relationships.append(rel(campaign.id, "exploits", vuln.id, google_tag.id, confidence=80))
    relationships.append(rel(campaign.id, "uses", infra.id, google_tag.id, confidence=80))
    relationships.append(rel(campaign.id, "uses", ap_template_injection.id, google_tag.id, confidence=80))
    relationships.append(rel(campaign.id, "uses", ap_exploit_client.id, google_tag.id, confidence=80))
    relationships.append(rel(campaign.id, "uses", ap_indicator_removal.id, google_tag.id, confidence=60))

    # Intrusion-set also linked (optional, improves readability)
    relationships.append(rel(apt37_is.id, "uses", infra.id, google_tag.id, confidence=70))
    relationships.append(rel(apt37_is.id, "exploits", vuln.id, google_tag.id, confidence=70))
    relationships.append(rel(apt37_is.id, "uses", ap_template_injection.id, google_tag.id, confidence=60))
    relationships.append(rel(apt37_is.id, "uses", ap_exploit_client.id, google_tag.id, confidence=60))

    # Historical malware use (not confirmed in this campaign)
    relationships.append(
        rel(
            apt37_ta.id,
            "uses",
            rokrat.id,
            google_tag.id,
            description="Historically associated per TAG; not confirmed as payload in this campaign.",
            confidence=45,
        )
    )
    relationships.append(
        rel(
            apt37_ta.id,
            "uses",
            bluelight.id,
            google_tag.id,
            description="Historically associated per TAG; not confirmed as payload in this campaign.",
            confidence=45,
        )
    )
    relationships.append(
        rel(
            apt37_ta.id,
            "uses",
            dolphin.id,
            google_tag.id,
            description="Historically associated per TAG; not confirmed as payload in this campaign.",
            confidence=45,
        )
    )

    # indicator — indicates → threat-actor (APT37) + campaign + (domains) infrastructure
    for ind in indicators:
        ta_conf = 60 if "domain" in ind.labels else 50
        relationships.append(rel(ind.id, "indicates", apt37_ta.id, google_tag.id, confidence=ta_conf))
        relationships.append(rel(ind.id, "indicates", campaign.id, google_tag.id, confidence=70))
        if "domain" in ind.labels:
            relationships.append(rel(ind.id, "indicates", infra.id, google_tag.id, confidence=70))

    # -----------------------------
    # Report aggregates everything
    # -----------------------------
    report = Report(
        spec_version="2.1",
        name=ARTICLE_TITLE,
        description=(
            "Google TAG report describing in-the-wild exploitation of CVE-2022-41128 (Internet Explorer JScript / jscript9.dll) "
            "attributed to APT37. The chain uses a malicious Office document pulling a remote RTF template, which loads remote HTML "
            "rendered via Internet Explorer. TAG provides file hashes and C2 domains as indicators."
        ),
        report_types=["threat-report"],
        published=utc(ARTICLE_PUBLISHED),
        external_references=[{"source_name": "google-tag", "url": ARTICLE_URL}],
        created_by_ref=google_tag.id,
        object_refs=[
            # Core SDOs
            google_tag.id,
            apt37_ta.id,   # important for icon visibility in tools that follow report refs
            apt37_is.id,
            campaign.id,
            vuln.id,
            infra.id,
            south_korea.id,
            # ATT&CK patterns
            ap_template_injection.id,
            ap_exploit_client.id,
            ap_indicator_removal.id,
            ap_spearphish_attach.id,
            # Optional malware families
            rokrat.id,
            bluelight.id,
            dolphin.id,
            # Notes
            note_protected_view.id,
            note_cookie_gate.id,
            note_spearphish_assessment.id,
            # Indicators + Relationships
            *[ind.id for ind in indicators],
            *[r.id for r in relationships],
        ],
    )

    # -----------------------------
    # Bundle output (Bundle must NOT have spec_version)
    # -----------------------------
    all_objects = [
        google_tag,
        south_korea,
        apt37_ta,      # <-- ensures threat-actor SDO exists in the bundle
        apt37_is,
        campaign,
        vuln,
        infra,
        ap_template_injection,
        ap_exploit_client,
        ap_indicator_removal,
        ap_spearphish_attach,
        rokrat,
        bluelight,
        dolphin,
        note_protected_view,
        note_cookie_gate,
        note_spearphish_assessment,
        report,
        *indicators,
        *relationships,
    ]

    bundle = Bundle(objects=all_objects)

    with open(args.out, "w", encoding="utf-8") as f:
        f.write(bundle.serialize(pretty=args.pretty))

    print(f"STIX bundle written to: {args.out}")
    print(f"Objects in bundle: {len(all_objects)}")
    print("Sanity check: ThreatActor included =", any(getattr(o, "type", None) == "threat-actor" for o in all_objects))


if __name__ == "__main__":
    main()

