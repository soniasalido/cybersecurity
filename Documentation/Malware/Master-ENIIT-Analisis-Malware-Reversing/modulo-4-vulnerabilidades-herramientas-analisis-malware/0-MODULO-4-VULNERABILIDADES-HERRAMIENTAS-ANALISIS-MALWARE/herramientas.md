
## Vista rápida
| Herramienta           | Tipo principal                                        | Enfoque                                                             |
| --------------------- | ----------------------------------------------------- | ------------------------------------------------------------------- |
| **OllyDbg**           | Depurador **dinámico** (x86)                          | Reversing clásico 32-bit en Windows                                 |
| **x32dbg / x64dbg**   | Depurador **dinámico** (x86/x64)                      | Malware y binarios modernos en Windows                              |
| **Immunity Debugger** | Depurador **dinámico** (x86)                          | Exploit dev con scripting Python (mona.py)                          |
| **IDA**               | **Estático** (desensamblador; con depurador opcional) | Análisis profundo + (opcional) decompilación Hex-Rays               |
| **Ghidra**            | **Estático** (desensamblador + decompilador)          | Alternativa gratuita multi-arquitectura con decompilación integrada |

------------------

## Detalle por capacidades
| Aspecto                  | OllyDbg                       | x32dbg / x64dbg                                      | Immunity Debugger                          | IDA                                                     | Ghidra                                                |
| ------------------------ | ----------------------------- | ---------------------------------------------------- | ------------------------------------------ | ------------------------------------------------------- | ----------------------------------------------------- |
| **Arquitecturas**        | x86 32-bit                    | x86 32/64-bit                                        | x86 32-bit                                 | Muchas (x86/x64, ARM, MIPS, PPC, RISC-V, etc.)          | Muchas (x86/x64, ARM, MIPS, PPC, RISC-V, etc.)        |
| **Sistema operativo**    | Windows                       | Windows                                              | Windows                                    | Win/macOS/Linux                                         | Win/macOS/Linux                                       |
| **Depuración dinámica**  | Sí                            | Sí (muy completa)                                    | Sí (fuerte con Python)                     | Sí (local/remota según edición)                         | Limitada (integración externa; foco en estático)      |
| **Análisis estático**    | Básico                        | Básico/medio                                         | Básico                                     | Muy alto (cross-refs, grafos, firmas)                   | Muy alto (grafos, análisis, refactor)                 |
| **Decompilador**         | No                            | No (plugins limitados)                               | No                                         | **Hex-Rays** (pago) o decompilador cloud en Free/Home   | **Incluido** (C-like)                                 |
| **Scripting**            | Plugins antiguos (ODbgScript) | Script propio + plugins; opción a Python vía plugins | **Python integrado** (mona.py, PyCommands) | **IDAPython/IDC/C++ SDK**                               | **Python/Java** (API amplia)                          |
| **Plugins destacados**   | HideOD, OllyDumpEx            | **ScyllaHide, Scylla/x64dbgDump, Labeless**          | **mona.py**, PyDbg                         | BinDiff, Labeless, gran ecosistema                      | P-code, Ghidrathon, extensiones oficiales             |
| **Uso típico**           | Binarios antiguos, docencia   | Malware moderno, reversing diario                    | CTF/Exploit dev, ROP, patrones             | Ingeniería inversa profesional, firmware, documentación | Ingeniería inversa general, alternativa libre a IDA   |
| **Curva de aprendizaje** | Baja                          | Media                                                | Media-alta                                 | Alta                                                    | Media                                                 |
| **Licencia / coste**     | Freeware (antiguo)            | **Gratis / Open**                                    | Gratis (sin mantenimiento activo)          | **Free/Home/Pro** (Pro de pago)                         | **Gratis / Open Source**                              |
| **Puntos fuertes**       | Ligero y simple               | Actual, 64-bit, comunidad activa                     | Python & mona.py para exploits             | Análisis profundo + ecosistema + Hex-Rays               | Decompilador gratis, multi-arquitectura, colaborativo |
| **Limitaciones**         | Solo 32-bit, viejo            | Sin decompilador nativo                              | Solo 32-bit, abandonado                    | Pro es caro; Free/Home con límites                      | Depuración no tan integrada como x64dbg               |


------------------

## Análisis Estático VS Análisis Dinámico
| Tarea                                                        | Mejor enfoque                      | Herramientas recomendadas              | Nota                                               |
| ------------------------------------------------------------ | ---------------------------------- | -------------------------------------- | -------------------------------------------------- |
| **Cartografiar el binario** (funciones, xrefs, strings, CFG) | Estático                           | **IDA / Ghidra**                       | Punto de partida casi siempre.                     |
| **Entender lógica compleja** (parsers, crypto, estados)      | Estático (+ dinámica para validar) | **IDA(+Hex-Rays)/Ghidra** → **x64dbg** | Lee en decompilador, verifica al correr.           |
| **Desempaquetar**                                            | Dinámico                           | **x64dbg**, Olly (legacy)              | Con **Scylla/ScyllaHide** para PE dump/anti-debug. |
| **Extraer claves/strings descifradas**                       | Dinámico                           | **x64dbg/Immunity**                    | Breakpoints en APIs de crypto/memcpy.              |
| **Exploit dev / CTF**                                        | Dinámico (+ estático para gadgets) | **Immunity (mona.py)**, **x64dbg**     | Immunity brilla con Python; x64dbg para x64.       |
| **Malware 64-bit y Windows moderno**                         | Dinámico + Estático                | **x64dbg** + **IDA/Ghidra**            | Combo estándar actual.                             |
| **Firmware/ARM/MIPS/RISC-V**                                 | Estático                           | **IDA/Ghidra**                         | Dinámico posible, pero más complejo.               |

------------------

## Flujo de trabajo recomendado (malware/reversing)
- Estático rápido (IDA/Ghidra)
  - Strings, imports, secciones raras, CFG de funciones principales.
  - Marca símbolos, renombra, coloca comentarios.

- Hipótesis
  - ¿Empaquetado? ¿Persistencia? ¿Red? ¿Crypto?

- Dinámico controlado (x64dbg)
  - VM aislada + snapshots.
  - BPs estratégicos (APIs sospechosas, descifrado, OEP).
  - Extraemos artefactos (config, claves, payloads, rutas C2).

- Vuelta al estático
  - Documentamos con lo que vimos en runtime.
  - Refinamos el modelo (diagramas, flujo, IOC).

- (Opcional) Scripting
  - Immunity/mona.py para tareas de exploit dev o automatizaciones de búsqueda.
  - IDAPython/Ghidrathon para renombrar/etiquetar en lote.

------------------

## Decisión rápida (cheatsheet)
- Entender la lógica del malware → IDA/Ghidra (estático).
- Ver qué hace realmente → x64dbg (dinámico).
- ¿Está empaquetado/ofuscado? → Dinámico primero (unpack) → luego Estático.
- Exploit/CTF → Immunity (mona.py) + x64dbg para 64-bit.
- Solo 32-bit clásico o docencia → OllyDbg aún sirve.

---------------------------
# PE-Bear & PE-Sieve
La analista de malware de origen polaco Aleksandra Doniec (@hasherezade) ha desarrollado una serie de herramientas para realizar el estudio y análisis de archivos PE (archivos ejecutables de Windows), entre las que destacan: 

## PE-Bear
Es una herramienta freeware y multi-plataforma (Windows, MacOs y Linux) para realizar ingeniería inversa de archivos ejecutables de Windows -  PE (Portable Executable) – para obtener una vista rápida y flexible de la estructura de estos archivos, también es capaz de manejar archivos con encabezado PE corrupto o malformado (en ocasiones de manera deliberada para cuflajear malware).

**Características:**
- Análisis de archivos PE: Permite visualizar el diseño de un archivo PE y sus diferentes secciones.
- Reconocimiento de empaquetadores: Puede reconocer empaquetadores conocidos basándose en sus firmas.
- Edición: Ofrece la capacidad de editar archivos PE (un simple e interactivo desensamblador) y añadir nuevos elementos.
- Manejo de archivos malformados: Su diseño lo hace estable para analizar archivos PE que pueden estar dañados o malformados.
- Interfaz gráfica: Tiene una interfaz gráfica de usuario (GUI) intuitiva, lo que la hace fácil de usar.
- Compatible tanto con archivos PE de 32 y 64 bits.
- Utilizado por la CIA (https://wikileaks.org/ciav7p1/cms/page_20250761.html)
- Desde 18/septiembre/2022 PE-bear es Open Source (https://github.com/hasherezade/pe-bear)


## PE-sieve
Es una herramienta Open Source desarrollada para Windows (compatible desde xp hasta Windows 11), la cual escanea un proceso determinado, en busca de “implantes” y “parches” potencialmente maliciosos dentro del espacio del proceso. Cuando se encuentra, hace un volcado del PE junto con un informe en formato JSON, realizando un reporte de los indicadores encontrados.

**Funciones principales:**
- Detección de inyecciones de código: Identifica técnicas de inyección de malware, incluye PE hollowing el cual es una técnica de evasión sofisticada utilizada por el malware para ocultar su presencia, evitar su detección y asegurar su persistencia, funciona de la siguiente manera:
  - Creación de un proceso legitimo: El malware inicia un proceso legítimo y benigno en un estado suspendido (pausado).
  - Vaciado (Hollowing): El atacante manipula la memoria de este proceso suspendido, eliminando (vaciando) su código original.
  - Inyección del código malicioso: En el espacio de memoria vaciado, el malware escribe su propio código malicioso. Este código suele estar ofuscado o cifrado para dificultar su análisis y detección.
  - Reanudación del proceso: El proceso se reanuda, pero ahora ejecuta el código malicioso en lugar del programa original (legítimo).
  - También identifica la técnica de Process Doppelgänging, la cual funciona de manera similar a PE hollowing solo que en este caso no utiliza archivos (fileless) para no dejar rastro de su actividad maliciosa en disco.
- Desempaquetado de malware: Ayuda a desempaquetar muestras de malware automáticamente al extraer los implantes de código malicioso de la memoria.
- Extracción de artefactos: Reconoce y descarga varios tipos de implantes, como archivos ejecutables (PE) reemplazados, shellcode, hooks y otros parches en memoria.
- Análisis de actividad sospechosa: Genera informes detallados y archivos volcados que los analistas de malware pueden inspeccionar para comprender mejor la actividad maliciosa.
- Reconstrucción de archivos: Puede reconstruir partes corruptas de un archivo PE donde los autores de malware han borrado encabezados o tablas de importación para evadir el análisis automatizado.
- Análisis pasivo: Realiza escaneos de forma pasiva, sin enganchar (hooking) las APIs del sistema, lo que hace que difícilmente el malware detecte su presencia.

Todo ello convierte a PE-sieve en una herramienta valiosa para analistas de malware y equipos de respuesta de incidentes que necesitan investigar y extraer código malicioso ofuscado o inyectado en procesos activos. PE-sieve tiene un enfoque en detectar PE hollowing y Process Doppelgänging sin necesidad de hacer hooking de APIs; es decir, sin poner estos “ganchos” (hooks) en funciones, sino analizando la memoria tal cual, lo que hace más difícil que el malware detecte que está siendo observado. Ese análisis pasivo es clave para no levantar sospechas en muestras más avanzadas. Muy útil para responder a incidentes donde sabes que algo pasa en memoria pero no está claro todavía el “qué”.

 
Fuentes: 
- https://hshrzd.wordpress.com/pe-bear/
- https://hshrzd.wordpress.com/pe-sieve/
- Proyectos de @hasherezade: 
- https://hasherezade.github.io/

--------------------------------------------------------------

# Binary NINJA

# Qué es Binary Ninja?
Binary Ninja es una plataforma de ingeniería inversa y análisis binario desarrollada por Vector 35. A diferencia de herramientas como IDA Pro o Ghidra (ampliamente conocidas), Binary Ninja destaca por su alto rendimiento, interfaz moderna, potente API y enfoque en la automatización.


## La utilizan principalmente:
- Analistas de malware.
- Profesionales de seguridad ofensiva (pentesters, red teamers).
- Investigadores de seguridad.
- Desarrolladores de compiladores y cadenas de herramientas


## Para qué se utiliza? 
- Ingeniería inversa: Analizar programas compilados (sin código fuente) para comprender su funcionalidad, encontrar vulnerabilidades o romper protecciones.
- Análisis de malware: Examinar código malicioso para comprender su comportamiento, mecanismos de infección y comunicación.
- Investigación de vulnerabilidades: Identificar y explotar fallos de seguridad en software.
- CTF (Capturar la bandera) y desafíos de seguridad: Resolver desafíos binarios en competiciones.
- Desarrollo de herramientas: Cree plugins y scripts personalizados para automatizar tareas de análisis.
- Comprobación de código: Valide la seguridad del software analizando su binario.


## Características clave y diferenciadores
- Rendimiento extremadamente rápido: El análisis y la descompilación son significativamente más rápidos que con muchas herramientas de la competencia.
- Interfaz de usuario (IU) limpia y moderna: Multiplataforma (Windows, macOS, Linux) con una experiencia fluida.
- Arquitectura de asignación única estática (SSA): El núcleo de su análisis. Permite a Binary Ninja comprender el flujo de datos y las variables con gran precisión, lo que resulta en descompilaciones de alta calidad.
- API potente y bien documentada (Python y C++): Facilita la creación de plugins, scripts y la automatización de tareas complejas. Es uno de sus principales activos.
- Lenguaje intermedio (IL): Binja traduce el ensamblado de la arquitectura de destino a su propio lenguaje intermedio (LLIL, MLIL, HLIL). Esto abstrae las peculiaridades del ensamblado y permite un análisis más genérico y potente.
- Precios competitivos en comparación con IDA PRO: Ofrece una versión gratuita (demo) con funciones limitadas y licencias de pago más asequibles que las de la competencia directa.
- Compatibilidad con múltiples arquitecturas: x86, x86_64, ARM, ARM64, MIPS, PowerPC, etc.

Por lo tanto, entre tantas características interesantes, la que más me gustó fue Firmware Ninja (FWN), que ofrece recursos analíticos avanzados para ayudar a superar desafíos específicos en la ingeniería inversa de firmware. Las características de Firmware Ninja son particularmente valiosas para examinar programas físicos con un modelo de memoria estática, como firmware de microcontroladores, cargadores de arranque, imágenes de kernel y sistemas operativos en tiempo real. FWN aborda desafíos importantes en el análisis de firmware, como la creación de mapas de memoria precisos, la interpretación de las interacciones del código con periféricos externos y la comprensión de las interfaces de comunicación entre dispositivos.

Como se muestra en la imagen a continuación:
