# Desbordamientos de B√∫fer

En la explotaci√≥n binaria, nuestro objetivo principal es subvertir la ejecuci√≥n del binario de una manera que nos beneficie. Los desbordamientos de b√∫fer son el tipo m√°s com√∫n de explotaci√≥n binaria, pero existen otros tipos, como la explotaci√≥n de cadenas de formato (Format String) y la explotaci√≥n del Heap.

Un desbordamiento de b√∫fer ocurre cuando un programa recibe datos m√°s largos de lo esperado, de modo que esos datos sobrescriben todo el espacio de memoria del b√∫fer en la pila. Esto puede sobrescribir el siguiente puntero de instrucci√≥n (EIP/RIP), lo que hace que el programa falle porque intentar√° ejecutar instrucciones en una direcci√≥n de memoria inv√°lida. Forzar al programa a fallar es el ejemplo m√°s b√°sico de explotaci√≥n de desbordamientos de b√∫fer, conocido como un ataque de Denegaci√≥n de Servicio (DoS).

Otro ataque b√°sico consiste en sobrescribir un valor en la pila para cambiar el comportamiento del programa. Por ejemplo, si un programa de ex√°menes tuviera una vulnerabilidad de desbordamiento de b√∫fer, podr√≠amos sobrescribir el b√∫fer lo suficiente para sobrescribir nuestra puntuaci√≥n. Dado que la puntuaci√≥n est√° almacenada en la pila en este ejemplo, podr√≠amos aprovechar esta falla para cambiarla.

Si somos un poco m√°s sofisticados, podemos cambiar la direcci√≥n del EIP hacia una instrucci√≥n que ejecute nuestro shellcode. Esto permitir√≠a ejecutar cualquier comando que queramos, en lugar de solo hacer que el programa falle; esto se conoce como saltar al shellcode.

Con protecciones de memoria m√°s avanzadas, puede que no sea posible cargar nuestro shellcode completo y apuntar a √©l. En ese caso, podemos usar una combinaci√≥n de instrucciones del propio binario para ejecutar una funci√≥n concreta y sobrescribir varios punteros para cambiar el flujo de ejecuci√≥n del programa. Esto se conoce como un ataque Return Oriented Programming (ROP).

Finalmente, los programas y sistemas operativos modernos pueden usar el Heap en lugar de la pila para almacenar memoria de b√∫fer, lo que requerir√≠a desbordamientos o explotaci√≥n del Heap.

# Desbordamiento de la Pila (Stack Overflow)

Comencemos demostrando c√≥mo funciona la pila al almacenar datos. La pila tiene un dise√±o `LIFO (Last-In, First-Out)`, lo que significa que solo podemos extraer (pop) el √∫ltimo elemento insertado (push). Si insertamos un elemento, quedar√° en la parte superior de la pila. Si extraemos algo, ser√° ese elemento superior el que se retire.

La siguiente tabla muestra como funciona el stack:  
![table-stack](capturas/table-stack.png)

El siguiente ejemplo espera una entrada de ocho caracteres. Pero ¬øqu√© ocurre si enviamos algo m√°s largo? Probemos enviando: `01234567890123456789`
![stack-overflow](capturas/stack-overflow.png)


Lo que ocurre cuando escribimos M√ÅS all√° del b√∫fer (desbordamiento):
```css
            B√∫fer v√°lido
            ‚ñº
0xabcdef   [ 01 | 23 | 45 | 67 ]
           [ 89 | 01 | 23 | 45 ]  ‚Üê comienzo del desbordamiento
           -----------------------
0x401000   [ 67 | 89 | 01 | 23 ]  ‚Üê üî• EIP sobrescrito
           -----------------------
0x12345678 [ 45 | 67 | 89 | 01 ]  ‚Üê ‚ö†Ô∏è EBP sobrescrito
``` 

Como podemos ver, cuando enviamos una cadena m√°s larga de lo esperado, sobrescribe otros valores existentes en la pila e incluso podr√≠a sobrescribir toda la pila si es lo suficientemente larga. Lo m√°s importante es que sobrescribe el valor del EIP, y cuando la funci√≥n intenta volver a esa direcci√≥n, el programa se bloquea porque esa direcci√≥n 0x6789 no existe en memoria.

Esto ocurre debido al dise√±o LIFO de la pila, que crece hacia arriba, mientras que una cadena muy larga sobrescribe valores hacia abajo hasta eventualmente sobrescribir la direcci√≥n de retorno (return address) y el puntero base de la pila EBP. 

Cuando se llama a una funci√≥n, se crea un nuevo stack frame, y la antigua direcci√≥n EIP se inserta en la parte superior del nuevo frame para que el programa sepa a d√≥nde volver cuando la funci√≥n termine. Por ejemplo, si nuestro b√∫fer sobrescribe la pila y la direcci√≥n de retorno, entonces la direcci√≥n sobrescrita ser√° utilizada cuando la funci√≥n ejecute la instrucci√≥n RET.

Si calculamos nuestra entrada con precisi√≥n, podemos colocar una direcci√≥n v√°lida en la posici√≥n donde se almacena el EIP. Esto llevar√≠a al programa a ir a esa direcci√≥n cuando retorne, subvirtiendo el flujo de ejecuci√≥n hacia un lugar elegido por nosotros.

# Protecciones contra Stack Overflow

Los sistemas modernos implementan protecciones como:
- evitar ejecutar c√≥digo en la pila (NX bit)
- randomizar direcciones de memoria (ASLR)
- a√±adir stack canaries
- compilar binarios con medidas de seguridad adicionales

Esto dificulta ejecutar nuestro propio c√≥digo o calcular direcciones v√°lidas.

Aun as√≠, existen t√©cnicas avanzadas para saltarse estas defensas:
- ROP
- Egg Hunting
- Explotaci√≥n SEH en Windows

Adem√°s, los compiladores modernos previenen el uso de funciones inseguras, reduciendo mucho los desbordamientos de pila.

# Fuzzing de Par√°metros

Para la explotaci√≥n de desbordamientos de b√∫fer basados en la pila, normalmente seguimos cinco pasos principales para identificar y explotar la vulnerabilidad:
- Fuzzing de par√°metros
- Controlar EIP
- Identificar caracteres inv√°lidos (Bad Characters)
- Encontrar una instrucci√≥n de retorno
- Saltar al shellcode

Generalmente, el primer paso en cualquier ejercicio de vulnerabilidades en binarios es hacer fuzzing sobre varios par√°metros y sobre cualquier otra entrada que el programa acepte, para ver si nuestra entrada puede hacer que la aplicaci√≥n falle. Si alguna de nuestras entradas logra hacer que el programa se bloquee, revisamos qu√© provoc√≥ ese fallo. Si vemos que el programa fall√≥ porque nuestra entrada sobrescribi√≥ el registro EIP, es probable que tengamos una vulnerabilidad de desbordamiento de b√∫fer basado en la pila.

Lo √∫nico que queda es explotar esta vulnerabilidad con √©xito, lo cual puede variar en dificultad dependiendo del sistema operativo, la arquitectura del programa y las protecciones.


## ¬øQu√© es exactamente fuzzing?
El fuzzing es una t√©cnica en la que:
- env√≠as entradas malformadas,
- muy largas,
- inesperadas,
- repetitivas,
- o aleatorias

para comprobar si el programa puede manejar esos datos o si se rompe.
