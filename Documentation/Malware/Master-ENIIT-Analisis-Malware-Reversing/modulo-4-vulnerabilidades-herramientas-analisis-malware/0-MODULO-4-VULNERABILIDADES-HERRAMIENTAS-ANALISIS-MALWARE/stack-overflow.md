# Desbordamientos de BÃºfer

En la explotaciÃ³n binaria, nuestro objetivo principal es subvertir la ejecuciÃ³n del binario de una manera que nos beneficie. Los desbordamientos de bÃºfer son el tipo mÃ¡s comÃºn de explotaciÃ³n binaria, pero existen otros tipos, como la explotaciÃ³n de cadenas de formato (Format String) y la explotaciÃ³n del Heap.

Un desbordamiento de bÃºfer ocurre cuando un programa recibe datos mÃ¡s largos de lo esperado, de modo que esos datos sobrescriben todo el espacio de memoria del bÃºfer en la pila. Esto puede sobrescribir el siguiente puntero de instrucciÃ³n (EIP/RIP), lo que hace que el programa falle porque intentarÃ¡ ejecutar instrucciones en una direcciÃ³n de memoria invÃ¡lida. Forzar al programa a fallar es el ejemplo mÃ¡s bÃ¡sico de explotaciÃ³n de desbordamientos de bÃºfer, conocido como un ataque de DenegaciÃ³n de Servicio (DoS).

Otro ataque bÃ¡sico consiste en sobrescribir un valor en la pila para cambiar el comportamiento del programa. Por ejemplo, si un programa de exÃ¡menes tuviera una vulnerabilidad de desbordamiento de bÃºfer, podrÃ­amos sobrescribir el bÃºfer lo suficiente para sobrescribir nuestra puntuaciÃ³n. Dado que la puntuaciÃ³n estÃ¡ almacenada en la pila en este ejemplo, podrÃ­amos aprovechar esta falla para cambiarla.

Si somos un poco mÃ¡s sofisticados, podemos cambiar la direcciÃ³n del EIP hacia una instrucciÃ³n que ejecute nuestro shellcode. Esto permitirÃ­a ejecutar cualquier comando que queramos, en lugar de solo hacer que el programa falle; esto se conoce como saltar al shellcode.

Con protecciones de memoria mÃ¡s avanzadas, puede que no sea posible cargar nuestro shellcode completo y apuntar a Ã©l. En ese caso, podemos usar una combinaciÃ³n de instrucciones del propio binario para ejecutar una funciÃ³n concreta y sobrescribir varios punteros para cambiar el flujo de ejecuciÃ³n del programa. Esto se conoce como un ataque Return Oriented Programming (ROP).

Finalmente, los programas y sistemas operativos modernos pueden usar el Heap en lugar de la pila para almacenar memoria de bÃºfer, lo que requerirÃ­a desbordamientos o explotaciÃ³n del Heap.

# Desbordamiento de la Pila (Stack Overflow)

Comencemos demostrando cÃ³mo funciona la pila al almacenar datos. La pila tiene un diseÃ±o `LIFO (Last-In, First-Out)`, lo que significa que solo podemos extraer (pop) el Ãºltimo elemento insertado (push). Si insertamos un elemento, quedarÃ¡ en la parte superior de la pila. Si extraemos algo, serÃ¡ ese elemento superior el que se retire.

La siguiente tabla muestra como funciona el stack:  
![table-stack](capturas/table-stack.png)

El siguiente ejemplo espera una entrada de ocho caracteres. Pero Â¿quÃ© ocurre si enviamos algo mÃ¡s largo? Probemos enviando: `01234567890123456789`
![stack-overflow](capturas/stack-overflow.png)


Lo que ocurre cuando escribimos MÃS allÃ¡ del bÃºfer (desbordamiento):
```css
            BÃºfer vÃ¡lido
            â–¼
0xabcdef   [ 01 | 23 | 45 | 67 ]
           [ 89 | 01 | 23 | 45 ]  â† comienzo del desbordamiento
           -----------------------
0x401000   [ 67 | 89 | 01 | 23 ]  â† ðŸ”¥ EIP sobrescrito
           -----------------------
0x12345678 [ 45 | 67 | 89 | 01 ]  â† âš ï¸ EBP sobrescrito
``` 

Como podemos ver, cuando enviamos una cadena mÃ¡s larga de lo esperado, sobrescribe otros valores existentes en la pila e incluso podrÃ­a sobrescribir toda la pila si es lo suficientemente larga. Lo mÃ¡s importante es que sobrescribe el valor del EIP, y cuando la funciÃ³n intenta volver a esa direcciÃ³n, el programa se bloquea porque esa direcciÃ³n 0x6789 no existe en memoria.

Esto ocurre debido al diseÃ±o LIFO de la pila, que crece hacia arriba, mientras que una cadena muy larga sobrescribe valores hacia abajo hasta eventualmente sobrescribir la direcciÃ³n de retorno (return address) y el puntero base de la pila EBP. 

Cuando se llama a una funciÃ³n, se crea un nuevo stack frame, y la antigua direcciÃ³n EIP se inserta en la parte superior del nuevo frame para que el programa sepa a dÃ³nde volver cuando la funciÃ³n termine. Por ejemplo, si nuestro bÃºfer sobrescribe la pila y la direcciÃ³n de retorno, entonces la direcciÃ³n sobrescrita serÃ¡ utilizada cuando la funciÃ³n ejecute la instrucciÃ³n RET.

Si calculamos nuestra entrada con precisiÃ³n, podemos colocar una direcciÃ³n vÃ¡lida en la posiciÃ³n donde se almacena el EIP. Esto llevarÃ­a al programa a ir a esa direcciÃ³n cuando retorne, subvirtiendo el flujo de ejecuciÃ³n hacia un lugar elegido por nosotros.

# Protecciones contra Stack Overflow

Los sistemas modernos implementan protecciones como:
- evitar ejecutar cÃ³digo en la pila (NX bit)
- randomizar direcciones de memoria (ASLR)
- aÃ±adir stack canaries
- compilar binarios con medidas de seguridad adicionales

Esto dificulta ejecutar nuestro propio cÃ³digo o calcular direcciones vÃ¡lidas.

Aun asÃ­, existen tÃ©cnicas avanzadas para saltarse estas defensas:
- ROP
- Egg Hunting
- ExplotaciÃ³n SEH en Windows

AdemÃ¡s, los compiladores modernos previenen el uso de funciones inseguras, reduciendo mucho los desbordamientos de pila.

# Fuzzing de ParÃ¡metros

Para la explotaciÃ³n de desbordamientos de bÃºfer basados en la pila, normalmente seguimos cinco pasos principales para identificar y explotar la vulnerabilidad:
- Fuzzing de parÃ¡metros
- Controlar EIP
- Identificar caracteres invÃ¡lidos (Bad Characters)
- Encontrar una instrucciÃ³n de retorno
- Saltar al shellcode

Generalmente, el primer paso en cualquier ejercicio de vulnerabilidades en binarios es hacer fuzzing sobre varios parÃ¡metros y sobre cualquier otra entrada que el programa acepte, para ver si nuestra entrada puede hacer que la aplicaciÃ³n falle. Si alguna de nuestras entradas logra hacer que el programa se bloquee, revisamos quÃ© provocÃ³ ese fallo. Si vemos que el programa fallÃ³ porque nuestra entrada sobrescribiÃ³ el registro EIP, es probable que tengamos una vulnerabilidad de desbordamiento de bÃºfer basado en la pila.

Lo Ãºnico que queda es explotar esta vulnerabilidad con Ã©xito, lo cual puede variar en dificultad dependiendo del sistema operativo, la arquitectura del programa y las protecciones.


## Â¿QuÃ© es exactamente fuzzing?
El fuzzing es una tÃ©cnica en la que:
- envÃ­as entradas malformadas,
- muy largas,
- inesperadas,
- repetitivas,
- o aleatorias

para comprobar si el programa puede manejar esos datos o si se rompe.

Como cualquier programa puede tener muchos de estos tipos de parÃ¡metros, y cada uno puede requerir fuzzing con distintos tipos de entradas, deberÃ­amos intentar seleccionar primero los parÃ¡metros con mayores posibilidades de provocar desbordamientos y comenzar por ellos.
Debemos buscar un campo que espere una entrada corta, como un campo que establezca una fecha, ya que normalmente la fecha es corta y los desarrolladores podrÃ­an estar esperando Ãºnicamente una entrada breve.

Lo mismo aplica a los archivos que se abren, ya que los archivos abiertos suelen procesarse despuÃ©s de cargarse. Aunque los desarrolladores pueden reservar un bÃºfer muy largo para los archivos abiertos, ciertos archivos se esperan que sean mÃ¡s cortos, como los archivos de configuraciÃ³n, y si proporcionamos una entrada demasiado larga, podrÃ­a desbordarse el bÃºfer. Algunos tipos de archivo tienden a causar vulnerabilidades de desbordamiento, como los archivos .wav o .m3u, debido a vulnerabilidades en las bibliotecas que procesan esos tipos de archivos.


# Fuzzing de Campos de Texto
Recorremos los distintos elementos del menÃº del programa y, como mencionamos antes, los campos de registro de licencia suelen ser un buen candidato para desbordamientos, asÃ­ que empecemos a hacer fuzzing en ellos.

Comencemos creando un payload de texto muy grande, por ejemplo de 10,000 caracteres, e introduciÃ©ndolo en nuestro campo. Podemos generar este payload de texto con Python de la siguiente manera:
```c
powershell-session
PS C:\Users\htb-student\Desktop> python -c "print('A'*10000)"
```

Salida:
```c
AAAAA............AAAA
```

Ahora podemos copiar el payload y pegarlo en los campos de resgistro para ver si ocurre un crash en el programa.

