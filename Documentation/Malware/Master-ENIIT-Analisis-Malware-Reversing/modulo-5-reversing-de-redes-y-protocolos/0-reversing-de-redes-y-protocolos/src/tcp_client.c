#include <libgen.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <netdb.h>
#include <errno.h>
#include <poll.h>


#define BUFFER_SIZE 1024
#define TIMEOUT 10000 /* ms = 3 sec */
#define MAX_RETRIES 2


int main ( int argc, char* argv[] )
{
  if (argc != 4) {
    const char * myself = basename(argv[0]);
    fprintf(stderr, "Usage: %s <addr> <port> <file>\n", myself);
    fprintf(stderr, "  <server>: Domain name or IP address of the TCP server\n");
    fprintf(stderr, "    <port>: Port number of the TCP server\n");
    fprintf(stderr, "<filename>: Filename to request to the TCP server\n");
    exit(EXIT_FAILURE);
  }
  
  const char*   server_arg = argv[1];
  const char*     port_arg = argv[2];
  const char* filename_arg = argv[3];

  /* Obtain server address(es) matching host/port */
  struct addrinfo hints;
  struct addrinfo *result;

  memset(&hints, 0x00, sizeof(hints));
  hints.ai_family = AF_UNSPEC;     /* Allow IPv4 or IPv6 addresses */
  hints.ai_socktype = SOCK_STREAM;  /* Datagram socket */
  hints.ai_flags = AI_ADDRCONFIG;
  hints.ai_protocol = IPPROTO_TCP; /* TCP protocol */

  int err = getaddrinfo(server_arg, port_arg, &hints, &result);
  if (err != 0) {
    fprintf(stderr, "getaddrinfo() error: %s\n", gai_strerror(err));
    exit(EXIT_FAILURE);
  }

  /* getaddrinfo() returns a list of address structures. 
   * Try each address until we successfullty connect().
   * If socket() of connect() fails, we close the socket 
   * and try the next address. */
  
  struct addrinfo *ptr;
  int sock_fd;
  for (ptr = result; ptr != NULL; ptr = ptr->ai_next) {

    /* Open a TCP socket */
    sock_fd = socket(ptr->ai_family, ptr->ai_socktype, ptr->ai_protocol);
    if (sock_fd == -1) {
      continue; /* Failure! Try next address */
    }

    /* Open a TCP connection to server */
    err = connect(sock_fd, ptr->ai_addr, ptr->ai_addrlen);
    if (err == 0) {
      break; /* Success! No need to keep looking for more addresses */
    }

    close(sock_fd); /* Close socket, because connect() failed */
  }

  if (ptr == NULL) {
    /* No address succeeded */
    fprintf(stderr, "Cannot connect to TCP Server '%s/%s'\n", server_arg, port_arg);
    exit(EXIT_FAILURE);
  }

  freeaddrinfo(result); /* No longer needed */

  
  /* Get Server IP address and port */
  struct sockaddr_storage server_sa;
  socklen_t server_sa_len = sizeof(server_sa);
  err = getpeername(sock_fd, (struct sockaddr *) &server_sa, &server_sa_len);
  if (err == -1) {
    perror("getpeername() error");
    exit(EXIT_FAILURE);
  }
  
  char server_addr_str[NI_MAXHOST];
  char server_port_str[NI_MAXSERV];
  int gni_flags = NI_NUMERICHOST | NI_NUMERICSERV;
  err = getnameinfo((struct sockaddr *) &server_sa, server_sa_len,
		    server_addr_str, sizeof(server_addr_str),
		    server_port_str, sizeof(server_port_str), gni_flags);
  if (err == -1) {
      fprintf(stderr, "getnameinfo() error: %s\n", gai_strerror(err));
      exit(EXIT_FAILURE);
  }

  printf("Connected to TCP Server %s/%s\n", server_addr_str, server_port_str);

  
  /* Send request to TCP server and close transmission channel */
  ssize_t bytes_sent = send(sock_fd, filename_arg, strlen(filename_arg), 0);
  if (bytes_sent == -1) {
    perror("send() error");
    exit(EXIT_FAILURE);
  }

  err = shutdown(sock_fd, SHUT_WR);
  if (err != 0) {
    perror("shutdown() error");
    exit(EXIT_FAILURE);
  }
  
  printf("Requesting TCP Server %s/%s to download file \"%s\"\n",
	 server_addr_str, server_port_str, filename_arg);

  
  /* Create local file to download remote one */
  int file_fd = open(filename_arg, O_WRONLY | O_CREAT | O_EXCL, S_IRUSR | S_IWUSR);
  if (file_fd == -1) {
    if (errno == EEXIST) {
      fprintf(stderr, "File \"%s\" already exists! Please delete it\n", filename_arg);
    } else {
      perror("open() error");
    }
    exit(EXIT_FAILURE);
  }
  
  /* Receive the file from server */
  char buffer[BUFFER_SIZE];
  size_t total_bytes = 0;
  ssize_t bytes_recv;
  do {
    bytes_recv = recv(sock_fd, buffer, sizeof(buffer), 0);
    printf("D: bytes_recv = %ld\n", bytes_recv);
    if (bytes_recv == -1) {
      perror("recv() error");
      exit(EXIT_FAILURE);
    }

    ssize_t bytes_written = write(file_fd, buffer, bytes_recv);
    if (bytes_written == -1) {
      perror("write() error");
      exit(EXIT_FAILURE);
    }
    total_bytes += bytes_written;
    
  } while (bytes_recv > 0);

  if (total_bytes == 0) {
    fprintf(stderr, "TCP Server has not sent the requested file\n");
  } else {
    printf("%ld bytes received from TCP Server\n", total_bytes);
  }

  
  /* Close file, socket and exit */
  err = close(file_fd);
  if (err != 0) {
    perror("close() error");
    exit(EXIT_FAILURE);
  }

  err = close(sock_fd);
  if (err != 0) {
    perror("close() error");
    exit(EXIT_FAILURE);
  }
  
  return EXIT_SUCCESS;
}
