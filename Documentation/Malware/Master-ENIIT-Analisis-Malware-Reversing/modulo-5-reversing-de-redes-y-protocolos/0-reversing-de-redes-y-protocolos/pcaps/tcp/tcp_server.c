#include <libgen.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <netdb.h>
#include <errno.h>


#define BUFFER_SIZE 4096

int process_client ( int fd, struct sockaddr * sa, ssize_t sa_len );


int main ( int argc, char* argv[] )
{
  if (argc < 2 || argc > 3) {
    const char * myself = basename(argv[0]);
    fprintf(stderr, "Usage: %s <port> [<addr>]\n", myself);
    fprintf(stderr, "   <port>: Port number to bind to\n");
    fprintf(stderr, "   <addr>: IP Address to bind to\n");
    exit(EXIT_FAILURE);
  }
  
  const char* port_arg = argv[1];

  const char* addr_arg;
  if (argc == 3) {
    addr_arg = argv[2];
  } else {
    addr_arg = NULL;
  }
  
  /* Obtain server address(es) matching host/port */
  struct addrinfo *result;
  struct addrinfo hints;
  memset(&hints, 0x00, sizeof(hints));
  hints.ai_family = AF_UNSPEC;      /* Allow IPv4 or IPv6 addresses */
  hints.ai_socktype = SOCK_STREAM;  /* Stream socket */
  hints.ai_flags = AI_PASSIVE | AI_NUMERICHOST | AI_ADDRCONFIG;
                                   /* Ask for a configured server address */
  hints.ai_protocol = IPPROTO_TCP; /* TCP protocol */

  int err = getaddrinfo(addr_arg, port_arg, &hints, &result);
  if (err != 0) {
    fprintf(stderr, "getaddrinfo() error: %s\n", gai_strerror(err));
    exit(EXIT_FAILURE);
  }
  
  /* getaddrinfo() returns a list of address structures. 
   * Try each address until we successfullty bind().
   * If socket() of bind() fails, we close the socket 
   * and try the next address. */
  
  int sock_fd;
  
  struct addrinfo *ptr;
  for (ptr=result; ptr!=NULL; ptr=ptr->ai_next) {

    /* Open a TCP socket */
    sock_fd = socket(ptr->ai_family, ptr->ai_socktype, ptr->ai_protocol);
    if (sock_fd == -1) {
      /* Failure! Try next address */
      continue;
    }
  
    /* Bind to TCP port */
    err = bind(sock_fd, ptr->ai_addr, ptr->ai_addrlen);
    if (err == 0) {
      /* Success! No need to keep looking for more addresses */
      break;
    }

    close(sock_fd); /* Close socket, because bind() failed */
  }

  if (ptr == NULL) {
    /* No address succeeded */
    fprintf(stderr, "Cannot bind to TCP port '%s'\n", port_arg);
    exit(EXIT_FAILURE);
  }

  freeaddrinfo(result); /* No longer needed */

  /* Set SO_REUSEADDR socket option */
  int enable = 1;
  err = setsockopt(sock_fd, SOL_SOCKET, SO_REUSEADDR, &enable, sizeof(enable));
  if (err != 0) {
    perror("setsockopt() error");
    exit(EXIT_FAILURE);
  }
     
  /* Get Server IP address and port */
  struct sockaddr_storage server_sockaddr;
  socklen_t server_sockaddr_len = sizeof(server_sockaddr);
  err = getsockname(sock_fd, (struct sockaddr *) &server_sockaddr, &server_sockaddr_len);
  if (err == -1) {
    perror("getsockname() error");
    exit(EXIT_FAILURE);
  }
   
  char server_addr_str[NI_MAXHOST];
  char server_port_str[NI_MAXSERV];
  int gni_flags = NI_NUMERICHOST | NI_NUMERICSERV;
  err = getnameinfo((struct sockaddr *) &server_sockaddr, server_sockaddr_len,
		    server_addr_str, sizeof(server_addr_str),
		    server_port_str, sizeof(server_port_str), gni_flags);
  if (err == -1) {
    fprintf(stderr, "getnameinfo() error: %s\n", gai_strerror(err));
    exit(EXIT_FAILURE);
  }

  /* Start listening for incoming TCP connections */
  err = listen(sock_fd, 1);
  if (err != 0) {
    perror("listen() error");
    exit(EXIT_FAILURE);
  }
    
  printf("TCP Server listening at %s/%s ...\n", server_addr_str, server_port_str);

    
  for(;;) {

    /* Accept connection from client */
    struct sockaddr_storage client_sa;
    socklen_t client_sa_len = sizeof(client_sa);
    
    int conn_fd = accept(sock_fd, (struct sockaddr *) &client_sa, &client_sa_len);
    if (conn_fd == -1) {
      perror("accept()");
      break;
    }

    /* Process client connection */
    int err = process_client(conn_fd, (struct sockaddr*) &client_sa, client_sa_len);
    if (err == -1) {
      fprintf(stderr, "Internal TCP Server error. Exiting!\n");
      break;
    }

    /* Close connection and exit loop */
    err = close(conn_fd);
    if (err != 0) {
      perror("close() error");
      break;
    }
  }
  
  /* Close server socket and exit */
  err = close(sock_fd);
  if (err != 0) {
    perror("close() error");
  }

  return EXIT_FAILURE;
}



int process_client ( int fd, struct sockaddr * sa, ssize_t sa_len )
{
  /* Get client IP address and port */
  char client_addr_str[NI_MAXHOST];
  char client_port_str[NI_MAXSERV];
  int gni_flags = NI_NUMERICHOST | NI_NUMERICSERV;
  int err = getnameinfo(sa, sa_len, client_addr_str, sizeof(client_addr_str),
			client_port_str, sizeof(client_port_str), gni_flags);
  if (err == -1) {
    fprintf(stderr, "getnameinfo() error: %s\n", gai_strerror(err));
    return -1;
  }
  printf("New connection from TCP Client %s/%s\n", client_addr_str, client_port_str);


  /* Wait until we receive some data from the client.
   * Since TCP may split the response in different segments, concat
   * them until the client closes its end of the connection */ 
  char buffer[BUFFER_SIZE];
  size_t buffer_left = sizeof(buffer) - 1;
  size_t i = 0;

  ssize_t bytes_recv;
  do {
    bytes_recv = recv(fd, &buffer[i], buffer_left, 0);
    printf("D: %ld bytes recv\n", bytes_recv);
    
    if (bytes_recv == -1) {
      perror("recv() error");
      return -1; /* Internal server error */
    }      

    /* Append received data to buffer (if any) */
    buffer_left -= bytes_recv;
    if (buffer_left <= 0) {
      return -1; /* Filename too long. Return internal error */
    }
    i += bytes_recv;

  } while (bytes_recv > 0);

  /* Access only files from current directory */
  buffer[i] = '\0';
  char* filename = basename(buffer);
  
  printf("TCP Client %s/%s has requested file \"%s\"\n",
	 client_addr_str, client_port_str, filename);

  /* Open requested file */
  int file_fd = open(filename, O_RDONLY);
  if (file_fd == -1) {
    fprintf(stderr, "Cannot open requested file: \"%s\"\n", filename);
    return 1; /* Return client error */
  }
  
  /* Read file and send it to client until EOF */
  ssize_t total_bytes_sent = 0;
  ssize_t bytes_read;
  do {
    bytes_read = read(file_fd, buffer, sizeof(buffer));
    if (bytes_read == -1) {
      perror("read() error");
      return -1;
      
    } else if (bytes_read > 0) {
      ssize_t bytes_sent = send(fd, buffer, bytes_read, 0);
      if (bytes_sent == -1) {
	perror("read() error");
	return -1;
      }
      
      total_bytes_sent += bytes_sent;
    }
  } while (bytes_read > 0);
  
  /* File has been successfully sent, print summary and return with success */
  printf("%ld bytes sent to TCP Client %s/%s\n",
	 total_bytes_sent, client_addr_str, client_port_str);
  
  return 0;
}
