![tls.png](capturas/tls.png)

Esta captura de pantalla (tls.pcap) muestra una sesiÃ³n completa de HTTPS, que utiliza el protocolo TLSv1.2 sobre una base de TCP. AquÃ­ el objetivo es establecer un canal de comunicaciÃ³n cifrado y seguro entre el cliente (192.168.1.33) y el servidor (93.184.216.34).

## 1) Establecimiento TCP (3-Way Handshake) â€” paquetes 1â€“3
Cliente: 192.168.1.33:54908  
Servidor: 93.184.216.34:443  

- (1) SYN 54908 â†’ 443
- (2) SYN,ACK 443 â†’ 54908
- (3) ACK 54908 â†’ 443

âœ… Resultado: TCP queda establecido y ya puede iniciar TLS sobre ese canal.


## 2) Handshake TLS 1.2 â€” paquetes 4â€“15
### 2.1 ClientHello (inicio TLS)

- (4) TLSv1.2 Client Hello (SNI=www.example.com)  
Esto significa que el cliente (tu mÃ¡quina) propone:
    - VersiÃ³n TLS (1.2)
    - suites criptogrÃ¡ficas soportadas
    - extensiones
    - y el SNI (Server Name Indication): www.example.com

âœ… El SNI es clave porque permite que un mismo servidor IP aloje varios dominios HTTPS.


### 2.2 Respuesta del servidor: ServerHello + Certificado + parÃ¡metros de clave
- (6) Server Hello

- (8) Certificate

- (9) Server Key Exchange, Server Hello Done

ğŸ” En tu lista aparece un mensaje â€œTCP PDU reassembledâ€¦â€, lo que indica que parte de estos mensajes TLS van â€œtroceadosâ€ en varios segmentos TCP y Wireshark los recompone (esto es normal en TLS).

âœ… Hasta aquÃ­ el servidor ya ha:
    - elegido la configuraciÃ³n del cifrado
    - enviado el certificado
    - enviado parÃ¡metros para el intercambio de claves (por ejemplo, ECDHE suele ir aquÃ­ en TLS 1.2).


### 2.3 El cliente termina el handshake (pasa a cifrado)
- (14) Client Key Exchange, Change Cipher Spec, Encrypted Handshake Message

Esto significa:
    - El cliente envÃ­a el material para acordar la clave de sesiÃ³n
    - Luego manda ChangeCipherSpec: â€œa partir de ahora cifroâ€
    - Y envÃ­a el Finished (ya cifrado)

### 2.4 El servidor confirma y ya estÃ¡ cifrado todo
- (15) Change Cipher Spec, Encrypted Handshake Message

âœ… Con esto el handshake TLS se considera completado: ya pueden intercambiar Application Data (datos reales cifrados).


## 3) Intercambio de datos cifrados (Application Data) â€” paquetes 17â€“21
- (17) TLSv1.2 Application Data

- (18) TLSv1.2 Application Data

- (19) TLSv1.2 Application Data

ACKs asociados (20â€“21)

ğŸ“Œ Esto corresponde a trÃ¡fico HTTPS real (por ejemplo, peticiÃ³n/respuesta HTTP, pero cifrado). Wireshark no puede ver el contenido sin claves TLS, por eso lo muestra como â€œApplication Dataâ€.

âœ… AquÃ­ estÃ¡ claro que sÃ­ hubo comunicaciÃ³n Ãºtil, no solo handshake.

-------

Se necesita el fichero sslkeylogfile.txt para este tls.pcap, porque es un archivo de claves TLS (SSLKEYLOGFILE) que permite a Wireshark descifrar el trÃ¡fico TLS y mostrar el contenido real (HTTP) en lugar de solo ver â€œApplication Dataâ€. 

Sin el keylog, Wireshark solo puede mostrar:
- Handshake TLS (ClientHello, ServerHello, Certificateâ€¦)
- y despuÃ©s â€œTLS Application Dataâ€ (cifrado)

Con el keylog correcto, podrÃ¡s ver por ejemplo:
- HTTP GET / HTTP headers
- Respuestas HTTP (200, 301, etc.)
- Host, URI, User-Agent, etc.
- Seguir el flujo con Follow â†’ TLS Stream y leer contenido descifrado.


El keylog solo descifra si corresponde a esa misma sesiÃ³n TLS. CÃ³mo comprobarlo rÃ¡pido:
- Abre el paquete Client Hello en Wireshark
- Busca el campo Random (Client Random)
- Copia ese valor y verifica que exista en el sslkeylogfile.txt (lÃ­neas CLIENT_RANDOM ... o los secretos de trÃ¡fico)
- Si coincide, descifra. Si no coincide, no.

![tls-random](capturas/tls-random.png)  
random: 8ce84dec4edac65120f4b17c143d9863e6e3efd5effbf86f9b99d39a  
![tls-sslkeylog](capturas/tls-sslkeylog.png)



------

## 4) Cierre TLS y cierre TCP â€” paquetes 22â€“28 (aquÃ­ estÃ¡ â€œlo interesanteâ€)
### 4.1 Cierre TLS (correcto a nivel criptogrÃ¡fico)
- (22) TLSv1.2 Encrypted Alert (cliente â†’ servidor)  
Normalmente esto es un close_notify cifrado (avisa que va a cerrar TLS).

- (24) TLSv1.2 Encrypted Alert (servidor â†’ cliente)   
Respuesta equivalente: el servidor tambiÃ©n cierra la sesiÃ³n TLS â€œde forma educadaâ€.

âœ… Esto es el cierre â€œbien hechoâ€ de TLS: alertas close_notify.

### 4.2 Cierre TCP (FIN/ACK) y luego un RST (cierre anÃ³malo)
- (23) FIN, ACK (cliente inicia cierre TCP)

- (25) FIN, ACK (servidor cierra su lado)

**Y aquÃ­ viene el comportamiento anÃ³malo:**  
- (26) RST 54908 â†’ 443 (cliente resetea)

- (28) RST otra vez (cliente)

ğŸ“Œ Un RST significa: â€œcorto la conexiÃ³n de golpe / aborto el socketâ€. Â¿Por quÃ© puede pasar esto si ya habÃ­a FIN? Las causas tÃ­picas son:
    - La aplicaciÃ³n cliente cerrÃ³ el socket de forma brusca (por ejemplo con SO_LINGER=0 o terminando el proceso), y el sistema operativo envÃ­a RST.
    - El cliente no esperaba mÃ¡s paquetes (por ejemplo llega el FIN/ACK del servidor cuando el cliente ya â€œdio por cerradaâ€ la conexiÃ³n) y responde con reset.
    - AlgÃºn software intermedio (proxy/antivirus/inspector) fuerza el reset.

âœ… Lo importante: el handshake TLS y el intercambio de datos fueron correctos.  


âœ… El â€œproblemaâ€ estÃ¡ en el cierre TCP, que termina siendo reset en vez de un cierre 100% limpio.


## ConclusiÃ³n (resumen de lo que ocurre)
- Se establece TCP correctamente (1â€“3)
- Se completa TLS 1.2 con SNI www.example.com (4â€“15)
- Se intercambian datos cifrados (17â€“19)
- Se intenta cerrar correctamente con Encrypted Alert (22,24)
- El cierre TCP acaba en RST del cliente (26,28) â†’ cierre abrupto


-----------

## Cargamos el fichero sslkeylogfile en wireshark
CÃ³mo cargarlo en Wireshark (pasos)
- Edit â†’ Preferences
- Protocols â†’ TLS
- En (Pre)-Master-Secret log filename selecciona tu archivo sslkeylogfile.txt
- Aceptar y recargar el pcap

![tls-2](capturas/tls-2.png)


Ahora podemos analizar el trÃ¡fico cifrado que antes no podÃ­amos: Intercambio de datos real (HTTP descifrado) (paquetes 17â€“21)

### PeticiÃ³n
- (17) HTTP GET / HTTP/1.1 (cliente â†’ servidor)

Es decir: el cliente solicita la raÃ­z / (la pÃ¡gina principal).

### Respuesta
- (19) HTTP/1.1 200 OK (text/html) (servidor â†’ cliente)

Esto confirma que el servidor respondiÃ³ correctamente con un HTML (la tÃ­pica pÃ¡gina de example.com).

ğŸ“Œ El paquete (18) aparece como â€œTLS segment of a reassembled PDUâ€: es parte del troceado/reensamblado de la respuesta.

âœ… ConclusiÃ³n de esta fase: se completÃ³ la transacciÃ³n HTTPS (GET â†’ 200 OK).

![tls-paquete19](capturas/tls-paquete19.png)