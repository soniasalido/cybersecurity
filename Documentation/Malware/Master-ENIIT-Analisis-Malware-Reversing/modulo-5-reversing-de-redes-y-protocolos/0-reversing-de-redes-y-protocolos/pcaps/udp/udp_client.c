#include <libgen.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netdb.h>
#include <errno.h>
#include <poll.h>


#define BUFFER_SIZE 1024
#define TIMEOUT 3000 /* ms = 3 sec */
#define MAX_RETRIES 2


int main ( int argc, char* argv[] )
{
  if (argc != 4) {
    const char * myself = basename(argv[0]);
    fprintf(stderr, "Usage: %s <addr> <port> <msg>\n", myself);
    fprintf(stderr, " <server>: Domain name or IP address of the UDP server\n");
    fprintf(stderr, "   <port>: Port number of the UDP server\n");
    fprintf(stderr, "    <msg>: Message to send to the UDP server\n");
    exit(EXIT_FAILURE);
  }
  
  const char* server_arg = argv[1];
  const char*   port_arg = argv[2];
  const char*    msg_arg = argv[3];

  /* Obtain server address(es) matching host/port */
  struct addrinfo hints;
  struct addrinfo *result;

  memset(&hints, 0x00, sizeof(hints));
  hints.ai_family = AF_UNSPEC;     /* Allow IPv4 or IPv6 addresses */
  hints.ai_socktype = SOCK_DGRAM;  /* Datagram socket */
  hints.ai_flags = AI_ADDRCONFIG;
  hints.ai_protocol = IPPROTO_UDP; /* UDP protocol */

  int err = getaddrinfo(server_arg, port_arg, &hints, &result);
  if (err != 0) {
    fprintf(stderr, "getaddrinfo() error: %s\n", gai_strerror(err));
    exit(EXIT_FAILURE);
  }

  /* getaddrinfo() returns a list of address structures. 
   * Try each address until we successfully connect().
   * If socket() of connect() fails, we close the socket 
   * and try the next address. */
  
  struct addrinfo *ptr;
  int sock_fd;
  for (ptr = result; ptr != NULL; ptr = ptr->ai_next) {

    /* Open an UDP socket */
    sock_fd = socket(ptr->ai_family, ptr->ai_socktype, ptr->ai_protocol);
    if (sock_fd == -1) {
      continue; /* Failure! Try next address */
    }

    /* Fix socket to server address and UDP port */
    err = connect(sock_fd, ptr->ai_addr, ptr->ai_addrlen);
    if (err != -1) {
      break; /* Success! No need to keep looking for more addresses */
    }

    close(sock_fd); /* Close socket, because connect() failed */
  }

  if (ptr == NULL) {
    /* No address succeeded */
    fprintf(stderr, "Cannot connect to UDP Server '%s/%s'\n", server_arg, port_arg);
    exit(EXIT_FAILURE);
  }

  freeaddrinfo(result); /* No longer needed */

  
  /* Get Server IP address and port */
  struct sockaddr_storage server_sa;
  socklen_t server_sa_len = sizeof(server_sa);
  err = getpeername(sock_fd, (struct sockaddr *) &server_sa, &server_sa_len);
  if (err == -1) {
    perror("getpeername() error");
    exit(EXIT_FAILURE);
  }
  
  char server_addr_str[NI_MAXHOST];
  char server_port_str[NI_MAXSERV];
  int gni_flags = NI_NUMERICHOST | NI_NUMERICSERV;
  err = getnameinfo((struct sockaddr *) &server_sa, server_sa_len,
		    server_addr_str, sizeof(server_addr_str),
		    server_port_str, sizeof(server_port_str), gni_flags);
  if (err == -1) {
      fprintf(stderr, "getnameinfo() error: %s\n", gai_strerror(err));
      exit(EXIT_FAILURE);
  }

  
  /* Send a message to the server until we get a reply */
  char* msg = (char*) msg_arg;
  int msg_len = strlen(msg);

  nfds_t num_poll_fds = 1;
  struct pollfd poll_fds[num_poll_fds];
  poll_fds[0].fd = sock_fd;
  poll_fds[0].events = POLLIN | POLLERR;

  int retries;
  for (retries=0; retries<=MAX_RETRIES; retries++) {

    ssize_t bytes_sent = send(sock_fd, msg, msg_len, 0);
    if (bytes_sent == -1) {
      perror("send() error");
      exit(EXIT_FAILURE);
    }
  
    printf("%ld bytes sent to UDP Server %s/%s\n",
	   bytes_sent, server_addr_str, server_port_str);

    /* Now wait until we have a response.
     * We use poll() to implement the retransmission timer */
    int retval = poll(poll_fds, num_poll_fds, TIMEOUT);
    if (retval == -1) {
      perror("poll() error");
      exit(EXIT_FAILURE);
    } else if (retval == 0) {
      if (retries+1 <= MAX_RETRIES) {
	printf("Timeout! Retrying #%d\n", retries+1);
      }
      continue;
    } else {
      /* We have received a response from the server */
      break;
    }
  }

  if (retries > MAX_RETRIES) {
    /* No response from any of the replies. Abort! */
    fprintf(stderr, "Cannot contact UDP Server %s/%s\n",
	    server_addr_str, server_port_str);
    exit(EXIT_FAILURE);
  }
 
  /* Receive the message from server */ 
  char buffer[BUFFER_SIZE]; 
  ssize_t bytes_recv = recv(sock_fd, buffer, sizeof(buffer) - 1, 0);
  if (bytes_recv == -1) {
    perror("recv() error");
    exit(EXIT_FAILURE);
  }
  
  buffer[bytes_recv] = '\0';
  printf("%ld bytes received from UDP Server: \"%s\"\n", bytes_recv, buffer);
  
  /* Close socket and exit */
  err = close(sock_fd);
  if (err != 0) {
    perror("close() error");
    exit(EXIT_FAILURE);
    }
  
  return EXIT_SUCCESS;
}
