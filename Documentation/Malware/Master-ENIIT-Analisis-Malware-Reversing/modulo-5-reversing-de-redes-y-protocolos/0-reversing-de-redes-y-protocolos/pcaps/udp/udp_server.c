#include <libgen.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netdb.h>
#include <errno.h>


#define BUFFER_SIZE 1024


int main ( int argc, char* argv[] )
{
  if (argc < 2 || argc > 3) {
    const char * myself = basename(argv[0]);
    fprintf(stderr, "Usage: %s <port> [<addr>]\n", myself);
    fprintf(stderr, "   <port>: Port number to bind to\n");
    fprintf(stderr, "   <addr>: IP Address to bind to\n");
    exit(EXIT_FAILURE);
  }
  
  const char* port_arg = argv[1];

  const char* addr_arg;
  if (argc == 3) {
    addr_arg = argv[2];
  } else {
    addr_arg = NULL;
  }
  
  /* Obtain server address(es) matching host/port */
  struct addrinfo *result;
  struct addrinfo hints;
  memset(&hints, 0x00, sizeof(hints));
  hints.ai_family = AF_UNSPEC;     /* Allow IPv4 or IPv6 addresses */
  hints.ai_socktype = SOCK_DGRAM;  /* Datagram socket */
  hints.ai_flags = AI_PASSIVE | AI_NUMERICHOST | AI_ADDRCONFIG;
                                   /* Ask for a configured server address */
  hints.ai_protocol = IPPROTO_UDP; /* UDP protocol */

  int err = getaddrinfo(addr_arg, port_arg, &hints, &result);
  if (err != 0) {
    fprintf(stderr, "getaddrinfo() error: %s\n", gai_strerror(err));
    exit(EXIT_FAILURE);
  }
  
  /* getaddrinfo() returns a list of address structures. 
   * Try each address until we successfullty bind().
   * If socket() of bind() fails, we close the socket 
   * and try the next address. */
  
  int sock_fd;
  
  struct addrinfo *ptr;
  for (ptr=result; ptr!=NULL; ptr=ptr->ai_next) {

    /* Open an UDP socket */
    sock_fd = socket(ptr->ai_family, ptr->ai_socktype, ptr->ai_protocol);
    if (sock_fd == -1) {
      /* Failure! Try next address */
      continue;
    }
  
    /* Bind to UDP port */
    err = bind(sock_fd, ptr->ai_addr, ptr->ai_addrlen);
    if (err == 0) {
      /* Success! No need to keep looking for more addresses */
      break;
    }

    close(sock_fd); /* Close socket, because bind() failed */
  }

  if (ptr == NULL) {
    /* No address succeeded */
    fprintf(stderr, "Cannot bind to UDP port '%s'\n", port_arg);
    exit(EXIT_FAILURE);
  }

  freeaddrinfo(result); /* No longer needed */

  
  /* Get Server IP address and port */
  struct sockaddr_storage server_sa;
  socklen_t server_sa_len = sizeof(server_sa);
  err = getsockname(sock_fd, (struct sockaddr *) &server_sa, &server_sa_len);
  if (err == -1) {
    perror("getsockname() error");
    exit(EXIT_FAILURE);
  }
   
  char server_addr_str[NI_MAXHOST];
  char server_port_str[NI_MAXSERV];
  int gni_flags = NI_NUMERICHOST | NI_NUMERICSERV;
  err = getnameinfo((struct sockaddr *) &server_sa, server_sa_len,
		    server_addr_str, sizeof(server_addr_str),
		    server_port_str, sizeof(server_port_str), gni_flags);
  if (err == -1) {
    fprintf(stderr, "getnameinfo() error: %s\n", gai_strerror(err));
    exit(EXIT_FAILURE);
  }
  printf("UDP Server receiving at %s/%s ...\n", server_addr_str, server_port_str);
  printf("Press Ctrl+C to exit.\n");

  char buffer[BUFFER_SIZE];
  struct sockaddr_storage client_sa;
  socklen_t client_sa_len = sizeof(client_sa);

  char client_addr_str[NI_MAXHOST];
  char client_port_str[NI_MAXSERV];

  for(;;) {

    /* Wait until we receive some data from a client */
    ssize_t bytes_recv = recvfrom(sock_fd, buffer, sizeof(buffer), 0,
				  (struct sockaddr*) &client_sa, &client_sa_len);
    if (bytes_recv == -1) {
      perror("recv() error");
      break;
    }

    /* Get client IP address and port */
    err = getnameinfo((struct sockaddr *) &client_sa, client_sa_len,
		      client_addr_str, sizeof(client_addr_str),
		      client_port_str, sizeof(client_port_str), gni_flags);
    if (err == -1) {
      fprintf(stderr, "getnameinfo() error: %s\n", gai_strerror(err));
      break;
    }
    
    buffer[bytes_recv] = '\0';
    printf("%ld bytes received from UDP Client %s/%s: \"%s\"\n",
	   bytes_recv, client_addr_str, client_port_str, buffer);

    
    /* Send a response back to the client */
    ssize_t bytes_sent = sendto(sock_fd, buffer, bytes_recv, 0,
				(struct sockaddr*) &client_sa, client_sa_len);
    if (bytes_sent == -1) {
      perror("sendto() error");
      break;
    }

    printf("%ld bytes sent to UDP Client %s/%s: \"%s\"\n",
	   bytes_sent, client_addr_str, client_port_str, buffer);
  }
    
  /* Close socket and exit */
  err = close(sock_fd);
  if (err != 0) {
    perror("close() error");
  }
  
  return EXIT_FAILURE;
}
