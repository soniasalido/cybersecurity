
https://chatgpt.com/g/g-p-680653de039c8191b7a3c14c407bedf5-malware/c/696bbc30-06c8-8332-ba0c-964c815ea784


- [Entendiendo lo que pide el ejercicio:](#entendiendo-lo-que-pide-el-ejercicio)
  - [Capturar y analizar tráfico cifrado de un cliente DNS-over-TLS - DoT:](#capturar-y-analizar-tráfico-cifrado-de-un-cliente-dns-over-tls---dot)
    - [Fase 1 ➡ Análisis de la Aplicación - Cliente DoT](#fase-1--análisis-de-la-aplicación---cliente-dot)
    - [Fase 2 ➡ Interceptación y Descifrado del Tráfico](#fase-2--interceptación-y-descifrado-del-tráfico)
  - [Incluir evidencias](#incluir-evidencias)
- [Entendiendo que es un cliente DNS-over-TLS - DoT](#entendiendo-que-es-un-cliente-dns-over-tls---dot)
- [1. Análisis de la aplicación (cliente DoT)](#1-análisis-de-la-aplicación-cliente-dot)
  - [Instalación de kding](#instalación-de-kding)
  - [Hacer una consulta DNS-over-TLS (DoT) a Cloudflare](#hacer-una-consulta-dns-over-tls-dot-a-cloudflare)
  - [openssl](#openssl)
- [Ejercicio 1](#ejercicio-1)
- [Ejercicio 2](#ejercicio-2)
- [Parte 1: Análisis de la Aplicación](#parte-1-análisis-de-la-aplicación)
  - [1.1. Identificación de la Librería y Sockets](#11-identificación-de-la-librería-y-sockets)
  - [1.2. Análisis de la Sesión TLS (Wireshark)](#12-análisis-de-la-sesión-tls-wireshark)



# Entendiendo lo que pide el ejercicio:
## Capturar y analizar tráfico cifrado de un cliente DNS-over-TLS - DoT:
### Fase 1 ➡ Análisis de la Aplicación - Cliente DoT
Primero analizamos su comportamiento, aunque el tráfico vaya cifrado ➡ El objetivo es observar cómo la herramienta `kdig` realiza una consulta DNS segura a un servidor, como el de Cloudflare, 1.1.1.1.
    - Realizamos una captura del tráfico:
    - Capturamos las llamas al sistema empleadas, tal y como se describe en los Capítulos 4 y 6.
    - Identificamos el tipo de socket empleado.
    - Identificamos las llamadas de red más importantes utilizadas.
    - Identificamos la librería SSL/TLS empleada para cifrar las comunicaciones.
    - Hacemos un análisis completo de la sesión TLS establecida entre el cliente y el servidor DNS-over-TLS.


### Fase 2 ➡ Interceptación y Descifrado del Tráfico
Después interceptamos y desciframos ese tráfico usando dos técnicas diferentes del capitulo 7.


## Incluir evidencias
- De todos los comandos-
- De todas las pruebas:
  - Salidas de terminal.
  - Capturas, y ficheros generados como PCAP.
  - Explicar qué hace cada paso. 



# Entendiendo que es un cliente DNS-over-TLS - DoT
Un cliente DNS-over-TLS (DoT) es, en esencia, un cliente DNS que ha decidido ponerse una capa de seguridad antes de salir a la red. En lugar de gritar nuestras peticiones por megáfono, como hace el DNS tradicional, las mete en un túnel privado y cifrado.

Tradicionalmente, el DNS envía mensajes sobre datagramas UDP, lo cual es rápido pero totalmente legible para cualquiera que esté mirando el tráfico. Un cliente DoT, en cambio, establece una sesión TLS completa con el servidor DNS antes de preguntar nada. Esto implica que la comunicación no es "lanzar y olvidar", sino que requiere un protocolo de enlace (Handshake) previo para asegurar la conexión.


El objetivo principal de estos clientes es evitar que intermediarios, como nuestro proveedor de internet o un atacante en la red, puedan ver qué páginas estamos intentando visitar.

Estos clientes utilizan mecanismos avanzados como `Diffie-Hellman Efímero (DHE)` o `Curvas Elípticas (ECDH)` para el intercambio de claves, lo que garantiza que nadie pueda descifrar el tráfico incluso si robaran la clave privada del servidor en el futuro.



# 1. Análisis de la aplicación (cliente DoT)
El cliente DoT que recomienda usar el enunciado el ejerccio es `kdig` que es parte del paquete `knot-dnsutils`. Mientras que una herramienta normal como `nslookup` o `dig` usaría el `puerto 53 (UDP)`, `kdig` con el parámetro `+tls` busca establecer una conexión segura, normalmente en el `puerto 853`.

El tráfico generado por este cliente aparecerá en Wireshark simplemente como `Application Data`, ocultando la consulta DNS real bajo capas criptográficas. Realizando la última parte del ejercicio, conseguiremos descifrar estas capas.


En la Fase 1, donde realizaremos un análisis sin descifrar:
- Wireshark capturará los paquetes, pero al estar cifrados con TLS, el contenido útil se mostrará etiquetado simplemente como "Application Data".
- En esta etapa solo podremos ver el "envoltorio": las direcciones IP, los puertos (normalmente el 853 para DoT) y el Handshake de TLS (donde se intercambian certificados y se negocian algoritmos).
- La consulta DNS real (google.com, por ejemplo) y su respuesta serán totalmente ilegibles.

En la Fase 2, tras el descifrado: Al aplicar las técnicas que menciona el documento (como el uso de SSLKEYLOGFILE o un proxy como mitmproxy), ocurrirá lo siguiente:
- Wireshark utilizará las claves de sesión obtenidas para "pelar" las capas criptográficas en tiempo real.
- Debajo de la capa de Transport Layer Security, aparecerá una nueva sección en el análisis del paquete llamada Domain Name System.
- Ahí podremos ver finalmente el "texto claro": el nombre de dominio consultado, el tipo de registro (A, AAAA, MX) y la dirección IP devuelta por el servidor.


Pasos:
- Ejecutar un cliente DoT (recomendado: kdig) contra Cloudflare: Cloudflare ofrece DoT en 1.1.1.1:853 (TCP + TLS) y también por hostname one.one.one.one.

- Tenemos que estudiar el programa (cliente) que hace consultas DNS usando DNS-over-TLS (DoT).
    - DoT = DNS tradicional, pero en vez de ir en claro (UDP/53), va cifrado dentro de TLS y normalmente por TCP/853.
    - “Cliente DoT” = la herramienta que tú ejecutas para hacer la consulta DNS cifrada (por ejemplo kdig).
    - Qué buscan con “análisis”:
        - Que demuestres que el programa realmente está usando TCP y el puerto 853.
        - Que identifiques detalles de la sesión TLS (handshake, certificado, etc.).
        - Que dejes evidencia (capturas, comandos, trazas).

- “Ejecutar un cliente DoT (recomendado: kdig) contra Cloudflare”: Te piden que uses un cliente DoT (idealmente kdig) para consultar un servidor DoT real. En el ejemplo te dicen usar Cloudflare porque ofrece DoT públicamente. ¿Qué significa “Cloudflare ofrece DoT en 1.1.1.1:853 y por hostname one.one.one.one”? -->
    - 1.1.1.1 es la IP del resolver DNS de Cloudflare.
    - :853 indica el puerto donde escucha DoT.
    - one.one.one.one es el nombre (hostname) asociado al servicio. En TLS, el hostname es importante porque el certificado del servidor se valida contra ese nombre (no contra la IP).

```
kdig @1.1.1.1 +tls-ca +tls-host=one.one.one.one example.com
```
donde:
- kdig : el programa cliente DNS.
- @1.1.1.1 : le dices “consulta a este servidor DNS” (Cloudflare).
- +tls-ca : “usa TLS y valida el certificado con autoridades de certificación (CA)”.
- +tls-host=one.one.one.one : “cuando valides el certificado, comprueba que corresponde al hostname one.one.one.one” (esto evita que un atacante haga MITM con otro certificado).
- example.com : el dominio que estás consultando.
- Lo que estamos haciendo es: Ejecutar una consulta DNS cifrada (DoT) con kdig contra el servidor DoT de Cloudflare (1.1.1.1 puerto 853), validando correctamente el certificado TLS usando el nombre one.one.one.one, y luego analiza ese tráfico.”


## Instalación de kding
En Debian, kdig viene en el paquete knot-dnsutils.
```
sudo apt update
sudo apt install -y knot-dnsutils ca-certificates
```
donde:
- El ca-certificates es para que la validación de certificados TLS funcione con el almacén del sistema, que es lo que usa +tls-ca.

Comprobamos que está instalado: 
```
kdig -V
kdig, Knot DNS 3.4.6
```



## Hacer una consulta DNS-over-TLS (DoT) a Cloudflare
Cloudflare ofrece DoT en 1.1.1.1 puerto 853 (TCP+TLS) y también por hostname one.one.one.one.

Comando recomendado (con debug y validación TLS):
```
kdig -d @1.1.1.1 +tls-ca +tls-host=one.one.one.one example.com
```
donde:
- `-d`: activa mensajes de depuración (te muestra TCP, puerto 853, y detalles de TLS).
- `@1.1.1.1`: servidor DNS de Cloudflare.
- `+tls-ca`: usa TLS y valida el certificado con CAs (del sistema si no indicas un fichero).
- `+tls-host=one.one.one.one`: le dices qué hostname debe cuadrar con el certificado (es clave para evitar MITM).
- `example.com`: dominio a resolver.


Probar el otro IP de Cloudflare para DoT: Cloudflare también da DoT en 1.0.0.1:853:
```
nc -vz 1.0.0.1 853
```

Ejecuta kdig con DoT contra 1.0.0.1 (Cloudflare). Usa exactamente este comando:
```
$ kdig -d @1.0.0.1 +tls-ca +tls-host=one.one.one.one example.com
;; DEBUG: Querying for owner(example.com.), class(1), type(1), server(1.0.0.1), port(853), protocol(TCP)
;; DEBUG: TLS, imported 151 system certificates
;; DEBUG: TLS, received certificate hierarchy:
;; DEBUG:  #1, C=US,ST=California,L=San Francisco,O=Cloudflare\, Inc.,CN=cloudflare-dns.com
;; DEBUG:      SHA-256 PIN: ltQ6aXy3tqpNZKJdnevMD7oR+IsI5rNWbOssFDrl+Ew=
;; DEBUG:  #2, C=US,ST=Texas,L=Houston,O=SSL Corp,CN=SSL.com SSL Intermediate CA ECC R2
;; DEBUG:      SHA-256 PIN: zGgA4OU4DjJdvpRYUqbi5Vh2g9W5Oc/PgKihy9mkLsE=
;; DEBUG:  #3, C=US,ST=Texas,L=Houston,O=SSL Corporation,CN=SSL.com Root Certification Authority ECC
;; DEBUG:      SHA-256 PIN: oyD01TTXvpfBro3QSZc1vIlcMjrdLTiL/M9mLCPX+Zo=
;; DEBUG: TLS, skipping certificate PIN check
;; DEBUG: TLS, The certificate is trusted. 
;; TLS session (TLS1.3)-(ECDHE-X25519)-(ECDSA-SECP256R1-SHA256)-(AES-256-GCM)
;; ->>HEADER<<- opcode: QUERY; status: NOERROR; id: 33829
;; Flags: qr rd ra; QUERY: 1; ANSWER: 2; AUTHORITY: 0; ADDITIONAL: 1

;; EDNS PSEUDOSECTION:
;; Version: 0; flags: ; UDP size: 1232 B; ext-rcode: NOERROR
;; PADDING: 392 B

;; QUESTION SECTION:
;; example.com.        		IN	A

;; ANSWER SECTION:
example.com.        	101	IN	A	104.18.27.120
example.com.        	101	IN	A	104.18.26.120

;; Received 468 B
;; Time 2026-01-17 18:15:45 CET
;; From 1.0.0.1@853(TLS) in 56.7 ms
```
donde:
- 1) Evidencia de que realmente estás usando DoT (DNS-over-TLS)
    - `;; DEBUG: Querying for owner(example.com.), class(1), type(1), server(1.0.0.1), port(853), protocol(TCP)`
    - `owner(example.com.)`: el nombre consultado.
    - `type(1)`: el tipo A (IPv4). En DNS, el tipo A es el código 1.
    - `class(1)`: clase IN (Internet). En DNS, IN es el código 1.
    - `server(1.0.0.1), port(853), protocol(TCP)`: esto es clave: confirma que la consulta va a 1.0.0.1 por TCP/853, que es el puerto estándar de DoT.
    - En tu informe, esta línea es la prueba directa de “cliente DoT contra Cloudflare” usando TCP + 853.

- 2) Evidencia de validación TLS con CAs del sistema
    - `;; DEBUG: TLS, imported 151 system certificates`
    - `+tls-ca` hace que kdig cargue el almacén de CA del sistema (o el path que corresponda) para validar el certificado del servidor.
    - `“151 system certificates”` es evidencia de que está usando el trust store del sistema para la validación.

- 3) Cadena de certificados (certificate chain) presentada por el servidor
    - `;; DEBUG: TLS, received certificate hierarchy:`
    - Certificado #1 (leaf / servidor): `#1 ... O=Cloudflare, Inc., CN=cloudflare-dns.com`
        - Este es el certificado del servidor (leaf).
        - Ojo: tu comando indica +tls-host=one.one.one.one, pero el CN que imprime kdig es cloudflare-dns.com. Eso no es necesariamente un problema: hoy en día lo que manda para hostname validation suele ser el SAN (Subject Alternative Name), no el CN. Es muy posible que el SAN incluya one.one.one.one y/o nombres del servicio DoT de Cloudflare.
        - Para una evidencia “cerrada” en memoria, conviene añadir una captura complementaria con openssl s_client mostrando SANs (te dejo el comando al final).

        - SHA-256 PIN: ... kdig te muestra el pin (hash) de la clave pública/cert para pinning. Es información útil para “fingerprinting” del certificado, pero no imprescindible salvo que el guion del curso pida pinning.

    - Certificado #2 (intermediate): #2 ... CN=SSL.com SSL Intermediate CA ECC R2
        - Certificado intermedio (CA intermedia) que firma el leaf.
    
    - Certificado #3 (root): #3 ... CN=SSL.com Root Certification Authority ECC
        - Certificado raíz (root CA) del que deriva la confianza (normalmente ya está en el sistema o se valida por cadena hasta un root confiable).

- 4) Pinning y confianza del certificado:
    - `;; DEBUG: TLS, skipping certificate PIN check`: Indica que no se está aplicando pinning (no has configurado un pin esperado). Esto es normal.
    - `;; DEBUG: TLS, The certificate is trusted.`: Esta es la evidencia principal de que la verificación TLS con CA ha sido correcta: el certificado presentado por el servidor es confiable según el almacén del sistema (y la validación que hace kdig con los parámetros que le diste).


- 5) Parámetros criptográficos de la sesión TLS (muy importante para el análisis del handshake)
    - ;; TLS session (TLS1.3)-(ECDHE-X25519)-(ECDSA-SECP256R1-SHA256)-(AES-256-GCM)
    - Esta línea resume lo esencial del canal cifrado:
        - TLS1.3: la sesión negoció TLS 1.3 (moderno; handshake y cifrados distintos a TLS 1.2).
        - ECDHE-X25519: intercambio de claves efímero con curva X25519 (Perfect Forward Secrecy).
        - ECDSA-SECP256R1-SHA256: autenticación/firmas con ECDSA (curva P-256 / secp256r1) y hash SHA-256.
        - AES-256-GCM: cifrado simétrico de la sesión con AES-GCM (AEAD), clave 256 bits.
    - Para tu memoria, esto cubre muy bien la parte de “análisis de TLS”: versión y suite/algoritmos principales.


## openssl
```
xxniwexx@debian:~$ openssl s_client -tls1_3 -connect 1.0.0.1:853 -servername cloudflare-dns.com
Connecting to 1.0.0.1
CONNECTED(00000003)
depth=2 C=US, ST=Texas, L=Houston, O=SSL Corporation, CN=SSL.com Root Certification Authority ECC
verify return:1
depth=1 C=US, ST=Texas, L=Houston, O=SSL Corp, CN=SSL.com SSL Intermediate CA ECC R2
verify return:1
depth=0 C=US, ST=California, L=San Francisco, O=Cloudflare, Inc., CN=cloudflare-dns.com
verify return:1
---
Certificate chain
 0 s:C=US, ST=California, L=San Francisco, O=Cloudflare, Inc., CN=cloudflare-dns.com
   i:C=US, ST=Texas, L=Houston, O=SSL Corp, CN=SSL.com SSL Intermediate CA ECC R2
   a:PKEY: EC, (prime256v1); sigalg: ecdsa-with-SHA384
   v:NotBefore: Dec 31 19:20:01 2025 GMT; NotAfter: Dec 21 19:20:01 2026 GMT
 1 s:C=US, ST=Texas, L=Houston, O=SSL Corp, CN=SSL.com SSL Intermediate CA ECC R2
   i:C=US, ST=Texas, L=Houston, O=SSL Corporation, CN=SSL.com Root Certification Authority ECC
   a:PKEY: EC, (secp384r1); sigalg: ecdsa-with-SHA384
   v:NotBefore: Mar  7 19:42:42 2019 GMT; NotAfter: Mar  3 19:42:42 2034 GMT
 2 s:C=US, ST=Texas, L=Houston, O=SSL Corporation, CN=SSL.com Root Certification Authority ECC
   i:C=US, ST=Texas, L=Houston, O=SSL Corporation, CN=SSL.com Root Certification Authority ECC
   a:PKEY: EC, (secp384r1); sigalg: ecdsa-with-SHA256
   v:NotBefore: Feb 12 18:14:03 2016 GMT; NotAfter: Feb 12 18:14:03 2041 GMT
---
Server certificate
-----BEGIN CERTIFICATE-----
MIIFgTCCBQigAwIBAgIQTtAzBMRrh6jC61Vp2566DDAKBggqhkjOPQQDAzBvMQsw
CQYDVQQGEwJVUzEOMAwGA1UECAwFVGV4YXMxEDAOBgNVBAcMB0hvdXN0b24xETAP
BgNVBAoMCFNTTCBDb3JwMSswKQYDVQQDDCJTU0wuY29tIFNTTCBJbnRlcm1lZGlh
dGUgQ0EgRUNDIFIyMB4XDTI1MTIzMTE5MjAwMVoXDTI2MTIyMTE5MjAwMVowcjEL
MAkGA1UEBhMCVVMxEzARBgNVBAgMCkNhbGlmb3JuaWExFjAUBgNVBAcMDVNhbiBG
cmFuY2lzY28xGTAXBgNVBAoMEENsb3VkZmxhcmUsIEluYy4xGzAZBgNVBAMMEmNs
b3VkZmxhcmUtZG5zLmNvbTBZMBMGByqGSM49AgEGCCqGSM49AwEHA0IABGODUCUS
6nJ4GesyR6/BBVKcKitgioROdW2BSEfBx77PhXlsEilbULPM7FChlJ7cRAgHDIAa
k9O9eBF7tqPI6qyjggOBMIIDfTAMBgNVHRMBAf8EAjAAMB8GA1UdIwQYMBaAFA10
Zgpen+Is7NXCXSUEf3Uyuv99MHEGCCsGAQUFBwEBBGUwYzA/BggrBgEFBQcwAoYz
aHR0cDovL2NlcnQuc3NsLmNvbS9TU0xjb20tU3ViQ0EtU1NMLUVDQy0zODQtUjIu
Y2VyMCAGCCsGAQUFBzABhhRodHRwOi8vb2NzcHMuc3NsLmNvbTCBpgYDVR0RBIGe
MIGbghJjbG91ZGZsYXJlLWRucy5jb22CFCouY2xvdWRmbGFyZS1kbnMuY29thwQB
AAABhwQBAQEBhwSinyQBhwSiny4BhxAmBkcARwAAAAAAAAAAABABhxAmBkcARwAA
AAAAAAAAABERhxAmBkcARwAAAAAAAAAAAABkhxAmBkcARwAAAAAAAAAAAGQAgg9v
bmUub25lLm9uZS5vbmUwIwYDVR0gBBwwGjAIBgZngQwBAgIwDgYMKwYBBAGCqTAB
AwECMBMGA1UdJQQMMAoGCCsGAQUFBwMBMEQGA1UdHwQ9MDswOaA3oDWGM2h0dHA6
Ly9jcmxzLnNzbC5jb20vU1NMY29tLVN1YkNBLVNTTC1FQ0MtMzg0LVIyLmNybDAd
BgNVHQ4EFgQULCjsVCC2hgAmVappu7bDZS4W+h8wDgYDVR0PAQH/BAQDAgeAMIIB
fwYKKwYBBAHWeQIEAgSCAW8EggFrAWkAdgDCMX5XRRmjRe5/ON6ykEHrx8IhWiK/
f9W1rXaa2Q5SzQAAAZt144FrAAAEAwBHMEUCIHuQBtNhAb4vKGOEHCF7VVPrLHCJ
zk63LICoCBt00zT1AiEAyWgmqpFEDhYYf7tCfbPHKIFQ0m7FAnfkvAbtdxitYr0A
dwDIo8R/x7OtuTVrAT9qehJt4zpOQ6XGRvmXrTl1mR3PmgAAAZt144HcAAAEAwBI
MEYCIQDK+OeKN052kyl9skxqqvcjM0EnMjAoqfW/w2oDJhe+KwIhANhNTK+gJ6lT
DGHjETKguyIS+BGaEnybtSUbxasJS0BoAHYA2AlVO5RPev/IFhlvlE+Fq7D4/F6H
VSYPFdEucrtFSxQAAAGbdeOCMgAABAMARzBFAiBCcTgVSPtumHiOc5mABE05SNon
hQ+/HKlM/mZ5fujyAgIhALV9R9eZpDKVs4o6+Y8uQYQIshlc6drDSS5Ojen3Q2dH
MAoGCCqGSM49BAMDA2cAMGQCMBsutT9/NO4qecncXj/hWurz/QWBsk7GyrZB71SA
1P7QMBDonFpyfkEQWoiWANfPDwIwEvzlukLPMNPCKWOAcErLN5FR6h4kqMEzd1Lq
Tjux4jSNXWzCsgVjnOxJn4q3MjKF
-----END CERTIFICATE-----
subject=C=US, ST=California, L=San Francisco, O=Cloudflare, Inc., CN=cloudflare-dns.com
issuer=C=US, ST=Texas, L=Houston, O=SSL Corp, CN=SSL.com SSL Intermediate CA ECC R2
---
No client certificate CA names sent
Peer signing digest: SHA256
Peer signature type: ecdsa_secp256r1_sha256
Negotiated TLS1.3 group: X25519MLKEM768
---
SSL handshake has read 4372 bytes and written 1567 bytes
Verification: OK
---
New, TLSv1.3, Cipher is TLS_AES_256_GCM_SHA384
Protocol: TLSv1.3
Server public key is 256 bit
This TLS version forbids renegotiation.
Compression: NONE
Expansion: NONE
No ALPN negotiated
Early data was not sent
Verify return code: 0 (ok)
---
---
Post-Handshake New Session Ticket arrived:
SSL-Session:
    Protocol  : TLSv1.3
    Cipher    : TLS_AES_256_GCM_SHA384
    Session-ID: 7487130BF071CCBB11621F8257A3FE7EDEAC64A21E1AC1DA14640C7FA83AE03D
    Session-ID-ctx: 
    Resumption PSK: D8D07FE6D3E11EDD1DC26C9391DA3AAFA0EAC30521CBE8672ED86CCCCE47B3BFA58F7220E0C0CA6E15F30F823068D775
    PSK identity: None
    PSK identity hint: None
    SRP username: None
    TLS session ticket lifetime hint: 172800 (seconds)
    TLS session ticket:
    0000 - 10 11 b5 af fb 55 e8 9c-e3 37 bd 7c fd 6e 2e af   .....U...7.|.n..
    0010 - b4 7a 33 4f 39 4a 89 a7-1d a3 a6 9f 8a 66 d0 77   .z3O9J.......f.w
    0020 - 99 35 8c d9 6e ca 47 f2-86 0a 03 a8 57 b6 ba 00   .5..n.G.....W...
    0030 - c3 27 29 dd 1d 2b 6f b5-68 c2 71 30 9a f2 e5 59   .')..+o.h.q0...Y
    0040 - d4 9e 6d 34 aa b7 bf 42-96 04 b2 cc 5e 2e c0 ca   ..m4...B....^...
    0050 - b0 d8 7d c7 f7 40 6e 5c-ef 77 08 c5 73 ed 95 26   ..}..@n\.w..s..&
    0060 - 64 96 54 df c5 b1 a9 89-06 4f 22 01 96 0f aa c0   d.T......O".....
    0070 - 9b fa 54 2c 3c dd 92 64-ae 07 52 e1 80 30 0e 17   ..T,<..d..R..0..
    0080 - 08 1a f8 6d f3 72 f3 93-42 60 b1 fe 68 a0 13 f5   ...m.r..B`..h...
    0090 - 5c 45 90 ca c1 03 e8 53-c4 2c fa f9 86 31 f1 00   \E.....S.,...1..
    00a0 - 81 2d 4b f3 36 77 0e 1b-eb 4f fb 4c 04 e6 2b 34   .-K.6w...O.L..+4
    00b0 - 71 92 e6 2c c2 c6 ab d1-30 6d bb 24 10 8b 29 ab   q..,....0m.$..).

    Start Time: 1769192805
    Timeout   : 7200 (sec)
    Verify return code: 0 (ok)
    Extended master secret: no
    Max Early Data: 0
---
read R BLOCK
---
Post-Handshake New Session Ticket arrived:
SSL-Session:
    Protocol  : TLSv1.3
    Cipher    : TLS_AES_256_GCM_SHA384
    Session-ID: A7A6E6FBCBE7F4ECF1A50EBB3D1DC50CD3FF644C051720DF94FD7DA805455EF6
    Session-ID-ctx: 
    Resumption PSK: 1B89C9AF91124DEEA3FA312DAFEA0A314658913B7DD58E9B1BB8987CABCD69E40BC963885C7174D0F27F278BFCF42EEA
    PSK identity: None
    PSK identity hint: None
    SRP username: None
    TLS session ticket lifetime hint: 172800 (seconds)
    TLS session ticket:
    0000 - 10 11 b5 af fb 55 e8 9c-e3 37 bd 7c fd 6e 2e af   .....U...7.|.n..
    0010 - 5e 1a f0 2c 5c a7 7f a7-f5 f1 dc 06 ec c0 3e fd   ^..,\.........>.
    0020 - 96 7a bf 5b 9f 87 77 ad-f0 63 df 23 30 00 18 2c   .z.[..w..c.#0..,
    0030 - 8b ca 3e 6a c0 b0 5d 2a-04 91 27 ca 65 c6 ca 54   ..>j..]*..'.e..T
    0040 - c0 ee bf 8b 4d 8a 6e 87-36 e4 59 5c 98 5e 57 30   ....M.n.6.Y\.^W0
    0050 - 94 ad b9 45 bb 1d e0 d6-d6 7f 2b 67 17 13 96 ec   ...E......+g....
    0060 - fe 78 4c 25 be 3d 10 a5-99 7e c5 b7 dd 84 cf d2   .xL%.=...~......
    0070 - 4e 9e 97 24 34 87 5b 24-a8 f5 88 09 ce b5 6f b5   N..$4.[$......o.
    0080 - 2a fb ae 09 1b 67 81 7e-bd 2b 15 7f bd 4d 18 72   *....g.~.+...M.r
    0090 - 4d 34 5d c7 7b c0 23 41-4e 9e e6 04 ec 29 22 03   M4].{.#AN....)".
    00a0 - 16 89 3e 3d 24 47 97 73-c0 c9 d6 8f ee 21 f0 12   ..>=$G.s.....!..
    00b0 - a9 49 a1 41 90 0c b6 07-a5 15 f6 46 6e 0b b0 cb   .I.A.......Fn...

    Start Time: 1769192805
    Timeout   : 7200 (sec)
    Verify return code: 0 (ok)
    Extended master secret: no
    Max Early Data: 0
---
read R BLOCK
closed
```


-----------------------------
# Ejercicio 1

La idea base: lanzar kdig hacia 1.1.1.1:853, capturar tráfico y syscalls, y con eso responder:
- Qué tipo de socket usa (TCP, AF_INET/AF_INET6, tipo stream, puerto 853).
- Qué llamadas de red hace (socket, connect, send/recv, close, etc.).
- Qué librería TLS usa (OpenSSL, GnuTLS, mbedTLS, etc.).
- Cómo es el handshake TLS (versiones, cipher suite, extensión SNI, certificados, etc.).

Incluyendo que las sesiones modernas usan ECDHE/DHE, lo que impide descifrar pasivamente solo con la clave privada del servidor y obliga a colaborar con un extremo o a usar AitM.


1. Lanzar el cliente DoT con kdig: Ejemplo orientativo (ajústalo a las opciones de tu versión):
- Resolver un dominio sencillo (p. ej. example.com) con DoT contra Cloudflare.
- Forzar puerto 853 y TLS, en modo “verbose” para que dé información extra de TLS.
- Explicar:
  - Salida completa del comando.
  - Cada opción que usemos (no solo copiar el comando).


2. Captura de tráfico (Wireshark/tcpdump)
- Capturar en la interfaz de salida cuando se lance kdig.
- Filtrar por la IP de Cloudflare (1.1.1.1) y puerto 853 (o el que uses para DoT).
- Evidencias a guardar:
    - Pantallazo o export de la sesión TCP con el handshake TLS marcado.
    - Listado del flujo TCP (3‑way handshake) y luego los mensajes TLS: ClientHello, ServerHello, Certificate, etc.
    
- Justificar por qué se concluye que está usando TCP (3‑way handshake, flags SYN/SYN‑ACK/ACK, tipo de segmento, etc.).
- Explicar brevemente la secuencia del handshake TLS: qué envía el cliente, qué devuelve el servidor, qué extensión SNI ves, qué versión de TLS y cipher suite se negocian (conceptualmente, sin entrar en criptografía profunda). Puedes apoyarte en lo que explican los capítulos sobre TLS.


  ​

3. Captura de llamadas al sistema (strace, ltrace, bpftrace, etc.)
- Ejecutar kdig trazando syscalls de red: por ejemplo con strace -f -e trace=network kdig ....
- Puede ser interesante mostrar llamadas a open/read para ver qué librerías carga (pero céntrate en las de red). De esta ejecución deberías extraer:
    - Creación del socket: algo tipo socket(AF_INET, SOCK_STREAM, IPPROTO_TCP) o equivalente.
    - connect a 1.1.1.1:853.
    - Secuencia de sendto/recvfrom o send/recv durante el handshake TLS y el intercambio DNS.
    - Cierre de la conexión (close, shutdown).
- Análisis que tendrás que escribir:
    - Qué tipo de socket usa (familia, tipo, protocolo) y por qué encaja con “DoT sobre TCP”.
    - Qué llamada inicia la conexión, cuál empieza a mandar datos de aplicación (TLS), y cuál termina la sesión.






4. Identificar la librería TLS.
- ldd $(which kdig) para ver contra qué librerías enlaza. Si ves algo tipo libgnutls, libssl.so, etc., ya tienes la respuesta.
- También puedes mirar con strings o con tu herramienta de reversing favorita, pero ldd suele bastar.
- Evidencia de la ejecución de ldd.
- Explicación de cuál es la librería TLS y, muy brevemente, qué rol juega en la aplicación (responsable de handshake, cifrado, verificación de certificados, etc.).


5. Análisis de la sesión TLS en Wireshark: Aunque aún no corresponde descrifrar (eso corresponde a la parte 2), ya puede hacer un análisis estructural:
    - Versión de TLS negociada.
    - Cipher suite (por ejemplo, una con ECDHE y AES‑GCM, coherente con lo que se explica en el capítulo 7 sobre el uso de Diffie‑Hellman efímero/ECDH).
    - Extensiones relevantes: SNI, ALPN (si aplica), etc. Aquí es donde se conecta con la teoría del PDF: explicar que, al usar ECDHE/ECDH para el intercambio de claves, incluso con la clave privada del servidor no podrías derivar las claves de sesión a posteriori, lo que motiva las técnicas de la parte 2 (SSLKEYLOGFILE, proxies TLS, etc.).
  



-----------------------------
# Ejercicio 2

Las dos técnicas de descifrado de la parte 2 (una con volcado de claves de sesión al estilo SSLKEYLOGFILE y otra con AitM/mitmproxy, que es precisamente lo que se describe en el capítulo 7).


----------------------------------

# Parte 1: Análisis de la Aplicación

## 1.1. Identificación de la Librería y Sockets

Utilizamos herramientas de análisis estático y dinámico para responder a los requisitos:
- Librería SSL/TLS: Ejecutamos `ldd $(which kdig)` para ver las librerías compartidas. Buscamos entradas como libssl.so (OpenSSL) o libgnutls.so (GnuTLS).
- Tipo de Socket: Ejecutamos el comando bajo la supervisión de strace: `strace -e socket,connect kdig @1.1.1.1 +tls google.com`.
  - Evidencia: Debemnos identificar una llamada tipo socket(AF_INET, SOCK_STREAM, ...). Al usar TLS, el socket debe ser TCP (SOCK_STREAM), a diferencia del DNS tradicional que usa UDP (SOCK_DGRAM).


## 1.2. Análisis de la Sesión TLS (Wireshark)
Capturamos el tráfico con Wireshark mientras ejecutas el comando. En la memoria, describe los pasos del Handshake:
- Client Hello: Identifica el campo Server Name Indication (SNI) y los Cipher Suites ofrecidos.
- Server Hello: Observa qué suite de cifrado seleccionó el servidor (ej. TLS_AES_256_GCM_SHA384).
- Intercambio de claves: Identifica si se usa RSA o Diffie-Hellman Efímero (ECDHE).

