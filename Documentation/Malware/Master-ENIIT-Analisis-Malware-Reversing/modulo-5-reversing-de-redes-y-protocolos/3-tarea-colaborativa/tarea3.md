
https://chatgpt.com/g/g-p-680653de039c8191b7a3c14c407bedf5-malware/c/696bbc30-06c8-8332-ba0c-964c815ea784


- [Entendiendo lo que pide el ejercicio:](#entendiendo-lo-que-pide-el-ejercicio)
  - [1. Capturar y analizar tráfico cifrado de un cliente DNS-over-TLS - DoT:](#1-capturar-y-analizar-tráfico-cifrado-de-un-cliente-dns-over-tls---dot)
    - [Fase 1 ➡ Análisis de la Aplicación - Cliente DoT](#fase-1--análisis-de-la-aplicación---cliente-dot)
    - [Fase 2 ➡ Interceptación y Descifrado del Tráfico](#fase-2--interceptación-y-descifrado-del-tráfico)
  - [2. Incluir evidencias](#2-incluir-evidencias)
- [Entendiendo que es un cliente DNS-over-TLS - DoT](#entendiendo-que-es-un-cliente-dns-over-tls---dot)
- [Análisis de la aplicación - Cliente DoT](#análisis-de-la-aplicación---cliente-dot)
- [Fase 1](#fase-1)
  - [Instalación de kding](#instalación-de-kding)
  - [La consulta con el cliente kdig en @1.1.1.1](#la-consulta-con-el-cliente-kdig-en-1111)
  - [El Error WARNING: can't connect to 1.1.1.1@853(TLS).](#el-error-warning-cant-connect-to-1111853tls)
    - [1. Verificamos la conexión con el servidor Cloudflare.](#1-verificamos-la-conexión-con-el-servidor-cloudflare)
    - [2. Verificamos si el puerto 853 está bloqueado](#2-verificamos-si-el-puerto-853-está-bloqueado)
  - [Probamos el otro IP de Cloudflare para DoT](#probamos-el-otro-ip-de-cloudflare-para-dot)
  - [La consulta con el cliente kdig en @1.0.0.1](#la-consulta-con-el-cliente-kdig-en-1001)
  - [Captura de tráfico de red](#captura-de-tráfico-de-red)
  - [Captura de llamadas al sistema (strace, ltrace, bpftrace, etc.)](#captura-de-llamadas-al-sistema-strace-ltrace-bpftrace-etc)
  - [Identificar la librería TLS.](#identificar-la-librería-tls)
  - [Análisis de la sesión TLS en Wireshark:](#análisis-de-la-sesión-tls-en-wireshark)
  - [Cipher suite negociada](#cipher-suite-negociada)
  - [Intercambio de claves (PFS)](#intercambio-de-claves-pfs)
  - [Version TLS](#version-tls)
  - [SNI](#sni)
  - [AF\_INET](#af_inet)
  - [Analizamos el pcap con Wireshark:](#analizamos-el-pcap-con-wireshark)
- [Ejercicio 1](#ejercicio-1)
  - [openssl](#openssl)
- [Fase 2](#fase-2)
- [Parte 1: Análisis de la Aplicación](#parte-1-análisis-de-la-aplicación)
  - [1.1. Identificación de la Librería y Sockets](#11-identificación-de-la-librería-y-sockets)
  - [1.2. Análisis de la Sesión TLS (Wireshark)](#12-análisis-de-la-sesión-tls-wireshark)



# Entendiendo lo que pide el ejercicio:
## 1. Capturar y analizar tráfico cifrado de un cliente DNS-over-TLS - DoT:
### Fase 1 ➡ Análisis de la Aplicación - Cliente DoT

Primero analizamos su comportamiento, aunque el tráfico vaya cifrado ➡ El objetivo es observar cómo la herramienta `kdig` realiza una consulta DNS segura a un servidor, como el de Cloudflare, 1.1.1.1.

- Realizamos una captura del tráfico.
- Capturamos las llamas al sistema empleadas, tal y como se describe en los Capítulos 4 y 6.
- Identificamos el tipo de socket empleado.
- Identificamos las llamadas de red más importantes utilizadas.
- Identificamos la librería SSL/TLS empleada para cifrar las comunicaciones.
- Hacemos un análisis completo de la sesión TLS establecida entre el cliente y el servidor DNS-over-TLS.


### Fase 2 ➡ Interceptación y Descifrado del Tráfico
Después interceptamos y desciframos ese tráfico usando dos técnicas diferentes del capitulo 7.


## 2. Incluir evidencias
- De todos los comandos.
- De todas las pruebas:
  - Salidas de terminal.
  - Capturas, y ficheros generados como PCAP.
  - Explicar qué hace cada paso. 



# Entendiendo que es un cliente DNS-over-TLS - DoT
Un cliente DNS-over-TLS (DoT) es, en esencia, un cliente DNS que ha decidido ponerse una capa de seguridad antes de salir a la red. En lugar de gritar nuestras peticiones por megáfono, como hace el DNS tradicional, las mete en un túnel privado y cifrado.

Tradicionalmente, el DNS envía mensajes sobre datagramas UDP, lo cual es rápido pero totalmente legible para cualquiera que esté mirando el tráfico. Un cliente DoT, en cambio, establece una sesión TLS completa con el servidor DNS antes de preguntar nada. Esto implica que la comunicación no es "lanzar y olvidar", sino que requiere un protocolo de enlace (Handshake) previo para asegurar la conexión.


**El objetivo principal de estos clientes es evitar que intermediarios, como nuestro proveedor de internet o un atacante en la red, puedan ver qué páginas estamos intentando visitar.**

Estos clientes utilizan mecanismos avanzados como `Diffie-Hellman Efímero (DHE)` o `Curvas Elípticas (ECDH)` para el intercambio de claves, lo que garantiza que nadie pueda descifrar el tráfico incluso si robaran la clave privada del servidor en el futuro.



# Análisis de la aplicación - Cliente DoT
El cliente DoT que recomienda usar el enunciado el ejerccio es `kdig` que es parte del paquete `knot-dnsutils`. Mientras que una herramienta normal como `nslookup` o `dig` usaría el `puerto 53 (UDP)`, `kdig` con el parámetro `+tls` busca establecer una conexión segura, normalmente en el `puerto 853`.

El tráfico generado por este cliente aparecerá en Wireshark simplemente como `Application Data`, ocultando la consulta DNS real bajo capas criptográficas. Realizando la última parte del ejercicio, conseguiremos descifrar estas capas.


**En la Fase 1, donde realizaremos un análisis sin descifrar:**
- Wireshark capturará los paquetes, pero al estar cifrados con TLS, el contenido útil se mostrará etiquetado simplemente como `Application Data`.
- En esta etapa sólo podremos ver el "envoltorio":
  - Las direcciones IP.
  - Los puertos, normalmente el 853 para DoT.
  - El Handshake de TLS, donde se intercambian certificados y se negocian algoritmos.
- La consulta DNS real y su respuesta serán totalmente ilegibles.

**En la Fase 2, tras el descifrado:** Al aplicar las técnicas que menciona el documento, como el uso de SSLKEYLOGFILE o un proxy como mitmproxy, ocurrirá lo siguiente:
- Wireshark utilizará las claves de sesión obtenidas para "pelar" las capas criptográficas en tiempo real.
- Debajo de la capa de `Transport Layer Security`, aparecerá una nueva sección en el análisis del paquete llamada `Domain Name System`.
- Ahí podremos ver finalmente el `texto claro`: el nombre de dominio consultado, el tipo de registro (A, AAAA, MX) y la dirección IP devuelta por el servidor.



# Fase 1
Ejecutamos una consulta DNS cifrada (DoT) con kdig contra el servidor DoT de Cloudflare (1.1.1.1 puerto 853), validando correctamente el certificado TLS usando el nombre one.one.one.one, y luego analizaremos este tráfico.


## Instalación de kding
En Debian, kdig viene en el paquete knot-dnsutils.
```
sudo apt update
sudo apt install -y knot-dnsutils ca-certificates
```
donde:
- El ca-certificates es para que la validación de certificados TLS funcione con el almacén del sistema, que es lo que usa +tls-ca.


Comprobamos que está instalado: 
```
kdig -V
kdig, Knot DNS 3.4.6
```

## La consulta con el cliente kdig en @1.1.1.1
```
kdig -d @1.1.1.1 +tls-ca +tls-host=one.one.one.one example.com
```
donde:
- `-d`: activa mensajes de depuración.
- `kdig`: el programa cliente DNS.
- `@1.1.1.1`: servidor DNS a la que lanza la consulta, en este caso Cloudflare.
- `+tls-ca`: Opción que indica que usa TLS y valida el certificado con autoridades de certificación (CA).
- `+tls-host=one.one.one.one`: Opción que indica que cuando valide el certificado, debe comprobar que corresponde al hostname one.one.one.one. Esto evita que un atacante haga MITM con otro certificado. En TLS, el hostname es importante porque el certificado del servidor se valida contra ese nombre, no contra la IP.
- `example.com`: el dominio que está consultando.


**<mark>Lo que estamos haciendo es: Ejecutar una consulta DNS cifrada (DoT) con kdig contra el servidor DoT de Cloudflare (1.1.1.1 puerto 853), validando correctamente el certificado TLS usando el nombre one.one.one.one, para luego, analizar ese tráfico.</mark>**


![Consulta kdig](capturas/tarea3-modulo5-1.png)
donde:
- Puerto y Protocolo: La línea de `DEBUG` indica que se está intentando conectar al `puerto 853` usando el `protocolo TCP`. Esto es fundamental, ya que el `DNS` estándar usa `UDP/53`, pero DoT requiere una conexión orientada a flujo (`TCP`) para establecer el `túnel TLS`.
- Interacción con Librerías: El mensaje `imported 146 system certificates` indica que `kdig` está utilizando las librerías criptográficas del sistema para validar la identidad del servidor de Cloudflare. Esto da una pista sobre la `librería SSL/TLS` que mencionan los apuntes de clase, probablemente `GnuTLS` u `OpenSSL`, dependiendo de la distribución Linux usada.


## El Error WARNING: can't connect to 1.1.1.1@853(TLS).
Ese error significa que no logramos establecer una conexión TCP/TLS hacia 1.1.1.1 en el puerto 853. Verificaremos si el puerto 853 es alcanzable desde nuestra red ya que, muchas redes/ISP lo bloquean.

### 1. Verificamos la conexión con el servidor Cloudflare.
```
ping -c 2 1.1.1.1
```
![Consulta ping](capturas/tarea3-modulo5-ping.png)  
donde:
- Confirmamos que hay conexión con el servidor Cloudflare.

### 2. Verificamos si el puerto 853 está bloqueado
![Consulta nc en 1.1.1.1](capturas/tarea3-modulo5-3.png)  
donde:
- El servidor, o un firewall intermedio, ha enviado un paquete `TCP RST` (`Reset`), cerrando activamente el intento de conexión.
- No sabemos la causa pero esto nos obliga a usar otro servidor de Cloudflare para DOT.



## Probamos el otro IP de Cloudflare para DoT
Vemos en la documentación que Cloudflare ofrece DoT en TCP/853 sobre 1.1.1.1 y 1.0.0.1 (y sus IPv6) [DNS over TLS](https://developers.cloudflare.com/1.1.1.1/encryption/dns-over-tls/). Probamos si tenemos conexión con este servidor DOT en 1.0.0.1:
```
nc -vz 1.0.0.1 853
```

![Consulta nc en 1.0.0.1](capturas/tarea3-modulo5-4.png)
donde:
- Observamos que se establece la conexión en ese servidor y con ese puerto.
- **<mark>Realizaremos el ejercicio usando este servidor.</mark>**



## La consulta con el cliente kdig en @1.0.0.1
Ejecutamos kdig con DoT contra 1.0.0.1 (Cloudflare):
```
$ kdig -d @1.0.0.1 +tls-ca +tls-host=one.one.one.one example.com
;; DEBUG: Querying for owner(example.com.), class(1), type(1), server(1.0.0.1), port(853), protocol(TCP)
;; DEBUG: TLS, imported 151 system certificates
;; DEBUG: TLS, received certificate hierarchy:
;; DEBUG:  #1, C=US,ST=California,L=San Francisco,O=Cloudflare\, Inc.,CN=cloudflare-dns.com
;; DEBUG:      SHA-256 PIN: ltQ6aXy3tqpNZKJdnevMD7oR+IsI5rNWbOssFDrl+Ew=
;; DEBUG:  #2, C=US,ST=Texas,L=Houston,O=SSL Corp,CN=SSL.com SSL Intermediate CA ECC R2
;; DEBUG:      SHA-256 PIN: zGgA4OU4DjJdvpRYUqbi5Vh2g9W5Oc/PgKihy9mkLsE=
;; DEBUG:  #3, C=US,ST=Texas,L=Houston,O=SSL Corporation,CN=SSL.com Root Certification Authority ECC
;; DEBUG:      SHA-256 PIN: oyD01TTXvpfBro3QSZc1vIlcMjrdLTiL/M9mLCPX+Zo=
;; DEBUG: TLS, skipping certificate PIN check
;; DEBUG: TLS, The certificate is trusted. 
;; TLS session (TLS1.3)-(ECDHE-X25519)-(ECDSA-SECP256R1-SHA256)-(AES-256-GCM)
;; ->>HEADER<<- opcode: QUERY; status: NOERROR; id: 33829
;; Flags: qr rd ra; QUERY: 1; ANSWER: 2; AUTHORITY: 0; ADDITIONAL: 1

;; EDNS PSEUDOSECTION:
;; Version: 0; flags: ; UDP size: 1232 B; ext-rcode: NOERROR
;; PADDING: 392 B

;; QUESTION SECTION:
;; example.com.        		IN	A

;; ANSWER SECTION:
example.com.        	101	IN	A	104.18.27.120
example.com.        	101	IN	A	104.18.26.120

;; Received 468 B
;; Time 2026-01-17 18:15:45 CET
;; From 1.0.0.1@853(TLS) in 56.7 ms
```
![Consulta kdig en 1.0.0.1](capturas/tarea3-modulo5-5.png)  
donde:
- **1) Evidencia de que realmente estamos usando el cliente DoT contra Cloudflare, usando TCP + 853:**
    - `;; DEBUG: Querying for owner(example.com.), class(1), type(1), server(1.0.0.1), port(853), protocol(TCP)`
    - `owner(example.com.)`: el nombre consultado `example.com`.
    - `type(1)`: el tipo A (IPv4). En DNS, el tipo A es el código 1.
    - `class(1)`: clase IN (Internet). En DNS, IN es el código 1.
    - `server(1.0.0.1), port(853), protocol(TCP)`: confirma que la consulta va a `1.0.0.1` por `TCP/853`, que es el puerto estándar de DoT.

- **2) Evidencia de validación `TLS` con `CAs` del sistema**
    - `;; DEBUG: TLS, imported 151 system certificates`
    - `+tls-ca` hace que kdig cargue el almacén de `CA` del sistema, o el path que corresponda, para validar el certificado del servidor.
    - `“151 system certificates”` es evidencia de que está usando el `trust store` del sistema para la validación.

- **3) Cadena de certificados `certificate chain` presentada por el servidor:**
    - `;; DEBUG: TLS, received certificate hierarchy:`
    - Certificado #1 (leaf / servidor): `#1 ... O=Cloudflare, Inc., CN=cloudflare-dns.com`
        - Este es el certificado del servidor (leaf-hoja).
        - xxxx Ojo: el comando indica `+tls-host=one.one.one.one`, pero el `CN` que imprime `kdig` es `cloudflare-dns.com`. Eso no es necesariamente un problema: hoy en día lo que manda para hostname validation suele ser el SAN `(Subject Alternative Name)`, no el `CN`. Es muy posible que el `SAN` incluya `one.one.one.one` y/o nombres del servicio DoT de Cloudflare.
        - xxxxx Para una evidencia “cerrada” en memoria, conviene añadir una captura complementaria con openssl s_client mostrando SANs (te dejo el comando al final).

        - `SHA-256 PIN: ....` kdig muestra el pin (hash) de la clave pública/cert para pinning. Es información útil para “fingerprinting” del certificado, pero no imprescindible salvo que el guion del curso pida pinning. xxxxx

    - Certificado `#2 (intermediate): #2 ... CN=SSL.com SSL Intermediate CA ECC R2`: Es el certificado intermedio (CA intermedia) que firma el leaf.
    
    - Certificado `#3 (root): #3 ... CN=SSL.com Root Certification Authority ECC`: Es el certificado raíz (root CA) del que deriva la confianza (normalmente ya está en el sistema o se valida por cadena hasta un root confiable).

- **4) Pinning y confianza del certificado:**
    - `;; DEBUG: TLS, skipping certificate PIN check`: Indica que no se está aplicando pinning, ya que no se ha configurado un pin.
    - `;; DEBUG: TLS, The certificate is trusted.`: Esta es la evidencia principal de que la verificación TLS con CA ha sido correcta: el certificado presentado por el servidor es confiable según el almacén del sistema (y la validación que hace kdig con los parámetros que le diste).


- **5) Parámetros criptográficos de la sesión TLS:** Esto es muy importante para el análisis del handshake:
    - `;; TLS session (TLS1.3)-(ECDHE-X25519)-(ECDSA-SECP256R1-SHA256)-(AES-256-GCM)`. Esta línea resume lo esencial del canal cifrado:
        - `TLS1.3`: La sesión negoció TLS 1.3 (moderno; handshake y cifrados distintos a TLS 1.2).
        - `ECDHE-X25519`: intercambio de claves efímero con `curva X25519`, Perfect Forward Secrecy.
        - `ECDSA-SECP256R1-SHA256`: Autenticación/firmas con `ECDSA` (`curva P-256` / `secp256r1`) y `hash SHA-256`.
        - `AES-256-GCM`: cifrado simétrico de la sesión con `AES-GCM` (`AEAD`), clave 256 bits.


- **6) Interpretación de la respuesta DNS (ya dentro del túnel TLS):**
    - Cabecera DNS:
      - `->>HEADER<<- opcode: QUERY; status: NOERROR; id: 33829`
        - opcode: QUERY: consulta estándar.
        - status: NOERROR: resolución correcta.
        - id: 33829: identificador de transacción DNS (sirve para emparejar request/response).
      - `;; Flags: qr rd ra; QUERY: 1; ANSWER: 2; AUTHORITY: 0; ADDITIONAL: 1`
        - qr: es respuesta (Query Response).
        - rd: Recursion Desired (el cliente pidió recursión).
        - ra: Recursion Available (el resolver la ofrece).
        - QUERY: 1: una pregunta.
        - ANSWER: 2: dos registros en la respuesta.
        - ADDITIONAL: 1: información adicional (aquí se ve que es EDNS).
    - EDNS y padding:
      - `;; EDNS PSEUDOSECTION: ... UDP size: 1232 B ... PADDING: 392 B`
        - Aunque estamos usando TCP/TLS, se sigue usando EDNS(0) como mecanismo de extensión.
        - UDP size 1232 B: tamaño anunciado típico “seguro” (1232) para evitar fragmentación en muchos entornos; es un valor común en resolvers modernos.
        - PADDING 392 B: esto es relevante para privacidad: el padding ayuda a homogeneizar tamaños y reducir filtraciones por longitud (traffic analysis). En DoT/DoH se utiliza precisamente para mitigar correlación por tamaño de paquete.

    - Pregunta y respuesta:
      - `;; QUESTION SECTION: example.com. IN A`:
        - Pregunta: A de example.com.
      - `;; ANSWER SECTION: ... 104.18.27.120`
        ... 104.18.26.120
        - Dos A records (dos IPv4) con TTL 101 segundos (lo que queda de caché en el resolver en ese momento).


- **7) Métricas de transferencia y latencia:**
    - `;; Received 468 B`: Tamaño total del mensaje DNS (a nivel aplicación DNS) recibido.
    - `;; Time 2026-01-17 18:15:45 CET`: Marca de tiempo del sistema donde ejecutaste el comando (útil como evidencia de cuándo se hizo la prueba).
    - `;; From 1.0.0.1@853(TLS) in 56.7 ms`: Confirma de nuevo: servidor 1.0.0.1, puerto 853, sobre TLS.
    - `56.7 ms`: latencia de la consulta (incluye establecimiento/uso de sesión).
  

**Capturas/“evidencias” para incluir en el informe:**
- La primera línea DEBUG (TCP/853) y la última (From 1.0.0.1@853(TLS)).
- La línea de “The certificate is trusted”.
- La línea del “TLS session (TLS1.3)…”.
- La sección EDNS con PADDING (porque es un indicador claro de medidas anti-análisis de tráfico).
- QUESTION y ANSWER.



------------------------------

xxxxxx

**Tema del hostname vs CN**
Como kdig muestra CN=cloudflare-dns.com pero como nosotros validamos contra one.one.one.one, conviene añadir una evidencia con SANs:
```
openssl s_client -connect 1.0.0.1:853 -servername one.one.one.one -CApath /etc/ssl/certs </dev/null 2>/dev/null | openssl x509 -noout -subject -issuer -ext subjectAltName
```
donde:
- Podemos demostrar explícitamente que one.one.one.one (u otros nombres equivalentes del servicio) aparecen en subjectAltName, que es lo que normalmente se valida.



-----------------------------

## Captura de tráfico de red
**Analizamos la configuración de red de la máquina virtual:**
![Consulta configuracion red](capturas/tarea3-modulo5-configuracion-red.png)  
donde:
- La interfaz de red es la enp0s3.

----

**Capturamos el tráfico en la interfaz de salida cuando se lanza kdig:**
```
sudo tcpdump -ni enp0s3 host 1.0.0.1 and tcp port 853 -w trafico_cloudflare_1.0.0.1.pcap
```
![Captura trafico tcpdump](capturas/tarea3-modulo5-tcpdump.png)  
donde:
- Filtraremos por la IP de Cloudflare (1.0.0.1).
- Filtraremos por el puerto 853.

----


**En otra terminal, lanzamos varias consultas:**
```
kdig -d @1.0.0.1 +tls-ca +tls-host=one.one.one.one example.com
kdig -d @1.0.0.1 +tls-ca +tls-host=one.one.one.one example2.com
kdig -d @1.0.0.1 +tls-ca +tls-host=one.one.one.one cloudflare.com
```

----



**Archivo pcap obtenido:**
![Captura trafico pcap](capturas/tarea3-modulo5-pcap.png) 
con este fichero pcap:
- demostraremos que el tráfico es TCP/853,
- analizaremos el handshake TLS,
- y, más adelante, descifraremos este tráfico con dos técnicas del capítulo 7.


-----
  ​

## Captura de llamadas al sistema (strace, ltrace, bpftrace, etc.)
- Ejecutar kdig trazando syscalls de red: por ejemplo con strace -f -e trace=network kdig ....
- Puede ser interesante mostrar llamadas a open/read para ver qué librerías carga (pero céntrate en las de red). De esta ejecución deberías extraer:
    - Creación del socket: algo tipo socket(AF_INET, SOCK_STREAM, IPPROTO_TCP) o equivalente.
    - connect a 1.1.1.1:853.
    - Secuencia de sendto/recvfrom o send/recv durante el handshake TLS y el intercambio DNS.
    - Cierre de la conexión (close, shutdown).
- Análisis que tendrás que escribir:
    - Qué tipo de socket usa (familia, tipo, protocolo) y por qué encaja con “DoT sobre TCP”.
    - Qué llamada inicia la conexión, cuál empieza a mandar datos de aplicación (TLS), y cuál termina la sesión.



-----


## Identificar la librería TLS.
- ldd $(which kdig) para ver contra qué librerías enlaza. Si ves algo tipo libgnutls, libssl.so, etc., ya tienes la respuesta.
- También puedes mirar con strings o con tu herramienta de reversing favorita, pero ldd suele bastar.
- Evidencia de la ejecución de ldd.
- Explicación de cuál es la librería TLS y, muy brevemente, qué rol juega en la aplicación (responsable de handshake, cifrado, verificación de certificados, etc.).

-----


## Análisis de la sesión TLS en Wireshark:
Aunque aún no corresponde descrifrar, ya que eso corresponde a la parte 2, podemos analizar:
- Versión de TLS negociada.
- Cipher suite (por ejemplo, una con ECDHE y AES‑GCM, coherente con lo que se explica en el capítulo 7 sobre el uso de Diffie‑Hellman efímero/ECDH).
- Extensiones relevantes: SNI, ALPN (si aplica), etc. Aquí es donde se conecta con la teoría del PDF: explicar que, al usar ECDHE/ECDH para el intercambio de claves, incluso con la clave privada del servidor no podrías derivar las claves de sesión a posteriori, lo que motiva las técnicas de la parte 2 (SSLKEYLOGFILE, proxies TLS, etc.).



**Identificamos una sesión - stream - TLS concreta:** Como hemos lanzado 3 veces el comando kdig, habrá varias conexiones TCP, con varios handshakes. Para elegir un handshake concreto:
- Vamos a: Statistics → Conversations → TCP
- Buscamos conversaciones donde uno de los puertos sea 853 y el peer sea 1.0.0.1
  ![wireshark conversation tcp](capturas/tarea3-modulo5-conversations-tcp.png) 


**Seleccionamos una conversación, por ejemplo la primera que tiene un Stream ID = 0:**
Filtramos por ese stream 0: Se ha seleccionado el Stream TCP 0 para el análisis, el cual contiene el intercambio completo de la primera consulta DNS-over-TLS. En este flujo se observa el Handshake inicial donde el cliente propone las suites de cifrado y el servidor Cloudflare responde con la configuración final.
```
tcp.stream == 0
```
![wireshark conversation tcp stream 0](capturas/tarea3-modulo5-conversations-tcp-stream-0.png)  
donde:
- TCP Handshake. Se comprueba que DoT va por TCP y que se usa el puerto 853:
  - Paquete 1: `10.0.2.15:49761 → 1.0.0.1:853 [SYN]`.
  - Paquete 2: `1.0.0.1:853 → 10.0.2.15:49761 [SYN, ACK]`.
  - Paquete 3: `[ACK]`.
  
- Handshake TLS 1.3 - Inicio del canal cifrado:
  - Paquete 4: `TLSv1.3 Client Hello` y en el campo “Info” ya aparece: `SNI=one.one.one.one`. Esto es una evidencia directa de la extensión SNI (Server Name Indication).
  - Paquete 6: `TLSv1.3 Server Hello, Change Cipher Spec`.
    - Wireshark etiqueta la sesión como `TLSv1.3`, así que la versión negociada de TLS es TLS 1.3.
    - Campo tipo `Supported Version: TLS 1.3`. Suele aparecer como mensaje de compatibilidad.

- Tráfico cifrado de aplicación - DNS dentro de TLS. Es tráfico cifrado, donde va la consulta DNS y la respuesta:
  - Paquete 8.
  - Paquete 12.
  - Paquete 13.
  - Paquete 16.
  - Paquete 17.


- Cierre de la conexión:
  - Paquete 18: el cliente envía FIN, ACK.
  - El servidor responde ACK y luego su FIN, ACK


**<mark>Resumiento: Lo que sabemos hasta este punto:</mark>**
- DoT sobre TCP/853: 3-way handshake + puerto destino 853.
- TLS negociado: TLS 1.3. Wireshark etiqueta ClientHello/ServerHello como TLSv1.3.
- SNI presente: one.one.one.one.


-----

## Cipher suite negociada
En la lista de paquetes de la captura anterior, NO se ve el nombre de la cipher suite, tendremos que abrir el detalle del paquete `ServerHello`. Para ello hacemos click en el paquete 6 y en el panel inferior de Package Details buscaremos:
![tarea3-modulo5-conversations-tcp-stream-0-cipher-suite](capturas/tarea3-modulo5-conversations-tcp-stream-0-cipher-suite.png)  
donde:
- Cipher Suite: `TLS_AES_256_GCM_SHA384 (0x1302)`
- `AES_256_GCM`:
  - Cifrado simétrico `AES` con clave de 256 bits en modo GCM (AEAD).
  - GCM aporta confidencialidad + integridad/autenticación, no se necesita una MAC aparte.
- `SHA384`: Hash usado en TLS 1.3 para derivación de claves (HKDF) y para el transcript del handshake.


En TLS 1.3, la cipher suite define principalmente:
- El cifrado simétrico, para los datos de aplicación, y
- La función hash asociada al HKDF y al transcript del handshake.

A diferencia de TLS 1.2, en TLS 1.3 la cipher suite ya no incluye en su nombre el intercambio de claves (ECDHE) ni el algoritmo de firma (RSA/ECDSA). Esto se negocia en otros campos, como key_share, supported_groups, y el signature_algorithms.


En el ServerHello se observa la suite negociada TLS_AES_256_GCM_SHA384 (0x1302). En TLS 1.3 esta suite indica que el tráfico de aplicación se cifra con AES-256 en modo GCM (AEAD) y que se emplea SHA-384 en la derivación de claves y el transcript del handshake. El intercambio de claves efímero no forma parte del nombre de la suite en TLS 1.3; se evidencia aparte mediante la extensión key_share (que analizamos en el siguiente apartado).


## Intercambio de claves (PFS)
Dentro del mismo paquete 6, en el panel inferior de Package Details:  
![tarea3-modulo5-conversations-tcp-stream-0-key-share](capturas/tarea3-modulo5-conversations-tcp-stream-0-key-share.png)
donde:
- `Extension: key_share … x25519`.
- `Key Share Entry: Group: x25519`
- `Key Exchange length: 32`
- `Key Exchange: <32 bytes…>` la clave pública efímera del cliente.
- `x25519` es un grupo de intercambio de claves basado en `Curve25519 (ECDH moderno)`. El `Key Exchange` es la clave pública efímera que el cliente aporta para derivar el secreto compartido con el servidor. Al ser efímero, cambia por sesión y no depende de la clave privada del servidor.

En el ClientHello se observa la extensión key_share con Group: x25519 (Key Exchange length 32), lo que evidencia que el intercambio de claves de TLS 1.3 usa ECDHE/ECDH efímero. Esto proporciona PFS, por lo que la posesión posterior de la clave privada del servidor no permitiría derivar las claves de sesión y descifrar la captura. Es por ello que necesitamos técnicas como SSLKEYLOGFILE o proxies TLS para obtener el tráfico en claro.


## Version TLS
Dentro del mismo paquete 6, en el panel inferior de Package Details → Versión negociada: TLS 1.3, por supported_versions:  
![tarea3-modulo5-conversations-tcp-stream-0-tls.png](capturas/tarea3-modulo5-conversations-tcp-stream-0-tls.png)

Nota: Aunque vemos `Version: TLS 1.2 (0x0303)`, la sesión es TLS 1.3. En TLS 1.3, muchos campos muestran un `legacy_version 0x0303`, que parece TLS 1.2 por compatibilidad. Sin embargo, la versión real negociada se evidencia en la extensión: `Extension: supported_versions TLS 1.3`.


## SNI
En el paquete 4 `ClientHello` de la conexión DoT (10.0.2.15 → 1.0.0.1:853), en la columna `Info` ya vimos: `Client Hello (SNI=one.one.one.one)`. Vamos a buscar ela extensión SNI en el árbol de Wireshark. Seleccionamos este paquete y en el panel Packet Details →  Transport Layer Security → Handshake Protocol: Client Hello → Extensions → server_name
![tarea3-modulo5-conversations-tcp-stream-0-sni.png](capturas/tarea3-modulo5-conversations-tcp-stream-0-sni.png)  
donde:
- `Extension: server_name (...) name=one.one.one.one`.
- `Server Name Indication extension`
- `Server Name: one.one.one.one`
- SNI (Server Name Indication) es una extensión de TLS donde el cliente envía el hostname del servicio al que quiere conectarse.
- Esto permite al servidor escoger el certificado correcto (y configuración TLS) cuando hay varios servicios/hostnames detrás de la misma IP.
- En este caso, concuerda con el comando que lanzamos `kdig ... +tls-host=one.one.one.one`: estamos indicando que el hostname esperado y por tanto el que se valida, es `one.one.one.one`.
- El ClientHello y el SNI, se envían antes de que exista cifrado de aplicación, así que SNI queda visible en el PCAP aunque luego el DNS vaya cifrado dentro de `Application Data`. Aaunque DoT cifra el DNS, ciertos metadatos del handshake (como SNI) pueden observarse.



## AF_INET
AF_INET (IPv4) vs AF_INET6 (IPv6):  
![tarea3-modulo5-conversations-tcp-stream-0-af-inet.png](capturas/tarea3-modulo5-conversations-tcp-stream-0-af-inet.png)
donde:
- `Internet Protocol Version 4`.
- `Version: 4`.
- `Src: 10.0.2.15`.
- `Dst: 1.0.0.1`.


En el PCAP, los paquetes del flujo DoT muestran Internet Protocol Version 4. Con origen 10.0.2.15 y destino 1.0.0.1. Por tanto, la familia de direcciones utilizada es IPv4, equivalente a un socket AF_INET (no AF_INET6).

-----

## Analizamos el pcap con Wireshark:
Evidencias a guardar:
    - Pantallazo o export de la sesión TCP con el handshake TLS marcado.
    - Listado del flujo TCP (3‑way handshake) y luego los mensajes TLS: ClientHello, ServerHello, Certificate, etc.
    
Justificar por qué se concluye que está usando TCP (3‑way handshake, flags SYN/SYN‑ACK/ACK, tipo de segmento, etc.).

Explicar brevemente la secuencia del handshake TLS: qué envía el cliente, qué devuelve el servidor, qué extensión SNI ves, qué versión de TLS y cipher suite se negocian (conceptualmente, sin entrar en criptografía profunda). Puedes apoyarte en lo que explican los capítulos sobre TLS.



------------------------------------------

# Ejercicio 1

La idea base: lanzar kdig hacia 1.1.1.1:853, capturar tráfico y syscalls, y con eso responder:
- Qué tipo de socket usa (TCP, AF_INET/AF_INET6, tipo stream, puerto 853).
- Qué llamadas de red hace (socket, connect, send/recv, close, etc.).
- Qué librería TLS usa (OpenSSL, GnuTLS, mbedTLS, etc.).
- Cómo es el handshake TLS (versiones, cipher suite, extensión SNI, certificados, etc.).

Incluyendo que las sesiones modernas usan ECDHE/DHE, lo que impide descifrar pasivamente solo con la clave privada del servidor y obliga a colaborar con un extremo o a usar AitM.



------------------------------------------------------

## openssl
```
xxniwexx@debian:~$ openssl s_client -tls1_3 -connect 1.0.0.1:853 -servername cloudflare-dns.com
Connecting to 1.0.0.1
CONNECTED(00000003)
depth=2 C=US, ST=Texas, L=Houston, O=SSL Corporation, CN=SSL.com Root Certification Authority ECC
verify return:1
depth=1 C=US, ST=Texas, L=Houston, O=SSL Corp, CN=SSL.com SSL Intermediate CA ECC R2
verify return:1
depth=0 C=US, ST=California, L=San Francisco, O=Cloudflare, Inc., CN=cloudflare-dns.com
verify return:1
---
Certificate chain
 0 s:C=US, ST=California, L=San Francisco, O=Cloudflare, Inc., CN=cloudflare-dns.com
   i:C=US, ST=Texas, L=Houston, O=SSL Corp, CN=SSL.com SSL Intermediate CA ECC R2
   a:PKEY: EC, (prime256v1); sigalg: ecdsa-with-SHA384
   v:NotBefore: Dec 31 19:20:01 2025 GMT; NotAfter: Dec 21 19:20:01 2026 GMT
 1 s:C=US, ST=Texas, L=Houston, O=SSL Corp, CN=SSL.com SSL Intermediate CA ECC R2
   i:C=US, ST=Texas, L=Houston, O=SSL Corporation, CN=SSL.com Root Certification Authority ECC
   a:PKEY: EC, (secp384r1); sigalg: ecdsa-with-SHA384
   v:NotBefore: Mar  7 19:42:42 2019 GMT; NotAfter: Mar  3 19:42:42 2034 GMT
 2 s:C=US, ST=Texas, L=Houston, O=SSL Corporation, CN=SSL.com Root Certification Authority ECC
   i:C=US, ST=Texas, L=Houston, O=SSL Corporation, CN=SSL.com Root Certification Authority ECC
   a:PKEY: EC, (secp384r1); sigalg: ecdsa-with-SHA256
   v:NotBefore: Feb 12 18:14:03 2016 GMT; NotAfter: Feb 12 18:14:03 2041 GMT
---
Server certificate
-----BEGIN CERTIFICATE-----
MIIFgTCCBQigAwIBAgIQTtAzBMRrh6jC61Vp2566DDAKBggqhkjOPQQDAzBvMQsw
CQYDVQQGEwJVUzEOMAwGA1UECAwFVGV4YXMxEDAOBgNVBAcMB0hvdXN0b24xETAP
BgNVBAoMCFNTTCBDb3JwMSswKQYDVQQDDCJTU0wuY29tIFNTTCBJbnRlcm1lZGlh
dGUgQ0EgRUNDIFIyMB4XDTI1MTIzMTE5MjAwMVoXDTI2MTIyMTE5MjAwMVowcjEL
MAkGA1UEBhMCVVMxEzARBgNVBAgMCkNhbGlmb3JuaWExFjAUBgNVBAcMDVNhbiBG
cmFuY2lzY28xGTAXBgNVBAoMEENsb3VkZmxhcmUsIEluYy4xGzAZBgNVBAMMEmNs
b3VkZmxhcmUtZG5zLmNvbTBZMBMGByqGSM49AgEGCCqGSM49AwEHA0IABGODUCUS
6nJ4GesyR6/BBVKcKitgioROdW2BSEfBx77PhXlsEilbULPM7FChlJ7cRAgHDIAa
k9O9eBF7tqPI6qyjggOBMIIDfTAMBgNVHRMBAf8EAjAAMB8GA1UdIwQYMBaAFA10
Zgpen+Is7NXCXSUEf3Uyuv99MHEGCCsGAQUFBwEBBGUwYzA/BggrBgEFBQcwAoYz
aHR0cDovL2NlcnQuc3NsLmNvbS9TU0xjb20tU3ViQ0EtU1NMLUVDQy0zODQtUjIu
Y2VyMCAGCCsGAQUFBzABhhRodHRwOi8vb2NzcHMuc3NsLmNvbTCBpgYDVR0RBIGe
MIGbghJjbG91ZGZsYXJlLWRucy5jb22CFCouY2xvdWRmbGFyZS1kbnMuY29thwQB
AAABhwQBAQEBhwSinyQBhwSiny4BhxAmBkcARwAAAAAAAAAAABABhxAmBkcARwAA
AAAAAAAAABERhxAmBkcARwAAAAAAAAAAAABkhxAmBkcARwAAAAAAAAAAAGQAgg9v
bmUub25lLm9uZS5vbmUwIwYDVR0gBBwwGjAIBgZngQwBAgIwDgYMKwYBBAGCqTAB
AwECMBMGA1UdJQQMMAoGCCsGAQUFBwMBMEQGA1UdHwQ9MDswOaA3oDWGM2h0dHA6
Ly9jcmxzLnNzbC5jb20vU1NMY29tLVN1YkNBLVNTTC1FQ0MtMzg0LVIyLmNybDAd
BgNVHQ4EFgQULCjsVCC2hgAmVappu7bDZS4W+h8wDgYDVR0PAQH/BAQDAgeAMIIB
fwYKKwYBBAHWeQIEAgSCAW8EggFrAWkAdgDCMX5XRRmjRe5/ON6ykEHrx8IhWiK/
f9W1rXaa2Q5SzQAAAZt144FrAAAEAwBHMEUCIHuQBtNhAb4vKGOEHCF7VVPrLHCJ
zk63LICoCBt00zT1AiEAyWgmqpFEDhYYf7tCfbPHKIFQ0m7FAnfkvAbtdxitYr0A
dwDIo8R/x7OtuTVrAT9qehJt4zpOQ6XGRvmXrTl1mR3PmgAAAZt144HcAAAEAwBI
MEYCIQDK+OeKN052kyl9skxqqvcjM0EnMjAoqfW/w2oDJhe+KwIhANhNTK+gJ6lT
DGHjETKguyIS+BGaEnybtSUbxasJS0BoAHYA2AlVO5RPev/IFhlvlE+Fq7D4/F6H
VSYPFdEucrtFSxQAAAGbdeOCMgAABAMARzBFAiBCcTgVSPtumHiOc5mABE05SNon
hQ+/HKlM/mZ5fujyAgIhALV9R9eZpDKVs4o6+Y8uQYQIshlc6drDSS5Ojen3Q2dH
MAoGCCqGSM49BAMDA2cAMGQCMBsutT9/NO4qecncXj/hWurz/QWBsk7GyrZB71SA
1P7QMBDonFpyfkEQWoiWANfPDwIwEvzlukLPMNPCKWOAcErLN5FR6h4kqMEzd1Lq
Tjux4jSNXWzCsgVjnOxJn4q3MjKF
-----END CERTIFICATE-----
subject=C=US, ST=California, L=San Francisco, O=Cloudflare, Inc., CN=cloudflare-dns.com
issuer=C=US, ST=Texas, L=Houston, O=SSL Corp, CN=SSL.com SSL Intermediate CA ECC R2
---
No client certificate CA names sent
Peer signing digest: SHA256
Peer signature type: ecdsa_secp256r1_sha256
Negotiated TLS1.3 group: X25519MLKEM768
---
SSL handshake has read 4372 bytes and written 1567 bytes
Verification: OK
---
New, TLSv1.3, Cipher is TLS_AES_256_GCM_SHA384
Protocol: TLSv1.3
Server public key is 256 bit
This TLS version forbids renegotiation.
Compression: NONE
Expansion: NONE
No ALPN negotiated
Early data was not sent
Verify return code: 0 (ok)
---
---
Post-Handshake New Session Ticket arrived:
SSL-Session:
    Protocol  : TLSv1.3
    Cipher    : TLS_AES_256_GCM_SHA384
    Session-ID: 7487130BF071CCBB11621F8257A3FE7EDEAC64A21E1AC1DA14640C7FA83AE03D
    Session-ID-ctx: 
    Resumption PSK: D8D07FE6D3E11EDD1DC26C9391DA3AAFA0EAC30521CBE8672ED86CCCCE47B3BFA58F7220E0C0CA6E15F30F823068D775
    PSK identity: None
    PSK identity hint: None
    SRP username: None
    TLS session ticket lifetime hint: 172800 (seconds)
    TLS session ticket:
    0000 - 10 11 b5 af fb 55 e8 9c-e3 37 bd 7c fd 6e 2e af   .....U...7.|.n..
    0010 - b4 7a 33 4f 39 4a 89 a7-1d a3 a6 9f 8a 66 d0 77   .z3O9J.......f.w
    0020 - 99 35 8c d9 6e ca 47 f2-86 0a 03 a8 57 b6 ba 00   .5..n.G.....W...
    0030 - c3 27 29 dd 1d 2b 6f b5-68 c2 71 30 9a f2 e5 59   .')..+o.h.q0...Y
    0040 - d4 9e 6d 34 aa b7 bf 42-96 04 b2 cc 5e 2e c0 ca   ..m4...B....^...
    0050 - b0 d8 7d c7 f7 40 6e 5c-ef 77 08 c5 73 ed 95 26   ..}..@n\.w..s..&
    0060 - 64 96 54 df c5 b1 a9 89-06 4f 22 01 96 0f aa c0   d.T......O".....
    0070 - 9b fa 54 2c 3c dd 92 64-ae 07 52 e1 80 30 0e 17   ..T,<..d..R..0..
    0080 - 08 1a f8 6d f3 72 f3 93-42 60 b1 fe 68 a0 13 f5   ...m.r..B`..h...
    0090 - 5c 45 90 ca c1 03 e8 53-c4 2c fa f9 86 31 f1 00   \E.....S.,...1..
    00a0 - 81 2d 4b f3 36 77 0e 1b-eb 4f fb 4c 04 e6 2b 34   .-K.6w...O.L..+4
    00b0 - 71 92 e6 2c c2 c6 ab d1-30 6d bb 24 10 8b 29 ab   q..,....0m.$..).

    Start Time: 1769192805
    Timeout   : 7200 (sec)
    Verify return code: 0 (ok)
    Extended master secret: no
    Max Early Data: 0
---
read R BLOCK
---
Post-Handshake New Session Ticket arrived:
SSL-Session:
    Protocol  : TLSv1.3
    Cipher    : TLS_AES_256_GCM_SHA384
    Session-ID: A7A6E6FBCBE7F4ECF1A50EBB3D1DC50CD3FF644C051720DF94FD7DA805455EF6
    Session-ID-ctx: 
    Resumption PSK: 1B89C9AF91124DEEA3FA312DAFEA0A314658913B7DD58E9B1BB8987CABCD69E40BC963885C7174D0F27F278BFCF42EEA
    PSK identity: None
    PSK identity hint: None
    SRP username: None
    TLS session ticket lifetime hint: 172800 (seconds)
    TLS session ticket:
    0000 - 10 11 b5 af fb 55 e8 9c-e3 37 bd 7c fd 6e 2e af   .....U...7.|.n..
    0010 - 5e 1a f0 2c 5c a7 7f a7-f5 f1 dc 06 ec c0 3e fd   ^..,\.........>.
    0020 - 96 7a bf 5b 9f 87 77 ad-f0 63 df 23 30 00 18 2c   .z.[..w..c.#0..,
    0030 - 8b ca 3e 6a c0 b0 5d 2a-04 91 27 ca 65 c6 ca 54   ..>j..]*..'.e..T
    0040 - c0 ee bf 8b 4d 8a 6e 87-36 e4 59 5c 98 5e 57 30   ....M.n.6.Y\.^W0
    0050 - 94 ad b9 45 bb 1d e0 d6-d6 7f 2b 67 17 13 96 ec   ...E......+g....
    0060 - fe 78 4c 25 be 3d 10 a5-99 7e c5 b7 dd 84 cf d2   .xL%.=...~......
    0070 - 4e 9e 97 24 34 87 5b 24-a8 f5 88 09 ce b5 6f b5   N..$4.[$......o.
    0080 - 2a fb ae 09 1b 67 81 7e-bd 2b 15 7f bd 4d 18 72   *....g.~.+...M.r
    0090 - 4d 34 5d c7 7b c0 23 41-4e 9e e6 04 ec 29 22 03   M4].{.#AN....)".
    00a0 - 16 89 3e 3d 24 47 97 73-c0 c9 d6 8f ee 21 f0 12   ..>=$G.s.....!..
    00b0 - a9 49 a1 41 90 0c b6 07-a5 15 f6 46 6e 0b b0 cb   .I.A.......Fn...

    Start Time: 1769192805
    Timeout   : 7200 (sec)
    Verify return code: 0 (ok)
    Extended master secret: no
    Max Early Data: 0
---
read R BLOCK
closed
```




-----------------------------
# Fase 2

Las dos técnicas de descifrado de la parte 2 (una con volcado de claves de sesión al estilo SSLKEYLOGFILE y otra con AitM/mitmproxy, que es precisamente lo que se describe en el capítulo 7).


----------------------------------

# Parte 1: Análisis de la Aplicación

## 1.1. Identificación de la Librería y Sockets

Utilizamos herramientas de análisis estático y dinámico para responder a los requisitos:
- Librería SSL/TLS: Ejecutamos `ldd $(which kdig)` para ver las librerías compartidas. Buscamos entradas como libssl.so (OpenSSL) o libgnutls.so (GnuTLS).
- Tipo de Socket: Ejecutamos el comando bajo la supervisión de strace: `strace -e socket,connect kdig @1.1.1.1 +tls google.com`.
  - Evidencia: Debemnos identificar una llamada tipo socket(AF_INET, SOCK_STREAM, ...). Al usar TLS, el socket debe ser TCP (SOCK_STREAM), a diferencia del DNS tradicional que usa UDP (SOCK_DGRAM).


## 1.2. Análisis de la Sesión TLS (Wireshark)
Capturamos el tráfico con Wireshark mientras ejecutas el comando. En la memoria, describe los pasos del Handshake:
- Client Hello: Identifica el campo Server Name Indication (SNI) y los Cipher Suites ofrecidos.
- Server Hello: Observa qué suite de cifrado seleccionó el servidor (ej. TLS_AES_256_GCM_SHA384).
- Intercambio de claves: Identifica si se usa RSA o Diffie-Hellman Efímero (ECDHE).

